"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b3) => {
    for (var prop in b3 ||= {})
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a2, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a2, prop, b3[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b3) => __defProps(a2, __getOwnPropDescs(b3));
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e3) {
          reject(e3);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e3) {
          reject(e3);
        }
      };
      var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports2, module2) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component2.prototype.isReactComponent = {};
          Component2.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component2.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component2.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component2.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign(pureComponentPrototype, Component2.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray(a2) {
            return isArrayImpl(a2);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x2) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement13(type, config, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config);
                }
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              self2 = config.__self === void 0 ? null : config.__self;
              source = config.__source === void 0 ? null : config.__source;
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i2 = 0; i2 < childrenLength; i2++) {
                childArray[i2] = arguments[i2 + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement5(element, config, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config != null) {
              if (hasValidRef(config)) {
                ref = config.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i2 = 0; i2 < childrenLength; i2++) {
                childArray[i2] = arguments[i2 + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement2(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index2) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index2.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c2) {
                  return c2;
                });
              } else if (mappedChild != null) {
                if (isValidElement2(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray(children)) {
              for (var i2 = 0; i2 < children.length; i2++) {
                child = children[i2];
                nextName = nextNamePrefix + getElementKey(child, i2);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n2 = 0;
            mapChildren(children, function() {
              n2++;
            });
            return n2;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement2(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext2(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef7(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!render.name && !render.displayName) {
                    render.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo2(type, compare) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare === void 0 ? null : compare
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name) {
                  ownName = name;
                  if (!type.name && !type.displayName) {
                    type.displayName = name;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext2(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState19(initialState3) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState3);
          }
          function useReducer(reducer, initialArg, init) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init);
          }
          function useRef9(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect15(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create, deps);
          }
          function useInsertionEffect(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create, deps);
          }
          function useLayoutEffect3(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create, deps);
          }
          function useCallback6(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo14(create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create, deps);
          }
          function useImperativeHandle(ref, create, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create, deps);
          }
          function useDebugValue(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x2) {
                  var match = x2.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    control = x2;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x2) {
                    control = x2;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x2) {
                  control = x2;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s2 = sampleLines.length - 1;
                var c2 = controlLines.length - 1;
                while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                  c2--;
                }
                for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                  if (sampleLines[s2] !== controlLines[c2]) {
                    if (s2 !== 1 || c2 !== 1) {
                      do {
                        s2--;
                        c2--;
                        if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                          var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s2 >= 1 && c2 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x2) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray(node)) {
              for (var i2 = 0; i2 < node.length; i2++) {
                var child = node[i2];
                if (isValidElement2(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement2(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement2(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i2 = 0; i2 < keys.length; i2++) {
                var key = keys[i2];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement13.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i2 = 2; i2 < arguments.length; i2++) {
                validateChildKeys(arguments[i2], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement5.apply(this, arguments);
            for (var i2 = 2; i2 < arguments.length; i2++) {
              validateChildKeys(arguments[i2], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope2, options) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope2();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module2 && module2[requireString];
                enqueueTaskImpl = nodeRequire.call(module2, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i2 = 0;
                try {
                  for (; i2 < queue.length; i2++) {
                    var callback = queue[i2];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i2 + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children4 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray,
            only: onlyChild
          };
          exports2.Children = Children4;
          exports2.Component = Component2;
          exports2.Fragment = REACT_FRAGMENT_TYPE;
          exports2.Profiler = REACT_PROFILER_TYPE;
          exports2.PureComponent = PureComponent;
          exports2.StrictMode = REACT_STRICT_MODE_TYPE;
          exports2.Suspense = REACT_SUSPENSE_TYPE;
          exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports2.cloneElement = cloneElement$1;
          exports2.createContext = createContext2;
          exports2.createElement = createElement$1;
          exports2.createFactory = createFactory;
          exports2.createRef = createRef;
          exports2.forwardRef = forwardRef7;
          exports2.isValidElement = isValidElement2;
          exports2.lazy = lazy;
          exports2.memo = memo2;
          exports2.startTransition = startTransition;
          exports2.unstable_act = act;
          exports2.useCallback = useCallback6;
          exports2.useContext = useContext2;
          exports2.useDebugValue = useDebugValue;
          exports2.useDeferredValue = useDeferredValue;
          exports2.useEffect = useEffect15;
          exports2.useId = useId;
          exports2.useImperativeHandle = useImperativeHandle;
          exports2.useInsertionEffect = useInsertionEffect;
          exports2.useLayoutEffect = useLayoutEffect3;
          exports2.useMemo = useMemo14;
          exports2.useReducer = useReducer;
          exports2.useRef = useRef9;
          exports2.useState = useState19;
          exports2.useSyncExternalStore = useSyncExternalStore;
          exports2.useTransition = useTransition;
          exports2.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports2, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports2) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push2(heap, node) {
            var index2 = heap.length;
            heap.push(node);
            siftUp(heap, node, index2);
          }
          function peek(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          }
          function siftUp(heap, node, i2) {
            var index2 = i2;
            while (index2 > 0) {
              var parentIndex = index2 - 1 >>> 1;
              var parent = heap[parentIndex];
              if (compare(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index2] = parent;
                index2 = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i2) {
            var index2 = i2;
            var length = heap.length;
            var halfLength = length >>> 1;
            while (index2 < halfLength) {
              var leftIndex = (index2 + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (compare(left, node) < 0) {
                if (rightIndex < length && compare(right, left) < 0) {
                  heap[index2] = right;
                  heap[rightIndex] = node;
                  index2 = rightIndex;
                } else {
                  heap[index2] = left;
                  heap[leftIndex] = node;
                  index2 = leftIndex;
                }
              } else if (rightIndex < length && compare(right, node) < 0) {
                heap[index2] = right;
                heap[rightIndex] = node;
                index2 = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare(a2, b3) {
            var diff = a2.sortIndex - b3.sortIndex;
            return diff !== 0 ? diff : a2.id - b3.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports2.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports2.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push2(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error) {
                  if (currentTask !== null) {
                    var currentTime = exports2.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports2.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options) {
            var currentTime = exports2.unstable_now();
            var startTime2;
            if (typeof options === "object" && options !== null) {
              var delay = options.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime2 = currentTime + delay;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push2(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push2(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports2.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports2.unstable_now();
              startTime = currentTime;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports2.unstable_now());
            }, ms);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports2.unstable_IdlePriority = IdlePriority;
          exports2.unstable_ImmediatePriority = ImmediatePriority;
          exports2.unstable_LowPriority = LowPriority;
          exports2.unstable_NormalPriority = NormalPriority;
          exports2.unstable_Profiling = unstable_Profiling;
          exports2.unstable_UserBlockingPriority = UserBlockingPriority;
          exports2.unstable_cancelCallback = unstable_cancelCallback;
          exports2.unstable_continueExecution = unstable_continueExecution;
          exports2.unstable_forceFrameRate = forceFrameRate;
          exports2.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports2.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports2.unstable_next = unstable_next;
          exports2.unstable_pauseExecution = unstable_pauseExecution;
          exports2.unstable_requestPaint = unstable_requestPaint;
          exports2.unstable_runWithPriority = unstable_runWithPriority;
          exports2.unstable_scheduleCallback = unstable_scheduleCallback;
          exports2.unstable_shouldYield = shouldYieldToHost;
          exports2.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports2, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports2) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React30 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React30.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn(format) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error(format) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment8 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = false;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i2 = 0; i2 < dependencies.length; i2++) {
              allNativeEvents.add(dependencies[i2]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkPropStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name) {
            return properties.hasOwnProperty(name) ? properties[name] : null;
          }
          function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              RESERVED,
              false,
              name,
              null,
              false,
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name = _ref[0], attributeName = _ref[1];
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              name.toLowerCase(),
              null,
              false,
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEANISH_STRING,
              false,
              name,
              null,
              false,
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              false,
              name.toLowerCase(),
              null,
              false,
              false
            );
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              BOOLEAN,
              true,
              name,
              null,
              false,
              false
            );
          });
          [
            "capture",
            "download"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              OVERLOADED_BOOLEAN,
              false,
              name,
              null,
              false,
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              POSITIVE_NUMERIC,
              false,
              name,
              null,
              false,
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name) {
            properties[name] = new PropertyInfoRecord(
              name,
              NUMERIC,
              false,
              name.toLowerCase(),
              null,
              false,
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name = attributeName.replace(CAMELIZE, capitalize);
            properties[name] = new PropertyInfoRecord(
              name,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              false,
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              true,
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name)) {
                return;
              }
              if (!node.hasAttribute(name)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name);
              {
                checkAttributeStringCoercion(expected, name);
              }
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name);
            if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name)) {
                var _attributeName = name;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value, name);
                  }
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x2) {
                  var match = x2.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    control = x2;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x2) {
                    control = x2;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x2) {
                  control = x2;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s2 = sampleLines.length - 1;
                var c2 = controlLines.length - 1;
                while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                  c2--;
                }
                for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                  if (sampleLines[s2] !== controlLines[c2]) {
                    if (s2 !== 1 || c2 !== 1) {
                      do {
                        s2--;
                        c2--;
                        if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                          var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s2 >= 1 && c2 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x2) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x2) {
              return "\nError generating stack: " + x2.message + "\n" + x2.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x2) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context = type;
                return getContextName$1(context) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment8:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value);
                }
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get3 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get3.call(this);
              },
              set: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
                set2.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e3) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || node.value != value) {
                  node.value = toString(value);
                }
              } else if (node.value !== toString(value)) {
                node.value = toString(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name = node.name;
            if (name !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name !== "") {
              node.name = name;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name = props.name;
            if (props.type === "radio" && name != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name, "name");
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
              for (var i2 = 0; i2 < group.length; i2++) {
                var otherNode = group[i2];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (type !== "number" || getActiveElement(node.ownerDocument) !== node) {
              if (value == null) {
                node.defaultValue = toString(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString(value)) {
                node.defaultValue = toString(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React30.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a2) {
            return isArrayImpl(a2);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                var propName = valuePropNames[i2];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options2 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i2 = 0; i2 < selectedValues.length; i2++) {
                selectedValue["$" + selectedValues[i2]] = true;
              }
              for (var _i = 0; _i < options2.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
                if (options2[_i].selected !== selected) {
                  options2[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options2[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options2.length; _i2++) {
                if (options2[_i2].value === _selectedValue) {
                  options2[_i2].selected = true;
                  if (setDefaultSelected) {
                    options2[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options2[_i2].disabled) {
                  defaultSelected = options2[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE2 = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
              return value + "px";
            }
            {
              checkCSSPropertyStringCoercion(value, name);
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name) {
            return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string2) {
              return string2.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error(
                "Unsupported style property %s. Did you mean %s?",
                name,
                camelize(name.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name) {
              if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
                return;
              }
              warnedStyleNames[name] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name);
            };
            var warnStyleValueIsInfinity = function(name, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name);
            };
            warnValidStyle = function(name, value) {
              if (name.indexOf("-") > -1) {
                warnHyphenatedStyleName(name);
              } else if (badVendoredStyleNamePattern.test(name)) {
                warnBadVendoredStyleName(name);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i2 = 0; i2 < longhands.length; i2++) {
                expanded[longhands[i2]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          };
          var voidElementTags = assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML2 = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML2 in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name) {
            {
              if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
                return true;
              }
              if (rARIACamel.test(name)) {
                var ariaName = "aria-" + name.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                  warnedProperties[name] = true;
                  return true;
                }
                if (name !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
              if (rARIA.test(name)) {
                var lowerCasedName = name.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name] = true;
                  return false;
                }
                if (name !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties[name] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid = validateProperty(type, key);
                if (!isValid) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name, value, eventRegistry) {
              if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
                return true;
              }
              var lowerCasedName = name.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                  warnedProperties$1[name] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name)) {
                if (INVALID_EVENT_NAME_REGEX.test(name)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
                warnedProperties$1[name] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                  warnedProperties$1[name] = true;
                  return true;
                }
              } else if (!isReserved && name !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
                }
                warnedProperties$1[name] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
                warnedProperties$1[name] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
                warnedProperties$1[name] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i2 = 0; i2 < queuedTargets.length; i2++) {
                restoreStateOfTarget(queuedTargets[i2]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn2, bookkeeping) {
            return fn2(bookkeeping);
          };
          var flushSyncImpl = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn2, a2, b3) {
            if (isInsideEventHandler) {
              return fn2(a2, b3);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn2, a2, b3);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name, type, props) {
            switch (name) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options = {};
              Object.defineProperty(options, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options, options);
              window.removeEventListener("test", options, options);
            } catch (e3) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name, func, context, a2, b3, c2, d3, e3, f2) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error2) {
              this.onError(error2);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a2, b3, c2, d3, e3, f2) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error2;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error2 = event.error;
                  didSetError = true;
                  if (error2 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error2 != null && typeof error2 === "object") {
                      try {
                        error2._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name ? name : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error2);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error2) {
              hasError = true;
              caughtError = error2;
            }
          };
          function invokeGuardedCallback(name, func, context, a2, b3, c2, d3, e3, f2) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name, func, context, a2, b3, c2, d3, e3, f2) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error2 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error2;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error2 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error2;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error2 = caughtError;
              hasError = false;
              caughtError = null;
              return error2;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get2(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set(key, value) {
            key._reactInternals = value;
          }
          var NoFlags = 0;
          var PerformedWork = 1;
          var Placement = 2;
          var Update = 4;
          var ChildDeletion = 16;
          var ContentReset = 32;
          var Callback = 64;
          var DidCapture = 128;
          var ForceClientRender = 256;
          var Ref2 = 512;
          var Snapshot = 1024;
          var Passive = 2048;
          var Hydrating = 4096;
          var Visibility = 8192;
          var StoreConsistency = 16384;
          var LifecycleEffectMask = Passive | Update | Callback | Ref2 | Snapshot | StoreConsistency;
          var HostEffectMask = 32767;
          var Incomplete = 32768;
          var ShouldCapture = 65536;
          var ForceUpdateForLegacySuspense = 131072;
          var Forked = 1048576;
          var RefStatic = 2097152;
          var LayoutStatic = 4194304;
          var PassiveStatic = 8388608;
          var MountLayoutDev = 16777216;
          var MountPassiveDev = 33554432;
          var BeforeMutationMask = Update | Snapshot | 0;
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref2 | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref2 | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get2(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a2 = fiber;
            var b3 = alternate;
            while (true) {
              var parentA = a2.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a2 = b3 = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a2) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b3) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a2.return !== b3.return) {
                a2 = parentA;
                b3 = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a2) {
                    didFindChild = true;
                    a2 = parentA;
                    b3 = parentB;
                    break;
                  }
                  if (_child === b3) {
                    didFindChild = true;
                    b3 = parentA;
                    a2 = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a2) {
                      didFindChild = true;
                      a2 = parentB;
                      b3 = parentA;
                      break;
                    }
                    if (_child === b3) {
                      didFindChild = true;
                      b3 = parentB;
                      a2 = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a2.alternate !== b3) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a2.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a2.stateNode.current === a2) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              var match = findCurrentHostFiberImpl(child);
              if (match !== null) {
                return match;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match !== null) {
                  return match;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now2 = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root3, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root3, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root3, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root3.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root3, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root3) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root3);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index3 = 0; index3 < TotalLanes; index3++) {
                var label = getLabelForLane(lane);
                map.set(lane, label);
                lane *= 2;
              }
              return map;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = 0;
          var ConcurrentMode = 1;
          var ProfileMode = 2;
          var StrictLegacyMode = 8;
          var StrictEffectsMode = 16;
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x2) {
            var asUint = x2 >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = 0;
          var NoLane = 0;
          var SyncLane = 1;
          var InputContinuousHydrationLane = 2;
          var InputContinuousLane = 4;
          var DefaultHydrationLane = 8;
          var DefaultLane = 16;
          var TransitionHydrationLane = 32;
          var TransitionLanes = 4194240;
          var TransitionLane1 = 64;
          var TransitionLane2 = 128;
          var TransitionLane3 = 256;
          var TransitionLane4 = 512;
          var TransitionLane5 = 1024;
          var TransitionLane6 = 2048;
          var TransitionLane7 = 4096;
          var TransitionLane8 = 8192;
          var TransitionLane9 = 16384;
          var TransitionLane10 = 32768;
          var TransitionLane11 = 65536;
          var TransitionLane12 = 131072;
          var TransitionLane13 = 262144;
          var TransitionLane14 = 524288;
          var TransitionLane15 = 1048576;
          var TransitionLane16 = 2097152;
          var RetryLanes = 130023424;
          var RetryLane1 = 4194304;
          var RetryLane2 = 8388608;
          var RetryLane3 = 16777216;
          var RetryLane4 = 33554432;
          var RetryLane5 = 67108864;
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = 134217728;
          var NonIdleLanes = 268435455;
          var IdleHydrationLane = 268435456;
          var IdleLane = 536870912;
          var OffscreenLane = 1073741824;
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root3, wipLanes) {
            var pendingLanes = root3.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root3.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root3.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index3 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index3;
                nextLanes |= entanglements[index3];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root3, lanes) {
            var eventTimes = root3.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var eventTime = eventTimes[index3];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root3, currentTime) {
            var pendingLanes = root3.pendingLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var expirationTime = expirationTimes[index3];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index3] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root3.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root3) {
            return getHighestPriorityLanes(root3.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root3) {
            var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root3, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root3, lanes) {
            return (lanes & root3.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a2, b3) {
            return (a2 & b3) !== NoLanes;
          }
          function isSubsetOfLanes(set2, subset) {
            return (set2 & subset) === subset;
          }
          function mergeLanes(a2, b3) {
            return a2 | b3;
          }
          function removeLanes(set2, subset) {
            return set2 & ~subset;
          }
          function intersectLanes(a2, b3) {
            return a2 & b3;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a2, b3) {
            return a2 !== NoLane && a2 < b3 ? a2 : b3;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i2 = 0; i2 < TotalLanes; i2++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root3, updateLane, eventTime) {
            root3.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root3.suspendedLanes = NoLanes;
              root3.pingedLanes = NoLanes;
            }
            var eventTimes = root3.eventTimes;
            var index3 = laneToIndex(updateLane);
            eventTimes[index3] = eventTime;
          }
          function markRootSuspended(root3, suspendedLanes) {
            root3.suspendedLanes |= suspendedLanes;
            root3.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root3, pingedLanes, eventTime) {
            root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root3, remainingLanes) {
            var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes;
            root3.pendingLanes = remainingLanes;
            root3.suspendedLanes = NoLanes;
            root3.pingedLanes = NoLanes;
            root3.expiredLanes &= remainingLanes;
            root3.mutableReadLanes &= remainingLanes;
            root3.entangledLanes &= remainingLanes;
            var entanglements = root3.entanglements;
            var eventTimes = root3.eventTimes;
            var expirationTimes = root3.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              entanglements[index3] = NoLanes;
              eventTimes[index3] = NoTimestamp;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root3, entangledLanes) {
            var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
            var entanglements = root3.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              if (lane & entangledLanes | entanglements[index3] & entangledLanes) {
                entanglements[index3] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root3, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root3, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index3 = laneToIndex(lanes);
              var lane = 1 << index3;
              var updaters = pendingUpdatersLaneMap[index3];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root3, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            var memoizedUpdaters = root3.memoizedUpdaters;
            while (lanes > 0) {
              var index3 = laneToIndex(lanes);
              var lane = 1 << index3;
              var updaters = pendingUpdatersLaneMap[index3];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root3, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn2) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn2();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a2, b3) {
            return a2 !== 0 && a2 < b3 ? a2 : b3;
          }
          function lowerEventPriority(a2, b3) {
            return a2 === 0 || a2 > b3 ? a2 : b3;
          }
          function isHigherEventPriority(a2, b3) {
            return a2 !== 0 && a2 < b3;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root3) {
            var currentState = root3.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn2) {
            _attemptSynchronousHydration = fn2;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn2) {
            attemptContinuousHydration = fn2;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn2) {
            attemptHydrationAtCurrentPriority = fn2;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn2) {
            getCurrentUpdatePriority$1 = fn2;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn2) {
            attemptHydrationAtPriority = fn2;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target,
              priority: updatePriority
            };
            var i2 = 0;
            for (; i2 < queuedExplicitHydrationTargets.length; i2++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i2].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i2, 0, queuedTarget);
            if (i2 === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i2 = 1; i2 < queuedDiscreteEvents.length; i2++) {
                var queuedEvent = queuedDiscreteEvents[i2];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              passive
            });
            return listener;
          }
          var root2 = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root2 = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset() {
            root2 = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText();
            var endLength = endValue.length;
            for (start = 0; start < startLength; start++) {
              if (startValue[start] !== endValue[start]) {
                break;
              }
            }
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root2) {
              return root2.value;
            }
            return root2.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize2 = Interface[_propName];
                if (normalize2) {
                  this[_propName] = normalize2(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              persist: function() {
              },
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported2 = eventName in document;
            if (!isSupported2) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported2 = typeof element[eventName] === "function";
            }
            return isSupported2;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from;
            var to;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from = targetInst;
              to = _related ? getClosestInstanceFromNode(_related) : null;
              if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                  to = null;
                }
              }
            } else {
              from = null;
              to = targetInst;
            }
            if (from === to) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from == null ? win : getNodeFromInstance(from);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
          }
          function is(x2, y2) {
            return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          function shallowEqual2(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i2 = 0; i2 < keysA.length; i2++) {
              var currentKey = keysA[i2];
              if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root3, offset2) {
            var node = getLeafNode(root3);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset2 && nodeEnd >= offset2) {
                  return {
                    node,
                    offset: offset2 - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e3) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length = 0;
            var start = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start = length + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end = length + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start = length;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end = length;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
            if (start === -1 || end === -1) {
              return null;
            }
            return {
              start,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length = node.textContent.length;
            var start = Math.min(offsets.start, length);
            var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);
            if (!selection.extend && start > end) {
              var temp = end;
              end = start;
              start = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE2) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i2 = 0; i2 < ancestors.length; i2++) {
                var info = ancestors[i2];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start = offsets.start;
            var end = offsets.end;
            if (end === void 0) {
              end = start;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual2(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i2 = 0; i2 < simpleEventPluginEvents.length; i2++) {
              var eventName = simpleEventPluginEvents[i2];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i2 = dispatchListeners.length - 1; i2 >= 0; i2--) {
                var _dispatchListeners$i = dispatchListeners[i2], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i2 = 0; i2 < dispatchQueue.length; i2++) {
              var _dispatchQueue$i = dispatchQueue[i2], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop:
                  while (true) {
                    if (node === null) {
                      return;
                    }
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container2 = node.stateNode.containerInfo;
                      if (isMatchingRootContainer(container2, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container2 !== null) {
                        var parentNode = getClosestInstanceFromNode(container2);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container2 = container2.parentNode;
                      }
                    }
                    node = node.return;
                  }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
            var common = from && to ? getLowestCommonAncestor(from, to) : null;
            if (from !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
            }
            if (to !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              dialog: true,
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name) {
                names.push(name);
              });
              error("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop3() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop3;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i2 = 0; i2 < updatePayload.length; i2 += 2) {
              var propKey = updatePayload[i2];
              var propValue = updatePayload[i2 + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement13(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i2 = 0; i2 < mediaEventTypes.length; i2++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i2], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name = attributes[_i].name.toLowerCase();
                switch (name) {
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root3 = rootContainerInstance.documentElement;
                namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container2 = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container2.namespaceURI || null;
                type = container2.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string2 = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement13(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string2 = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error2) {
            setTimeout(function() {
              throw error2;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container2, child) {
            var parentNode;
            if (container2.nodeType === COMMENT_NODE) {
              parentNode = container2.parentNode;
              parentNode.insertBefore(child, container2);
            } else {
              parentNode = container2;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container2._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container2, child, beforeChild) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.insertBefore(child, beforeChild);
            } else {
              container2.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container2, child) {
            if (container2.nodeType === COMMENT_NODE) {
              container2.parentNode.removeChild(child);
            } else {
              container2.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data = nextNode.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container2, suspenseInstance) {
            if (container2.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container2.parentNode, suspenseInstance);
            } else if (container2.nodeType === ELEMENT_NODE2) {
              clearSuspenseBoundary(container2, suspenseInstance);
            }
            retryIfBlockedOn(container2);
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container2) {
            if (container2.nodeType === ELEMENT_NODE2) {
              container2.textContent = "";
            } else if (container2.nodeType === DOCUMENT_NODE) {
              if (container2.documentElement) {
                container2.removeChild(container2.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE2 || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message, stack;
            if (dataset) {
              digest = dataset.dgst;
              {
                message = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message,
                digest,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE2 || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container2) {
            retryIfBlockedOn(container2);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE2) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE2) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE2) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedText(parentNode, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index2 = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index2 < 0) {
              {
                error("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index2]) {
                error("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index2];
            valueStack[index2] = null;
            {
              fiberStack[index2] = null;
            }
            index2--;
          }
          function push2(cursor, value, fiber) {
            index2++;
            valueStack[index2] = cursor.current;
            {
              fiberStack[index2] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push2(contextStackCursor, context, fiber);
              push2(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name);
              }
              return assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push2(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push2(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push2(contextStackCursor, mergedContext, workInProgress2);
                push2(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push2(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component2 = node.type;
                    if (isContextProvider(Component2)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
            } else {
              syncQueue.push(callback);
            }
          }
          function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i2 = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i2 < queue.length; i2++) {
                  var callback = queue[i2];
                  do {
                    callback = callback(isSync);
                  } while (callback !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error2) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i2 + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error2;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index3) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index3 + 1;
            var length = getBitLength(totalChildren) + baseLength;
            if (length > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              treeContextId = 1 << length | _id;
              treeContextOverflow = _overflow;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number) {
            return 32 - clz32(number);
          }
          function getLeadingBit(id) {
            return 1 << getBitLength(id) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null)
                    didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null)
                    switch (fiber.tag) {
                      case HostComponent:
                        var _type2 = fiber.type;
                        var _props2 = fiber.pendingProps;
                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                        break;
                      case HostText:
                        var _text2 = fiber.pendingProps;
                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                        break;
                    }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error2) {
            if (hydrationErrors === null) {
              hydrationErrors = [error2];
            } else {
              hydrationErrors.push(error2);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictLegacyMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array = [];
              set2.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = assign({}, baseProps);
              var defaultProps = Component2.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context, nextValue) {
            {
              push2(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node === propagationRoot) {
                break;
              }
              node = node.return;
            }
            {
              if (node !== propagationRoot) {
                error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update = createUpdate(NoTimestamp, lane);
                      update.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null)
                        ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update.next = update;
                        } else {
                          update.next = pending.next;
                          pending.next = update;
                        }
                        sharedQueue.pending = update;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              {
                var firstContext = dependencies.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies.firstContext = null;
                }
              }
            }
          }
          function readContext(context) {
            {
              if (isDisallowedContextReadInDEV) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value = context._currentValue;
            if (lastFullyObservedContext === context)
              ;
            else {
              var contextItem = {
                context,
                memoizedValue: value,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i2 = 0; i2 < concurrentQueues.length; i2++) {
                var queue = concurrentQueues[i2];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root3 = node.stateNode;
              return root3;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update.next = update;
              } else {
                update.next = pending.next;
                pending.next = update;
              }
              sharedQueue.pending = update;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
          }
          function entangleTransitions(root3, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone;
                    } else {
                      newLast.next = clone;
                      newLast = clone;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback = update.callback;
                  if (callback !== null && update.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (typeof callback !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i2 = 0; i2 < effects.length; i2++) {
                var effect = effects[i2];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var emptyRefsObject = new React30.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual2(oldProps, newProps) || !shallowEqual2(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name);
              }
              {
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name, name);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name, name);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray(_state))) {
                error("%s.state: must be set to an object or null", name);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = resolvedInst.refs;
                  if (refs === emptyRefsObject) {
                    refs = resolvedInst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init = lazyType._init;
            return init(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone = createWorkInProgress(fiber, pendingProps);
              clone.index = 0;
              clone.sibling = null;
              return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key) {
              if (current2 === null || current2.tag !== Fragment8) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return createChild(returnFiber, init(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init(payload), lanes);
                  }
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
                }
                if (isArray(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init = child._init;
                    warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i2 = 0; i2 < newChildren.length; i2++) {
                  var child = newChildren[i2];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  var elementType = element.type;
                  if (elementType === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment8) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
                }
                if (isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c2) {
            if (c2 === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c2;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push2(rootInstanceStackCursor, nextRootInstance, fiber);
            push2(contextFiberStackCursor, fiber, fiber);
            push2(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push2(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push2(contextFiberStackCursor, fiber, fiber);
            push2(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push2(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = 0;
          var HasEffect = 1;
          var Insertion = 2;
          var Layout = 4;
          var Passive$1 = 8;
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i2 = 0; i2 < workInProgressSources.length; i2++) {
              var mutableSource = workInProgressSources[i2];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root3, mutableSource) {
            var getVersion = mutableSource._getVersion;
            var version = getVersion(mutableSource._source);
            if (root3.mutableSourceEagerHydrationData == null) {
              root3.mutableSourceEagerHydrationData = [mutableSource, version];
            } else {
              root3.mutableSourceEagerHydrationData.push(mutableSource, version);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray(deps)) {
                error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i2 = 0; i2 <= hookTypesUpdateIndexDev; i2++) {
                    var oldHookName = hookTypesDev[i2];
                    var newHookName = i2 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i2 + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
              if (objectIs(nextDeps[i2], prevDeps[i2])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component2(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component2(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && (current2.mode & ConcurrentMode) !== NoMode) {
                error("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init) {
            var hook = mountWorkInProgressHook();
            var initialState3;
            if (init !== void 0) {
              initialState3 = init(initialArg);
            } else {
              initialState3 = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState3;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState3
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone = {
                    lane: updateLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      lane: NoLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.hasEagerState) {
                    newState = update.eagerState;
                  } else {
                    var action = update.action;
                    newState = reducer(newState, action);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action = update.action;
                newState = reducer(newState, action);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState3) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState3 === "function") {
              initialState3 = initialState3();
            }
            hook.memoizedState = hook.baseState = initialState3;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState3
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState3) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState3) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create, destroy, deps) {
            var effect = {
              tag,
              create,
              destroy,
              deps,
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
          }
          function mountEffect(create, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
            }
          }
          function updateEffect(create, deps) {
            return updateEffectImpl(Passive, Passive$1, create, deps);
          }
          function mountInsertionEffect(create, deps) {
            return mountEffectImpl(Update, Insertion, create, deps);
          }
          function updateInsertionEffect(create, deps) {
            return updateEffectImpl(Update, Insertion, create, deps);
          }
          function mountLayoutEffect(create, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create, deps);
          }
          function updateLayoutEffect(create, deps) {
            return updateEffectImpl(Update, Layout, create, deps);
          }
          function imperativeHandleEffect(create, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create, deps) {
            {
              if (typeof create !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
          }
          function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
          function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value;
              return value;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value;
              return value;
            }
          }
          function startTransition(setPending, callback, options2) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start;
            return [isPending, start];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root3 = getWorkInProgressRoot();
            var identifierPrefix = root3.identifierPrefix;
            var id;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id += "H" + localId.toString(32);
              }
              id += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id;
            return id;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id = hook.memoizedState;
            return id;
          }
          function dispatchReducerAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                      return;
                    }
                  } catch (error2) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
          }
          function entangleTransitionUpdate(root3, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState3) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState3) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState3) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState3) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState3) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState3) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create, deps);
              },
              useImperativeHandle: function(ref, create, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create, deps);
              },
              useInsertionEffect: function(create, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create, deps);
              },
              useLayoutEffect: function(create, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create, deps);
              },
              useMemo: function(create, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState3) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    root3.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    if (root3 !== null) {
                      root3.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function createCapturedValueAtFiber(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value, digest, stack) {
            return {
              value,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest != null ? digest : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error2 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error2 != null && error2._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error2);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error2);
              }
            } catch (e3) {
              setTimeout(function() {
                throw e3;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error2 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error2);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update;
          }
          function attachPingListener(root3, wakeable, lanes) {
            var pingCache = root3.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root3.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root3, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
              if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                return node;
              }
              node = node.return;
            } while (node !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root3, rootRenderLanes);
              }
            }
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root3, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                  return;
                }
              }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var render2 = Component2.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component2.type;
              if (isSimpleFunctionComponent(type) && Component2.compare === null && Component2.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component2.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare = Component2.compare;
              compare = compare !== null ? compare : shallowEqual2;
              if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    outerMemoType = init(payload);
                  } catch (x2) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual2(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref2;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component2, nextProps);
              mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component2, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component2, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root3 = workInProgress2.stateNode;
            if (root3.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
            } else if (root3.context) {
              pushTopLevelContextObject(workInProgress2, root3.context, false);
            }
            pushHostContainer(workInProgress2, root3.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root3 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node = child;
                while (node) {
                  node.flags = node.flags & ~Placement | Hydrating;
                  node = node.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init = lazyComponent._init;
            var Component2 = init(payload);
            workInProgress2.type = Component2;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
            var resolvedProps = resolveDefaultProps(Component2, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component2);
                  workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
                }
                child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
                }
                child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
                }
                child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        "prop",
                        getComponentNameFromType(Component2)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component2,
                  resolveDefaultProps(Component2.type, resolvedProps),
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". " + ("Lazy element type must resolve to a class or function." + hint));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
              {
                var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component2)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component2, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if ((mode & ConcurrentMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest, message, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest = _getSuspenseInstanceF.digest;
                  message = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error2;
                if (message) {
                  error2 = new Error(message);
                } else {
                  error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error2, digest, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root3 = getWorkInProgressRoot();
                if (root3 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index3) {
            {
              var isAnArray = isArray(childSlot);
              var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable) {
                var type = isAnArray ? "array" : "iterable";
                error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index3, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray(children)) {
                  for (var i2 = 0; i2 < children.length; i2++) {
                    if (!validateSuspenseListNestedChild(children[i2], i2)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    tail,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    _tail,
                    null,
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    null,
                    null,
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root3 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context = workInProgress2.type._context;
                pushProvider(workInProgress2, context, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state = workInProgress2.memoizedState;
                if (state !== null) {
                  if (state.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
              }
              case FunctionComponent: {
                var Component2 = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component2 ? unresolvedProps : resolveDefaultProps(Component2, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component2, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment8:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref2;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment8:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (!prevState.isDehydrated || (workInProgress2.flags & ForceClientRender) !== NoFlags) {
                        workInProgress2.flags |= Snapshot;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now2() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.renderingStartTime = now2();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root3 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root3 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context = interruptedWork.type._context;
                popProvider(context, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error2) {
            {
              invokeGuardedCallback(null, function() {
                throw error2;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref(null);
                  }
                } catch (error2) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root3, firstChild) {
            focusedInstanceHandle = prepareForCommit(root3.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root3 = finishedWork.stateNode;
                    clearContainer(root3.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create = effect.create;
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect.destroy = create();
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect.tag & Insertion) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root3 = parentFiber.stateNode;
                            root3.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer:
                        while (parentFiber !== null) {
                          switch (parentFiber.tag) {
                            case HostRoot:
                              var root3 = parentFiber.stateNode;
                              root3.effectDuration += effectDuration;
                              break outer;
                            case Profiler:
                              var parentStateNode = parentFiber.stateNode;
                              parentStateNode.effectDuration += effectDuration;
                              break outer;
                          }
                          parentFiber = parentFiber.return;
                        }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref2) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (node.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                  } finally {
                    recordLayoutEffectDuration(node);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node, node.return, instance);
                }
                safelyAttachRef(node, node.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node, node.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node;
                    try {
                      var instance = node.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node.stateNode, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if (node.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node) {
                    hostSubtreeRoot = null;
                  }
                  node = node.return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root3, returnFiber, deletedFiber) {
            {
              var parent = returnFiber;
              findParent:
                while (parent !== null) {
                  switch (parent.tag) {
                    case HostComponent: {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break findParent;
                    }
                    case HostRoot: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                    case HostPortal: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                  }
                  parent = parent.return;
                }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect = firstEffect;
                      do {
                        var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag & Insertion) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect = effect.next;
                      } while (effect !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (deletedFiber.mode & ConcurrentMode) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root3, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root3);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i2 = 0; i2 < deletions.length; i2++) {
                var childToDelete = deletions[i2];
                try {
                  commitDeletionEffects(root3, parentFiber, childToDelete);
                } catch (error2) {
                  captureCommitPhaseError(childToDelete, parentFiber, error2);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root3);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref2) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref2) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root3.containerInfo);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (finishedWork.mode & ConcurrentMode) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root3, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root3, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      root3,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root3, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i2 = 0; i2 < deletions.length; i2++) {
                    var fiberToDelete = deletions[i2];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = 0;
          var BatchedContext = 1;
          var RenderContext = 2;
          var CommitContext = 4;
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now2();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now2();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition = ReactCurrentBatchConfig$3.transition;
                if (!transition._updatedFibers) {
                  transition._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root3, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root3, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root3 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root3, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root3, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
            var current2 = root3.current;
            current2.lanes = lane;
            markRootUpdated(root3, lane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (executionContext & RenderContext) !== NoContext;
          }
          function ensureRootIsScheduled(root3, currentTime) {
            var existingCallbackNode = root3.callbackNode;
            markStarvedLanesAsExpired(root3, currentTime);
            var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root3.callbackNode = null;
              root3.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root3.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root3.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
            }
            root3.callbackPriority = newCallbackPriority;
            root3.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root3, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root3.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root3.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root3, NoLanes);
                markRootSuspended$1(root3, lanes);
                ensureRootIsScheduled(root3, now2());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root3, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root3, lanes);
                var finishedWork = root3.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root3, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root3, NoLanes);
                    markRootSuspended$1(root3, lanes);
                    ensureRootIsScheduled(root3, now2());
                    throw _fatalError;
                  }
                }
                root3.finishedWork = finishedWork;
                root3.finishedLanes = lanes;
                finishConcurrentRender(root3, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root3, now2());
            if (root3.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root3);
            }
            return null;
          }
          function recoverFromConcurrentError(root3, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root3)) {
              var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root3.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root3, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root3, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootErrored: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root3, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root3.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root3, suspendedLanes);
                      break;
                    }
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now2() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
              if (node.flags & StoreConsistency) {
                var updateQueue = node.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i2 = 0; i2 < checks.length; i2++) {
                      var check = checks[i2];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error2) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node.child;
              if (node.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node;
                node = child;
                continue;
              }
              if (node === finishedWork) {
                return true;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return true;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root3, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root3, suspendedLanes);
          }
          function performSyncWorkOnRoot(root3) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root3, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root3, now2());
              return null;
            }
            var exitStatus = renderRootSync(root3, lanes);
            if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root3, NoLanes);
              markRootSuspended$1(root3, lanes);
              ensureRootIsScheduled(root3, now2());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root3.current.alternate;
            root3.finishedWork = finishedWork;
            root3.finishedLanes = lanes;
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root3, now2());
            return null;
          }
          function flushRoot(root3, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root3, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root3, now2());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn2, a2) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn2(a2);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn2, a2, b3, c2, d3) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn2(a2, b3, c2, d3);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync2(fn2) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn2) {
                return fn2();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push2(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root3, lanes) {
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            var timeoutHandle = root3.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root3.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root3;
            var rootWorkInProgress = createWorkInProgress(root3.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root3, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now2();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error2) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error2];
            } else {
              workInProgressRootConcurrentErrors.push(error2);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root3, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root3.finishedWork;
            var lanes = root3.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            if (finishedWork === root3.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root3.callbackNode = null;
            root3.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root3, remainingLanes);
            if (root3 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root3, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root3, finishedWork, lanes);
              resetAfterCommit(root3.containerInfo);
              root3.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root3, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root3.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root3;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root3.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root3.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root3.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root3, now2());
            if (recoverableErrors !== null) {
              var onRecoverableError = root3.onRecoverableError;
              for (var i2 = 0; i2 < recoverableErrors.length; i2++) {
                var recoverableError = recoverableErrors[i2];
                var componentStack = recoverableError.stack;
                var digest = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root3.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root3 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root3;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root3 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root3.current);
            commitPassiveMountEffects(root3, root3.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i2 = 0; i2 < profilerEffects.length; i2++) {
                var _fiber = profilerEffects[i2];
                commitPassiveEffectDurations(root3, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root3.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root3 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root3;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root3);
            {
              var stateNode = root3.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error2) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error2;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
            var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root3 = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root3 !== null) {
              markRootUpdated(root3, SyncLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root3 = enqueueUpdate(fiber, update, SyncLane);
                  var eventTime = requestEventTime();
                  if (root3 !== null) {
                    markRootUpdated(root3, SyncLane, eventTime);
                    ensureRootIsScheduled(root3, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root3, wakeable, pingedLanes) {
            var pingCache = root3.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root3, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root3);
            if (workInProgressRoot === root3 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root3, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root3, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root3 !== null) {
              markRootUpdated(root3, retryLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root3, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root3, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
            {
              if (root3.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root3, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync2(function() {
                scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root3, element) {
            {
              if (root3.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync2(function() {
                updateContainer(element, root3, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root !== null) {
                  scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root3, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types2 = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root3.current, types2, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types2.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e3) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component2) {
            if (typeof Component2 === "function") {
              return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
            } else if (Component2 !== void 0 && Component2 !== null) {
              var $$typeof = Component2.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode;
              if (isStrictMode === true) {
                mode |= StrictLegacyMode;
                {
                  mode |= StrictEffectsMode;
                }
              }
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictLegacyMode;
                    if ((mode & ConcurrentMode) !== NoMode) {
                      mode |= StrictEffectsMode;
                    }
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                  case REACT_SCOPE_TYPE:
                  case REACT_CACHE_TYPE:
                  case REACT_TRACING_MARKER_TYPE:
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment8, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i = 0; _i < TotalLanes; _i++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root3 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root3.current = uninitializedFiber;
            uninitializedFiber.stateNode = root3;
            {
              var _initialState = {
                element: initialChildren,
                isDehydrated: hydrate2,
                cache: null,
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root3;
          }
          var ReactVersion = "18.2.0";
          function createPortal(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key);
            }
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get2(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component2 = fiber.type;
              if (isContextProvider(Component2)) {
                return processChildContext(fiber, Component2, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get2(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys = Object.keys(component).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = true;
            var root3 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root3.context = getContextForSubtree(null);
            var current2 = root3.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update = createUpdate(eventTime, lane);
            update.callback = callback !== void 0 && callback !== null ? callback : null;
            enqueueUpdate(current2, update, lane);
            scheduleInitialHydrationOnRoot(root3, lane, eventTime);
            return root3;
          }
          function updateContainer(element, container2, parentComponent, callback) {
            {
              onScheduleRoot(container2, element);
            }
            var current$1 = container2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container2.context === null) {
              container2.context = context;
            } else {
              container2.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            var root3 = enqueueUpdate(current$1, update, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, current$1, lane, eventTime);
              entangleTransitions(root3, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container2) {
            var containerFiber = container2.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root3 = fiber.stateNode;
                if (isRootDehydrated(root3)) {
                  var lanes = getHighestPriorityPendingLanes(root3);
                  flushRoot(root3, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync2(function() {
                  var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root4 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index3) {
              var key = path[index3];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              if (index3 + 1 === path.length) {
                if (isArray(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index3 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index3) {
              var oldKey = oldPath[index3];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              if (index3 + 1 === oldPath.length) {
                var newKey = newPath[index3];
                updated[newKey] = updated[oldKey];
                if (isArray(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index3 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i2 = 0; i2 < newPath.length - 1; i2++) {
                  if (oldPath[i2] !== newPath[i2]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index3, value) {
              if (index3 >= path.length) {
                return value;
              }
              var key = path[index3];
              var updated = isArray(obj) ? obj.slice() : assign({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index3 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id > 0) {
                currentHook2 = currentHook2.next;
                id--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id, path, value) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id, path) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
              var hook = findHook(fiber, id);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              getCurrentFiber: getCurrentFiberForDevTools,
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? reportError : function(error2) {
            console["error"](error2);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root3 = this._internalRoot;
            if (root3 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container2 = root3.containerInfo;
              if (container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root3.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root3, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root3 = this._internalRoot;
            if (root3 !== null) {
              this._internalRoot = null;
              var container2 = root3.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync2(function() {
                updateContainer(null, root3, null, null);
              });
              unmarkContainerAsRoot(container2);
            }
          };
          function createRoot2(container2, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options2 !== null && options2 !== void 0) {
              {
                if (options2.hydrate) {
                  warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                    error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
              if (options2.transitionCallbacks !== void 0) {
                transitionCallbacks = options2.transitionCallbacks;
              }
            }
            var root3 = createContainer(container2, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container2);
            var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root3);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target) {
            if (target) {
              queueExplicitHydrationTarget(target);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container2, initialChildren, options2) {
            if (!isValidContainer(container2)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container2);
            {
              if (initialChildren === void 0) {
                error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options2 != null ? options2 : null;
            var mutableSources = options2 != null && options2.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options2 !== null && options2 !== void 0) {
              if (options2.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options2.identifierPrefix !== void 0) {
                identifierPrefix = options2.identifierPrefix;
              }
              if (options2.onRecoverableError !== void 0) {
                onRecoverableError = options2.onRecoverableError;
              }
            }
            var root3 = createHydrationContainer(initialChildren, null, container2, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container2);
            listenToAllSupportedEvents(container2);
            if (mutableSources) {
              for (var i2 = 0; i2 < mutableSources.length; i2++) {
                var mutableSource = mutableSources[i2];
                registerMutableSourceForHydration(root3, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root3);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE2 || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE2 || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container2) {
            {
              if (container2.nodeType === ELEMENT_NODE2 && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container2)) {
                if (container2._reactRootContainer) {
                  error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container2) {
              if (container2._reactRootContainer && container2.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container2._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container2) {
                    error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container2._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container2);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container2.nodeType === ELEMENT_NODE2 && container2.tagName && container2.tagName.toUpperCase() === "BODY") {
                error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container2) {
            if (!container2) {
              return null;
            }
            if (container2.nodeType === DOCUMENT_NODE) {
              return container2.documentElement;
            } else {
              return container2.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container2, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              var root3 = createHydrationContainer(
                initialChildren,
                callback,
                container2,
                LegacyRoot,
                null,
                false,
                false,
                "",
                noopOnRecoverableError
              );
              container2._reactRootContainer = root3;
              markContainerAsRoot(root3.current, container2);
              var rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync2();
              return root3;
            } else {
              var rootSibling;
              while (rootSibling = container2.lastChild) {
                container2.removeChild(rootSibling);
              }
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(_root);
                  _originalCallback.call(instance);
                };
              }
              var _root = createContainer(
                container2,
                LegacyRoot,
                null,
                false,
                false,
                "",
                noopOnRecoverableError
              );
              container2._reactRootContainer = _root;
              markContainerAsRoot(_root.current, container2);
              var _rootContainerElement = container2.nodeType === COMMENT_NODE ? container2.parentNode : container2;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync2(function() {
                updateContainer(initialChildren, _root, parentComponent, callback);
              });
              return _root;
            }
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container2, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container2);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var maybeRoot = container2._reactRootContainer;
            var root3;
            if (!maybeRoot) {
              root3 = legacyCreateRootFromDOMContainer(container2, children, parentComponent, callback, forceHydrate);
            } else {
              root3 = maybeRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root3, parentComponent, callback);
            }
            return getPublicRootInstance(root3);
          }
          function findDOMNode(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE2) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container2, callback) {
            {
              error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, true, callback);
          }
          function render(element, container2, callback) {
            {
              error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container2, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
              error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container2) {
            if (!isValidContainerLegacy(container2)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container2) && container2._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container2._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container2);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync2(function() {
                legacyRenderSubtreeIntoContainer(null, null, container2, false, function() {
                  container2._reactRootContainer = null;
                  unmarkContainerAsRoot(container2);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container2);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container2.nodeType === ELEMENT_NODE2 && isValidContainerLegacy(container2.parentNode) && !!container2.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync2);
          function createPortal$1(children, container2) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container2)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal(children, container2, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          var Internals = {
            usingClientEntryPoint: false,
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container2, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot2(container2, options2);
          }
          function hydrateRoot$1(container2, initialChildren, options2) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container2, initialChildren, options2);
          }
          function flushSync$1(fn2) {
            {
              if (isAlreadyRendering()) {
                error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync2(fn2);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol = window.location.protocol;
                if (/^(https?|file):$/.test(protocol)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports2.createPortal = createPortal$1;
          exports2.createRoot = createRoot$1;
          exports2.findDOMNode = findDOMNode;
          exports2.flushSync = flushSync$1;
          exports2.hydrate = hydrate;
          exports2.hydrateRoot = hydrateRoot$1;
          exports2.render = render;
          exports2.unmountComponentAtNode = unmountComponentAtNode;
          exports2.unstable_batchedUpdates = batchedUpdates$1;
          exports2.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports2.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports2, module2) {
      "use strict";
      if (false) {
        checkDCE();
        module2.exports = null;
      } else {
        module2.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "node_modules/tslib/tslib.js"(exports2, module2) {
      var __extends2;
      var __assign2;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __classPrivateFieldIn2;
      var __createBinding2;
      (function(factory) {
        var root2 = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports3) {
            factory(createExporter(root2, createExporter(exports3)));
          });
        } else if (typeof module2 === "object" && typeof module2.exports === "object") {
          factory(createExporter(root2, createExporter(module2.exports)));
        } else {
          factory(createExporter(root2));
        }
        function createExporter(exports3, previous) {
          if (exports3 !== root2) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports3, "__esModule", { value: true });
            } else {
              exports3.__esModule = true;
            }
          }
          return function(id, v2) {
            return exports3[id] = previous ? previous(id, v2) : v2;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        __extends2 = function(d3, b3) {
          if (typeof b3 !== "function" && b3 !== null)
            throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
          extendStatics(d3, b3);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
        };
        __assign2 = Object.assign || function(t2) {
          for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            s2 = arguments[i2];
            for (var p2 in s2)
              if (Object.prototype.hasOwnProperty.call(s2, p2))
                t2[p2] = s2[p2];
          }
          return t2;
        };
        __rest2 = function(s2, e3) {
          var t2 = {};
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
              t2[p2] = s2[p2];
          if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
              if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
                t2[p2[i2]] = s2[p2[i2]];
            }
          return t2;
        };
        __decorate2 = function(decorators, target, key, desc) {
          var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r2 = Reflect.decorate(decorators, target, key, desc);
          else
            for (var i2 = decorators.length - 1; i2 >= 0; i2--)
              if (d3 = decorators[i2])
                r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
          return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key) {
            decorator(target, key, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P3, generator) {
          function adopt(value) {
            return value instanceof P3 ? value : new P3(function(resolve) {
              resolve(value);
            });
          }
          return new (P3 || (P3 = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e3) {
                reject(e3);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e3) {
                reject(e3);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t2[0] & 1)
              throw t2[1];
            return t2[1];
          }, trys: [], ops: [] }, f2, y2, t2, g2;
          return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
            return this;
          }), g2;
          function verb(n2) {
            return function(v2) {
              return step([n2, v2]);
            };
          }
          function step(op) {
            if (f2)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
                  return t2;
                if (y2 = 0, t2)
                  op = [op[0] & 2, t2.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t2 = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y2 = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t2[1]) {
                      _.label = t2[1];
                      t2 = op;
                      break;
                    }
                    if (t2 && _.label < t2[2]) {
                      _.label = t2[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t2[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e3) {
                op = [6, e3];
                y2 = 0;
              } finally {
                f2 = t2 = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m2, o2) {
          for (var p2 in m2)
            if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2))
              __createBinding2(o2, m2, p2);
        };
        __createBinding2 = Object.create ? function(o2, m2, k3, k22) {
          if (k22 === void 0)
            k22 = k3;
          var desc = Object.getOwnPropertyDescriptor(m2, k3);
          if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m2[k3];
            } };
          }
          Object.defineProperty(o2, k22, desc);
        } : function(o2, m2, k3, k22) {
          if (k22 === void 0)
            k22 = k3;
          o2[k22] = m2[k3];
        };
        __values2 = function(o2) {
          var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o2[s2], i2 = 0;
          if (m2)
            return m2.call(o2);
          if (o2 && typeof o2.length === "number")
            return {
              next: function() {
                if (o2 && i2 >= o2.length)
                  o2 = void 0;
                return { value: o2 && o2[i2++], done: !o2 };
              }
            };
          throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o2, n2) {
          var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
          if (!m2)
            return o2;
          var i2 = m2.call(o2), r2, ar2 = [], e3;
          try {
            while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
              ar2.push(r2.value);
          } catch (error) {
            e3 = { error };
          } finally {
            try {
              if (r2 && !r2.done && (m2 = i2["return"]))
                m2.call(i2);
            } finally {
              if (e3)
                throw e3.error;
            }
          }
          return ar2;
        };
        __spread2 = function() {
          for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
            ar2 = ar2.concat(__read2(arguments[i2]));
          return ar2;
        };
        __spreadArrays2 = function() {
          for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
            s2 += arguments[i2].length;
          for (var r2 = Array(s2), k3 = 0, i2 = 0; i2 < il; i2++)
            for (var a2 = arguments[i2], j3 = 0, jl = a2.length; j3 < jl; j3++, k3++)
              r2[k3] = a2[j3];
          return r2;
        };
        __spreadArray2 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i2 = 0, l2 = from.length, ar2; i2 < l2; i2++) {
              if (ar2 || !(i2 in from)) {
                if (!ar2)
                  ar2 = Array.prototype.slice.call(from, 0, i2);
                ar2[i2] = from[i2];
              }
            }
          return to.concat(ar2 || Array.prototype.slice.call(from));
        };
        __await2 = function(v2) {
          return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g2 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
          return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
            return this;
          }, i2;
          function verb(n2) {
            if (g2[n2])
              i2[n2] = function(v2) {
                return new Promise(function(a2, b3) {
                  q3.push([n2, v2, a2, b3]) > 1 || resume(n2, v2);
                });
              };
          }
          function resume(n2, v2) {
            try {
              step(g2[n2](v2));
            } catch (e3) {
              settle(q3[0][3], e3);
            }
          }
          function step(r2) {
            r2.value instanceof __await2 ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q3[0][2], r2);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f2, v2) {
            if (f2(v2), q3.shift(), q3.length)
              resume(q3[0][0], q3[0][1]);
          }
        };
        __asyncDelegator2 = function(o2) {
          var i2, p2;
          return i2 = {}, verb("next"), verb("throw", function(e3) {
            throw e3;
          }), verb("return"), i2[Symbol.iterator] = function() {
            return this;
          }, i2;
          function verb(n2, f2) {
            i2[n2] = o2[n2] ? function(v2) {
              return (p2 = !p2) ? { value: __await2(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
            } : f2;
          }
        };
        __asyncValues2 = function(o2) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m2 = o2[Symbol.asyncIterator], i2;
          return m2 ? m2.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
            return this;
          }, i2);
          function verb(n2) {
            i2[n2] = o2[n2] && function(v2) {
              return new Promise(function(resolve, reject) {
                v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
              });
            };
          }
          function settle(resolve, reject, d3, v2) {
            Promise.resolve(v2).then(function(v3) {
              resolve({ value: v3, done: d3 });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o2, v2) {
          Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
        } : function(o2, v2) {
          o2["default"] = v2;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k3 in mod)
              if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
                __createBinding2(result, mod, k3);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
          if (kind === "a" && !f2)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn2 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign2);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
      });
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.development.js
  var require_react_jsx_runtime_development = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.development.js"(exports2) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React30 = require_react();
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactSharedInternals = React30.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init(payload));
                  } catch (x2) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x2) {
                  var match = x2.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x2) {
                    control = x2;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x2) {
                    control = x2;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x2) {
                  control = x2;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s2 = sampleLines.length - 1;
                var c2 = controlLines.length - 1;
                while (s2 >= 1 && c2 >= 0 && sampleLines[s2] !== controlLines[c2]) {
                  c2--;
                }
                for (; s2 >= 1 && c2 >= 0; s2--, c2--) {
                  if (sampleLines[s2] !== controlLines[c2]) {
                    if (s2 !== 1 || c2 !== 1) {
                      do {
                        s2--;
                        c2--;
                        if (c2 < 0 || sampleLines[s2] !== controlLines[c2]) {
                          var _frame = "\n" + sampleLines[s2].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s2 >= 1 && c2 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                  } catch (x2) {
                  }
                }
              }
            }
            return "";
          }
          var hasOwnProperty = Object.prototype.hasOwnProperty;
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray(a2) {
            return isArrayImpl(a2);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e3) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown;
          var specialPropRefWarningShown;
          var didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config) {
            {
              if (hasOwnProperty.call(config, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.ref !== void 0;
          }
          function hasValidKey(config) {
            {
              if (hasOwnProperty.call(config, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config.key !== void 0;
          }
          function warnIfStringRefCannotBeAutoConverted(config, self2) {
            {
              if (typeof config.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          function defineKeyPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingKey = function() {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingKey.isReactWarning = true;
              Object.defineProperty(props, "key", {
                get: warnAboutAccessingKey,
                configurable: true
              });
            }
          }
          function defineRefPropWarningGetter(props, displayName) {
            {
              var warnAboutAccessingRef = function() {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              };
              warnAboutAccessingRef.isReactWarning = true;
              Object.defineProperty(props, "ref", {
                get: warnAboutAccessingRef,
                configurable: true
              });
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function jsxDEV(type, config, maybeKey, source, self2) {
            {
              var propName;
              var props = {};
              var key = null;
              var ref = null;
              if (maybeKey !== void 0) {
                {
                  checkKeyStringCoercion(maybeKey);
                }
                key = "" + maybeKey;
              }
              if (hasValidKey(config)) {
                {
                  checkKeyStringCoercion(config.key);
                }
                key = "" + config.key;
              }
              if (hasValidRef(config)) {
                ref = config.ref;
                warnIfStringRefCannotBeAutoConverted(config, self2);
              }
              for (propName in config) {
                if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config[propName];
                }
              }
              if (type && type.defaultProps) {
                var defaultProps = type.defaultProps;
                for (propName in defaultProps) {
                  if (props[propName] === void 0) {
                    props[propName] = defaultProps[propName];
                  }
                }
              }
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
              return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function isValidElement2(object) {
            {
              return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
            }
          }
          function getDeclarationErrorAddendum() {
            {
              if (ReactCurrentOwner$1.current) {
                var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
                if (name) {
                  return "\n\nCheck the render method of `" + name + "`.";
                }
              }
              return "";
            }
          }
          function getSourceInfoErrorAddendum(source) {
            {
              if (source !== void 0) {
                var fileName = source.fileName.replace(/^.*[\\\/]/, "");
                var lineNumber = source.lineNumber;
                return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
              }
              return "";
            }
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            {
              var info = getDeclarationErrorAddendum();
              if (!info) {
                var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
                if (parentName) {
                  info = "\n\nCheck the top-level render call using <" + parentName + ">.";
                }
              }
              return info;
            }
          }
          function validateExplicitKey(element, parentType) {
            {
              if (!element._store || element._store.validated || element.key != null) {
                return;
              }
              element._store.validated = true;
              var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
              if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
                return;
              }
              ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
              var childOwner = "";
              if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
                childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
              }
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            {
              if (typeof node !== "object") {
                return;
              }
              if (isArray(node)) {
                for (var i2 = 0; i2 < node.length; i2++) {
                  var child = node[i2];
                  if (isValidElement2(child)) {
                    validateExplicitKey(child, parentType);
                  }
                }
              } else if (isValidElement2(node)) {
                if (node._store) {
                  node._store.validated = true;
                }
              } else if (node) {
                var iteratorFn = getIteratorFn(node);
                if (typeof iteratorFn === "function") {
                  if (iteratorFn !== node.entries) {
                    var iterator = iteratorFn.call(node);
                    var step;
                    while (!(step = iterator.next()).done) {
                      if (isValidElement2(step.value)) {
                        validateExplicitKey(step.value, parentType);
                      }
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys = Object.keys(fragment.props);
              for (var i2 = 0; i2 < keys.length; i2++) {
                var key = keys[i2];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function jsxWithValidation(type, props, key, isStaticChildren, source, self2) {
            {
              var validType = isValidElementType(type);
              if (!validType) {
                var info = "";
                if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var sourceInfo = getSourceInfoErrorAddendum(source);
                if (sourceInfo) {
                  info += sourceInfo;
                } else {
                  info += getDeclarationErrorAddendum();
                }
                var typeString;
                if (type === null) {
                  typeString = "null";
                } else if (isArray(type)) {
                  typeString = "array";
                } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                  typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                  info = " Did you accidentally export a JSX literal instead of a component?";
                } else {
                  typeString = typeof type;
                }
                error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
              var element = jsxDEV(type, props, key, source, self2);
              if (element == null) {
                return element;
              }
              if (validType) {
                var children = props.children;
                if (children !== void 0) {
                  if (isStaticChildren) {
                    if (isArray(children)) {
                      for (var i2 = 0; i2 < children.length; i2++) {
                        validateChildKeys(children[i2], type);
                      }
                      if (Object.freeze) {
                        Object.freeze(children);
                      }
                    } else {
                      error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                    }
                  } else {
                    validateChildKeys(children, type);
                  }
                }
              }
              if (type === REACT_FRAGMENT_TYPE) {
                validateFragmentProps(element);
              } else {
                validatePropTypes(element);
              }
              return element;
            }
          }
          function jsxWithValidationStatic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, true);
            }
          }
          function jsxWithValidationDynamic(type, props, key) {
            {
              return jsxWithValidation(type, props, key, false);
            }
          }
          var jsx = jsxWithValidationDynamic;
          var jsxs = jsxWithValidationStatic;
          exports2.Fragment = REACT_FRAGMENT_TYPE;
          exports2.jsx = jsx;
          exports2.jsxs = jsxs;
        })();
      }
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports2, module2) {
      "use strict";
      if (false) {
        module2.exports = null;
      } else {
        module2.exports = require_react_jsx_runtime_development();
      }
    }
  });

  // node_modules/fast-deep-equal/index.js
  var require_fast_deep_equal = __commonJS({
    "node_modules/fast-deep-equal/index.js"(exports2, module2) {
      "use strict";
      module2.exports = function equal2(a2, b3) {
        if (a2 === b3)
          return true;
        if (a2 && b3 && typeof a2 == "object" && typeof b3 == "object") {
          if (a2.constructor !== b3.constructor)
            return false;
          var length, i2, keys;
          if (Array.isArray(a2)) {
            length = a2.length;
            if (length != b3.length)
              return false;
            for (i2 = length; i2-- !== 0; )
              if (!equal2(a2[i2], b3[i2]))
                return false;
            return true;
          }
          if (a2.constructor === RegExp)
            return a2.source === b3.source && a2.flags === b3.flags;
          if (a2.valueOf !== Object.prototype.valueOf)
            return a2.valueOf() === b3.valueOf();
          if (a2.toString !== Object.prototype.toString)
            return a2.toString() === b3.toString();
          keys = Object.keys(a2);
          length = keys.length;
          if (length !== Object.keys(b3).length)
            return false;
          for (i2 = length; i2-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(b3, keys[i2]))
              return false;
          for (i2 = length; i2-- !== 0; ) {
            var key = keys[i2];
            if (!equal2(a2[key], b3[key]))
              return false;
          }
          return true;
        }
        return a2 !== a2 && b3 !== b3;
      };
    }
  });

  // node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js
  var require_typesafe_actions_umd_production = __commonJS({
    "node_modules/typesafe-actions/dist/typesafe-actions.umd.production.js"(exports2, module2) {
      !function(n2, t2) {
        "object" == typeof exports2 && "undefined" != typeof module2 ? t2(exports2) : "function" == typeof define && define.amd ? define(["exports"], t2) : t2((n2 = n2 || self).TypesafeActions = {});
      }(exports2, function(n2) {
        "use strict";
        function t2(n3) {
          return null == n3;
        }
        function r2(n3) {
          throw new Error("Argument " + n3 + " is empty.");
        }
        function e3(n3) {
          return "function" == typeof n3 && "getType" in n3;
        }
        function i2(n3) {
          throw new Error("Argument " + n3 + ' is invalid, it should be an action-creator instance from "typesafe-actions"');
        }
        function o2(n3, t3) {
          if (null == n3)
            throw new Error("Argument contains array with empty element at index " + t3);
          if (null == n3.getType)
            throw new Error("Argument contains array with invalid element at index " + t3 + ', it should be an action-creator instance from "typesafe-actions"');
        }
        function u2(n3) {
          return "string" == typeof n3 || "symbol" == typeof n3;
        }
        function a2(n3) {
          return !u2(n3);
        }
        function c2(n3) {
          throw new Error("Argument " + n3 + " is invalid, it should be an action type of type: string | symbol");
        }
        function f2(n3, t3) {
          if (null == n3)
            throw new Error("Argument contains array with empty element at index " + t3);
          if ("string" != typeof n3 && "symbol" != typeof n3)
            throw new Error("Argument contains array with invalid element at index " + t3 + ", it should be of type: string | symbol");
        }
        function s2(n3, e4, o3, u3) {
          return t2(n3) && r2(1), a2(n3) && i2(1), { type: n3, payload: e4, meta: o3, error: u3 };
        }
        function y2(n3, e4) {
          t2(n3) && r2(1), a2(n3) && c2(1);
          return Object.assign(function() {
            var t3 = null != e4 ? e4.apply(void 0, arguments) : void 0;
            return Object.assign({ type: n3 }, t3);
          }, { getType: function() {
            return n3;
          }, toString: function() {
            return n3;
          } });
        }
        function l2(n3, e4, i3) {
          return t2(n3) && r2(1), a2(n3) && c2(1), function() {
            return y2(n3, function() {
              var n4 = arguments.length <= 0 ? void 0 : arguments[0], t3 = arguments.length <= 1 ? void 0 : arguments[1];
              return null == e4 && null == i3 || (n4 = null != e4 ? e4.apply(void 0, arguments) : void 0, t3 = null != i3 ? i3.apply(void 0, arguments) : void 0), Object.assign({}, void 0 !== n4 && { payload: n4 }, {}, void 0 !== t3 && { meta: t3 });
            });
          };
        }
        function p2(n3) {
          return t2(n3) && r2(1), e3(n3) || i2(1), n3.getType();
        }
        function d3(n3, e4) {
          t2(n3) && r2(1), a2(n3) && c2(1);
          var i3 = null != e4 ? e4(n3) : function() {
            return { type: n3 };
          };
          return Object.assign(i3, { getType: function() {
            return n3;
          }, toString: function() {
            return n3;
          } });
        }
        var g2 = { createAction: function(n3, t3) {
          var r3 = null == t3 ? function() {
            return s2(n3);
          } : t3(s2.bind(null, n3));
          return Object.assign(r3, { getType: function() {
            return n3;
          }, toString: function() {
            return n3;
          } });
        }, createCustomAction: d3, createStandardAction: function(n3) {
          return t2(n3) && r2(1), a2(n3) && c2(1), Object.assign(function() {
            return d3(n3, function(n4) {
              return function(t3, r3) {
                return { type: n4, payload: t3, meta: r3 };
              };
            });
          }, { map: function(t3) {
            return d3(n3, function(n4) {
              return function(r3, e4) {
                return Object.assign(t3(r3, e4), { type: n4 });
              };
            });
          } });
        } };
        n2.action = s2, n2.createAction = l2, n2.createAsyncAction = function(n3, t3, r3, e4) {
          return function() {
            var i3 = [n3, t3, r3, e4].map(function(n4, t4) {
              return Array.isArray(n4) ? l2(n4[0], n4[1], n4[2])() : "string" == typeof n4 || "symbol" == typeof n4 ? l2(n4)() : void (t4 < 3 && function(n5) {
                throw new Error("Argument " + n5 + ' is invalid, it should be an action type of "string | symbol" or a tuple of "[string | symbol, Function, Function?]"');
              }(t4));
            });
            return { request: i3[0], success: i3[1], failure: i3[2], cancel: i3[3] };
          };
        }, n2.createCustomAction = y2, n2.createReducer = function n3(t3, r3) {
          void 0 === r3 && (r3 = {});
          var i3 = Object.assign({}, r3), o3 = function(r4, o4) {
            var a3 = Array.isArray(r4) ? r4 : [r4], c3 = {};
            return a3.map(function(n4, t4) {
              return e3(n4) ? p2(n4) : u2(n4) ? n4 : function(n5) {
                throw new Error("Argument " + n5 + ' is invalid, it should be an action-creator instance from "typesafe-actions" or action type of type: string | symbol');
              }(t4 + 1);
            }).forEach(function(n4) {
              return c3[n4] = o4;
            }), n3(t3, Object.assign({}, i3, {}, c3));
          };
          return Object.assign(function(n4, r4) {
            if (void 0 === n4 && (n4 = t3), i3.hasOwnProperty(r4.type)) {
              var e4 = i3[r4.type];
              if ("function" != typeof e4)
                throw Error('Reducer under "' + r4.type + '" key is not a valid reducer');
              return e4(n4, r4);
            }
            return n4;
          }, { handlers: Object.assign({}, i3), handleAction: o3, handleType: o3 });
        }, n2.deprecated = g2, n2.getType = p2, n2.isActionOf = function(n3, e4) {
          t2(n3) && r2(1);
          var i3 = Array.isArray(n3) ? n3 : [n3];
          i3.forEach(o2);
          var u3 = function(n4) {
            return i3.some(function(t3) {
              return n4.type === t3.getType();
            });
          };
          return void 0 === e4 ? u3 : u3(e4);
        }, n2.isOfType = function(n3, e4) {
          t2(n3) && r2(1);
          var i3 = Array.isArray(n3) ? n3 : [n3];
          i3.forEach(f2);
          var o3 = function(n4) {
            return i3.includes(n4.type);
          };
          return void 0 === e4 ? o3 : o3(e4);
        };
      });
    }
  });

  // node_modules/react-error-boundary/dist/react-error-boundary.cjs.js
  var require_react_error_boundary_cjs = __commonJS({
    "node_modules/react-error-boundary/dist/react-error-boundary.cjs.js"(exports2) {
      "use strict";
      "use client";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var react = require_react();
      var ErrorBoundaryContext2 = react.createContext(null);
      var initialState3 = {
        didCatch: false,
        error: null
      };
      var ErrorBoundary2 = class extends react.Component {
        constructor(props) {
          super(props);
          this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
          this.state = initialState3;
        }
        static getDerivedStateFromError(error) {
          return {
            didCatch: true,
            error
          };
        }
        resetErrorBoundary() {
          const {
            error
          } = this.state;
          if (error !== null) {
            var _this$props$onReset, _this$props;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
              args,
              reason: "imperative-api"
            });
            this.setState(initialState3);
          }
        }
        componentDidCatch(error, info) {
          var _this$props$onError, _this$props2;
          (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
        }
        componentDidUpdate(prevProps, prevState) {
          const {
            didCatch
          } = this.state;
          const {
            resetKeys
          } = this.props;
          if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
            var _this$props$onReset2, _this$props3;
            (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
              next: resetKeys,
              prev: prevProps.resetKeys,
              reason: "keys"
            });
            this.setState(initialState3);
          }
        }
        render() {
          const {
            children,
            fallbackRender,
            FallbackComponent,
            fallback
          } = this.props;
          const {
            didCatch,
            error
          } = this.state;
          let childToRender = children;
          if (didCatch) {
            const props = {
              error,
              resetErrorBoundary: this.resetErrorBoundary
            };
            if (react.isValidElement(fallback)) {
              childToRender = fallback;
            } else if (typeof fallbackRender === "function") {
              childToRender = fallbackRender(props);
            } else if (FallbackComponent) {
              childToRender = react.createElement(FallbackComponent, props);
            } else {
              throw error;
            }
          }
          return react.createElement(ErrorBoundaryContext2.Provider, {
            value: {
              didCatch,
              error,
              resetErrorBoundary: this.resetErrorBoundary
            }
          }, childToRender);
        }
      };
      function hasArrayChanged() {
        let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        let b3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        return a2.length !== b3.length || a2.some((item, index2) => !Object.is(item, b3[index2]));
      }
      function assertErrorBoundaryContext(value) {
        if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") {
          throw new Error("ErrorBoundaryContext not found");
        }
        return true;
      }
      function useErrorBoundary2() {
        const context = react.useContext(ErrorBoundaryContext2);
        assertErrorBoundaryContext(context);
        const [state, setState] = react.useState({
          error: null,
          hasError: false
        });
        const memoized = react.useMemo(() => ({
          resetBoundary: () => {
            context === null || context === void 0 ? void 0 : context.resetErrorBoundary();
            setState({
              error: null,
              hasError: false
            });
          },
          showBoundary: (error) => setState({
            error,
            hasError: true
          })
        }), [context === null || context === void 0 ? void 0 : context.resetErrorBoundary]);
        if (state.hasError) {
          throw state.error;
        }
        return memoized;
      }
      function withErrorBoundary2(component, errorBoundaryProps) {
        const Wrapped = react.forwardRef((props, ref) => react.createElement(ErrorBoundary2, errorBoundaryProps, react.createElement(component, {
          ...props,
          ref
        })));
        const name = component.displayName || component.name || "Unknown";
        Wrapped.displayName = "withErrorBoundary(".concat(name, ")");
        return Wrapped;
      }
      exports2.ErrorBoundary = ErrorBoundary2;
      exports2.ErrorBoundaryContext = ErrorBoundaryContext2;
      exports2.useErrorBoundary = useErrorBoundary2;
      exports2.withErrorBoundary = withErrorBoundary2;
    }
  });

  // node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-html.js
  var require_decode_data_html = __commonJS({
    "node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = new Uint16Array(
        '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c2) {
          return c2.charCodeAt(0);
        })
      );
    }
  });

  // node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-xml.js
  var require_decode_data_xml = __commonJS({
    "node_modules/htmlparser2/node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = new Uint16Array(
        "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c2) {
          return c2.charCodeAt(0);
        })
      );
    }
  });

  // node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js
  var require_decode_codepoint = __commonJS({
    "node_modules/htmlparser2/node_modules/entities/lib/decode_codepoint.js"(exports2) {
      "use strict";
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
      var decodeMap = /* @__PURE__ */ new Map([
        [0, 65533],
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376]
      ]);
      exports2.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
        var output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      };
      function replaceCodePoint(codePoint) {
        var _a2;
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          return 65533;
        }
        return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
      }
      exports2.replaceCodePoint = replaceCodePoint;
      function decodeCodePoint(codePoint) {
        return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
      }
      exports2.default = decodeCodePoint;
    }
  });

  // node_modules/htmlparser2/node_modules/entities/lib/decode.js
  var require_decode = __commonJS({
    "node_modules/htmlparser2/node_modules/entities/lib/decode.js"(exports2) {
      "use strict";
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m2, k3);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m2[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar2 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding2(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
      var decode_data_html_js_1 = __importDefault2(require_decode_data_html());
      exports2.htmlDecodeTree = decode_data_html_js_1.default;
      var decode_data_xml_js_1 = __importDefault2(require_decode_data_xml());
      exports2.xmlDecodeTree = decode_data_xml_js_1.default;
      var decode_codepoint_js_1 = __importStar2(require_decode_codepoint());
      exports2.decodeCodePoint = decode_codepoint_js_1.default;
      var decode_codepoint_js_2 = require_decode_codepoint();
      Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
        return decode_codepoint_js_2.replaceCodePoint;
      } });
      Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
        return decode_codepoint_js_2.fromCodePoint;
      } });
      var CharCodes;
      (function(CharCodes2) {
        CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
        CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
        CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
        CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
        CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
        CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
        CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
        CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
        CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
        CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
        CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
        CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
      })(CharCodes || (CharCodes = {}));
      var TO_LOWER_BIT = 32;
      var BinTrieFlags;
      (function(BinTrieFlags2) {
        BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
      })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
      function isNumber(code) {
        return code >= CharCodes.ZERO && code <= CharCodes.NINE;
      }
      function isHexadecimalCharacter(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
      }
      function isAsciiAlphaNumeric(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
      }
      function isEntityInAttributeInvalidEnd(code) {
        return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
      }
      var EntityDecoderState;
      (function(EntityDecoderState2) {
        EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
        EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
        EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
        EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
        EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
      })(EntityDecoderState || (EntityDecoderState = {}));
      var DecodingMode;
      (function(DecodingMode2) {
        DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
        DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
        DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
      })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
      var EntityDecoder = function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str, offset2) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset2) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset2 + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset2);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset2);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset2);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset2);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset2);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str, offset2) {
          if (offset2 >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset2 + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset2);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str, offset2) {
          var startIdx = offset2;
          while (offset2 < str.length) {
            var char = str.charCodeAt(offset2);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset2, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset2, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str, offset2) {
          var startIdx = offset2;
          while (offset2 < str.length) {
            var char = str.charCodeAt(offset2);
            if (isNumber(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset2, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset2, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str, offset2) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset2 < str.length; offset2++, this.excess++) {
            var char = str.charCodeAt(offset2);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }();
      exports2.EntityDecoder = EntityDecoder;
      function getDecoder(decodeTree) {
        var ret = "";
        var decoder2 = new EntityDecoder(decodeTree, function(str) {
          return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
        });
        return function decodeWithTrie(str, decodeMode) {
          var lastIndex = 0;
          var offset2 = 0;
          while ((offset2 = str.indexOf("&", offset2)) >= 0) {
            ret += str.slice(lastIndex, offset2);
            decoder2.startEntity(decodeMode);
            var len = decoder2.write(
              str,
              offset2 + 1
            );
            if (len < 0) {
              lastIndex = offset2 + decoder2.end();
              break;
            }
            lastIndex = offset2 + len;
            offset2 = len === 0 ? lastIndex + 1 : lastIndex;
          }
          var result = ret + str.slice(lastIndex);
          ret = "";
          return result;
        };
      }
      function determineBranch(decodeTree, current, nodeIdx, char) {
        var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        if (branchCount === 0) {
          return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
        }
        if (jumpOffset) {
          var value = char - jumpOffset;
          return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
        }
        var lo = nodeIdx;
        var hi = lo + branchCount - 1;
        while (lo <= hi) {
          var mid = lo + hi >>> 1;
          var midVal = decodeTree[mid];
          if (midVal < char) {
            lo = mid + 1;
          } else if (midVal > char) {
            hi = mid - 1;
          } else {
            return decodeTree[mid + branchCount];
          }
        }
        return -1;
      }
      exports2.determineBranch = determineBranch;
      var htmlDecoder = getDecoder(decode_data_html_js_1.default);
      var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
      function decodeHTML(str, mode) {
        if (mode === void 0) {
          mode = DecodingMode.Legacy;
        }
        return htmlDecoder(str, mode);
      }
      exports2.decodeHTML = decodeHTML;
      function decodeHTMLAttribute(str) {
        return htmlDecoder(str, DecodingMode.Attribute);
      }
      exports2.decodeHTMLAttribute = decodeHTMLAttribute;
      function decodeHTMLStrict(str) {
        return htmlDecoder(str, DecodingMode.Strict);
      }
      exports2.decodeHTMLStrict = decodeHTMLStrict;
      function decodeXML(str) {
        return xmlDecoder(str, DecodingMode.Strict);
      }
      exports2.decodeXML = decodeXML;
    }
  });

  // node_modules/htmlparser2/lib/Tokenizer.js
  var require_Tokenizer = __commonJS({
    "node_modules/htmlparser2/lib/Tokenizer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.QuoteType = void 0;
      var decode_js_1 = require_decode();
      var CharCodes;
      (function(CharCodes2) {
        CharCodes2[CharCodes2["Tab"] = 9] = "Tab";
        CharCodes2[CharCodes2["NewLine"] = 10] = "NewLine";
        CharCodes2[CharCodes2["FormFeed"] = 12] = "FormFeed";
        CharCodes2[CharCodes2["CarriageReturn"] = 13] = "CarriageReturn";
        CharCodes2[CharCodes2["Space"] = 32] = "Space";
        CharCodes2[CharCodes2["ExclamationMark"] = 33] = "ExclamationMark";
        CharCodes2[CharCodes2["Number"] = 35] = "Number";
        CharCodes2[CharCodes2["Amp"] = 38] = "Amp";
        CharCodes2[CharCodes2["SingleQuote"] = 39] = "SingleQuote";
        CharCodes2[CharCodes2["DoubleQuote"] = 34] = "DoubleQuote";
        CharCodes2[CharCodes2["Dash"] = 45] = "Dash";
        CharCodes2[CharCodes2["Slash"] = 47] = "Slash";
        CharCodes2[CharCodes2["Zero"] = 48] = "Zero";
        CharCodes2[CharCodes2["Nine"] = 57] = "Nine";
        CharCodes2[CharCodes2["Semi"] = 59] = "Semi";
        CharCodes2[CharCodes2["Lt"] = 60] = "Lt";
        CharCodes2[CharCodes2["Eq"] = 61] = "Eq";
        CharCodes2[CharCodes2["Gt"] = 62] = "Gt";
        CharCodes2[CharCodes2["Questionmark"] = 63] = "Questionmark";
        CharCodes2[CharCodes2["UpperA"] = 65] = "UpperA";
        CharCodes2[CharCodes2["LowerA"] = 97] = "LowerA";
        CharCodes2[CharCodes2["UpperF"] = 70] = "UpperF";
        CharCodes2[CharCodes2["LowerF"] = 102] = "LowerF";
        CharCodes2[CharCodes2["UpperZ"] = 90] = "UpperZ";
        CharCodes2[CharCodes2["LowerZ"] = 122] = "LowerZ";
        CharCodes2[CharCodes2["LowerX"] = 120] = "LowerX";
        CharCodes2[CharCodes2["OpeningSquareBracket"] = 91] = "OpeningSquareBracket";
      })(CharCodes || (CharCodes = {}));
      var State2;
      (function(State3) {
        State3[State3["Text"] = 1] = "Text";
        State3[State3["BeforeTagName"] = 2] = "BeforeTagName";
        State3[State3["InTagName"] = 3] = "InTagName";
        State3[State3["InSelfClosingTag"] = 4] = "InSelfClosingTag";
        State3[State3["BeforeClosingTagName"] = 5] = "BeforeClosingTagName";
        State3[State3["InClosingTagName"] = 6] = "InClosingTagName";
        State3[State3["AfterClosingTagName"] = 7] = "AfterClosingTagName";
        State3[State3["BeforeAttributeName"] = 8] = "BeforeAttributeName";
        State3[State3["InAttributeName"] = 9] = "InAttributeName";
        State3[State3["AfterAttributeName"] = 10] = "AfterAttributeName";
        State3[State3["BeforeAttributeValue"] = 11] = "BeforeAttributeValue";
        State3[State3["InAttributeValueDq"] = 12] = "InAttributeValueDq";
        State3[State3["InAttributeValueSq"] = 13] = "InAttributeValueSq";
        State3[State3["InAttributeValueNq"] = 14] = "InAttributeValueNq";
        State3[State3["BeforeDeclaration"] = 15] = "BeforeDeclaration";
        State3[State3["InDeclaration"] = 16] = "InDeclaration";
        State3[State3["InProcessingInstruction"] = 17] = "InProcessingInstruction";
        State3[State3["BeforeComment"] = 18] = "BeforeComment";
        State3[State3["CDATASequence"] = 19] = "CDATASequence";
        State3[State3["InSpecialComment"] = 20] = "InSpecialComment";
        State3[State3["InCommentLike"] = 21] = "InCommentLike";
        State3[State3["BeforeSpecialS"] = 22] = "BeforeSpecialS";
        State3[State3["SpecialStartSequence"] = 23] = "SpecialStartSequence";
        State3[State3["InSpecialTag"] = 24] = "InSpecialTag";
        State3[State3["BeforeEntity"] = 25] = "BeforeEntity";
        State3[State3["BeforeNumericEntity"] = 26] = "BeforeNumericEntity";
        State3[State3["InNamedEntity"] = 27] = "InNamedEntity";
        State3[State3["InNumericEntity"] = 28] = "InNumericEntity";
        State3[State3["InHexEntity"] = 29] = "InHexEntity";
      })(State2 || (State2 = {}));
      function isWhitespace(c2) {
        return c2 === CharCodes.Space || c2 === CharCodes.NewLine || c2 === CharCodes.Tab || c2 === CharCodes.FormFeed || c2 === CharCodes.CarriageReturn;
      }
      function isEndOfTagSection(c2) {
        return c2 === CharCodes.Slash || c2 === CharCodes.Gt || isWhitespace(c2);
      }
      function isNumber(c2) {
        return c2 >= CharCodes.Zero && c2 <= CharCodes.Nine;
      }
      function isASCIIAlpha(c2) {
        return c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerZ || c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperZ;
      }
      function isHexDigit(c2) {
        return c2 >= CharCodes.UpperA && c2 <= CharCodes.UpperF || c2 >= CharCodes.LowerA && c2 <= CharCodes.LowerF;
      }
      var QuoteType;
      (function(QuoteType2) {
        QuoteType2[QuoteType2["NoValue"] = 0] = "NoValue";
        QuoteType2[QuoteType2["Unquoted"] = 1] = "Unquoted";
        QuoteType2[QuoteType2["Single"] = 2] = "Single";
        QuoteType2[QuoteType2["Double"] = 3] = "Double";
      })(QuoteType = exports2.QuoteType || (exports2.QuoteType = {}));
      var Sequences = {
        Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
        CdataEnd: new Uint8Array([93, 93, 62]),
        CommentEnd: new Uint8Array([45, 45, 62]),
        ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
        StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
        TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
      };
      var Tokenizer = function() {
        function Tokenizer2(_a, cbs) {
          var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
          this.cbs = cbs;
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.isSpecial = false;
          this.running = true;
          this.offset = 0;
          this.currentSequence = void 0;
          this.sequenceIndex = 0;
          this.trieIndex = 0;
          this.trieCurrent = 0;
          this.entityResult = 0;
          this.entityExcess = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityTrie = xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree;
        }
        Tokenizer2.prototype.reset = function() {
          this.state = State2.Text;
          this.buffer = "";
          this.sectionStart = 0;
          this.index = 0;
          this.baseState = State2.Text;
          this.currentSequence = void 0;
          this.running = true;
          this.offset = 0;
        };
        Tokenizer2.prototype.write = function(chunk) {
          this.offset += this.buffer.length;
          this.buffer = chunk;
          this.parse();
        };
        Tokenizer2.prototype.end = function() {
          if (this.running)
            this.finish();
        };
        Tokenizer2.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer2.prototype.resume = function() {
          this.running = true;
          if (this.index < this.buffer.length + this.offset) {
            this.parse();
          }
        };
        Tokenizer2.prototype.getIndex = function() {
          return this.index;
        };
        Tokenizer2.prototype.getSectionStart = function() {
          return this.sectionStart;
        };
        Tokenizer2.prototype.stateText = function(c2) {
          if (c2 === CharCodes.Lt || !this.decodeEntities && this.fastForwardTo(CharCodes.Lt)) {
            if (this.index > this.sectionStart) {
              this.cbs.ontext(this.sectionStart, this.index);
            }
            this.state = State2.BeforeTagName;
            this.sectionStart = this.index;
          } else if (this.decodeEntities && c2 === CharCodes.Amp) {
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateSpecialStartSequence = function(c2) {
          var isEnd = this.sequenceIndex === this.currentSequence.length;
          var isMatch = isEnd ? isEndOfTagSection(c2) : (c2 | 32) === this.currentSequence[this.sequenceIndex];
          if (!isMatch) {
            this.isSpecial = false;
          } else if (!isEnd) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0;
          this.state = State2.InTagName;
          this.stateInTagName(c2);
        };
        Tokenizer2.prototype.stateInSpecialTag = function(c2) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (c2 === CharCodes.Gt || isWhitespace(c2)) {
              var endOfText = this.index - this.currentSequence.length;
              if (this.sectionStart < endOfText) {
                var actualIndex = this.index;
                this.index = endOfText;
                this.cbs.ontext(this.sectionStart, endOfText);
                this.index = actualIndex;
              }
              this.isSpecial = false;
              this.sectionStart = endOfText + 2;
              this.stateInClosingTagName(c2);
              return;
            }
            this.sequenceIndex = 0;
          }
          if ((c2 | 32) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
          } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
              if (this.decodeEntities && c2 === CharCodes.Amp) {
                this.state = State2.BeforeEntity;
              }
            } else if (this.fastForwardTo(CharCodes.Lt)) {
              this.sequenceIndex = 1;
            }
          } else {
            this.sequenceIndex = Number(c2 === CharCodes.Lt);
          }
        };
        Tokenizer2.prototype.stateCDATASequence = function(c2) {
          if (c2 === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
              this.state = State2.InCommentLike;
              this.currentSequence = Sequences.CdataEnd;
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
            }
          } else {
            this.sequenceIndex = 0;
            this.state = State2.InDeclaration;
            this.stateInDeclaration(c2);
          }
        };
        Tokenizer2.prototype.fastForwardTo = function(c2) {
          while (++this.index < this.buffer.length + this.offset) {
            if (this.buffer.charCodeAt(this.index - this.offset) === c2) {
              return true;
            }
          }
          this.index = this.buffer.length + this.offset - 1;
          return false;
        };
        Tokenizer2.prototype.stateInCommentLike = function(c2) {
          if (c2 === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
              if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(this.sectionStart, this.index, 2);
              } else {
                this.cbs.oncomment(this.sectionStart, this.index, 2);
              }
              this.sequenceIndex = 0;
              this.sectionStart = this.index + 1;
              this.state = State2.Text;
            }
          } else if (this.sequenceIndex === 0) {
            if (this.fastForwardTo(this.currentSequence[0])) {
              this.sequenceIndex = 1;
            }
          } else if (c2 !== this.currentSequence[this.sequenceIndex - 1]) {
            this.sequenceIndex = 0;
          }
        };
        Tokenizer2.prototype.isTagStartChar = function(c2) {
          return this.xmlMode ? !isEndOfTagSection(c2) : isASCIIAlpha(c2);
        };
        Tokenizer2.prototype.startSpecial = function(sequence, offset2) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset2;
          this.state = State2.SpecialStartSequence;
        };
        Tokenizer2.prototype.stateBeforeTagName = function(c2) {
          if (c2 === CharCodes.ExclamationMark) {
            this.state = State2.BeforeDeclaration;
            this.sectionStart = this.index + 1;
          } else if (c2 === CharCodes.Questionmark) {
            this.state = State2.InProcessingInstruction;
            this.sectionStart = this.index + 1;
          } else if (this.isTagStartChar(c2)) {
            var lower = c2 | 32;
            this.sectionStart = this.index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
              this.startSpecial(Sequences.TitleEnd, 3);
            } else {
              this.state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? State2.BeforeSpecialS : State2.InTagName;
            }
          } else if (c2 === CharCodes.Slash) {
            this.state = State2.BeforeClosingTagName;
          } else {
            this.state = State2.Text;
            this.stateText(c2);
          }
        };
        Tokenizer2.prototype.stateInTagName = function(c2) {
          if (isEndOfTagSection(c2)) {
            this.cbs.onopentagname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c2);
          }
        };
        Tokenizer2.prototype.stateBeforeClosingTagName = function(c2) {
          if (isWhitespace(c2)) {
          } else if (c2 === CharCodes.Gt) {
            this.state = State2.Text;
          } else {
            this.state = this.isTagStartChar(c2) ? State2.InClosingTagName : State2.InSpecialComment;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInClosingTagName = function(c2) {
          if (c2 === CharCodes.Gt || isWhitespace(c2)) {
            this.cbs.onclosetag(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterClosingTagName;
            this.stateAfterClosingTagName(c2);
          }
        };
        Tokenizer2.prototype.stateAfterClosingTagName = function(c2) {
          if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeName = function(c2) {
          if (c2 === CharCodes.Gt) {
            this.cbs.onopentagend(this.index);
            if (this.isSpecial) {
              this.state = State2.InSpecialTag;
              this.sequenceIndex = 0;
            } else {
              this.state = State2.Text;
            }
            this.baseState = this.state;
            this.sectionStart = this.index + 1;
          } else if (c2 === CharCodes.Slash) {
            this.state = State2.InSelfClosingTag;
          } else if (!isWhitespace(c2)) {
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateInSelfClosingTag = function(c2) {
          if (c2 === CharCodes.Gt) {
            this.cbs.onselfclosingtag(this.index);
            this.state = State2.Text;
            this.baseState = State2.Text;
            this.sectionStart = this.index + 1;
            this.isSpecial = false;
          } else if (!isWhitespace(c2)) {
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c2);
          }
        };
        Tokenizer2.prototype.stateInAttributeName = function(c2) {
          if (c2 === CharCodes.Eq || isEndOfTagSection(c2)) {
            this.cbs.onattribname(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.state = State2.AfterAttributeName;
            this.stateAfterAttributeName(c2);
          }
        };
        Tokenizer2.prototype.stateAfterAttributeName = function(c2) {
          if (c2 === CharCodes.Eq) {
            this.state = State2.BeforeAttributeValue;
          } else if (c2 === CharCodes.Slash || c2 === CharCodes.Gt) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c2);
          } else if (!isWhitespace(c2)) {
            this.cbs.onattribend(QuoteType.NoValue, this.index);
            this.state = State2.InAttributeName;
            this.sectionStart = this.index;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeValue = function(c2) {
          if (c2 === CharCodes.DoubleQuote) {
            this.state = State2.InAttributeValueDq;
            this.sectionStart = this.index + 1;
          } else if (c2 === CharCodes.SingleQuote) {
            this.state = State2.InAttributeValueSq;
            this.sectionStart = this.index + 1;
          } else if (!isWhitespace(c2)) {
            this.sectionStart = this.index;
            this.state = State2.InAttributeValueNq;
            this.stateInAttributeValueNoQuotes(c2);
          }
        };
        Tokenizer2.prototype.handleInAttributeValue = function(c2, quote) {
          if (c2 === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(quote === CharCodes.DoubleQuote ? QuoteType.Double : QuoteType.Single, this.index);
            this.state = State2.BeforeAttributeName;
          } else if (this.decodeEntities && c2 === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c2) {
          this.handleInAttributeValue(c2, CharCodes.DoubleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c2) {
          this.handleInAttributeValue(c2, CharCodes.SingleQuote);
        };
        Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c2) {
          if (isWhitespace(c2) || c2 === CharCodes.Gt) {
            this.cbs.onattribdata(this.sectionStart, this.index);
            this.sectionStart = -1;
            this.cbs.onattribend(QuoteType.Unquoted, this.index);
            this.state = State2.BeforeAttributeName;
            this.stateBeforeAttributeName(c2);
          } else if (this.decodeEntities && c2 === CharCodes.Amp) {
            this.baseState = this.state;
            this.state = State2.BeforeEntity;
          }
        };
        Tokenizer2.prototype.stateBeforeDeclaration = function(c2) {
          if (c2 === CharCodes.OpeningSquareBracket) {
            this.state = State2.CDATASequence;
            this.sequenceIndex = 0;
          } else {
            this.state = c2 === CharCodes.Dash ? State2.BeforeComment : State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInDeclaration = function(c2) {
          if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.ondeclaration(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateInProcessingInstruction = function(c2) {
          if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.onprocessinginstruction(this.sectionStart, this.index);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeComment = function(c2) {
          if (c2 === CharCodes.Dash) {
            this.state = State2.InCommentLike;
            this.currentSequence = Sequences.CommentEnd;
            this.sequenceIndex = 2;
            this.sectionStart = this.index + 1;
          } else {
            this.state = State2.InDeclaration;
          }
        };
        Tokenizer2.prototype.stateInSpecialComment = function(c2) {
          if (c2 === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {
            this.cbs.oncomment(this.sectionStart, this.index, 0);
            this.state = State2.Text;
            this.sectionStart = this.index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialS = function(c2) {
          var lower = c2 | 32;
          if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
          } else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
          } else {
            this.state = State2.InTagName;
            this.stateInTagName(c2);
          }
        };
        Tokenizer2.prototype.stateBeforeEntity = function(c2) {
          this.entityExcess = 1;
          this.entityResult = 0;
          if (c2 === CharCodes.Number) {
            this.state = State2.BeforeNumericEntity;
          } else if (c2 === CharCodes.Amp) {
          } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.state = State2.InNamedEntity;
            this.stateInNamedEntity(c2);
          }
        };
        Tokenizer2.prototype.stateInNamedEntity = function(c2) {
          this.entityExcess += 1;
          this.trieIndex = (0, decode_js_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c2);
          if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this.index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          var masked = this.trieCurrent & decode_js_1.BinTrieFlags.VALUE_LENGTH;
          if (masked) {
            var valueLength = (masked >> 14) - 1;
            if (!this.allowLegacyEntity() && c2 !== CharCodes.Semi) {
              this.trieIndex += valueLength;
            } else {
              var entityStart = this.index - this.entityExcess + 1;
              if (entityStart > this.sectionStart) {
                this.emitPartial(this.sectionStart, entityStart);
              }
              this.entityResult = this.trieIndex;
              this.trieIndex += valueLength;
              this.entityExcess = 0;
              this.sectionStart = this.index + 1;
              if (valueLength === 0) {
                this.emitNamedEntity();
              }
            }
          }
        };
        Tokenizer2.prototype.emitNamedEntity = function() {
          this.state = this.baseState;
          if (this.entityResult === 0) {
            return;
          }
          var valueLength = (this.entityTrie[this.entityResult] & decode_js_1.BinTrieFlags.VALUE_LENGTH) >> 14;
          switch (valueLength) {
            case 1: {
              this.emitCodePoint(this.entityTrie[this.entityResult] & ~decode_js_1.BinTrieFlags.VALUE_LENGTH);
              break;
            }
            case 2: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              break;
            }
            case 3: {
              this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
              this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
            }
          }
        };
        Tokenizer2.prototype.stateBeforeNumericEntity = function(c2) {
          if ((c2 | 32) === CharCodes.LowerX) {
            this.entityExcess++;
            this.state = State2.InHexEntity;
          } else {
            this.state = State2.InNumericEntity;
            this.stateInNumericEntity(c2);
          }
        };
        Tokenizer2.prototype.emitNumericEntity = function(strict) {
          var entityStart = this.index - this.entityExcess - 1;
          var numberStart = entityStart + 2 + Number(this.state === State2.InHexEntity);
          if (numberStart !== this.index) {
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.sectionStart, entityStart);
            }
            this.sectionStart = this.index + Number(strict);
            this.emitCodePoint((0, decode_js_1.replaceCodePoint)(this.entityResult));
          }
          this.state = this.baseState;
        };
        Tokenizer2.prototype.stateInNumericEntity = function(c2) {
          if (c2 === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c2)) {
            this.entityResult = this.entityResult * 10 + (c2 - CharCodes.Zero);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.stateInHexEntity = function(c2) {
          if (c2 === CharCodes.Semi) {
            this.emitNumericEntity(true);
          } else if (isNumber(c2)) {
            this.entityResult = this.entityResult * 16 + (c2 - CharCodes.Zero);
            this.entityExcess++;
          } else if (isHexDigit(c2)) {
            this.entityResult = this.entityResult * 16 + ((c2 | 32) - CharCodes.LowerA + 10);
            this.entityExcess++;
          } else {
            if (this.allowLegacyEntity()) {
              this.emitNumericEntity(false);
            } else {
              this.state = this.baseState;
            }
            this.index--;
          }
        };
        Tokenizer2.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === State2.Text || this.baseState === State2.InSpecialTag);
        };
        Tokenizer2.prototype.cleanup = function() {
          if (this.running && this.sectionStart !== this.index) {
            if (this.state === State2.Text || this.state === State2.InSpecialTag && this.sequenceIndex === 0) {
              this.cbs.ontext(this.sectionStart, this.index);
              this.sectionStart = this.index;
            } else if (this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueNq) {
              this.cbs.onattribdata(this.sectionStart, this.index);
              this.sectionStart = this.index;
            }
          }
        };
        Tokenizer2.prototype.shouldContinue = function() {
          return this.index < this.buffer.length + this.offset && this.running;
        };
        Tokenizer2.prototype.parse = function() {
          while (this.shouldContinue()) {
            var c2 = this.buffer.charCodeAt(this.index - this.offset);
            switch (this.state) {
              case State2.Text: {
                this.stateText(c2);
                break;
              }
              case State2.SpecialStartSequence: {
                this.stateSpecialStartSequence(c2);
                break;
              }
              case State2.InSpecialTag: {
                this.stateInSpecialTag(c2);
                break;
              }
              case State2.CDATASequence: {
                this.stateCDATASequence(c2);
                break;
              }
              case State2.InAttributeValueDq: {
                this.stateInAttributeValueDoubleQuotes(c2);
                break;
              }
              case State2.InAttributeName: {
                this.stateInAttributeName(c2);
                break;
              }
              case State2.InCommentLike: {
                this.stateInCommentLike(c2);
                break;
              }
              case State2.InSpecialComment: {
                this.stateInSpecialComment(c2);
                break;
              }
              case State2.BeforeAttributeName: {
                this.stateBeforeAttributeName(c2);
                break;
              }
              case State2.InTagName: {
                this.stateInTagName(c2);
                break;
              }
              case State2.InClosingTagName: {
                this.stateInClosingTagName(c2);
                break;
              }
              case State2.BeforeTagName: {
                this.stateBeforeTagName(c2);
                break;
              }
              case State2.AfterAttributeName: {
                this.stateAfterAttributeName(c2);
                break;
              }
              case State2.InAttributeValueSq: {
                this.stateInAttributeValueSingleQuotes(c2);
                break;
              }
              case State2.BeforeAttributeValue: {
                this.stateBeforeAttributeValue(c2);
                break;
              }
              case State2.BeforeClosingTagName: {
                this.stateBeforeClosingTagName(c2);
                break;
              }
              case State2.AfterClosingTagName: {
                this.stateAfterClosingTagName(c2);
                break;
              }
              case State2.BeforeSpecialS: {
                this.stateBeforeSpecialS(c2);
                break;
              }
              case State2.InAttributeValueNq: {
                this.stateInAttributeValueNoQuotes(c2);
                break;
              }
              case State2.InSelfClosingTag: {
                this.stateInSelfClosingTag(c2);
                break;
              }
              case State2.InDeclaration: {
                this.stateInDeclaration(c2);
                break;
              }
              case State2.BeforeDeclaration: {
                this.stateBeforeDeclaration(c2);
                break;
              }
              case State2.BeforeComment: {
                this.stateBeforeComment(c2);
                break;
              }
              case State2.InProcessingInstruction: {
                this.stateInProcessingInstruction(c2);
                break;
              }
              case State2.InNamedEntity: {
                this.stateInNamedEntity(c2);
                break;
              }
              case State2.BeforeEntity: {
                this.stateBeforeEntity(c2);
                break;
              }
              case State2.InHexEntity: {
                this.stateInHexEntity(c2);
                break;
              }
              case State2.InNumericEntity: {
                this.stateInNumericEntity(c2);
                break;
              }
              default: {
                this.stateBeforeNumericEntity(c2);
              }
            }
            this.index++;
          }
          this.cleanup();
        };
        Tokenizer2.prototype.finish = function() {
          if (this.state === State2.InNamedEntity) {
            this.emitNamedEntity();
          }
          if (this.sectionStart < this.index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer2.prototype.handleTrailingData = function() {
          var endIndex = this.buffer.length + this.offset;
          if (this.state === State2.InCommentLike) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(this.sectionStart, endIndex, 0);
            } else {
              this.cbs.oncomment(this.sectionStart, endIndex, 0);
            }
          } else if (this.state === State2.InNumericEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InHexEntity && this.allowLegacyEntity()) {
            this.emitNumericEntity(false);
          } else if (this.state === State2.InTagName || this.state === State2.BeforeAttributeName || this.state === State2.BeforeAttributeValue || this.state === State2.AfterAttributeName || this.state === State2.InAttributeName || this.state === State2.InAttributeValueSq || this.state === State2.InAttributeValueDq || this.state === State2.InAttributeValueNq || this.state === State2.InClosingTagName) {
          } else {
            this.cbs.ontext(this.sectionStart, endIndex);
          }
        };
        Tokenizer2.prototype.emitPartial = function(start, endIndex) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribdata(start, endIndex);
          } else {
            this.cbs.ontext(start, endIndex);
          }
        };
        Tokenizer2.prototype.emitCodePoint = function(cp) {
          if (this.baseState !== State2.Text && this.baseState !== State2.InSpecialTag) {
            this.cbs.onattribentity(cp);
          } else {
            this.cbs.ontextentity(cp);
          }
        };
        return Tokenizer2;
      }();
      exports2.default = Tokenizer;
    }
  });

  // node_modules/htmlparser2/lib/Parser.js
  var require_Parser = __commonJS({
    "node_modules/htmlparser2/lib/Parser.js"(exports2) {
      "use strict";
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m2, k3);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m2[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar2 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding2(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = void 0;
      var Tokenizer_js_1 = __importStar2(require_Tokenizer());
      var decode_js_1 = require_decode();
      var formTags = /* @__PURE__ */ new Set([
        "input",
        "option",
        "optgroup",
        "select",
        "button",
        "datalist",
        "textarea"
      ]);
      var pTag = /* @__PURE__ */ new Set(["p"]);
      var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
      var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
      var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
      var openImpliesClose = /* @__PURE__ */ new Map([
        ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
        ["th", /* @__PURE__ */ new Set(["th"])],
        ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
        ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
        ["li", /* @__PURE__ */ new Set(["li"])],
        ["p", pTag],
        ["h1", pTag],
        ["h2", pTag],
        ["h3", pTag],
        ["h4", pTag],
        ["h5", pTag],
        ["h6", pTag],
        ["select", formTags],
        ["input", formTags],
        ["output", formTags],
        ["button", formTags],
        ["datalist", formTags],
        ["textarea", formTags],
        ["option", /* @__PURE__ */ new Set(["option"])],
        ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
        ["dd", ddtTags],
        ["dt", ddtTags],
        ["address", pTag],
        ["article", pTag],
        ["aside", pTag],
        ["blockquote", pTag],
        ["details", pTag],
        ["div", pTag],
        ["dl", pTag],
        ["fieldset", pTag],
        ["figcaption", pTag],
        ["figure", pTag],
        ["footer", pTag],
        ["form", pTag],
        ["header", pTag],
        ["hr", pTag],
        ["main", pTag],
        ["nav", pTag],
        ["ol", pTag],
        ["pre", pTag],
        ["section", pTag],
        ["table", pTag],
        ["ul", pTag],
        ["rt", rtpTags],
        ["rp", rtpTags],
        ["tbody", tableSectionTags],
        ["tfoot", tableSectionTags]
      ]);
      var voidElements = /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
      var htmlIntegrationElements = /* @__PURE__ */ new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignobject",
        "desc",
        "title"
      ]);
      var reNameEnd = /\s|\//;
      var Parser = function() {
        function Parser2(cbs, options) {
          if (options === void 0) {
            options = {};
          }
          var _a, _b, _c, _d, _e;
          this.options = options;
          this.startIndex = 0;
          this.endIndex = 0;
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.buffers = [];
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : !options.xmlMode;
          this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
          this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser2.prototype.ontext = function(start, endIndex) {
          var _a, _b;
          var data = this.getSlice(start, endIndex);
          this.endIndex = endIndex - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);
          this.startIndex = endIndex;
        };
        Parser2.prototype.ontextentity = function(cp) {
          var _a, _b;
          var index2 = this.tokenizer.getSectionStart();
          this.endIndex = index2 - 1;
          (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));
          this.startIndex = index2;
        };
        Parser2.prototype.isVoidElement = function(name) {
          return !this.options.xmlMode && voidElements.has(name);
        };
        Parser2.prototype.onopentagname = function(start, endIndex) {
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          this.emitOpenTag(name);
        };
        Parser2.prototype.emitOpenTag = function(name) {
          var _a, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name;
          var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
          if (impliesClose) {
            while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
              var element = this.stack.pop();
              (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);
            }
          }
          if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name)) {
              this.foreignContext.push(false);
            }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser2.prototype.endOpenTag = function(isImplied) {
          var _a, _b;
          this.startIndex = this.openTagStart;
          if (this.attribs) {
            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);
            this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
        };
        Parser2.prototype.onopentagend = function(endIndex) {
          this.endIndex = endIndex;
          this.endOpenTag(false);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onclosetag = function(start, endIndex) {
          var _a, _b, _c, _d, _e, _f;
          this.endIndex = endIndex;
          var name = this.getSlice(start, endIndex);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
          }
          if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                var count = this.stack.length - pos;
                while (count--) {
                  this.cbs.onclosetag(this.stack.pop(), count !== 0);
                }
              } else
                this.stack.length = pos;
            } else if (!this.options.xmlMode && name === "p") {
              this.emitOpenTag("p");
              this.closeCurrentTag(true);
            }
          } else if (!this.options.xmlMode && name === "br") {
            (_b = (_a = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a, "br");
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, "br", {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, "br", false);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onselfclosingtag = function(endIndex) {
          this.endIndex = endIndex;
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            this.startIndex = endIndex + 1;
          } else {
            this.onopentagend(endIndex);
          }
        };
        Parser2.prototype.closeCurrentTag = function(isOpenImplied) {
          var _a, _b;
          var name = this.tagname;
          this.endOpenTag(isOpenImplied);
          if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);
            this.stack.pop();
          }
        };
        Parser2.prototype.onattribname = function(start, endIndex) {
          this.startIndex = start;
          var name = this.getSlice(start, endIndex);
          this.attribname = this.lowerCaseAttributeNames ? name.toLowerCase() : name;
        };
        Parser2.prototype.onattribdata = function(start, endIndex) {
          this.attribvalue += this.getSlice(start, endIndex);
        };
        Parser2.prototype.onattribentity = function(cp) {
          this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);
        };
        Parser2.prototype.onattribend = function(quote, endIndex) {
          var _a, _b;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double ? '"' : quote === Tokenizer_js_1.QuoteType.Single ? "'" : quote === Tokenizer_js_1.QuoteType.NoValue ? void 0 : null);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribvalue = "";
        };
        Parser2.prototype.getInstructionName = function(value) {
          var index2 = value.search(reNameEnd);
          var name = index2 < 0 ? value : value.substr(0, index2);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          return name;
        };
        Parser2.prototype.ondeclaration = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!".concat(name), "!".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onprocessinginstruction = function(start, endIndex) {
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex);
          if (this.cbs.onprocessinginstruction) {
            var name = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?".concat(name), "?".concat(value));
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncomment = function(start, endIndex, offset2) {
          var _a, _b, _c, _d;
          this.endIndex = endIndex;
          (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset2));
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.oncdata = function(start, endIndex, offset2) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = endIndex;
          var value = this.getSlice(start, endIndex - offset2);
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[".concat(value, "]]"));
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          this.startIndex = endIndex + 1;
        };
        Parser2.prototype.onend = function() {
          var _a, _b;
          if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var index2 = this.stack.length; index2 > 0; this.cbs.onclosetag(this.stack[--index2], true))
              ;
          }
          (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        Parser2.prototype.reset = function() {
          var _a, _b, _c, _d;
          (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack.length = 0;
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          this.buffers.length = 0;
          this.bufferOffset = 0;
          this.writeIndex = 0;
          this.ended = false;
        };
        Parser2.prototype.parseComplete = function(data) {
          this.reset();
          this.end(data);
        };
        Parser2.prototype.getSlice = function(start, end) {
          while (start - this.bufferOffset >= this.buffers[0].length) {
            this.shiftBuffer();
          }
          var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);
          while (end - this.bufferOffset > this.buffers[0].length) {
            this.shiftBuffer();
            slice += this.buffers[0].slice(0, end - this.bufferOffset);
          }
          return slice;
        };
        Parser2.prototype.shiftBuffer = function() {
          this.bufferOffset += this.buffers[0].length;
          this.writeIndex--;
          this.buffers.shift();
        };
        Parser2.prototype.write = function(chunk) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".write() after done!"));
            return;
          }
          this.buffers.push(chunk);
          if (this.tokenizer.running) {
            this.tokenizer.write(chunk);
            this.writeIndex++;
          }
        };
        Parser2.prototype.end = function(chunk) {
          var _a, _b;
          if (this.ended) {
            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(".end() after done!"));
            return;
          }
          if (chunk)
            this.write(chunk);
          this.ended = true;
          this.tokenizer.end();
        };
        Parser2.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser2.prototype.resume = function() {
          this.tokenizer.resume();
          while (this.tokenizer.running && this.writeIndex < this.buffers.length) {
            this.tokenizer.write(this.buffers[this.writeIndex++]);
          }
          if (this.ended)
            this.tokenizer.end();
        };
        Parser2.prototype.parseChunk = function(chunk) {
          this.write(chunk);
        };
        Parser2.prototype.done = function(chunk) {
          this.end(chunk);
        };
        return Parser2;
      }();
      exports2.Parser = Parser;
    }
  });

  // node_modules/domelementtype/lib/index.js
  var require_lib = __commonJS({
    "node_modules/domelementtype/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
      var ElementType;
      (function(ElementType2) {
        ElementType2["Root"] = "root";
        ElementType2["Text"] = "text";
        ElementType2["Directive"] = "directive";
        ElementType2["Comment"] = "comment";
        ElementType2["Script"] = "script";
        ElementType2["Style"] = "style";
        ElementType2["Tag"] = "tag";
        ElementType2["CDATA"] = "cdata";
        ElementType2["Doctype"] = "doctype";
      })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
      function isTag(elem) {
        return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
      }
      exports2.isTag = isTag;
      exports2.Root = ElementType.Root;
      exports2.Text = ElementType.Text;
      exports2.Directive = ElementType.Directive;
      exports2.Comment = ElementType.Comment;
      exports2.Script = ElementType.Script;
      exports2.Style = ElementType.Style;
      exports2.Tag = ElementType.Tag;
      exports2.CDATA = ElementType.CDATA;
      exports2.Doctype = ElementType.Doctype;
    }
  });

  // node_modules/domhandler/lib/node.js
  var require_node = __commonJS({
    "node_modules/domhandler/lib/node.js"(exports2) {
      "use strict";
      var __extends2 = exports2 && exports2.__extends || function() {
        var extendStatics = function(d3, b3) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
            d4.__proto__ = b4;
          } || function(d4, b4) {
            for (var p2 in b4)
              if (Object.prototype.hasOwnProperty.call(b4, p2))
                d4[p2] = b4[p2];
          };
          return extendStatics(d3, b3);
        };
        return function(d3, b3) {
          if (typeof b3 !== "function" && b3 !== null)
            throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
          extendStatics(d3, b3);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
        };
      }();
      var __assign2 = exports2 && exports2.__assign || function() {
        __assign2 = Object.assign || function(t2) {
          for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            s2 = arguments[i2];
            for (var p2 in s2)
              if (Object.prototype.hasOwnProperty.call(s2, p2))
                t2[p2] = s2[p2];
          }
          return t2;
        };
        return __assign2.apply(this, arguments);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.CDATA = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
      var domelementtype_1 = require_lib();
      var Node2 = function() {
        function Node3() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node3.prototype, "parentNode", {
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "previousSibling", {
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node3.prototype, "nextSibling", {
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node3.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node3;
      }();
      exports2.Node = Node2;
      var DataNode = function(_super) {
        __extends2(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node2);
      exports2.DataNode = DataNode;
      var Text = function(_super) {
        __extends2(Text2, _super);
        function Text2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text2.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text2;
      }(DataNode);
      exports2.Text = Text;
      var Comment = function(_super) {
        __extends2(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      }(DataNode);
      exports2.Comment = Comment;
      var ProcessingInstruction = function(_super) {
        __extends2(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      }(DataNode);
      exports2.ProcessingInstruction = ProcessingInstruction;
      var NodeWithChildren = function(_super) {
        __extends2(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node2);
      exports2.NodeWithChildren = NodeWithChildren;
      var CDATA = function(_super) {
        __extends2(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      }(NodeWithChildren);
      exports2.CDATA = CDATA;
      var Document = function(_super) {
        __extends2(Document2, _super);
        function Document2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document2.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document2;
      }(NodeWithChildren);
      exports2.Document = Document;
      var Element2 = function(_super) {
        __extends2(Element3, _super);
        function Element3(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element3.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "tagName", {
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element3.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element3;
      }(NodeWithChildren);
      exports2.Element = Element2;
      function isTag(node) {
        return (0, domelementtype_1.isTag)(node);
      }
      exports2.isTag = isTag;
      function isCDATA(node) {
        return node.type === domelementtype_1.ElementType.CDATA;
      }
      exports2.isCDATA = isCDATA;
      function isText(node) {
        return node.type === domelementtype_1.ElementType.Text;
      }
      exports2.isText = isText;
      function isComment(node) {
        return node.type === domelementtype_1.ElementType.Comment;
      }
      exports2.isComment = isComment;
      function isDirective(node) {
        return node.type === domelementtype_1.ElementType.Directive;
      }
      exports2.isDirective = isDirective;
      function isDocument(node) {
        return node.type === domelementtype_1.ElementType.Root;
      }
      exports2.isDocument = isDocument;
      function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
      }
      exports2.hasChildren = hasChildren;
      function cloneNode(node, recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        var result;
        if (isText(node)) {
          result = new Text(node.data);
        } else if (isComment(node)) {
          result = new Comment(node.data);
        } else if (isTag(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_1 = new Element2(node.name, __assign2({}, node.attribs), children);
          children.forEach(function(child) {
            return child.parent = clone_1;
          });
          if (node.namespace != null) {
            clone_1.namespace = node.namespace;
          }
          if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign2({}, node["x-attribsNamespace"]);
          }
          if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign2({}, node["x-attribsPrefix"]);
          }
          result = clone_1;
        } else if (isCDATA(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_2 = new CDATA(children);
          children.forEach(function(child) {
            return child.parent = clone_2;
          });
          result = clone_2;
        } else if (isDocument(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_3 = new Document(children);
          children.forEach(function(child) {
            return child.parent = clone_3;
          });
          if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
          }
          result = clone_3;
        } else if (isDirective(node)) {
          var instruction = new ProcessingInstruction(node.name, node.data);
          if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
          }
          result = instruction;
        } else {
          throw new Error("Not implemented yet: ".concat(node.type));
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
          result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
      }
      exports2.cloneNode = cloneNode;
      function cloneChildren(childs) {
        var children = childs.map(function(child) {
          return cloneNode(child, true);
        });
        for (var i2 = 1; i2 < children.length; i2++) {
          children[i2].prev = children[i2 - 1];
          children[i2 - 1].next = children[i2];
        }
        return children;
      }
    }
  });

  // node_modules/domhandler/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/domhandler/lib/index.js"(exports2) {
      "use strict";
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m2, k3);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m2[k3];
      });
      var __exportStar2 = exports2 && exports2.__exportStar || function(m2, exports3) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding2(exports3, m2, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DomHandler = void 0;
      var domelementtype_1 = require_lib();
      var node_js_1 = require_node();
      __exportStar2(require_node(), exports2);
      var defaultOpts = {
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false
      };
      var DomHandler = function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }();
      exports2.DomHandler = DomHandler;
      exports2.default = DomHandler;
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-html.js
  var require_decode_data_html2 = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = new Uint16Array(
        '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c2) {
          return c2.charCodeAt(0);
        })
      );
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-xml.js
  var require_decode_data_xml2 = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.default = new Uint16Array(
        "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c2) {
          return c2.charCodeAt(0);
        })
      );
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js
  var require_decode_codepoint2 = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/decode_codepoint.js"(exports2) {
      "use strict";
      var _a;
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
      var decodeMap = /* @__PURE__ */ new Map([
        [0, 65533],
        [128, 8364],
        [130, 8218],
        [131, 402],
        [132, 8222],
        [133, 8230],
        [134, 8224],
        [135, 8225],
        [136, 710],
        [137, 8240],
        [138, 352],
        [139, 8249],
        [140, 338],
        [142, 381],
        [145, 8216],
        [146, 8217],
        [147, 8220],
        [148, 8221],
        [149, 8226],
        [150, 8211],
        [151, 8212],
        [152, 732],
        [153, 8482],
        [154, 353],
        [155, 8250],
        [156, 339],
        [158, 382],
        [159, 376]
      ]);
      exports2.fromCodePoint = (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
        var output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      };
      function replaceCodePoint(codePoint) {
        var _a2;
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          return 65533;
        }
        return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
      }
      exports2.replaceCodePoint = replaceCodePoint;
      function decodeCodePoint(codePoint) {
        return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
      }
      exports2.default = decodeCodePoint;
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/decode.js
  var require_decode2 = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/decode.js"(exports2) {
      "use strict";
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m2, k3);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m2[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar2 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding2(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
      var decode_data_html_js_1 = __importDefault2(require_decode_data_html2());
      exports2.htmlDecodeTree = decode_data_html_js_1.default;
      var decode_data_xml_js_1 = __importDefault2(require_decode_data_xml2());
      exports2.xmlDecodeTree = decode_data_xml_js_1.default;
      var decode_codepoint_js_1 = __importStar2(require_decode_codepoint2());
      exports2.decodeCodePoint = decode_codepoint_js_1.default;
      var decode_codepoint_js_2 = require_decode_codepoint2();
      Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
        return decode_codepoint_js_2.replaceCodePoint;
      } });
      Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
        return decode_codepoint_js_2.fromCodePoint;
      } });
      var CharCodes;
      (function(CharCodes2) {
        CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
        CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
        CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
        CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
        CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
        CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
        CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
        CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
        CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
        CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
        CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
        CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
      })(CharCodes || (CharCodes = {}));
      var TO_LOWER_BIT = 32;
      var BinTrieFlags;
      (function(BinTrieFlags2) {
        BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
        BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
        BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
      })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
      function isNumber(code) {
        return code >= CharCodes.ZERO && code <= CharCodes.NINE;
      }
      function isHexadecimalCharacter(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
      }
      function isAsciiAlphaNumeric(code) {
        return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
      }
      function isEntityInAttributeInvalidEnd(code) {
        return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
      }
      var EntityDecoderState;
      (function(EntityDecoderState2) {
        EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
        EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
        EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
        EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
        EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
      })(EntityDecoderState || (EntityDecoderState = {}));
      var DecodingMode;
      (function(DecodingMode2) {
        DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
        DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
        DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
      })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
      var EntityDecoder = function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str, offset2) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset2) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset2 + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset2);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset2);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset2);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset2);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset2);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str, offset2) {
          if (offset2 >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset2) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset2 + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset2);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str, offset2) {
          var startIdx = offset2;
          while (offset2 < str.length) {
            var char = str.charCodeAt(offset2);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset2, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset2, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str, offset2) {
          var startIdx = offset2;
          while (offset2 < str.length) {
            var char = str.charCodeAt(offset2);
            if (isNumber(char)) {
              offset2 += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset2, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset2, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str, offset2) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset2 < str.length; offset2++, this.excess++) {
            var char = str.charCodeAt(offset2);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || this.decodeMode === DecodingMode.Attribute && (valueLength === 0 || isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      }();
      exports2.EntityDecoder = EntityDecoder;
      function getDecoder(decodeTree) {
        var ret = "";
        var decoder2 = new EntityDecoder(decodeTree, function(str) {
          return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
        });
        return function decodeWithTrie(str, decodeMode) {
          var lastIndex = 0;
          var offset2 = 0;
          while ((offset2 = str.indexOf("&", offset2)) >= 0) {
            ret += str.slice(lastIndex, offset2);
            decoder2.startEntity(decodeMode);
            var len = decoder2.write(
              str,
              offset2 + 1
            );
            if (len < 0) {
              lastIndex = offset2 + decoder2.end();
              break;
            }
            lastIndex = offset2 + len;
            offset2 = len === 0 ? lastIndex + 1 : lastIndex;
          }
          var result = ret + str.slice(lastIndex);
          ret = "";
          return result;
        };
      }
      function determineBranch(decodeTree, current, nodeIdx, char) {
        var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
        var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
        if (branchCount === 0) {
          return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
        }
        if (jumpOffset) {
          var value = char - jumpOffset;
          return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
        }
        var lo = nodeIdx;
        var hi = lo + branchCount - 1;
        while (lo <= hi) {
          var mid = lo + hi >>> 1;
          var midVal = decodeTree[mid];
          if (midVal < char) {
            lo = mid + 1;
          } else if (midVal > char) {
            hi = mid - 1;
          } else {
            return decodeTree[mid + branchCount];
          }
        }
        return -1;
      }
      exports2.determineBranch = determineBranch;
      var htmlDecoder = getDecoder(decode_data_html_js_1.default);
      var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
      function decodeHTML(str, mode) {
        if (mode === void 0) {
          mode = DecodingMode.Legacy;
        }
        return htmlDecoder(str, mode);
      }
      exports2.decodeHTML = decodeHTML;
      function decodeHTMLAttribute(str) {
        return htmlDecoder(str, DecodingMode.Attribute);
      }
      exports2.decodeHTMLAttribute = decodeHTMLAttribute;
      function decodeHTMLStrict(str) {
        return htmlDecoder(str, DecodingMode.Strict);
      }
      exports2.decodeHTMLStrict = decodeHTMLStrict;
      function decodeXML(str) {
        return xmlDecoder(str, DecodingMode.Strict);
      }
      exports2.decodeXML = decodeXML;
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/generated/encode-html.js
  var require_encode_html = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/generated/encode-html.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function restoreDiff(arr) {
        for (var i2 = 1; i2 < arr.length; i2++) {
          arr[i2][0] += arr[i2 - 1][0] + 1;
        }
        return arr;
      }
      exports2.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/escape.js
  var require_escape = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/escape.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
      exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
      var xmlCodeMap = /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [39, "&apos;"],
        [60, "&lt;"],
        [62, "&gt;"]
      ]);
      exports2.getCodePoint = String.prototype.codePointAt != null ? function(str, index2) {
        return str.codePointAt(index2);
      } : function(c2, index2) {
        return (c2.charCodeAt(index2) & 64512) === 55296 ? (c2.charCodeAt(index2) - 55296) * 1024 + c2.charCodeAt(index2 + 1) - 56320 + 65536 : c2.charCodeAt(index2);
      };
      function encodeXML(str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = exports2.xmlReplacer.exec(str)) !== null) {
          var i2 = match.index;
          var char = str.charCodeAt(i2);
          var next = xmlCodeMap.get(char);
          if (next !== void 0) {
            ret += str.substring(lastIdx, i2) + next;
            lastIdx = i2 + 1;
          } else {
            ret += "".concat(str.substring(lastIdx, i2), "&#x").concat((0, exports2.getCodePoint)(str, i2).toString(16), ";");
            lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
          }
        }
        return ret + str.substr(lastIdx);
      }
      exports2.encodeXML = encodeXML;
      exports2.escape = encodeXML;
      function getEscaper(regex, map) {
        return function escape(data) {
          var match;
          var lastIdx = 0;
          var result = "";
          while (match = regex.exec(data)) {
            if (lastIdx !== match.index) {
              result += data.substring(lastIdx, match.index);
            }
            result += map.get(match[0].charCodeAt(0));
            lastIdx = match.index + 1;
          }
          return result + data.substring(lastIdx);
        };
      }
      exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
      exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
        [34, "&quot;"],
        [38, "&amp;"],
        [160, "&nbsp;"]
      ]));
      exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
        [38, "&amp;"],
        [60, "&lt;"],
        [62, "&gt;"],
        [160, "&nbsp;"]
      ]));
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/encode.js
  var require_encode = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/encode.js"(exports2) {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.encodeNonAsciiHTML = exports2.encodeHTML = void 0;
      var encode_html_js_1 = __importDefault2(require_encode_html());
      var escape_js_1 = require_escape();
      var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
      function encodeHTML(data) {
        return encodeHTMLTrieRe(htmlReplacer, data);
      }
      exports2.encodeHTML = encodeHTML;
      function encodeNonAsciiHTML(data) {
        return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
      }
      exports2.encodeNonAsciiHTML = encodeNonAsciiHTML;
      function encodeHTMLTrieRe(regExp, str) {
        var ret = "";
        var lastIdx = 0;
        var match;
        while ((match = regExp.exec(str)) !== null) {
          var i2 = match.index;
          ret += str.substring(lastIdx, i2);
          var char = str.charCodeAt(i2);
          var next = encode_html_js_1.default.get(char);
          if (typeof next === "object") {
            if (i2 + 1 < str.length) {
              var nextChar = str.charCodeAt(i2 + 1);
              var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
              if (value !== void 0) {
                ret += value;
                lastIdx = regExp.lastIndex += 1;
                continue;
              }
            }
            next = next.v;
          }
          if (next !== void 0) {
            ret += next;
            lastIdx = i2 + 1;
          } else {
            var cp = (0, escape_js_1.getCodePoint)(str, i2);
            ret += "&#x".concat(cp.toString(16), ";");
            lastIdx = regExp.lastIndex += Number(cp !== char);
          }
        }
        return ret + str.substr(lastIdx);
      }
    }
  });

  // node_modules/dom-serializer/node_modules/entities/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/dom-serializer/node_modules/entities/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
      var decode_js_1 = require_decode2();
      var encode_js_1 = require_encode();
      var escape_js_1 = require_escape();
      var EntityLevel;
      (function(EntityLevel2) {
        EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
        EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
      })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
      var EncodingMode;
      (function(EncodingMode2) {
        EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
        EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
        EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
        EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
        EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
      })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
      function decode(data, options) {
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var level = typeof options === "number" ? options : options.level;
        if (level === EntityLevel.HTML) {
          var mode = typeof options === "object" ? options.mode : void 0;
          return (0, decode_js_1.decodeHTML)(data, mode);
        }
        return (0, decode_js_1.decodeXML)(data);
      }
      exports2.decode = decode;
      function decodeStrict(data, options) {
        var _a;
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var opts = typeof options === "number" ? { level: options } : options;
        (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
        return decode(data, opts);
      }
      exports2.decodeStrict = decodeStrict;
      function encode(data, options) {
        if (options === void 0) {
          options = EntityLevel.XML;
        }
        var opts = typeof options === "number" ? { level: options } : options;
        if (opts.mode === EncodingMode.UTF8)
          return (0, escape_js_1.escapeUTF8)(data);
        if (opts.mode === EncodingMode.Attribute)
          return (0, escape_js_1.escapeAttribute)(data);
        if (opts.mode === EncodingMode.Text)
          return (0, escape_js_1.escapeText)(data);
        if (opts.level === EntityLevel.HTML) {
          if (opts.mode === EncodingMode.ASCII) {
            return (0, encode_js_1.encodeNonAsciiHTML)(data);
          }
          return (0, encode_js_1.encodeHTML)(data);
        }
        return (0, escape_js_1.encodeXML)(data);
      }
      exports2.encode = encode;
      var escape_js_2 = require_escape();
      Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
        return escape_js_2.encodeXML;
      } });
      Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
        return escape_js_2.escape;
      } });
      Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
        return escape_js_2.escapeUTF8;
      } });
      Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
        return escape_js_2.escapeAttribute;
      } });
      Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
        return escape_js_2.escapeText;
      } });
      var encode_js_2 = require_encode();
      Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
        return encode_js_2.encodeHTML;
      } });
      Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
        return encode_js_2.encodeNonAsciiHTML;
      } });
      Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
        return encode_js_2.encodeHTML;
      } });
      Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
        return encode_js_2.encodeHTML;
      } });
      var decode_js_2 = require_decode2();
      Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
        return decode_js_2.EntityDecoder;
      } });
      Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
        return decode_js_2.DecodingMode;
      } });
      Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
        return decode_js_2.decodeXML;
      } });
      Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
        return decode_js_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLAttribute;
      } });
      Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
        return decode_js_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
        return decode_js_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
        return decode_js_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
        return decode_js_2.decodeXML;
      } });
    }
  });

  // node_modules/dom-serializer/lib/foreignNames.js
  var require_foreignNames = __commonJS({
    "node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attributeNames = exports2.elementNames = void 0;
      exports2.elementNames = new Map([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "clipPath",
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDistantLight",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight",
        "feTile",
        "feTurbulence",
        "foreignObject",
        "glyphRef",
        "linearGradient",
        "radialGradient",
        "textPath"
      ].map(function(val) {
        return [val.toLowerCase(), val];
      }));
      exports2.attributeNames = new Map([
        "definitionURL",
        "attributeName",
        "attributeType",
        "baseFrequency",
        "baseProfile",
        "calcMode",
        "clipPathUnits",
        "diffuseConstant",
        "edgeMode",
        "filterUnits",
        "glyphRef",
        "gradientTransform",
        "gradientUnits",
        "kernelMatrix",
        "kernelUnitLength",
        "keyPoints",
        "keySplines",
        "keyTimes",
        "lengthAdjust",
        "limitingConeAngle",
        "markerHeight",
        "markerUnits",
        "markerWidth",
        "maskContentUnits",
        "maskUnits",
        "numOctaves",
        "pathLength",
        "patternContentUnits",
        "patternTransform",
        "patternUnits",
        "pointsAtX",
        "pointsAtY",
        "pointsAtZ",
        "preserveAlpha",
        "preserveAspectRatio",
        "primitiveUnits",
        "refX",
        "refY",
        "repeatCount",
        "repeatDur",
        "requiredExtensions",
        "requiredFeatures",
        "specularConstant",
        "specularExponent",
        "spreadMethod",
        "startOffset",
        "stdDeviation",
        "stitchTiles",
        "surfaceScale",
        "systemLanguage",
        "tableValues",
        "targetX",
        "targetY",
        "textLength",
        "viewBox",
        "viewTarget",
        "xChannelSelector",
        "yChannelSelector",
        "zoomAndPan"
      ].map(function(val) {
        return [val.toLowerCase(), val];
      }));
    }
  });

  // node_modules/dom-serializer/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/dom-serializer/lib/index.js"(exports2) {
      "use strict";
      var __assign2 = exports2 && exports2.__assign || function() {
        __assign2 = Object.assign || function(t2) {
          for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
            s2 = arguments[i2];
            for (var p2 in s2)
              if (Object.prototype.hasOwnProperty.call(s2, p2))
                t2[p2] = s2[p2];
          }
          return t2;
        };
        return __assign2.apply(this, arguments);
      };
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m2, k3);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m2[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar2 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding2(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.render = void 0;
      var ElementType = __importStar2(require_lib());
      var entities_1 = require_lib3();
      var foreignNames_js_1 = require_foreignNames();
      var unencodedElements = /* @__PURE__ */ new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript"
      ]);
      function replaceQuotes(value) {
        return value.replace(/"/g, "&quot;");
      }
      function formatAttributes(attributes, opts) {
        var _a;
        if (!attributes)
          return;
        var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
        return Object.keys(attributes).map(function(key) {
          var _a2, _b;
          var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
          if (opts.xmlMode === "foreign") {
            key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
          }
          if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
          }
          return "".concat(key, '="').concat(encode(value), '"');
        }).join(" ");
      }
      var singleTag = /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      function render(node, options) {
        if (options === void 0) {
          options = {};
        }
        var nodes = "length" in node ? node : [node];
        var output = "";
        for (var i2 = 0; i2 < nodes.length; i2++) {
          output += renderNode(nodes[i2], options);
        }
        return output;
      }
      exports2.render = render;
      exports2.default = render;
      function renderNode(node, options) {
        switch (node.type) {
          case ElementType.Root:
            return render(node.children, options);
          case ElementType.Doctype:
          case ElementType.Directive:
            return renderDirective(node);
          case ElementType.Comment:
            return renderComment(node);
          case ElementType.CDATA:
            return renderCdata(node);
          case ElementType.Script:
          case ElementType.Style:
          case ElementType.Tag:
            return renderTag(node, options);
          case ElementType.Text:
            return renderText(node, options);
        }
      }
      var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ]);
      var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
      function renderTag(elem, opts) {
        var _a;
        if (opts.xmlMode === "foreign") {
          elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
          if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign2(__assign2({}, opts), { xmlMode: false });
          }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
          opts = __assign2(__assign2({}, opts), { xmlMode: "foreign" });
        }
        var tag = "<".concat(elem.name);
        var attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
          tag += " ".concat(attribs);
        }
        if (elem.children.length === 0 && (opts.xmlMode ? opts.selfClosingTags !== false : opts.selfClosingTags && singleTag.has(elem.name))) {
          if (!opts.xmlMode)
            tag += " ";
          tag += "/>";
        } else {
          tag += ">";
          if (elem.children.length > 0) {
            tag += render(elem.children, opts);
          }
          if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</".concat(elem.name, ">");
          }
        }
        return tag;
      }
      function renderDirective(elem) {
        return "<".concat(elem.data, ">");
      }
      function renderText(elem, opts) {
        var _a;
        var data = elem.data || "";
        if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
          data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
        }
        return data;
      }
      function renderCdata(elem) {
        return "<![CDATA[".concat(elem.children[0].data, "]]>");
      }
      function renderComment(elem) {
        return "<!--".concat(elem.data, "-->");
      }
    }
  });

  // node_modules/domutils/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/domutils/lib/stringify.js"(exports2) {
      "use strict";
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.innerText = exports2.textContent = exports2.getText = exports2.getInnerHTML = exports2.getOuterHTML = void 0;
      var domhandler_1 = require_lib2();
      var dom_serializer_1 = __importDefault2(require_lib4());
      var domelementtype_1 = require_lib();
      function getOuterHTML(node, options) {
        return (0, dom_serializer_1.default)(node, options);
      }
      exports2.getOuterHTML = getOuterHTML;
      function getInnerHTML(node, options) {
        return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
          return getOuterHTML(node2, options);
        }).join("") : "";
      }
      exports2.getInnerHTML = getInnerHTML;
      function getText(node) {
        if (Array.isArray(node))
          return node.map(getText).join("");
        if ((0, domhandler_1.isTag)(node))
          return node.name === "br" ? "\n" : getText(node.children);
        if ((0, domhandler_1.isCDATA)(node))
          return getText(node.children);
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.getText = getText;
      function textContent(node) {
        if (Array.isArray(node))
          return node.map(textContent).join("");
        if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
          return textContent(node.children);
        }
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.textContent = textContent;
      function innerText(node) {
        if (Array.isArray(node))
          return node.map(innerText).join("");
        if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
          return innerText(node.children);
        }
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.innerText = innerText;
    }
  });

  // node_modules/domutils/lib/traversal.js
  var require_traversal = __commonJS({
    "node_modules/domutils/lib/traversal.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prevElementSibling = exports2.nextElementSibling = exports2.getName = exports2.hasAttrib = exports2.getAttributeValue = exports2.getSiblings = exports2.getParent = exports2.getChildren = void 0;
      var domhandler_1 = require_lib2();
      function getChildren(elem) {
        return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
      }
      exports2.getChildren = getChildren;
      function getParent(elem) {
        return elem.parent || null;
      }
      exports2.getParent = getParent;
      function getSiblings(elem) {
        var _a, _b;
        var parent = getParent(elem);
        if (parent != null)
          return getChildren(parent);
        var siblings = [elem];
        var prev = elem.prev, next = elem.next;
        while (prev != null) {
          siblings.unshift(prev);
          _a = prev, prev = _a.prev;
        }
        while (next != null) {
          siblings.push(next);
          _b = next, next = _b.next;
        }
        return siblings;
      }
      exports2.getSiblings = getSiblings;
      function getAttributeValue(elem, name) {
        var _a;
        return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
      }
      exports2.getAttributeValue = getAttributeValue;
      function hasAttrib(elem, name) {
        return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
      }
      exports2.hasAttrib = hasAttrib;
      function getName(elem) {
        return elem.name;
      }
      exports2.getName = getName;
      function nextElementSibling(elem) {
        var _a;
        var next = elem.next;
        while (next !== null && !(0, domhandler_1.isTag)(next))
          _a = next, next = _a.next;
        return next;
      }
      exports2.nextElementSibling = nextElementSibling;
      function prevElementSibling(elem) {
        var _a;
        var prev = elem.prev;
        while (prev !== null && !(0, domhandler_1.isTag)(prev))
          _a = prev, prev = _a.prev;
        return prev;
      }
      exports2.prevElementSibling = prevElementSibling;
    }
  });

  // node_modules/domutils/lib/manipulation.js
  var require_manipulation = __commonJS({
    "node_modules/domutils/lib/manipulation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prepend = exports2.prependChild = exports2.append = exports2.appendChild = exports2.replaceElement = exports2.removeElement = void 0;
      function removeElement(elem) {
        if (elem.prev)
          elem.prev.next = elem.next;
        if (elem.next)
          elem.next.prev = elem.prev;
        if (elem.parent) {
          var childs = elem.parent.children;
          var childsIndex = childs.lastIndexOf(elem);
          if (childsIndex >= 0) {
            childs.splice(childsIndex, 1);
          }
        }
        elem.next = null;
        elem.prev = null;
        elem.parent = null;
      }
      exports2.removeElement = removeElement;
      function replaceElement(elem, replacement) {
        var prev = replacement.prev = elem.prev;
        if (prev) {
          prev.next = replacement;
        }
        var next = replacement.next = elem.next;
        if (next) {
          next.prev = replacement;
        }
        var parent = replacement.parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs[childs.lastIndexOf(elem)] = replacement;
          elem.parent = null;
        }
      }
      exports2.replaceElement = replaceElement;
      function appendChild(parent, child) {
        removeElement(child);
        child.next = null;
        child.parent = parent;
        if (parent.children.push(child) > 1) {
          var sibling = parent.children[parent.children.length - 2];
          sibling.next = child;
          child.prev = sibling;
        } else {
          child.prev = null;
        }
      }
      exports2.appendChild = appendChild;
      function append(elem, next) {
        removeElement(next);
        var parent = elem.parent;
        var currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
          currNext.prev = next;
          if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
          }
        } else if (parent) {
          parent.children.push(next);
        }
      }
      exports2.append = append;
      function prependChild(parent, child) {
        removeElement(child);
        child.parent = parent;
        child.prev = null;
        if (parent.children.unshift(child) !== 1) {
          var sibling = parent.children[1];
          sibling.prev = child;
          child.next = sibling;
        } else {
          child.next = null;
        }
      }
      exports2.prependChild = prependChild;
      function prepend(elem, prev) {
        removeElement(prev);
        var parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
          elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
      }
      exports2.prepend = prepend;
    }
  });

  // node_modules/domutils/lib/querying.js
  var require_querying = __commonJS({
    "node_modules/domutils/lib/querying.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.findAll = exports2.existsOne = exports2.findOne = exports2.findOneChild = exports2.find = exports2.filter = void 0;
      var domhandler_1 = require_lib2();
      function filter(test, node, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return find(test, Array.isArray(node) ? node : [node], recurse, limit);
      }
      exports2.filter = filter;
      function find(test, nodes, recurse, limit) {
        var result = [];
        var nodeStack = [nodes];
        var indexStack = [0];
        for (; ; ) {
          if (indexStack[0] >= nodeStack[0].length) {
            if (indexStack.length === 1) {
              return result;
            }
            nodeStack.shift();
            indexStack.shift();
            continue;
          }
          var elem = nodeStack[0][indexStack[0]++];
          if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
              return result;
          }
          if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
          }
        }
      }
      exports2.find = find;
      function findOneChild(test, nodes) {
        return nodes.find(test);
      }
      exports2.findOneChild = findOneChild;
      function findOne(test, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        var elem = null;
        for (var i2 = 0; i2 < nodes.length && !elem; i2++) {
          var node = nodes[i2];
          if (!(0, domhandler_1.isTag)(node)) {
            continue;
          } else if (test(node)) {
            elem = node;
          } else if (recurse && node.children.length > 0) {
            elem = findOne(test, node.children, true);
          }
        }
        return elem;
      }
      exports2.findOne = findOne;
      function existsOne(test, nodes) {
        return nodes.some(function(checked) {
          return (0, domhandler_1.isTag)(checked) && (test(checked) || existsOne(test, checked.children));
        });
      }
      exports2.existsOne = existsOne;
      function findAll(test, nodes) {
        var result = [];
        var nodeStack = [nodes];
        var indexStack = [0];
        for (; ; ) {
          if (indexStack[0] >= nodeStack[0].length) {
            if (nodeStack.length === 1) {
              return result;
            }
            nodeStack.shift();
            indexStack.shift();
            continue;
          }
          var elem = nodeStack[0][indexStack[0]++];
          if (!(0, domhandler_1.isTag)(elem))
            continue;
          if (test(elem))
            result.push(elem);
          if (elem.children.length > 0) {
            indexStack.unshift(0);
            nodeStack.unshift(elem.children);
          }
        }
      }
      exports2.findAll = findAll;
    }
  });

  // node_modules/domutils/lib/legacy.js
  var require_legacy = __commonJS({
    "node_modules/domutils/lib/legacy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getElementsByTagType = exports2.getElementsByTagName = exports2.getElementById = exports2.getElements = exports2.testElement = void 0;
      var domhandler_1 = require_lib2();
      var querying_js_1 = require_querying();
      var Checks = {
        tag_name: function(name) {
          if (typeof name === "function") {
            return function(elem) {
              return (0, domhandler_1.isTag)(elem) && name(elem.name);
            };
          } else if (name === "*") {
            return domhandler_1.isTag;
          }
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && elem.name === name;
          };
        },
        tag_type: function(type) {
          if (typeof type === "function") {
            return function(elem) {
              return type(elem.type);
            };
          }
          return function(elem) {
            return elem.type === type;
          };
        },
        tag_contains: function(data) {
          if (typeof data === "function") {
            return function(elem) {
              return (0, domhandler_1.isText)(elem) && data(elem.data);
            };
          }
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && elem.data === data;
          };
        }
      };
      function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
        };
      }
      function combineFuncs(a2, b3) {
        return function(elem) {
          return a2(elem) || b3(elem);
        };
      }
      function compileTest(options) {
        var funcs = Object.keys(options).map(function(key) {
          var value = options[key];
          return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
      }
      function testElement(options, node) {
        var test = compileTest(options);
        return test ? test(node) : true;
      }
      exports2.testElement = testElement;
      function getElements(options, nodes, recurse, limit) {
        if (limit === void 0) {
          limit = Infinity;
        }
        var test = compileTest(options);
        return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
      }
      exports2.getElements = getElements;
      function getElementById(id, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (!Array.isArray(nodes))
          nodes = [nodes];
        return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
      }
      exports2.getElementById = getElementById;
      function getElementsByTagName(tagName, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
      }
      exports2.getElementsByTagName = getElementsByTagName;
      function getElementsByTagType(type, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
      }
      exports2.getElementsByTagType = getElementsByTagType;
    }
  });

  // node_modules/domutils/lib/helpers.js
  var require_helpers = __commonJS({
    "node_modules/domutils/lib/helpers.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.uniqueSort = exports2.compareDocumentPosition = exports2.DocumentPosition = exports2.removeSubsets = void 0;
      var domhandler_1 = require_lib2();
      function removeSubsets(nodes) {
        var idx = nodes.length;
        while (--idx >= 0) {
          var node = nodes[idx];
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
          }
          for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
              nodes.splice(idx, 1);
              break;
            }
          }
        }
        return nodes;
      }
      exports2.removeSubsets = removeSubsets;
      var DocumentPosition;
      (function(DocumentPosition2) {
        DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
        DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
        DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
        DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
        DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
      })(DocumentPosition = exports2.DocumentPosition || (exports2.DocumentPosition = {}));
      function compareDocumentPosition(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        if (nodeA === nodeB) {
          return 0;
        }
        var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
        while (current) {
          aParents.unshift(current);
          current = current.parent;
        }
        current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
        while (current) {
          bParents.unshift(current);
          current = current.parent;
        }
        var maxIdx = Math.min(aParents.length, bParents.length);
        var idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
          idx++;
        }
        if (idx === 0) {
          return DocumentPosition.DISCONNECTED;
        }
        var sharedParent = aParents[idx - 1];
        var siblings = sharedParent.children;
        var aSibling = aParents[idx];
        var bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
          }
          return DocumentPosition.FOLLOWING;
        }
        if (sharedParent === nodeA) {
          return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
        }
        return DocumentPosition.PRECEDING;
      }
      exports2.compareDocumentPosition = compareDocumentPosition;
      function uniqueSort(nodes) {
        nodes = nodes.filter(function(node, i2, arr) {
          return !arr.includes(node, i2 + 1);
        });
        nodes.sort(function(a2, b3) {
          var relative = compareDocumentPosition(a2, b3);
          if (relative & DocumentPosition.PRECEDING) {
            return -1;
          } else if (relative & DocumentPosition.FOLLOWING) {
            return 1;
          }
          return 0;
        });
        return nodes;
      }
      exports2.uniqueSort = uniqueSort;
    }
  });

  // node_modules/domutils/lib/feeds.js
  var require_feeds = __commonJS({
    "node_modules/domutils/lib/feeds.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getFeed = void 0;
      var stringify_js_1 = require_stringify();
      var legacy_js_1 = require_legacy();
      function getFeed(doc) {
        var feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
      }
      exports2.getFeed = getFeed;
      function getAtomFeed(feedRoot) {
        var _a;
        var childs = feedRoot.children;
        var feed = {
          type: "atom",
          items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
            var _a2;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
            if (href2) {
              entry.link = href2;
            }
            var description = fetch2("summary", children) || fetch2("content", children);
            if (description) {
              entry.description = description;
            }
            var pubDate = fetch2("updated", children);
            if (pubDate) {
              entry.pubDate = new Date(pubDate);
            }
            return entry;
          })
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
        if (href) {
          feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch2("updated", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
      }
      function getRssFeed(feedRoot) {
        var _a, _b;
        var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
        var feed = {
          type: feedRoot.name.substr(0, 3),
          id: "",
          items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch2("pubDate", children) || fetch2("dc:date", children);
            if (pubDate)
              entry.pubDate = new Date(pubDate);
            return entry;
          })
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch2("lastBuildDate", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
      }
      var MEDIA_KEYS_STRING = ["url", "type", "lang"];
      var MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width"
      ];
      function getMediaElements(where) {
        return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
          var attribs = elem.attribs;
          var media = {
            medium: attribs["medium"],
            isDefault: !!attribs["isDefault"]
          };
          for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
              media[attrib] = attribs[attrib];
            }
          }
          for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
            var attrib = MEDIA_KEYS_INT_1[_a];
            if (attribs[attrib]) {
              media[attrib] = parseInt(attribs[attrib], 10);
            }
          }
          if (attribs["expression"]) {
            media.expression = attribs["expression"];
          }
          return media;
        });
      }
      function getOneElement(tagName, node) {
        return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
      }
      function fetch2(tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
      }
      function addConditionally(obj, prop, tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        var val = fetch2(tagName, where, recurse);
        if (val)
          obj[prop] = val;
      }
      function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
      }
    }
  });

  // node_modules/domutils/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/domutils/lib/index.js"(exports2) {
      "use strict";
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m2, k3);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m2[k3];
      });
      var __exportStar2 = exports2 && exports2.__exportStar || function(m2, exports3) {
        for (var p2 in m2)
          if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2))
            __createBinding2(exports3, m2, p2);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
      __exportStar2(require_stringify(), exports2);
      __exportStar2(require_traversal(), exports2);
      __exportStar2(require_manipulation(), exports2);
      __exportStar2(require_querying(), exports2);
      __exportStar2(require_legacy(), exports2);
      __exportStar2(require_helpers(), exports2);
      __exportStar2(require_feeds(), exports2);
      var domhandler_1 = require_lib2();
      Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
        return domhandler_1.isTag;
      } });
      Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
        return domhandler_1.isCDATA;
      } });
      Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
        return domhandler_1.isText;
      } });
      Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
        return domhandler_1.isComment;
      } });
      Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
        return domhandler_1.isDocument;
      } });
      Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
        return domhandler_1.hasChildren;
      } });
    }
  });

  // node_modules/htmlparser2/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/htmlparser2/lib/index.js"(exports2) {
      "use strict";
      var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        var desc = Object.getOwnPropertyDescriptor(m2, k3);
        if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m2[k3];
          } };
        }
        Object.defineProperty(o2, k22, desc);
      } : function(o2, m2, k3, k22) {
        if (k22 === void 0)
          k22 = k3;
        o2[k22] = m2[k3];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o2, v2) {
        Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
      } : function(o2, v2) {
        o2["default"] = v2;
      });
      var __importStar2 = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k3 in mod)
            if (k3 !== "default" && Object.prototype.hasOwnProperty.call(mod, k3))
              __createBinding2(result, mod, k3);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault2 = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DomUtils = exports2.parseFeed = exports2.getFeed = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DefaultHandler = exports2.DomHandler = exports2.Parser = void 0;
      var Parser_js_1 = require_Parser();
      var Parser_js_2 = require_Parser();
      Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
        return Parser_js_2.Parser;
      } });
      var domhandler_1 = require_lib2();
      var domhandler_2 = require_lib2();
      Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
        return domhandler_2.DomHandler;
      } });
      Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
        return domhandler_2.DomHandler;
      } });
      function parseDocument(data, options) {
        var handler = new domhandler_1.DomHandler(void 0, options);
        new Parser_js_1.Parser(handler, options).end(data);
        return handler.root;
      }
      exports2.parseDocument = parseDocument;
      function parseDOM(data, options) {
        return parseDocument(data, options).children;
      }
      exports2.parseDOM = parseDOM;
      function createDomStream(callback, options, elementCallback) {
        var handler = new domhandler_1.DomHandler(callback, options, elementCallback);
        return new Parser_js_1.Parser(handler, options);
      }
      exports2.createDomStream = createDomStream;
      var Tokenizer_js_1 = require_Tokenizer();
      Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
        return __importDefault2(Tokenizer_js_1).default;
      } });
      exports2.ElementType = __importStar2(require_lib());
      var domutils_1 = require_lib5();
      var domutils_2 = require_lib5();
      Object.defineProperty(exports2, "getFeed", { enumerable: true, get: function() {
        return domutils_2.getFeed;
      } });
      var parseFeedDefaultOptions = { xmlMode: true };
      function parseFeed(feed, options) {
        if (options === void 0) {
          options = parseFeedDefaultOptions;
        }
        return (0, domutils_1.getFeed)(parseDOM(feed, options));
      }
      exports2.parseFeed = parseFeed;
      exports2.DomUtils = __importStar2(require_lib5());
    }
  });

  // node_modules/escape-string-regexp/index.js
  var require_escape_string_regexp = __commonJS({
    "node_modules/escape-string-regexp/index.js"(exports2, module2) {
      "use strict";
      module2.exports = (string2) => {
        if (typeof string2 !== "string") {
          throw new TypeError("Expected a string");
        }
        return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      };
    }
  });

  // node_modules/sanitize-html/node_modules/is-plain-object/dist/is-plain-object.js
  var require_is_plain_object = __commonJS({
    "node_modules/sanitize-html/node_modules/is-plain-object/dist/is-plain-object.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function isObject2(o2) {
        return Object.prototype.toString.call(o2) === "[object Object]";
      }
      function isPlainObject2(o2) {
        var ctor, prot;
        if (isObject2(o2) === false)
          return false;
        ctor = o2.constructor;
        if (ctor === void 0)
          return true;
        prot = ctor.prototype;
        if (isObject2(prot) === false)
          return false;
        if (prot.hasOwnProperty("isPrototypeOf") === false) {
          return false;
        }
        return true;
      }
      exports2.isPlainObject = isPlainObject2;
    }
  });

  // node_modules/deepmerge/dist/cjs.js
  var require_cjs = __commonJS({
    "node_modules/deepmerge/dist/cjs.js"(exports2, module2) {
      "use strict";
      var isMergeableObject = function isMergeableObject2(value) {
        return isNonNullObject(value) && !isSpecial(value);
      };
      function isNonNullObject(value) {
        return !!value && typeof value === "object";
      }
      function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);
        return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
      }
      var canUseSymbol = typeof Symbol === "function" && Symbol.for;
      var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
      }
      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }
      function cloneUnlessOtherwiseSpecified(value, options) {
        return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
      }
      function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function(element) {
          return cloneUnlessOtherwiseSpecified(element, options);
        });
      }
      function getMergeFunction(key, options) {
        if (!options.customMerge) {
          return deepmerge;
        }
        var customMerge = options.customMerge(key);
        return typeof customMerge === "function" ? customMerge : deepmerge;
      }
      function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
          return Object.propertyIsEnumerable.call(target, symbol);
        }) : [];
      }
      function getKeys(target) {
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
      }
      function propertyIsOnObject(object, property) {
        try {
          return property in object;
        } catch (_) {
          return false;
        }
      }
      function propertyIsUnsafe(target, key) {
        return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
      }
      function mergeObject(target, source, options) {
        var destination = {};
        if (options.isMergeableObject(target)) {
          getKeys(target).forEach(function(key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
        }
        getKeys(source).forEach(function(key) {
          if (propertyIsUnsafe(target, key)) {
            return;
          }
          if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
          } else {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          }
        });
        return destination;
      }
      function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject;
        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options);
        } else {
          return mergeObject(target, source, options);
        }
      }
      deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
          throw new Error("first argument should be an array");
        }
        return array.reduce(function(prev, next) {
          return deepmerge(prev, next, options);
        }, {});
      };
      var deepmerge_1 = deepmerge;
      module2.exports = deepmerge_1;
    }
  });

  // node_modules/parse-srcset/src/parse-srcset.js
  var require_parse_srcset = __commonJS({
    "node_modules/parse-srcset/src/parse-srcset.js"(exports2, module2) {
      (function(root2, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module2 === "object" && module2.exports) {
          module2.exports = factory();
        } else {
          root2.parseSrcset = factory();
        }
      })(exports2, function() {
        return function(input) {
          function isSpace(c3) {
            return c3 === " " || c3 === "	" || c3 === "\n" || c3 === "\f" || c3 === "\r";
          }
          function collectCharacters(regEx) {
            var chars, match = regEx.exec(input.substring(pos));
            if (match) {
              chars = match[0];
              pos += chars.length;
              return chars;
            }
          }
          var inputLength = input.length, regexLeadingSpaces = /^[ \t\n\r\u000c]+/, regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/, regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/, regexTrailingCommas = /[,]+$/, regexNonNegativeInteger = /^\d+$/, regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, url, descriptors, currentDescriptor, state, c2, pos = 0, candidates = [];
          while (true) {
            collectCharacters(regexLeadingCommasOrSpaces);
            if (pos >= inputLength) {
              return candidates;
            }
            url = collectCharacters(regexLeadingNotSpaces);
            descriptors = [];
            if (url.slice(-1) === ",") {
              url = url.replace(regexTrailingCommas, "");
              parseDescriptors();
            } else {
              tokenize();
            }
          }
          function tokenize() {
            collectCharacters(regexLeadingSpaces);
            currentDescriptor = "";
            state = "in descriptor";
            while (true) {
              c2 = input.charAt(pos);
              if (state === "in descriptor") {
                if (isSpace(c2)) {
                  if (currentDescriptor) {
                    descriptors.push(currentDescriptor);
                    currentDescriptor = "";
                    state = "after descriptor";
                  }
                } else if (c2 === ",") {
                  pos += 1;
                  if (currentDescriptor) {
                    descriptors.push(currentDescriptor);
                  }
                  parseDescriptors();
                  return;
                } else if (c2 === "(") {
                  currentDescriptor = currentDescriptor + c2;
                  state = "in parens";
                } else if (c2 === "") {
                  if (currentDescriptor) {
                    descriptors.push(currentDescriptor);
                  }
                  parseDescriptors();
                  return;
                } else {
                  currentDescriptor = currentDescriptor + c2;
                }
              } else if (state === "in parens") {
                if (c2 === ")") {
                  currentDescriptor = currentDescriptor + c2;
                  state = "in descriptor";
                } else if (c2 === "") {
                  descriptors.push(currentDescriptor);
                  parseDescriptors();
                  return;
                } else {
                  currentDescriptor = currentDescriptor + c2;
                }
              } else if (state === "after descriptor") {
                if (isSpace(c2)) {
                } else if (c2 === "") {
                  parseDescriptors();
                  return;
                } else {
                  state = "in descriptor";
                  pos -= 1;
                }
              }
              pos += 1;
            }
          }
          function parseDescriptors() {
            var pError = false, w2, d3, h2, i2, candidate = {}, desc, lastChar, value, intVal, floatVal;
            for (i2 = 0; i2 < descriptors.length; i2++) {
              desc = descriptors[i2];
              lastChar = desc[desc.length - 1];
              value = desc.substring(0, desc.length - 1);
              intVal = parseInt(value, 10);
              floatVal = parseFloat(value);
              if (regexNonNegativeInteger.test(value) && lastChar === "w") {
                if (w2 || d3) {
                  pError = true;
                }
                if (intVal === 0) {
                  pError = true;
                } else {
                  w2 = intVal;
                }
              } else if (regexFloatingPoint.test(value) && lastChar === "x") {
                if (w2 || d3 || h2) {
                  pError = true;
                }
                if (floatVal < 0) {
                  pError = true;
                } else {
                  d3 = floatVal;
                }
              } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
                if (h2 || d3) {
                  pError = true;
                }
                if (intVal === 0) {
                  pError = true;
                } else {
                  h2 = intVal;
                }
              } else {
                pError = true;
              }
            }
            if (!pError) {
              candidate.url = url;
              if (w2) {
                candidate.w = w2;
              }
              if (d3) {
                candidate.d = d3;
              }
              if (h2) {
                candidate.h = h2;
              }
              candidates.push(candidate);
            } else if (console && console.log) {
              console.log("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
            }
          }
        };
      });
    }
  });

  // node_modules/picocolors/picocolors.browser.js
  var require_picocolors_browser = __commonJS({
    "node_modules/picocolors/picocolors.browser.js"(exports2, module2) {
      var x2 = String;
      var create = function() {
        return { isColorSupported: false, reset: x2, bold: x2, dim: x2, italic: x2, underline: x2, inverse: x2, hidden: x2, strikethrough: x2, black: x2, red: x2, green: x2, yellow: x2, blue: x2, magenta: x2, cyan: x2, white: x2, gray: x2, bgBlack: x2, bgRed: x2, bgGreen: x2, bgYellow: x2, bgBlue: x2, bgMagenta: x2, bgCyan: x2, bgWhite: x2 };
      };
      module2.exports = create();
      module2.exports.createColors = create;
    }
  });

  // (disabled):node_modules/postcss/lib/terminal-highlight
  var require_terminal_highlight = __commonJS({
    "(disabled):node_modules/postcss/lib/terminal-highlight"() {
    }
  });

  // node_modules/postcss/lib/css-syntax-error.js
  var require_css_syntax_error = __commonJS({
    "node_modules/postcss/lib/css-syntax-error.js"(exports2, module2) {
      "use strict";
      var pico = require_picocolors_browser();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError = class extends Error {
        constructor(message, line, column, source, file, plugin) {
          super(message);
          this.name = "CssSyntaxError";
          this.reason = message;
          if (file) {
            this.file = file;
          }
          if (source) {
            this.source = source;
          }
          if (plugin) {
            this.plugin = plugin;
          }
          if (typeof line !== "undefined" && typeof column !== "undefined") {
            if (typeof line === "number") {
              this.line = line;
              this.column = column;
            } else {
              this.line = line.line;
              this.column = line.column;
              this.endLine = column.line;
              this.endColumn = column.column;
            }
          }
          this.setMessage();
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, CssSyntaxError);
          }
        }
        setMessage() {
          this.message = this.plugin ? this.plugin + ": " : "";
          this.message += this.file ? this.file : "<css input>";
          if (typeof this.line !== "undefined") {
            this.message += ":" + this.line + ":" + this.column;
          }
          this.message += ": " + this.reason;
        }
        showSourceCode(color) {
          if (!this.source)
            return "";
          let css2 = this.source;
          if (color == null)
            color = pico.isColorSupported;
          if (terminalHighlight) {
            if (color)
              css2 = terminalHighlight(css2);
          }
          let lines = css2.split(/\r?\n/);
          let start = Math.max(this.line - 3, 0);
          let end = Math.min(this.line + 2, lines.length);
          let maxWidth = String(end).length;
          let mark, aside;
          if (color) {
            let { bold, gray, red } = pico.createColors(true);
            mark = (text) => bold(red(text));
            aside = (text) => gray(text);
          } else {
            mark = aside = (str) => str;
          }
          return lines.slice(start, end).map((line, index2) => {
            let number = start + 1 + index2;
            let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
            if (number === this.line) {
              let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + line + "\n " + spacing + mark("^");
            }
            return " " + aside(gutter) + line;
          }).join("\n");
        }
        toString() {
          let code = this.showSourceCode();
          if (code) {
            code = "\n\n" + code + "\n";
          }
          return this.name + ": " + this.message + code;
        }
      };
      module2.exports = CssSyntaxError;
      CssSyntaxError.default = CssSyntaxError;
    }
  });

  // node_modules/postcss/lib/symbols.js
  var require_symbols = __commonJS({
    "node_modules/postcss/lib/symbols.js"(exports2, module2) {
      "use strict";
      module2.exports.isClean = Symbol("isClean");
      module2.exports.my = Symbol("my");
    }
  });

  // node_modules/postcss/lib/stringifier.js
  var require_stringifier = __commonJS({
    "node_modules/postcss/lib/stringifier.js"(exports2, module2) {
      "use strict";
      var DEFAULT_RAW = {
        after: "\n",
        beforeClose: "\n",
        beforeComment: "\n",
        beforeDecl: "\n",
        beforeOpen: " ",
        beforeRule: "\n",
        colon: ": ",
        commentLeft: " ",
        commentRight: " ",
        emptyBody: "",
        indent: "    ",
        semicolon: false
      };
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      var Stringifier = class {
        constructor(builder) {
          this.builder = builder;
        }
        atrule(node, semicolon) {
          let name = "@" + node.name;
          let params = node.params ? this.rawValue(node, "params") : "";
          if (typeof node.raws.afterName !== "undefined") {
            name += node.raws.afterName;
          } else if (params) {
            name += " ";
          }
          if (node.nodes) {
            this.block(node, name + params);
          } else {
            let end = (node.raws.between || "") + (semicolon ? ";" : "");
            this.builder(name + params + end, node);
          }
        }
        beforeAfter(node, detect) {
          let value;
          if (node.type === "decl") {
            value = this.raw(node, null, "beforeDecl");
          } else if (node.type === "comment") {
            value = this.raw(node, null, "beforeComment");
          } else if (detect === "before") {
            value = this.raw(node, null, "beforeRule");
          } else {
            value = this.raw(node, null, "beforeClose");
          }
          let buf = node.parent;
          let depth = 0;
          while (buf && buf.type !== "root") {
            depth += 1;
            buf = buf.parent;
          }
          if (value.includes("\n")) {
            let indent = this.raw(node, null, "indent");
            if (indent.length) {
              for (let step = 0; step < depth; step++)
                value += indent;
            }
          }
          return value;
        }
        block(node, start) {
          let between = this.raw(node, "between", "beforeOpen");
          this.builder(start + between + "{", node, "start");
          let after;
          if (node.nodes && node.nodes.length) {
            this.body(node);
            after = this.raw(node, "after");
          } else {
            after = this.raw(node, "after", "emptyBody");
          }
          if (after)
            this.builder(after);
          this.builder("}", node, "end");
        }
        body(node) {
          let last = node.nodes.length - 1;
          while (last > 0) {
            if (node.nodes[last].type !== "comment")
              break;
            last -= 1;
          }
          let semicolon = this.raw(node, "semicolon");
          for (let i2 = 0; i2 < node.nodes.length; i2++) {
            let child = node.nodes[i2];
            let before = this.raw(child, "before");
            if (before)
              this.builder(before);
            this.stringify(child, last !== i2 || semicolon);
          }
        }
        comment(node) {
          let left = this.raw(node, "left", "commentLeft");
          let right = this.raw(node, "right", "commentRight");
          this.builder("/*" + left + node.text + right + "*/", node);
        }
        decl(node, semicolon) {
          let between = this.raw(node, "between", "colon");
          let string2 = node.prop + between + this.rawValue(node, "value");
          if (node.important) {
            string2 += node.raws.important || " !important";
          }
          if (semicolon)
            string2 += ";";
          this.builder(string2, node);
        }
        document(node) {
          this.body(node);
        }
        raw(node, own, detect) {
          let value;
          if (!detect)
            detect = own;
          if (own) {
            value = node.raws[own];
            if (typeof value !== "undefined")
              return value;
          }
          let parent = node.parent;
          if (detect === "before") {
            if (!parent || parent.type === "root" && parent.first === node) {
              return "";
            }
            if (parent && parent.type === "document") {
              return "";
            }
          }
          if (!parent)
            return DEFAULT_RAW[detect];
          let root2 = node.root();
          if (!root2.rawCache)
            root2.rawCache = {};
          if (typeof root2.rawCache[detect] !== "undefined") {
            return root2.rawCache[detect];
          }
          if (detect === "before" || detect === "after") {
            return this.beforeAfter(node, detect);
          } else {
            let method = "raw" + capitalize(detect);
            if (this[method]) {
              value = this[method](root2, node);
            } else {
              root2.walk((i2) => {
                value = i2.raws[own];
                if (typeof value !== "undefined")
                  return false;
              });
            }
          }
          if (typeof value === "undefined")
            value = DEFAULT_RAW[detect];
          root2.rawCache[detect] = value;
          return value;
        }
        rawBeforeClose(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length > 0) {
              if (typeof i2.raws.after !== "undefined") {
                value = i2.raws.after;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value)
            value = value.replace(/\S/g, "");
          return value;
        }
        rawBeforeComment(root2, node) {
          let value;
          root2.walkComments((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node, null, "beforeDecl");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeDecl(root2, node) {
          let value;
          root2.walkDecls((i2) => {
            if (typeof i2.raws.before !== "undefined") {
              value = i2.raws.before;
              if (value.includes("\n")) {
                value = value.replace(/[^\n]+$/, "");
              }
              return false;
            }
          });
          if (typeof value === "undefined") {
            value = this.raw(node, null, "beforeRule");
          } else if (value) {
            value = value.replace(/\S/g, "");
          }
          return value;
        }
        rawBeforeOpen(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.type !== "decl") {
              value = i2.raws.between;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawBeforeRule(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {
              if (typeof i2.raws.before !== "undefined") {
                value = i2.raws.before;
                if (value.includes("\n")) {
                  value = value.replace(/[^\n]+$/, "");
                }
                return false;
              }
            }
          });
          if (value)
            value = value.replace(/\S/g, "");
          return value;
        }
        rawColon(root2) {
          let value;
          root2.walkDecls((i2) => {
            if (typeof i2.raws.between !== "undefined") {
              value = i2.raws.between.replace(/[^\s:]/g, "");
              return false;
            }
          });
          return value;
        }
        rawEmptyBody(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length === 0) {
              value = i2.raws.after;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawIndent(root2) {
          if (root2.raws.indent)
            return root2.raws.indent;
          let value;
          root2.walk((i2) => {
            let p2 = i2.parent;
            if (p2 && p2 !== root2 && p2.parent && p2.parent === root2) {
              if (typeof i2.raws.before !== "undefined") {
                let parts = i2.raws.before.split("\n");
                value = parts[parts.length - 1];
                value = value.replace(/\S/g, "");
                return false;
              }
            }
          });
          return value;
        }
        rawSemicolon(root2) {
          let value;
          root2.walk((i2) => {
            if (i2.nodes && i2.nodes.length && i2.last.type === "decl") {
              value = i2.raws.semicolon;
              if (typeof value !== "undefined")
                return false;
            }
          });
          return value;
        }
        rawValue(node, prop) {
          let value = node[prop];
          let raw = node.raws[prop];
          if (raw && raw.value === value) {
            return raw.raw;
          }
          return value;
        }
        root(node) {
          this.body(node);
          if (node.raws.after)
            this.builder(node.raws.after);
        }
        rule(node) {
          this.block(node, this.rawValue(node, "selector"));
          if (node.raws.ownSemicolon) {
            this.builder(node.raws.ownSemicolon, node, "end");
          }
        }
        stringify(node, semicolon) {
          if (!this[node.type]) {
            throw new Error(
              "Unknown AST node type " + node.type + ". Maybe you need to change PostCSS stringifier."
            );
          }
          this[node.type](node, semicolon);
        }
      };
      module2.exports = Stringifier;
      Stringifier.default = Stringifier;
    }
  });

  // node_modules/postcss/lib/stringify.js
  var require_stringify2 = __commonJS({
    "node_modules/postcss/lib/stringify.js"(exports2, module2) {
      "use strict";
      var Stringifier = require_stringifier();
      function stringify(node, builder) {
        let str = new Stringifier(builder);
        str.stringify(node);
      }
      module2.exports = stringify;
      stringify.default = stringify;
    }
  });

  // node_modules/postcss/lib/node.js
  var require_node2 = __commonJS({
    "node_modules/postcss/lib/node.js"(exports2, module2) {
      "use strict";
      var { isClean, my } = require_symbols();
      var CssSyntaxError = require_css_syntax_error();
      var Stringifier = require_stringifier();
      var stringify = require_stringify2();
      function cloneNode(obj, parent) {
        let cloned = new obj.constructor();
        for (let i2 in obj) {
          if (!Object.prototype.hasOwnProperty.call(obj, i2)) {
            continue;
          }
          if (i2 === "proxyCache")
            continue;
          let value = obj[i2];
          let type = typeof value;
          if (i2 === "parent" && type === "object") {
            if (parent)
              cloned[i2] = parent;
          } else if (i2 === "source") {
            cloned[i2] = value;
          } else if (Array.isArray(value)) {
            cloned[i2] = value.map((j3) => cloneNode(j3, cloned));
          } else {
            if (type === "object" && value !== null)
              value = cloneNode(value);
            cloned[i2] = value;
          }
        }
        return cloned;
      }
      var Node2 = class {
        constructor(defaults2 = {}) {
          this.raws = {};
          this[isClean] = false;
          this[my] = true;
          for (let name in defaults2) {
            if (name === "nodes") {
              this.nodes = [];
              for (let node of defaults2[name]) {
                if (typeof node.clone === "function") {
                  this.append(node.clone());
                } else {
                  this.append(node);
                }
              }
            } else {
              this[name] = defaults2[name];
            }
          }
        }
        addToError(error) {
          error.postcssNode = this;
          if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
            let s2 = this.source;
            error.stack = error.stack.replace(
              /\n\s{4}at /,
              `$&${s2.input.from}:${s2.start.line}:${s2.start.column}$&`
            );
          }
          return error;
        }
        after(add2) {
          this.parent.insertAfter(this, add2);
          return this;
        }
        assign(overrides = {}) {
          for (let name in overrides) {
            this[name] = overrides[name];
          }
          return this;
        }
        before(add2) {
          this.parent.insertBefore(this, add2);
          return this;
        }
        cleanRaws(keepBetween) {
          delete this.raws.before;
          delete this.raws.after;
          if (!keepBetween)
            delete this.raws.between;
        }
        clone(overrides = {}) {
          let cloned = cloneNode(this);
          for (let name in overrides) {
            cloned[name] = overrides[name];
          }
          return cloned;
        }
        cloneAfter(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertAfter(this, cloned);
          return cloned;
        }
        cloneBefore(overrides = {}) {
          let cloned = this.clone(overrides);
          this.parent.insertBefore(this, cloned);
          return cloned;
        }
        error(message, opts = {}) {
          if (this.source) {
            let { end, start } = this.rangeBy(opts);
            return this.source.input.error(
              message,
              { column: start.column, line: start.line },
              { column: end.column, line: end.line },
              opts
            );
          }
          return new CssSyntaxError(message);
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value) {
              if (node[prop] === value)
                return true;
              node[prop] = value;
              if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || prop === "text") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        markDirty() {
          if (this[isClean]) {
            this[isClean] = false;
            let next = this;
            while (next = next.parent) {
              next[isClean] = false;
            }
          }
        }
        next() {
          if (!this.parent)
            return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 + 1];
        }
        positionBy(opts, stringRepresentation) {
          let pos = this.source.start;
          if (opts.index) {
            pos = this.positionInside(opts.index, stringRepresentation);
          } else if (opts.word) {
            stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1)
              pos = this.positionInside(index2, stringRepresentation);
          }
          return pos;
        }
        positionInside(index2, stringRepresentation) {
          let string2 = stringRepresentation || this.toString();
          let column = this.source.start.column;
          let line = this.source.start.line;
          for (let i2 = 0; i2 < index2; i2++) {
            if (string2[i2] === "\n") {
              column = 1;
              line += 1;
            } else {
              column += 1;
            }
          }
          return { column, line };
        }
        prev() {
          if (!this.parent)
            return void 0;
          let index2 = this.parent.index(this);
          return this.parent.nodes[index2 - 1];
        }
        rangeBy(opts) {
          let start = {
            column: this.source.start.column,
            line: this.source.start.line
          };
          let end = this.source.end ? {
            column: this.source.end.column + 1,
            line: this.source.end.line
          } : {
            column: start.column + 1,
            line: start.line
          };
          if (opts.word) {
            let stringRepresentation = this.toString();
            let index2 = stringRepresentation.indexOf(opts.word);
            if (index2 !== -1) {
              start = this.positionInside(index2, stringRepresentation);
              end = this.positionInside(index2 + opts.word.length, stringRepresentation);
            }
          } else {
            if (opts.start) {
              start = {
                column: opts.start.column,
                line: opts.start.line
              };
            } else if (opts.index) {
              start = this.positionInside(opts.index);
            }
            if (opts.end) {
              end = {
                column: opts.end.column,
                line: opts.end.line
              };
            } else if (opts.endIndex) {
              end = this.positionInside(opts.endIndex);
            } else if (opts.index) {
              end = this.positionInside(opts.index + 1);
            }
          }
          if (end.line < start.line || end.line === start.line && end.column <= start.column) {
            end = { column: start.column + 1, line: start.line };
          }
          return { end, start };
        }
        raw(prop, defaultType) {
          let str = new Stringifier();
          return str.raw(this, prop, defaultType);
        }
        remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        }
        replaceWith(...nodes) {
          if (this.parent) {
            let bookmark = this;
            let foundSelf = false;
            for (let node of nodes) {
              if (node === this) {
                foundSelf = true;
              } else if (foundSelf) {
                this.parent.insertAfter(bookmark, node);
                bookmark = node;
              } else {
                this.parent.insertBefore(bookmark, node);
              }
            }
            if (!foundSelf) {
              this.remove();
            }
          }
          return this;
        }
        root() {
          let result = this;
          while (result.parent && result.parent.type !== "document") {
            result = result.parent;
          }
          return result;
        }
        toJSON(_, inputs) {
          let fixed = {};
          let emitInputs = inputs == null;
          inputs = inputs || /* @__PURE__ */ new Map();
          let inputsNextIndex = 0;
          for (let name in this) {
            if (!Object.prototype.hasOwnProperty.call(this, name)) {
              continue;
            }
            if (name === "parent" || name === "proxyCache")
              continue;
            let value = this[name];
            if (Array.isArray(value)) {
              fixed[name] = value.map((i2) => {
                if (typeof i2 === "object" && i2.toJSON) {
                  return i2.toJSON(null, inputs);
                } else {
                  return i2;
                }
              });
            } else if (typeof value === "object" && value.toJSON) {
              fixed[name] = value.toJSON(null, inputs);
            } else if (name === "source") {
              let inputId = inputs.get(value.input);
              if (inputId == null) {
                inputId = inputsNextIndex;
                inputs.set(value.input, inputsNextIndex);
                inputsNextIndex++;
              }
              fixed[name] = {
                end: value.end,
                inputId,
                start: value.start
              };
            } else {
              fixed[name] = value;
            }
          }
          if (emitInputs) {
            fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
          }
          return fixed;
        }
        toProxy() {
          if (!this.proxyCache) {
            this.proxyCache = new Proxy(this, this.getProxyProcessor());
          }
          return this.proxyCache;
        }
        toString(stringifier = stringify) {
          if (stringifier.stringify)
            stringifier = stringifier.stringify;
          let result = "";
          stringifier(this, (i2) => {
            result += i2;
          });
          return result;
        }
        warn(result, text, opts) {
          let data = { node: this };
          for (let i2 in opts)
            data[i2] = opts[i2];
          return result.warn(text, data);
        }
        get proxyOf() {
          return this;
        }
      };
      module2.exports = Node2;
      Node2.default = Node2;
    }
  });

  // node_modules/postcss/lib/declaration.js
  var require_declaration = __commonJS({
    "node_modules/postcss/lib/declaration.js"(exports2, module2) {
      "use strict";
      var Node2 = require_node2();
      var Declaration = class extends Node2 {
        constructor(defaults2) {
          if (defaults2 && typeof defaults2.value !== "undefined" && typeof defaults2.value !== "string") {
            defaults2 = { ...defaults2, value: String(defaults2.value) };
          }
          super(defaults2);
          this.type = "decl";
        }
        get variable() {
          return this.prop.startsWith("--") || this.prop[0] === "$";
        }
      };
      module2.exports = Declaration;
      Declaration.default = Declaration;
    }
  });

  // (disabled):node_modules/source-map-js/source-map.js
  var require_source_map = __commonJS({
    "(disabled):node_modules/source-map-js/source-map.js"() {
    }
  });

  // (disabled):path
  var require_path = __commonJS({
    "(disabled):path"() {
    }
  });

  // (disabled):url
  var require_url = __commonJS({
    "(disabled):url"() {
    }
  });

  // node_modules/nanoid/non-secure/index.cjs
  var require_non_secure = __commonJS({
    "node_modules/nanoid/non-secure/index.cjs"(exports2, module2) {
      var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
      var customAlphabet = (alphabet, defaultSize = 21) => {
        return (size2 = defaultSize) => {
          let id = "";
          let i2 = size2;
          while (i2--) {
            id += alphabet[Math.random() * alphabet.length | 0];
          }
          return id;
        };
      };
      var nanoid = (size2 = 21) => {
        let id = "";
        let i2 = size2;
        while (i2--) {
          id += urlAlphabet[Math.random() * 64 | 0];
        }
        return id;
      };
      module2.exports = { nanoid, customAlphabet };
    }
  });

  // (disabled):fs
  var require_fs = __commonJS({
    "(disabled):fs"() {
    }
  });

  // node_modules/postcss/lib/previous-map.js
  var require_previous_map = __commonJS({
    "node_modules/postcss/lib/previous-map.js"(exports2, module2) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { existsSync, readFileSync } = require_fs();
      var { dirname, join } = require_path();
      function fromBase64(str) {
        if (Buffer) {
          return Buffer.from(str, "base64").toString();
        } else {
          return window.atob(str);
        }
      }
      var PreviousMap = class {
        constructor(css2, opts) {
          if (opts.map === false)
            return;
          this.loadAnnotation(css2);
          this.inline = this.startWith(this.annotation, "data:");
          let prev = opts.map ? opts.map.prev : void 0;
          let text = this.loadMap(opts.from, prev);
          if (!this.mapFile && opts.from) {
            this.mapFile = opts.from;
          }
          if (this.mapFile)
            this.root = dirname(this.mapFile);
          if (text)
            this.text = text;
        }
        consumer() {
          if (!this.consumerCache) {
            this.consumerCache = new SourceMapConsumer(this.text);
          }
          return this.consumerCache;
        }
        decodeInline(text) {
          let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
          let baseUri = /^data:application\/json;base64,/;
          let charsetUri = /^data:application\/json;charset=utf-?8,/;
          let uri = /^data:application\/json,/;
          if (charsetUri.test(text) || uri.test(text)) {
            return decodeURIComponent(text.substr(RegExp.lastMatch.length));
          }
          if (baseCharsetUri.test(text) || baseUri.test(text)) {
            return fromBase64(text.substr(RegExp.lastMatch.length));
          }
          let encoding = text.match(/data:application\/json;([^,]+),/)[1];
          throw new Error("Unsupported source map encoding " + encoding);
        }
        getAnnotationURL(sourceMapString) {
          return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
        }
        isMap(map) {
          if (typeof map !== "object")
            return false;
          return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
        }
        loadAnnotation(css2) {
          let comments = css2.match(/\/\*\s*# sourceMappingURL=/gm);
          if (!comments)
            return;
          let start = css2.lastIndexOf(comments.pop());
          let end = css2.indexOf("*/", start);
          if (start > -1 && end > -1) {
            this.annotation = this.getAnnotationURL(css2.substring(start, end));
          }
        }
        loadFile(path) {
          this.root = dirname(path);
          if (existsSync(path)) {
            this.mapFile = path;
            return readFileSync(path, "utf-8").toString().trim();
          }
        }
        loadMap(file, prev) {
          if (prev === false)
            return false;
          if (prev) {
            if (typeof prev === "string") {
              return prev;
            } else if (typeof prev === "function") {
              let prevPath = prev(file);
              if (prevPath) {
                let map = this.loadFile(prevPath);
                if (!map) {
                  throw new Error(
                    "Unable to load previous source map: " + prevPath.toString()
                  );
                }
                return map;
              }
            } else if (prev instanceof SourceMapConsumer) {
              return SourceMapGenerator.fromSourceMap(prev).toString();
            } else if (prev instanceof SourceMapGenerator) {
              return prev.toString();
            } else if (this.isMap(prev)) {
              return JSON.stringify(prev);
            } else {
              throw new Error(
                "Unsupported previous source map format: " + prev.toString()
              );
            }
          } else if (this.inline) {
            return this.decodeInline(this.annotation);
          } else if (this.annotation) {
            let map = this.annotation;
            if (file)
              map = join(dirname(file), map);
            return this.loadFile(map);
          }
        }
        startWith(string2, start) {
          if (!string2)
            return false;
          return string2.substr(0, start.length) === start;
        }
        withContent() {
          return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
        }
      };
      module2.exports = PreviousMap;
      PreviousMap.default = PreviousMap;
    }
  });

  // node_modules/postcss/lib/input.js
  var require_input = __commonJS({
    "node_modules/postcss/lib/input.js"(exports2, module2) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { fileURLToPath, pathToFileURL } = require_url();
      var { isAbsolute, resolve } = require_path();
      var { nanoid } = require_non_secure();
      var terminalHighlight = require_terminal_highlight();
      var CssSyntaxError = require_css_syntax_error();
      var PreviousMap = require_previous_map();
      var fromOffsetCache = Symbol("fromOffsetCache");
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(resolve && isAbsolute);
      var Input = class {
        constructor(css2, opts = {}) {
          if (css2 === null || typeof css2 === "undefined" || typeof css2 === "object" && !css2.toString) {
            throw new Error(`PostCSS received ${css2} instead of CSS string`);
          }
          this.css = css2.toString();
          if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
            this.hasBOM = true;
            this.css = this.css.slice(1);
          } else {
            this.hasBOM = false;
          }
          if (opts.from) {
            if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute(opts.from)) {
              this.file = opts.from;
            } else {
              this.file = resolve(opts.from);
            }
          }
          if (pathAvailable && sourceMapAvailable) {
            let map = new PreviousMap(this.css, opts);
            if (map.text) {
              this.map = map;
              let file = map.consumer().file;
              if (!this.file && file)
                this.file = this.mapResolve(file);
            }
          }
          if (!this.file) {
            this.id = "<input css " + nanoid(6) + ">";
          }
          if (this.map)
            this.map.file = this.from;
        }
        error(message, line, column, opts = {}) {
          let result, endLine, endColumn;
          if (line && typeof line === "object") {
            let start = line;
            let end = column;
            if (typeof start.offset === "number") {
              let pos = this.fromOffset(start.offset);
              line = pos.line;
              column = pos.col;
            } else {
              line = start.line;
              column = start.column;
            }
            if (typeof end.offset === "number") {
              let pos = this.fromOffset(end.offset);
              endLine = pos.line;
              endColumn = pos.col;
            } else {
              endLine = end.line;
              endColumn = end.column;
            }
          } else if (!column) {
            let pos = this.fromOffset(line);
            line = pos.line;
            column = pos.col;
          }
          let origin = this.origin(line, column, endLine, endColumn);
          if (origin) {
            result = new CssSyntaxError(
              message,
              origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
              origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
              origin.source,
              origin.file,
              opts.plugin
            );
          } else {
            result = new CssSyntaxError(
              message,
              endLine === void 0 ? line : { column, line },
              endLine === void 0 ? column : { column: endColumn, line: endLine },
              this.css,
              this.file,
              opts.plugin
            );
          }
          result.input = { column, endColumn, endLine, line, source: this.css };
          if (this.file) {
            if (pathToFileURL) {
              result.input.url = pathToFileURL(this.file).toString();
            }
            result.input.file = this.file;
          }
          return result;
        }
        fromOffset(offset2) {
          let lastLine, lineToIndex;
          if (!this[fromOffsetCache]) {
            let lines = this.css.split("\n");
            lineToIndex = new Array(lines.length);
            let prevIndex = 0;
            for (let i2 = 0, l2 = lines.length; i2 < l2; i2++) {
              lineToIndex[i2] = prevIndex;
              prevIndex += lines[i2].length + 1;
            }
            this[fromOffsetCache] = lineToIndex;
          } else {
            lineToIndex = this[fromOffsetCache];
          }
          lastLine = lineToIndex[lineToIndex.length - 1];
          let min2 = 0;
          if (offset2 >= lastLine) {
            min2 = lineToIndex.length - 1;
          } else {
            let max2 = lineToIndex.length - 2;
            let mid;
            while (min2 < max2) {
              mid = min2 + (max2 - min2 >> 1);
              if (offset2 < lineToIndex[mid]) {
                max2 = mid - 1;
              } else if (offset2 >= lineToIndex[mid + 1]) {
                min2 = mid + 1;
              } else {
                min2 = mid;
                break;
              }
            }
          }
          return {
            col: offset2 - lineToIndex[min2] + 1,
            line: min2 + 1
          };
        }
        mapResolve(file) {
          if (/^\w+:\/\//.test(file)) {
            return file;
          }
          return resolve(this.map.consumer().sourceRoot || this.map.root || ".", file);
        }
        origin(line, column, endLine, endColumn) {
          if (!this.map)
            return false;
          let consumer = this.map.consumer();
          let from = consumer.originalPositionFor({ column, line });
          if (!from.source)
            return false;
          let to;
          if (typeof endLine === "number") {
            to = consumer.originalPositionFor({ column: endColumn, line: endLine });
          }
          let fromUrl;
          if (isAbsolute(from.source)) {
            fromUrl = pathToFileURL(from.source);
          } else {
            fromUrl = new URL(
              from.source,
              this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
            );
          }
          let result = {
            column: from.column,
            endColumn: to && to.column,
            endLine: to && to.line,
            line: from.line,
            url: fromUrl.toString()
          };
          if (fromUrl.protocol === "file:") {
            if (fileURLToPath) {
              result.file = fileURLToPath(fromUrl);
            } else {
              throw new Error(`file: protocol is not available in this PostCSS build`);
            }
          }
          let source = consumer.sourceContentFor(from.source);
          if (source)
            result.source = source;
          return result;
        }
        toJSON() {
          let json = {};
          for (let name of ["hasBOM", "css", "file", "id"]) {
            if (this[name] != null) {
              json[name] = this[name];
            }
          }
          if (this.map) {
            json.map = { ...this.map };
            if (json.map.consumerCache) {
              json.map.consumerCache = void 0;
            }
          }
          return json;
        }
        get from() {
          return this.file || this.id;
        }
      };
      module2.exports = Input;
      Input.default = Input;
      if (terminalHighlight && terminalHighlight.registerInput) {
        terminalHighlight.registerInput(Input);
      }
    }
  });

  // node_modules/postcss/lib/map-generator.js
  var require_map_generator = __commonJS({
    "node_modules/postcss/lib/map-generator.js"(exports2, module2) {
      "use strict";
      var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
      var { dirname, relative, resolve, sep } = require_path();
      var { pathToFileURL } = require_url();
      var Input = require_input();
      var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
      var pathAvailable = Boolean(dirname && resolve && relative && sep);
      var MapGenerator = class {
        constructor(stringify, root2, opts, cssString) {
          this.stringify = stringify;
          this.mapOpts = opts.map || {};
          this.root = root2;
          this.opts = opts;
          this.css = cssString;
          this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
          this.memoizedFileURLs = /* @__PURE__ */ new Map();
          this.memoizedPaths = /* @__PURE__ */ new Map();
          this.memoizedURLs = /* @__PURE__ */ new Map();
        }
        addAnnotation() {
          let content;
          if (this.isInline()) {
            content = "data:application/json;base64," + this.toBase64(this.map.toString());
          } else if (typeof this.mapOpts.annotation === "string") {
            content = this.mapOpts.annotation;
          } else if (typeof this.mapOpts.annotation === "function") {
            content = this.mapOpts.annotation(this.opts.to, this.root);
          } else {
            content = this.outputFile() + ".map";
          }
          let eol = "\n";
          if (this.css.includes("\r\n"))
            eol = "\r\n";
          this.css += eol + "/*# sourceMappingURL=" + content + " */";
        }
        applyPrevMaps() {
          for (let prev of this.previous()) {
            let from = this.toUrl(this.path(prev.file));
            let root2 = prev.root || dirname(prev.file);
            let map;
            if (this.mapOpts.sourcesContent === false) {
              map = new SourceMapConsumer(prev.text);
              if (map.sourcesContent) {
                map.sourcesContent = map.sourcesContent.map(() => null);
              }
            } else {
              map = prev.consumer();
            }
            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));
          }
        }
        clearAnnotation() {
          if (this.mapOpts.annotation === false)
            return;
          if (this.root) {
            let node;
            for (let i2 = this.root.nodes.length - 1; i2 >= 0; i2--) {
              node = this.root.nodes[i2];
              if (node.type !== "comment")
                continue;
              if (node.text.indexOf("# sourceMappingURL=") === 0) {
                this.root.removeChild(i2);
              }
            }
          } else if (this.css) {
            this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, "");
          }
        }
        generate() {
          this.clearAnnotation();
          if (pathAvailable && sourceMapAvailable && this.isMap()) {
            return this.generateMap();
          } else {
            let result = "";
            this.stringify(this.root, (i2) => {
              result += i2;
            });
            return [result];
          }
        }
        generateMap() {
          if (this.root) {
            this.generateString();
          } else if (this.previous().length === 1) {
            let prev = this.previous()[0].consumer();
            prev.file = this.outputFile();
            this.map = SourceMapGenerator.fromSourceMap(prev);
          } else {
            this.map = new SourceMapGenerator({ file: this.outputFile() });
            this.map.addMapping({
              generated: { column: 0, line: 1 },
              original: { column: 0, line: 1 },
              source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
            });
          }
          if (this.isSourcesContent())
            this.setSourcesContent();
          if (this.root && this.previous().length > 0)
            this.applyPrevMaps();
          if (this.isAnnotation())
            this.addAnnotation();
          if (this.isInline()) {
            return [this.css];
          } else {
            return [this.css, this.map];
          }
        }
        generateString() {
          this.css = "";
          this.map = new SourceMapGenerator({ file: this.outputFile() });
          let line = 1;
          let column = 1;
          let noSource = "<no source>";
          let mapping = {
            generated: { column: 0, line: 0 },
            original: { column: 0, line: 0 },
            source: ""
          };
          let lines, last;
          this.stringify(this.root, (str, node, type) => {
            this.css += str;
            if (node && type !== "end") {
              mapping.generated.line = line;
              mapping.generated.column = column - 1;
              if (node.source && node.source.start) {
                mapping.source = this.sourcePath(node);
                mapping.original.line = node.source.start.line;
                mapping.original.column = node.source.start.column - 1;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                this.map.addMapping(mapping);
              }
            }
            lines = str.match(/\n/g);
            if (lines) {
              line += lines.length;
              last = str.lastIndexOf("\n");
              column = str.length - last;
            } else {
              column += str.length;
            }
            if (node && type !== "start") {
              let p2 = node.parent || { raws: {} };
              let childless = node.type === "decl" || node.type === "atrule" && !node.nodes;
              if (!childless || node !== p2.last || p2.raws.semicolon) {
                if (node.source && node.source.end) {
                  mapping.source = this.sourcePath(node);
                  mapping.original.line = node.source.end.line;
                  mapping.original.column = node.source.end.column - 1;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 2;
                  this.map.addMapping(mapping);
                } else {
                  mapping.source = noSource;
                  mapping.original.line = 1;
                  mapping.original.column = 0;
                  mapping.generated.line = line;
                  mapping.generated.column = column - 1;
                  this.map.addMapping(mapping);
                }
              }
            }
          });
        }
        isAnnotation() {
          if (this.isInline()) {
            return true;
          }
          if (typeof this.mapOpts.annotation !== "undefined") {
            return this.mapOpts.annotation;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.annotation);
          }
          return true;
        }
        isInline() {
          if (typeof this.mapOpts.inline !== "undefined") {
            return this.mapOpts.inline;
          }
          let annotation = this.mapOpts.annotation;
          if (typeof annotation !== "undefined" && annotation !== true) {
            return false;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.inline);
          }
          return true;
        }
        isMap() {
          if (typeof this.opts.map !== "undefined") {
            return !!this.opts.map;
          }
          return this.previous().length > 0;
        }
        isSourcesContent() {
          if (typeof this.mapOpts.sourcesContent !== "undefined") {
            return this.mapOpts.sourcesContent;
          }
          if (this.previous().length) {
            return this.previous().some((i2) => i2.withContent());
          }
          return true;
        }
        outputFile() {
          if (this.opts.to) {
            return this.path(this.opts.to);
          } else if (this.opts.from) {
            return this.path(this.opts.from);
          } else {
            return "to.css";
          }
        }
        path(file) {
          if (this.mapOpts.absolute)
            return file;
          if (file.charCodeAt(0) === 60)
            return file;
          if (/^\w+:\/\//.test(file))
            return file;
          let cached = this.memoizedPaths.get(file);
          if (cached)
            return cached;
          let from = this.opts.to ? dirname(this.opts.to) : ".";
          if (typeof this.mapOpts.annotation === "string") {
            from = dirname(resolve(from, this.mapOpts.annotation));
          }
          let path = relative(from, file);
          this.memoizedPaths.set(file, path);
          return path;
        }
        previous() {
          if (!this.previousMaps) {
            this.previousMaps = [];
            if (this.root) {
              this.root.walk((node) => {
                if (node.source && node.source.input.map) {
                  let map = node.source.input.map;
                  if (!this.previousMaps.includes(map)) {
                    this.previousMaps.push(map);
                  }
                }
              });
            } else {
              let input = new Input(this.css, this.opts);
              if (input.map)
                this.previousMaps.push(input.map);
            }
          }
          return this.previousMaps;
        }
        setSourcesContent() {
          let already = {};
          if (this.root) {
            this.root.walk((node) => {
              if (node.source) {
                let from = node.source.input.from;
                if (from && !already[from]) {
                  already[from] = true;
                  let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                  this.map.setSourceContent(fromUrl, node.source.input.css);
                }
              }
            });
          } else if (this.css) {
            let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
            this.map.setSourceContent(from, this.css);
          }
        }
        sourcePath(node) {
          if (this.mapOpts.from) {
            return this.toUrl(this.mapOpts.from);
          } else if (this.usesFileUrls) {
            return this.toFileUrl(node.source.input.from);
          } else {
            return this.toUrl(this.path(node.source.input.from));
          }
        }
        toBase64(str) {
          if (Buffer) {
            return Buffer.from(str).toString("base64");
          } else {
            return window.btoa(unescape(encodeURIComponent(str)));
          }
        }
        toFileUrl(path) {
          let cached = this.memoizedFileURLs.get(path);
          if (cached)
            return cached;
          if (pathToFileURL) {
            let fileURL = pathToFileURL(path).toString();
            this.memoizedFileURLs.set(path, fileURL);
            return fileURL;
          } else {
            throw new Error(
              "`map.absolute` option is not available in this PostCSS build"
            );
          }
        }
        toUrl(path) {
          let cached = this.memoizedURLs.get(path);
          if (cached)
            return cached;
          if (sep === "\\") {
            path = path.replace(/\\/g, "/");
          }
          let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);
          this.memoizedURLs.set(path, url);
          return url;
        }
      };
      module2.exports = MapGenerator;
    }
  });

  // node_modules/postcss/lib/comment.js
  var require_comment = __commonJS({
    "node_modules/postcss/lib/comment.js"(exports2, module2) {
      "use strict";
      var Node2 = require_node2();
      var Comment = class extends Node2 {
        constructor(defaults2) {
          super(defaults2);
          this.type = "comment";
        }
      };
      module2.exports = Comment;
      Comment.default = Comment;
    }
  });

  // node_modules/postcss/lib/container.js
  var require_container = __commonJS({
    "node_modules/postcss/lib/container.js"(exports2, module2) {
      "use strict";
      var { isClean, my } = require_symbols();
      var Declaration = require_declaration();
      var Comment = require_comment();
      var Node2 = require_node2();
      var parse2;
      var Rule;
      var AtRule;
      var Root;
      function cleanSource(nodes) {
        return nodes.map((i2) => {
          if (i2.nodes)
            i2.nodes = cleanSource(i2.nodes);
          delete i2.source;
          return i2;
        });
      }
      function markDirtyUp(node) {
        node[isClean] = false;
        if (node.proxyOf.nodes) {
          for (let i2 of node.proxyOf.nodes) {
            markDirtyUp(i2);
          }
        }
      }
      var Container = class extends Node2 {
        append(...children) {
          for (let child of children) {
            let nodes = this.normalize(child, this.last);
            for (let node of nodes)
              this.proxyOf.nodes.push(node);
          }
          this.markDirty();
          return this;
        }
        cleanRaws(keepBetween) {
          super.cleanRaws(keepBetween);
          if (this.nodes) {
            for (let node of this.nodes)
              node.cleanRaws(keepBetween);
          }
        }
        each(callback) {
          if (!this.proxyOf.nodes)
            return void 0;
          let iterator = this.getIterator();
          let index2, result;
          while (this.indexes[iterator] < this.proxyOf.nodes.length) {
            index2 = this.indexes[iterator];
            result = callback(this.proxyOf.nodes[index2], index2);
            if (result === false)
              break;
            this.indexes[iterator] += 1;
          }
          delete this.indexes[iterator];
          return result;
        }
        every(condition) {
          return this.nodes.every(condition);
        }
        getIterator() {
          if (!this.lastEach)
            this.lastEach = 0;
          if (!this.indexes)
            this.indexes = {};
          this.lastEach += 1;
          let iterator = this.lastEach;
          this.indexes[iterator] = 0;
          return iterator;
        }
        getProxyProcessor() {
          return {
            get(node, prop) {
              if (prop === "proxyOf") {
                return node;
              } else if (!node[prop]) {
                return node[prop];
              } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
                return (...args) => {
                  return node[prop](
                    ...args.map((i2) => {
                      if (typeof i2 === "function") {
                        return (child, index2) => i2(child.toProxy(), index2);
                      } else {
                        return i2;
                      }
                    })
                  );
                };
              } else if (prop === "every" || prop === "some") {
                return (cb) => {
                  return node[prop](
                    (child, ...other) => cb(child.toProxy(), ...other)
                  );
                };
              } else if (prop === "root") {
                return () => node.root().toProxy();
              } else if (prop === "nodes") {
                return node.nodes.map((i2) => i2.toProxy());
              } else if (prop === "first" || prop === "last") {
                return node[prop].toProxy();
              } else {
                return node[prop];
              }
            },
            set(node, prop, value) {
              if (node[prop] === value)
                return true;
              node[prop] = value;
              if (prop === "name" || prop === "params" || prop === "selector") {
                node.markDirty();
              }
              return true;
            }
          };
        }
        index(child) {
          if (typeof child === "number")
            return child;
          if (child.proxyOf)
            child = child.proxyOf;
          return this.proxyOf.nodes.indexOf(child);
        }
        insertAfter(exist, add2) {
          let existIndex = this.index(exist);
          let nodes = this.normalize(add2, this.proxyOf.nodes[existIndex]).reverse();
          existIndex = this.index(exist);
          for (let node of nodes)
            this.proxyOf.nodes.splice(existIndex + 1, 0, node);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (existIndex < index2) {
              this.indexes[id] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        insertBefore(exist, add2) {
          let existIndex = this.index(exist);
          let type = existIndex === 0 ? "prepend" : false;
          let nodes = this.normalize(add2, this.proxyOf.nodes[existIndex], type).reverse();
          existIndex = this.index(exist);
          for (let node of nodes)
            this.proxyOf.nodes.splice(existIndex, 0, node);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (existIndex <= index2) {
              this.indexes[id] = index2 + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        normalize(nodes, sample) {
          if (typeof nodes === "string") {
            nodes = cleanSource(parse2(nodes).nodes);
          } else if (Array.isArray(nodes)) {
            nodes = nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent)
                i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type === "root" && this.type !== "document") {
            nodes = nodes.nodes.slice(0);
            for (let i2 of nodes) {
              if (i2.parent)
                i2.parent.removeChild(i2, "ignore");
            }
          } else if (nodes.type) {
            nodes = [nodes];
          } else if (nodes.prop) {
            if (typeof nodes.value === "undefined") {
              throw new Error("Value field is missed in node creation");
            } else if (typeof nodes.value !== "string") {
              nodes.value = String(nodes.value);
            }
            nodes = [new Declaration(nodes)];
          } else if (nodes.selector) {
            nodes = [new Rule(nodes)];
          } else if (nodes.name) {
            nodes = [new AtRule(nodes)];
          } else if (nodes.text) {
            nodes = [new Comment(nodes)];
          } else {
            throw new Error("Unknown node type in node creation");
          }
          let processed = nodes.map((i2) => {
            if (!i2[my])
              Container.rebuild(i2);
            i2 = i2.proxyOf;
            if (i2.parent)
              i2.parent.removeChild(i2);
            if (i2[isClean])
              markDirtyUp(i2);
            if (typeof i2.raws.before === "undefined") {
              if (sample && typeof sample.raws.before !== "undefined") {
                i2.raws.before = sample.raws.before.replace(/\S/g, "");
              }
            }
            i2.parent = this.proxyOf;
            return i2;
          });
          return processed;
        }
        prepend(...children) {
          children = children.reverse();
          for (let child of children) {
            let nodes = this.normalize(child, this.first, "prepend").reverse();
            for (let node of nodes)
              this.proxyOf.nodes.unshift(node);
            for (let id in this.indexes) {
              this.indexes[id] = this.indexes[id] + nodes.length;
            }
          }
          this.markDirty();
          return this;
        }
        push(child) {
          child.parent = this;
          this.proxyOf.nodes.push(child);
          return this;
        }
        removeAll() {
          for (let node of this.proxyOf.nodes)
            node.parent = void 0;
          this.proxyOf.nodes = [];
          this.markDirty();
          return this;
        }
        removeChild(child) {
          child = this.index(child);
          this.proxyOf.nodes[child].parent = void 0;
          this.proxyOf.nodes.splice(child, 1);
          let index2;
          for (let id in this.indexes) {
            index2 = this.indexes[id];
            if (index2 >= child) {
              this.indexes[id] = index2 - 1;
            }
          }
          this.markDirty();
          return this;
        }
        replaceValues(pattern, opts, callback) {
          if (!callback) {
            callback = opts;
            opts = {};
          }
          this.walkDecls((decl) => {
            if (opts.props && !opts.props.includes(decl.prop))
              return;
            if (opts.fast && !decl.value.includes(opts.fast))
              return;
            decl.value = decl.value.replace(pattern, callback);
          });
          this.markDirty();
          return this;
        }
        some(condition) {
          return this.nodes.some(condition);
        }
        walk(callback) {
          return this.each((child, i2) => {
            let result;
            try {
              result = callback(child, i2);
            } catch (e3) {
              throw child.addToError(e3);
            }
            if (result !== false && child.walk) {
              result = child.walk(callback);
            }
            return result;
          });
        }
        walkAtRules(name, callback) {
          if (!callback) {
            callback = name;
            return this.walk((child, i2) => {
              if (child.type === "atrule") {
                return callback(child, i2);
              }
            });
          }
          if (name instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "atrule" && name.test(child.name)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "atrule" && child.name === name) {
              return callback(child, i2);
            }
          });
        }
        walkComments(callback) {
          return this.walk((child, i2) => {
            if (child.type === "comment") {
              return callback(child, i2);
            }
          });
        }
        walkDecls(prop, callback) {
          if (!callback) {
            callback = prop;
            return this.walk((child, i2) => {
              if (child.type === "decl") {
                return callback(child, i2);
              }
            });
          }
          if (prop instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "decl" && prop.test(child.prop)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "decl" && child.prop === prop) {
              return callback(child, i2);
            }
          });
        }
        walkRules(selector, callback) {
          if (!callback) {
            callback = selector;
            return this.walk((child, i2) => {
              if (child.type === "rule") {
                return callback(child, i2);
              }
            });
          }
          if (selector instanceof RegExp) {
            return this.walk((child, i2) => {
              if (child.type === "rule" && selector.test(child.selector)) {
                return callback(child, i2);
              }
            });
          }
          return this.walk((child, i2) => {
            if (child.type === "rule" && child.selector === selector) {
              return callback(child, i2);
            }
          });
        }
        get first() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[0];
        }
        get last() {
          if (!this.proxyOf.nodes)
            return void 0;
          return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
        }
      };
      Container.registerParse = (dependant) => {
        parse2 = dependant;
      };
      Container.registerRule = (dependant) => {
        Rule = dependant;
      };
      Container.registerAtRule = (dependant) => {
        AtRule = dependant;
      };
      Container.registerRoot = (dependant) => {
        Root = dependant;
      };
      module2.exports = Container;
      Container.default = Container;
      Container.rebuild = (node) => {
        if (node.type === "atrule") {
          Object.setPrototypeOf(node, AtRule.prototype);
        } else if (node.type === "rule") {
          Object.setPrototypeOf(node, Rule.prototype);
        } else if (node.type === "decl") {
          Object.setPrototypeOf(node, Declaration.prototype);
        } else if (node.type === "comment") {
          Object.setPrototypeOf(node, Comment.prototype);
        } else if (node.type === "root") {
          Object.setPrototypeOf(node, Root.prototype);
        }
        node[my] = true;
        if (node.nodes) {
          node.nodes.forEach((child) => {
            Container.rebuild(child);
          });
        }
      };
    }
  });

  // node_modules/postcss/lib/document.js
  var require_document = __commonJS({
    "node_modules/postcss/lib/document.js"(exports2, module2) {
      "use strict";
      var Container = require_container();
      var LazyResult;
      var Processor;
      var Document = class extends Container {
        constructor(defaults2) {
          super({ type: "document", ...defaults2 });
          if (!this.nodes) {
            this.nodes = [];
          }
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);
          return lazy.stringify();
        }
      };
      Document.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Document.registerProcessor = (dependant) => {
        Processor = dependant;
      };
      module2.exports = Document;
      Document.default = Document;
    }
  });

  // node_modules/postcss/lib/warn-once.js
  var require_warn_once = __commonJS({
    "node_modules/postcss/lib/warn-once.js"(exports2, module2) {
      "use strict";
      var printed = {};
      module2.exports = function warnOnce(message) {
        if (printed[message])
          return;
        printed[message] = true;
        if (typeof console !== "undefined" && console.warn) {
          console.warn(message);
        }
      };
    }
  });

  // node_modules/postcss/lib/warning.js
  var require_warning = __commonJS({
    "node_modules/postcss/lib/warning.js"(exports2, module2) {
      "use strict";
      var Warning = class {
        constructor(text, opts = {}) {
          this.type = "warning";
          this.text = text;
          if (opts.node && opts.node.source) {
            let range = opts.node.rangeBy(opts);
            this.line = range.start.line;
            this.column = range.start.column;
            this.endLine = range.end.line;
            this.endColumn = range.end.column;
          }
          for (let opt in opts)
            this[opt] = opts[opt];
        }
        toString() {
          if (this.node) {
            return this.node.error(this.text, {
              index: this.index,
              plugin: this.plugin,
              word: this.word
            }).message;
          }
          if (this.plugin) {
            return this.plugin + ": " + this.text;
          }
          return this.text;
        }
      };
      module2.exports = Warning;
      Warning.default = Warning;
    }
  });

  // node_modules/postcss/lib/result.js
  var require_result = __commonJS({
    "node_modules/postcss/lib/result.js"(exports2, module2) {
      "use strict";
      var Warning = require_warning();
      var Result = class {
        constructor(processor, root2, opts) {
          this.processor = processor;
          this.messages = [];
          this.root = root2;
          this.opts = opts;
          this.css = void 0;
          this.map = void 0;
        }
        toString() {
          return this.css;
        }
        warn(text, opts = {}) {
          if (!opts.plugin) {
            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
              opts.plugin = this.lastPlugin.postcssPlugin;
            }
          }
          let warning2 = new Warning(text, opts);
          this.messages.push(warning2);
          return warning2;
        }
        warnings() {
          return this.messages.filter((i2) => i2.type === "warning");
        }
        get content() {
          return this.css;
        }
      };
      module2.exports = Result;
      Result.default = Result;
    }
  });

  // node_modules/postcss/lib/tokenize.js
  var require_tokenize = __commonJS({
    "node_modules/postcss/lib/tokenize.js"(exports2, module2) {
      "use strict";
      var SINGLE_QUOTE = "'".charCodeAt(0);
      var DOUBLE_QUOTE = '"'.charCodeAt(0);
      var BACKSLASH = "\\".charCodeAt(0);
      var SLASH = "/".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var SPACE = " ".charCodeAt(0);
      var FEED = "\f".charCodeAt(0);
      var TAB = "	".charCodeAt(0);
      var CR = "\r".charCodeAt(0);
      var OPEN_SQUARE = "[".charCodeAt(0);
      var CLOSE_SQUARE = "]".charCodeAt(0);
      var OPEN_PARENTHESES = "(".charCodeAt(0);
      var CLOSE_PARENTHESES = ")".charCodeAt(0);
      var OPEN_CURLY = "{".charCodeAt(0);
      var CLOSE_CURLY = "}".charCodeAt(0);
      var SEMICOLON = ";".charCodeAt(0);
      var ASTERISK = "*".charCodeAt(0);
      var COLON = ":".charCodeAt(0);
      var AT = "@".charCodeAt(0);
      var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
      var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
      var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
      var RE_HEX_ESCAPE = /[\da-f]/i;
      module2.exports = function tokenizer(input, options = {}) {
        let css2 = input.css.valueOf();
        let ignore = options.ignoreErrors;
        let code, next, quote, content, escape;
        let escaped, escapePos, prev, n2, currentToken;
        let length = css2.length;
        let pos = 0;
        let buffer = [];
        let returned = [];
        function position() {
          return pos;
        }
        function unclosed(what) {
          throw input.error("Unclosed " + what, pos);
        }
        function endOfFile() {
          return returned.length === 0 && pos >= length;
        }
        function nextToken(opts) {
          if (returned.length)
            return returned.pop();
          if (pos >= length)
            return;
          let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
          code = css2.charCodeAt(pos);
          switch (code) {
            case NEWLINE:
            case SPACE:
            case TAB:
            case CR:
            case FEED: {
              next = pos;
              do {
                next += 1;
                code = css2.charCodeAt(next);
              } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
              currentToken = ["space", css2.slice(pos, next)];
              pos = next - 1;
              break;
            }
            case OPEN_SQUARE:
            case CLOSE_SQUARE:
            case OPEN_CURLY:
            case CLOSE_CURLY:
            case COLON:
            case SEMICOLON:
            case CLOSE_PARENTHESES: {
              let controlChar = String.fromCharCode(code);
              currentToken = [controlChar, controlChar, pos];
              break;
            }
            case OPEN_PARENTHESES: {
              prev = buffer.length ? buffer.pop()[1] : "";
              n2 = css2.charCodeAt(pos + 1);
              if (prev === "url" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {
                next = pos;
                do {
                  escaped = false;
                  next = css2.indexOf(")", next + 1);
                  if (next === -1) {
                    if (ignore || ignoreUnclosed) {
                      next = pos;
                      break;
                    } else {
                      unclosed("bracket");
                    }
                  }
                  escapePos = next;
                  while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                    escapePos -= 1;
                    escaped = !escaped;
                  }
                } while (escaped);
                currentToken = ["brackets", css2.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                next = css2.indexOf(")", pos + 1);
                content = css2.slice(pos, next + 1);
                if (next === -1 || RE_BAD_BRACKET.test(content)) {
                  currentToken = ["(", "(", pos];
                } else {
                  currentToken = ["brackets", content, pos, next];
                  pos = next;
                }
              }
              break;
            }
            case SINGLE_QUOTE:
            case DOUBLE_QUOTE: {
              quote = code === SINGLE_QUOTE ? "'" : '"';
              next = pos;
              do {
                escaped = false;
                next = css2.indexOf(quote, next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos + 1;
                    break;
                  } else {
                    unclosed("string");
                  }
                }
                escapePos = next;
                while (css2.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped = !escaped;
                }
              } while (escaped);
              currentToken = ["string", css2.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case AT: {
              RE_AT_END.lastIndex = pos + 1;
              RE_AT_END.test(css2);
              if (RE_AT_END.lastIndex === 0) {
                next = css2.length - 1;
              } else {
                next = RE_AT_END.lastIndex - 2;
              }
              currentToken = ["at-word", css2.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            case BACKSLASH: {
              next = pos;
              escape = true;
              while (css2.charCodeAt(next + 1) === BACKSLASH) {
                next += 1;
                escape = !escape;
              }
              code = css2.charCodeAt(next + 1);
              if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
                next += 1;
                if (RE_HEX_ESCAPE.test(css2.charAt(next))) {
                  while (RE_HEX_ESCAPE.test(css2.charAt(next + 1))) {
                    next += 1;
                  }
                  if (css2.charCodeAt(next + 1) === SPACE) {
                    next += 1;
                  }
                }
              }
              currentToken = ["word", css2.slice(pos, next + 1), pos, next];
              pos = next;
              break;
            }
            default: {
              if (code === SLASH && css2.charCodeAt(pos + 1) === ASTERISK) {
                next = css2.indexOf("*/", pos + 2) + 1;
                if (next === 0) {
                  if (ignore || ignoreUnclosed) {
                    next = css2.length;
                  } else {
                    unclosed("comment");
                  }
                }
                currentToken = ["comment", css2.slice(pos, next + 1), pos, next];
                pos = next;
              } else {
                RE_WORD_END.lastIndex = pos + 1;
                RE_WORD_END.test(css2);
                if (RE_WORD_END.lastIndex === 0) {
                  next = css2.length - 1;
                } else {
                  next = RE_WORD_END.lastIndex - 2;
                }
                currentToken = ["word", css2.slice(pos, next + 1), pos, next];
                buffer.push(currentToken);
                pos = next;
              }
              break;
            }
          }
          pos++;
          return currentToken;
        }
        function back(token) {
          returned.push(token);
        }
        return {
          back,
          endOfFile,
          nextToken,
          position
        };
      };
    }
  });

  // node_modules/postcss/lib/at-rule.js
  var require_at_rule = __commonJS({
    "node_modules/postcss/lib/at-rule.js"(exports2, module2) {
      "use strict";
      var Container = require_container();
      var AtRule = class extends Container {
        constructor(defaults2) {
          super(defaults2);
          this.type = "atrule";
        }
        append(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.append(...children);
        }
        prepend(...children) {
          if (!this.proxyOf.nodes)
            this.nodes = [];
          return super.prepend(...children);
        }
      };
      module2.exports = AtRule;
      AtRule.default = AtRule;
      Container.registerAtRule(AtRule);
    }
  });

  // node_modules/postcss/lib/root.js
  var require_root = __commonJS({
    "node_modules/postcss/lib/root.js"(exports2, module2) {
      "use strict";
      var Container = require_container();
      var LazyResult;
      var Processor;
      var Root = class extends Container {
        constructor(defaults2) {
          super(defaults2);
          this.type = "root";
          if (!this.nodes)
            this.nodes = [];
        }
        normalize(child, sample, type) {
          let nodes = super.normalize(child);
          if (sample) {
            if (type === "prepend") {
              if (this.nodes.length > 1) {
                sample.raws.before = this.nodes[1].raws.before;
              } else {
                delete sample.raws.before;
              }
            } else if (this.first !== sample) {
              for (let node of nodes) {
                node.raws.before = sample.raws.before;
              }
            }
          }
          return nodes;
        }
        removeChild(child, ignore) {
          let index2 = this.index(child);
          if (!ignore && index2 === 0 && this.nodes.length > 1) {
            this.nodes[1].raws.before = this.nodes[index2].raws.before;
          }
          return super.removeChild(child);
        }
        toResult(opts = {}) {
          let lazy = new LazyResult(new Processor(), this, opts);
          return lazy.stringify();
        }
      };
      Root.registerLazyResult = (dependant) => {
        LazyResult = dependant;
      };
      Root.registerProcessor = (dependant) => {
        Processor = dependant;
      };
      module2.exports = Root;
      Root.default = Root;
      Container.registerRoot(Root);
    }
  });

  // node_modules/postcss/lib/list.js
  var require_list = __commonJS({
    "node_modules/postcss/lib/list.js"(exports2, module2) {
      "use strict";
      var list = {
        comma(string2) {
          return list.split(string2, [","], true);
        },
        space(string2) {
          let spaces = [" ", "\n", "	"];
          return list.split(string2, spaces);
        },
        split(string2, separators, last) {
          let array = [];
          let current = "";
          let split = false;
          let func = 0;
          let inQuote = false;
          let prevQuote = "";
          let escape = false;
          for (let letter of string2) {
            if (escape) {
              escape = false;
            } else if (letter === "\\") {
              escape = true;
            } else if (inQuote) {
              if (letter === prevQuote) {
                inQuote = false;
              }
            } else if (letter === '"' || letter === "'") {
              inQuote = true;
              prevQuote = letter;
            } else if (letter === "(") {
              func += 1;
            } else if (letter === ")") {
              if (func > 0)
                func -= 1;
            } else if (func === 0) {
              if (separators.includes(letter))
                split = true;
            }
            if (split) {
              if (current !== "")
                array.push(current.trim());
              current = "";
              split = false;
            } else {
              current += letter;
            }
          }
          if (last || current !== "")
            array.push(current.trim());
          return array;
        }
      };
      module2.exports = list;
      list.default = list;
    }
  });

  // node_modules/postcss/lib/rule.js
  var require_rule = __commonJS({
    "node_modules/postcss/lib/rule.js"(exports2, module2) {
      "use strict";
      var Container = require_container();
      var list = require_list();
      var Rule = class extends Container {
        constructor(defaults2) {
          super(defaults2);
          this.type = "rule";
          if (!this.nodes)
            this.nodes = [];
        }
        get selectors() {
          return list.comma(this.selector);
        }
        set selectors(values) {
          let match = this.selector ? this.selector.match(/,\s*/) : null;
          let sep = match ? match[0] : "," + this.raw("between", "beforeOpen");
          this.selector = values.join(sep);
        }
      };
      module2.exports = Rule;
      Rule.default = Rule;
      Container.registerRule(Rule);
    }
  });

  // node_modules/postcss/lib/parser.js
  var require_parser = __commonJS({
    "node_modules/postcss/lib/parser.js"(exports2, module2) {
      "use strict";
      var Declaration = require_declaration();
      var tokenizer = require_tokenize();
      var Comment = require_comment();
      var AtRule = require_at_rule();
      var Root = require_root();
      var Rule = require_rule();
      var SAFE_COMMENT_NEIGHBOR = {
        empty: true,
        space: true
      };
      function findLastWithPosition(tokens) {
        for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
          let token = tokens[i2];
          let pos = token[3] || token[2];
          if (pos)
            return pos;
        }
      }
      var Parser = class {
        constructor(input) {
          this.input = input;
          this.root = new Root();
          this.current = this.root;
          this.spaces = "";
          this.semicolon = false;
          this.customProperty = false;
          this.createTokenizer();
          this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
        }
        atrule(token) {
          let node = new AtRule();
          node.name = token[1].slice(1);
          if (node.name === "") {
            this.unnamedAtrule(node, token);
          }
          this.init(node, token[2]);
          let type;
          let prev;
          let shift2;
          let last = false;
          let open = false;
          let params = [];
          let brackets = [];
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            type = token[0];
            if (type === "(" || type === "[") {
              brackets.push(type === "(" ? ")" : "]");
            } else if (type === "{" && brackets.length > 0) {
              brackets.push("}");
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
            }
            if (brackets.length === 0) {
              if (type === ";") {
                node.source.end = this.getPosition(token[2]);
                node.source.end.offset++;
                this.semicolon = true;
                break;
              } else if (type === "{") {
                open = true;
                break;
              } else if (type === "}") {
                if (params.length > 0) {
                  shift2 = params.length - 1;
                  prev = params[shift2];
                  while (prev && prev[0] === "space") {
                    prev = params[--shift2];
                  }
                  if (prev) {
                    node.source.end = this.getPosition(prev[3] || prev[2]);
                    node.source.end.offset++;
                  }
                }
                this.end(token);
                break;
              } else {
                params.push(token);
              }
            } else {
              params.push(token);
            }
            if (this.tokenizer.endOfFile()) {
              last = true;
              break;
            }
          }
          node.raws.between = this.spacesAndCommentsFromEnd(params);
          if (params.length) {
            node.raws.afterName = this.spacesAndCommentsFromStart(params);
            this.raw(node, "params", params);
            if (last) {
              token = params[params.length - 1];
              node.source.end = this.getPosition(token[3] || token[2]);
              node.source.end.offset++;
              this.spaces = node.raws.between;
              node.raws.between = "";
            }
          } else {
            node.raws.afterName = "";
            node.params = "";
          }
          if (open) {
            node.nodes = [];
            this.current = node;
          }
        }
        checkMissedSemicolon(tokens) {
          let colon = this.colon(tokens);
          if (colon === false)
            return;
          let founded = 0;
          let token;
          for (let j3 = colon - 1; j3 >= 0; j3--) {
            token = tokens[j3];
            if (token[0] !== "space") {
              founded += 1;
              if (founded === 2)
                break;
            }
          }
          throw this.input.error(
            "Missed semicolon",
            token[0] === "word" ? token[3] + 1 : token[2]
          );
        }
        colon(tokens) {
          let brackets = 0;
          let token, type, prev;
          for (let [i2, element] of tokens.entries()) {
            token = element;
            type = token[0];
            if (type === "(") {
              brackets += 1;
            }
            if (type === ")") {
              brackets -= 1;
            }
            if (brackets === 0 && type === ":") {
              if (!prev) {
                this.doubleColon(token);
              } else if (prev[0] === "word" && prev[1] === "progid") {
                continue;
              } else {
                return i2;
              }
            }
            prev = token;
          }
          return false;
        }
        comment(token) {
          let node = new Comment();
          this.init(node, token[2]);
          node.source.end = this.getPosition(token[3] || token[2]);
          node.source.end.offset++;
          let text = token[1].slice(2, -2);
          if (/^\s*$/.test(text)) {
            node.text = "";
            node.raws.left = text;
            node.raws.right = "";
          } else {
            let match = text.match(/^(\s*)([^]*\S)(\s*)$/);
            node.text = match[2];
            node.raws.left = match[1];
            node.raws.right = match[3];
          }
        }
        createTokenizer() {
          this.tokenizer = tokenizer(this.input);
        }
        decl(tokens, customProperty) {
          let node = new Declaration();
          this.init(node, tokens[0][2]);
          let last = tokens[tokens.length - 1];
          if (last[0] === ";") {
            this.semicolon = true;
            tokens.pop();
          }
          node.source.end = this.getPosition(
            last[3] || last[2] || findLastWithPosition(tokens)
          );
          node.source.end.offset++;
          while (tokens[0][0] !== "word") {
            if (tokens.length === 1)
              this.unknownWord(tokens);
            node.raws.before += tokens.shift()[1];
          }
          node.source.start = this.getPosition(tokens[0][2]);
          node.prop = "";
          while (tokens.length) {
            let type = tokens[0][0];
            if (type === ":" || type === "space" || type === "comment") {
              break;
            }
            node.prop += tokens.shift()[1];
          }
          node.raws.between = "";
          let token;
          while (tokens.length) {
            token = tokens.shift();
            if (token[0] === ":") {
              node.raws.between += token[1];
              break;
            } else {
              if (token[0] === "word" && /\w/.test(token[1])) {
                this.unknownWord([token]);
              }
              node.raws.between += token[1];
            }
          }
          if (node.prop[0] === "_" || node.prop[0] === "*") {
            node.raws.before += node.prop[0];
            node.prop = node.prop.slice(1);
          }
          let firstSpaces = [];
          let next;
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment")
              break;
            firstSpaces.push(tokens.shift());
          }
          this.precheckMissedSemicolon(tokens);
          for (let i2 = tokens.length - 1; i2 >= 0; i2--) {
            token = tokens[i2];
            if (token[1].toLowerCase() === "!important") {
              node.important = true;
              let string2 = this.stringFrom(tokens, i2);
              string2 = this.spacesFromEnd(tokens) + string2;
              if (string2 !== " !important")
                node.raws.important = string2;
              break;
            } else if (token[1].toLowerCase() === "important") {
              let cache = tokens.slice(0);
              let str = "";
              for (let j3 = i2; j3 > 0; j3--) {
                let type = cache[j3][0];
                if (str.trim().indexOf("!") === 0 && type !== "space") {
                  break;
                }
                str = cache.pop()[1] + str;
              }
              if (str.trim().indexOf("!") === 0) {
                node.important = true;
                node.raws.important = str;
                tokens = cache;
              }
            }
            if (token[0] !== "space" && token[0] !== "comment") {
              break;
            }
          }
          let hasWord = tokens.some((i2) => i2[0] !== "space" && i2[0] !== "comment");
          if (hasWord) {
            node.raws.between += firstSpaces.map((i2) => i2[1]).join("");
            firstSpaces = [];
          }
          this.raw(node, "value", firstSpaces.concat(tokens), customProperty);
          if (node.value.includes(":") && !customProperty) {
            this.checkMissedSemicolon(tokens);
          }
        }
        doubleColon(token) {
          throw this.input.error(
            "Double colon",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
        emptyRule(token) {
          let node = new Rule();
          this.init(node, token[2]);
          node.selector = "";
          node.raws.between = "";
          this.current = node;
        }
        end(token) {
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.semicolon = false;
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.spaces = "";
          if (this.current.parent) {
            this.current.source.end = this.getPosition(token[2]);
            this.current.source.end.offset++;
            this.current = this.current.parent;
          } else {
            this.unexpectedClose(token);
          }
        }
        endFile() {
          if (this.current.parent)
            this.unclosedBlock();
          if (this.current.nodes && this.current.nodes.length) {
            this.current.raws.semicolon = this.semicolon;
          }
          this.current.raws.after = (this.current.raws.after || "") + this.spaces;
          this.root.source.end = this.getPosition(this.tokenizer.position());
        }
        freeSemicolon(token) {
          this.spaces += token[1];
          if (this.current.nodes) {
            let prev = this.current.nodes[this.current.nodes.length - 1];
            if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
              prev.raws.ownSemicolon = this.spaces;
              this.spaces = "";
            }
          }
        }
        getPosition(offset2) {
          let pos = this.input.fromOffset(offset2);
          return {
            column: pos.col,
            line: pos.line,
            offset: offset2
          };
        }
        init(node, offset2) {
          this.current.push(node);
          node.source = {
            input: this.input,
            start: this.getPosition(offset2)
          };
          node.raws.before = this.spaces;
          this.spaces = "";
          if (node.type !== "comment")
            this.semicolon = false;
        }
        other(start) {
          let end = false;
          let type = null;
          let colon = false;
          let bracket = null;
          let brackets = [];
          let customProperty = start[1].startsWith("--");
          let tokens = [];
          let token = start;
          while (token) {
            type = token[0];
            tokens.push(token);
            if (type === "(" || type === "[") {
              if (!bracket)
                bracket = token;
              brackets.push(type === "(" ? ")" : "]");
            } else if (customProperty && colon && type === "{") {
              if (!bracket)
                bracket = token;
              brackets.push("}");
            } else if (brackets.length === 0) {
              if (type === ";") {
                if (colon) {
                  this.decl(tokens, customProperty);
                  return;
                } else {
                  break;
                }
              } else if (type === "{") {
                this.rule(tokens);
                return;
              } else if (type === "}") {
                this.tokenizer.back(tokens.pop());
                end = true;
                break;
              } else if (type === ":") {
                colon = true;
              }
            } else if (type === brackets[brackets.length - 1]) {
              brackets.pop();
              if (brackets.length === 0)
                bracket = null;
            }
            token = this.tokenizer.nextToken();
          }
          if (this.tokenizer.endOfFile())
            end = true;
          if (brackets.length > 0)
            this.unclosedBracket(bracket);
          if (end && colon) {
            if (!customProperty) {
              while (tokens.length) {
                token = tokens[tokens.length - 1][0];
                if (token !== "space" && token !== "comment")
                  break;
                this.tokenizer.back(tokens.pop());
              }
            }
            this.decl(tokens, customProperty);
          } else {
            this.unknownWord(tokens);
          }
        }
        parse() {
          let token;
          while (!this.tokenizer.endOfFile()) {
            token = this.tokenizer.nextToken();
            switch (token[0]) {
              case "space":
                this.spaces += token[1];
                break;
              case ";":
                this.freeSemicolon(token);
                break;
              case "}":
                this.end(token);
                break;
              case "comment":
                this.comment(token);
                break;
              case "at-word":
                this.atrule(token);
                break;
              case "{":
                this.emptyRule(token);
                break;
              default:
                this.other(token);
                break;
            }
          }
          this.endFile();
        }
        precheckMissedSemicolon() {
        }
        raw(node, prop, tokens, customProperty) {
          let token, type;
          let length = tokens.length;
          let value = "";
          let clean = true;
          let next, prev;
          for (let i2 = 0; i2 < length; i2 += 1) {
            token = tokens[i2];
            type = token[0];
            if (type === "space" && i2 === length - 1 && !customProperty) {
              clean = false;
            } else if (type === "comment") {
              prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : "empty";
              next = tokens[i2 + 1] ? tokens[i2 + 1][0] : "empty";
              if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
                if (value.slice(-1) === ",") {
                  clean = false;
                } else {
                  value += token[1];
                }
              } else {
                clean = false;
              }
            } else {
              value += token[1];
            }
          }
          if (!clean) {
            let raw = tokens.reduce((all, i2) => all + i2[1], "");
            node.raws[prop] = { raw, value };
          }
          node[prop] = value;
        }
        rule(tokens) {
          tokens.pop();
          let node = new Rule();
          this.init(node, tokens[0][2]);
          node.raws.between = this.spacesAndCommentsFromEnd(tokens);
          this.raw(node, "selector", tokens);
          this.current = node;
        }
        spacesAndCommentsFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space" && lastTokenType !== "comment")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        spacesAndCommentsFromStart(tokens) {
          let next;
          let spaces = "";
          while (tokens.length) {
            next = tokens[0][0];
            if (next !== "space" && next !== "comment")
              break;
            spaces += tokens.shift()[1];
          }
          return spaces;
        }
        spacesFromEnd(tokens) {
          let lastTokenType;
          let spaces = "";
          while (tokens.length) {
            lastTokenType = tokens[tokens.length - 1][0];
            if (lastTokenType !== "space")
              break;
            spaces = tokens.pop()[1] + spaces;
          }
          return spaces;
        }
        stringFrom(tokens, from) {
          let result = "";
          for (let i2 = from; i2 < tokens.length; i2++) {
            result += tokens[i2][1];
          }
          tokens.splice(from, tokens.length - from);
          return result;
        }
        unclosedBlock() {
          let pos = this.current.source.start;
          throw this.input.error("Unclosed block", pos.line, pos.column);
        }
        unclosedBracket(bracket) {
          throw this.input.error(
            "Unclosed bracket",
            { offset: bracket[2] },
            { offset: bracket[2] + 1 }
          );
        }
        unexpectedClose(token) {
          throw this.input.error(
            "Unexpected }",
            { offset: token[2] },
            { offset: token[2] + 1 }
          );
        }
        unknownWord(tokens) {
          throw this.input.error(
            "Unknown word",
            { offset: tokens[0][2] },
            { offset: tokens[0][2] + tokens[0][1].length }
          );
        }
        unnamedAtrule(node, token) {
          throw this.input.error(
            "At-rule without name",
            { offset: token[2] },
            { offset: token[2] + token[1].length }
          );
        }
      };
      module2.exports = Parser;
    }
  });

  // node_modules/postcss/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/postcss/lib/parse.js"(exports2, module2) {
      "use strict";
      var Container = require_container();
      var Parser = require_parser();
      var Input = require_input();
      function parse2(css2, opts) {
        let input = new Input(css2, opts);
        let parser = new Parser(input);
        try {
          parser.parse();
        } catch (e3) {
          if (true) {
            if (e3.name === "CssSyntaxError" && opts && opts.from) {
              if (/\.scss$/i.test(opts.from)) {
                e3.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
              } else if (/\.sass/i.test(opts.from)) {
                e3.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
              } else if (/\.less$/i.test(opts.from)) {
                e3.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
              }
            }
          }
          throw e3;
        }
        return parser.root;
      }
      module2.exports = parse2;
      parse2.default = parse2;
      Container.registerParse(parse2);
    }
  });

  // node_modules/postcss/lib/lazy-result.js
  var require_lazy_result = __commonJS({
    "node_modules/postcss/lib/lazy-result.js"(exports2, module2) {
      "use strict";
      var { isClean, my } = require_symbols();
      var MapGenerator = require_map_generator();
      var stringify = require_stringify2();
      var Container = require_container();
      var Document = require_document();
      var warnOnce = require_warn_once();
      var Result = require_result();
      var parse2 = require_parse();
      var Root = require_root();
      var TYPE_TO_CLASS_NAME = {
        atrule: "AtRule",
        comment: "Comment",
        decl: "Declaration",
        document: "Document",
        root: "Root",
        rule: "Rule"
      };
      var PLUGIN_PROPS = {
        AtRule: true,
        AtRuleExit: true,
        Comment: true,
        CommentExit: true,
        Declaration: true,
        DeclarationExit: true,
        Document: true,
        DocumentExit: true,
        Once: true,
        OnceExit: true,
        postcssPlugin: true,
        prepare: true,
        Root: true,
        RootExit: true,
        Rule: true,
        RuleExit: true
      };
      var NOT_VISITORS = {
        Once: true,
        postcssPlugin: true,
        prepare: true
      };
      var CHILDREN = 0;
      function isPromise2(obj) {
        return typeof obj === "object" && typeof obj.then === "function";
      }
      function getEvents(node) {
        let key = false;
        let type = TYPE_TO_CLASS_NAME[node.type];
        if (node.type === "decl") {
          key = node.prop.toLowerCase();
        } else if (node.type === "atrule") {
          key = node.name.toLowerCase();
        }
        if (key && node.append) {
          return [
            type,
            type + "-" + key,
            CHILDREN,
            type + "Exit",
            type + "Exit-" + key
          ];
        } else if (key) {
          return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
        } else if (node.append) {
          return [type, CHILDREN, type + "Exit"];
        } else {
          return [type, type + "Exit"];
        }
      }
      function toStack(node) {
        let events;
        if (node.type === "document") {
          events = ["Document", CHILDREN, "DocumentExit"];
        } else if (node.type === "root") {
          events = ["Root", CHILDREN, "RootExit"];
        } else {
          events = getEvents(node);
        }
        return {
          eventIndex: 0,
          events,
          iterator: 0,
          node,
          visitorIndex: 0,
          visitors: []
        };
      }
      function cleanMarks(node) {
        node[isClean] = false;
        if (node.nodes)
          node.nodes.forEach((i2) => cleanMarks(i2));
        return node;
      }
      var postcss = {};
      var LazyResult = class {
        constructor(processor, css2, opts) {
          this.stringified = false;
          this.processed = false;
          let root2;
          if (typeof css2 === "object" && css2 !== null && (css2.type === "root" || css2.type === "document")) {
            root2 = cleanMarks(css2);
          } else if (css2 instanceof LazyResult || css2 instanceof Result) {
            root2 = cleanMarks(css2.root);
            if (css2.map) {
              if (typeof opts.map === "undefined")
                opts.map = {};
              if (!opts.map.inline)
                opts.map.inline = false;
              opts.map.prev = css2.map;
            }
          } else {
            let parser = parse2;
            if (opts.syntax)
              parser = opts.syntax.parse;
            if (opts.parser)
              parser = opts.parser;
            if (parser.parse)
              parser = parser.parse;
            try {
              root2 = parser(css2, opts);
            } catch (error) {
              this.processed = true;
              this.error = error;
            }
            if (root2 && !root2[my]) {
              Container.rebuild(root2);
            }
          }
          this.result = new Result(processor, root2, opts);
          this.helpers = { ...postcss, postcss, result: this.result };
          this.plugins = this.processor.plugins.map((plugin) => {
            if (typeof plugin === "object" && plugin.prepare) {
              return { ...plugin, ...plugin.prepare(this.result) };
            } else {
              return plugin;
            }
          });
        }
        async() {
          if (this.error)
            return Promise.reject(this.error);
          if (this.processed)
            return Promise.resolve(this.result);
          if (!this.processing) {
            this.processing = this.runAsync();
          }
          return this.processing;
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        getAsyncError() {
          throw new Error("Use process(css).then(cb) to work with async plugins");
        }
        handleError(error, node) {
          let plugin = this.result.lastPlugin;
          try {
            if (node)
              node.addToError(error);
            this.error = error;
            if (error.name === "CssSyntaxError" && !error.plugin) {
              error.plugin = plugin.postcssPlugin;
              error.setMessage();
            } else if (plugin.postcssVersion) {
              if (true) {
                let pluginName = plugin.postcssPlugin;
                let pluginVer = plugin.postcssVersion;
                let runtimeVer = this.result.processor.version;
                let a2 = pluginVer.split(".");
                let b3 = runtimeVer.split(".");
                if (a2[0] !== b3[0] || parseInt(a2[1]) > parseInt(b3[1])) {
                  console.error(
                    "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                  );
                }
              }
            }
          } catch (err) {
            if (console && console.error)
              console.error(err);
          }
          return error;
        }
        prepareVisitors() {
          this.listeners = {};
          let add2 = (plugin, type, cb) => {
            if (!this.listeners[type])
              this.listeners[type] = [];
            this.listeners[type].push([plugin, cb]);
          };
          for (let plugin of this.plugins) {
            if (typeof plugin === "object") {
              for (let event in plugin) {
                if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                  throw new Error(
                    `Unknown event ${event} in ${plugin.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                  );
                }
                if (!NOT_VISITORS[event]) {
                  if (typeof plugin[event] === "object") {
                    for (let filter in plugin[event]) {
                      if (filter === "*") {
                        add2(plugin, event, plugin[event][filter]);
                      } else {
                        add2(
                          plugin,
                          event + "-" + filter.toLowerCase(),
                          plugin[event][filter]
                        );
                      }
                    }
                  } else if (typeof plugin[event] === "function") {
                    add2(plugin, event, plugin[event]);
                  }
                }
              }
            }
          }
          this.hasListener = Object.keys(this.listeners).length > 0;
        }
        async runAsync() {
          this.plugin = 0;
          for (let i2 = 0; i2 < this.plugins.length; i2++) {
            let plugin = this.plugins[i2];
            let promise = this.runOnRoot(plugin);
            if (isPromise2(promise)) {
              try {
                await promise;
              } catch (error) {
                throw this.handleError(error);
              }
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              let stack = [toStack(root2)];
              while (stack.length > 0) {
                let promise = this.visitTick(stack);
                if (isPromise2(promise)) {
                  try {
                    await promise;
                  } catch (e3) {
                    let node = stack[stack.length - 1].node;
                    throw this.handleError(e3, node);
                  }
                }
              }
            }
            if (this.listeners.OnceExit) {
              for (let [plugin, visitor] of this.listeners.OnceExit) {
                this.result.lastPlugin = plugin;
                try {
                  if (root2.type === "document") {
                    let roots = root2.nodes.map(
                      (subRoot) => visitor(subRoot, this.helpers)
                    );
                    await Promise.all(roots);
                  } else {
                    await visitor(root2, this.helpers);
                  }
                } catch (e3) {
                  throw this.handleError(e3);
                }
              }
            }
          }
          this.processed = true;
          return this.stringify();
        }
        runOnRoot(plugin) {
          this.result.lastPlugin = plugin;
          try {
            if (typeof plugin === "object" && plugin.Once) {
              if (this.result.root.type === "document") {
                let roots = this.result.root.nodes.map(
                  (root2) => plugin.Once(root2, this.helpers)
                );
                if (isPromise2(roots[0])) {
                  return Promise.all(roots);
                }
                return roots;
              }
              return plugin.Once(this.result.root, this.helpers);
            } else if (typeof plugin === "function") {
              return plugin(this.result.root, this.result);
            }
          } catch (error) {
            throw this.handleError(error);
          }
        }
        stringify() {
          if (this.error)
            throw this.error;
          if (this.stringified)
            return this.result;
          this.stringified = true;
          this.sync();
          let opts = this.result.opts;
          let str = stringify;
          if (opts.syntax)
            str = opts.syntax.stringify;
          if (opts.stringifier)
            str = opts.stringifier;
          if (str.stringify)
            str = str.stringify;
          let map = new MapGenerator(str, this.result.root, this.result.opts);
          let data = map.generate();
          this.result.css = data[0];
          this.result.map = data[1];
          return this.result;
        }
        sync() {
          if (this.error)
            throw this.error;
          if (this.processed)
            return this.result;
          this.processed = true;
          if (this.processing) {
            throw this.getAsyncError();
          }
          for (let plugin of this.plugins) {
            let promise = this.runOnRoot(plugin);
            if (isPromise2(promise)) {
              throw this.getAsyncError();
            }
          }
          this.prepareVisitors();
          if (this.hasListener) {
            let root2 = this.result.root;
            while (!root2[isClean]) {
              root2[isClean] = true;
              this.walkSync(root2);
            }
            if (this.listeners.OnceExit) {
              if (root2.type === "document") {
                for (let subRoot of root2.nodes) {
                  this.visitSync(this.listeners.OnceExit, subRoot);
                }
              } else {
                this.visitSync(this.listeners.OnceExit, root2);
              }
            }
          }
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this.opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this.css;
        }
        visitSync(visitors, node) {
          for (let [plugin, visitor] of visitors) {
            this.result.lastPlugin = plugin;
            let promise;
            try {
              promise = visitor(node, this.helpers);
            } catch (e3) {
              throw this.handleError(e3, node.proxyOf);
            }
            if (node.type !== "root" && node.type !== "document" && !node.parent) {
              return true;
            }
            if (isPromise2(promise)) {
              throw this.getAsyncError();
            }
          }
        }
        visitTick(stack) {
          let visit = stack[stack.length - 1];
          let { node, visitors } = visit;
          if (node.type !== "root" && node.type !== "document" && !node.parent) {
            stack.pop();
            return;
          }
          if (visitors.length > 0 && visit.visitorIndex < visitors.length) {
            let [plugin, visitor] = visitors[visit.visitorIndex];
            visit.visitorIndex += 1;
            if (visit.visitorIndex === visitors.length) {
              visit.visitors = [];
              visit.visitorIndex = 0;
            }
            this.result.lastPlugin = plugin;
            try {
              return visitor(node.toProxy(), this.helpers);
            } catch (e3) {
              throw this.handleError(e3, node);
            }
          }
          if (visit.iterator !== 0) {
            let iterator = visit.iterator;
            let child;
            while (child = node.nodes[node.indexes[iterator]]) {
              node.indexes[iterator] += 1;
              if (!child[isClean]) {
                child[isClean] = true;
                stack.push(toStack(child));
                return;
              }
            }
            visit.iterator = 0;
            delete node.indexes[iterator];
          }
          let events = visit.events;
          while (visit.eventIndex < events.length) {
            let event = events[visit.eventIndex];
            visit.eventIndex += 1;
            if (event === CHILDREN) {
              if (node.nodes && node.nodes.length) {
                node[isClean] = true;
                visit.iterator = node.getIterator();
              }
              return;
            } else if (this.listeners[event]) {
              visit.visitors = this.listeners[event];
              return;
            }
          }
          stack.pop();
        }
        walkSync(node) {
          node[isClean] = true;
          let events = getEvents(node);
          for (let event of events) {
            if (event === CHILDREN) {
              if (node.nodes) {
                node.each((child) => {
                  if (!child[isClean])
                    this.walkSync(child);
                });
              }
            } else {
              let visitors = this.listeners[event];
              if (visitors) {
                if (this.visitSync(visitors, node.toProxy()))
                  return;
              }
            }
          }
        }
        warnings() {
          return this.sync().warnings();
        }
        get content() {
          return this.stringify().content;
        }
        get css() {
          return this.stringify().css;
        }
        get map() {
          return this.stringify().map;
        }
        get messages() {
          return this.sync().messages;
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          return this.sync().root;
        }
        get [Symbol.toStringTag]() {
          return "LazyResult";
        }
      };
      LazyResult.registerPostcss = (dependant) => {
        postcss = dependant;
      };
      module2.exports = LazyResult;
      LazyResult.default = LazyResult;
      Root.registerLazyResult(LazyResult);
      Document.registerLazyResult(LazyResult);
    }
  });

  // node_modules/postcss/lib/no-work-result.js
  var require_no_work_result = __commonJS({
    "node_modules/postcss/lib/no-work-result.js"(exports2, module2) {
      "use strict";
      var MapGenerator = require_map_generator();
      var stringify = require_stringify2();
      var warnOnce = require_warn_once();
      var parse2 = require_parse();
      var Result = require_result();
      var NoWorkResult = class {
        constructor(processor, css2, opts) {
          css2 = css2.toString();
          this.stringified = false;
          this._processor = processor;
          this._css = css2;
          this._opts = opts;
          this._map = void 0;
          let root2;
          let str = stringify;
          this.result = new Result(this._processor, root2, this._opts);
          this.result.css = css2;
          let self2 = this;
          Object.defineProperty(this.result, "root", {
            get() {
              return self2.root;
            }
          });
          let map = new MapGenerator(str, root2, this._opts, css2);
          if (map.isMap()) {
            let [generatedCSS, generatedMap] = map.generate();
            if (generatedCSS) {
              this.result.css = generatedCSS;
            }
            if (generatedMap) {
              this.result.map = generatedMap;
            }
          }
        }
        async() {
          if (this.error)
            return Promise.reject(this.error);
          return Promise.resolve(this.result);
        }
        catch(onRejected) {
          return this.async().catch(onRejected);
        }
        finally(onFinally) {
          return this.async().then(onFinally, onFinally);
        }
        sync() {
          if (this.error)
            throw this.error;
          return this.result;
        }
        then(onFulfilled, onRejected) {
          if (true) {
            if (!("from" in this._opts)) {
              warnOnce(
                "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
              );
            }
          }
          return this.async().then(onFulfilled, onRejected);
        }
        toString() {
          return this._css;
        }
        warnings() {
          return [];
        }
        get content() {
          return this.result.css;
        }
        get css() {
          return this.result.css;
        }
        get map() {
          return this.result.map;
        }
        get messages() {
          return [];
        }
        get opts() {
          return this.result.opts;
        }
        get processor() {
          return this.result.processor;
        }
        get root() {
          if (this._root) {
            return this._root;
          }
          let root2;
          let parser = parse2;
          try {
            root2 = parser(this._css, this._opts);
          } catch (error) {
            this.error = error;
          }
          if (this.error) {
            throw this.error;
          } else {
            this._root = root2;
            return root2;
          }
        }
        get [Symbol.toStringTag]() {
          return "NoWorkResult";
        }
      };
      module2.exports = NoWorkResult;
      NoWorkResult.default = NoWorkResult;
    }
  });

  // node_modules/postcss/lib/processor.js
  var require_processor = __commonJS({
    "node_modules/postcss/lib/processor.js"(exports2, module2) {
      "use strict";
      var NoWorkResult = require_no_work_result();
      var LazyResult = require_lazy_result();
      var Document = require_document();
      var Root = require_root();
      var Processor = class {
        constructor(plugins = []) {
          this.version = "8.4.31";
          this.plugins = this.normalize(plugins);
        }
        normalize(plugins) {
          let normalized = [];
          for (let i2 of plugins) {
            if (i2.postcss === true) {
              i2 = i2();
            } else if (i2.postcss) {
              i2 = i2.postcss;
            }
            if (typeof i2 === "object" && Array.isArray(i2.plugins)) {
              normalized = normalized.concat(i2.plugins);
            } else if (typeof i2 === "object" && i2.postcssPlugin) {
              normalized.push(i2);
            } else if (typeof i2 === "function") {
              normalized.push(i2);
            } else if (typeof i2 === "object" && (i2.parse || i2.stringify)) {
              if (true) {
                throw new Error(
                  "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
                );
              }
            } else {
              throw new Error(i2 + " is not a PostCSS plugin");
            }
          }
          return normalized;
        }
        process(css2, opts = {}) {
          if (this.plugins.length === 0 && typeof opts.parser === "undefined" && typeof opts.stringifier === "undefined" && typeof opts.syntax === "undefined") {
            return new NoWorkResult(this, css2, opts);
          } else {
            return new LazyResult(this, css2, opts);
          }
        }
        use(plugin) {
          this.plugins = this.plugins.concat(this.normalize([plugin]));
          return this;
        }
      };
      module2.exports = Processor;
      Processor.default = Processor;
      Root.registerProcessor(Processor);
      Document.registerProcessor(Processor);
    }
  });

  // node_modules/postcss/lib/fromJSON.js
  var require_fromJSON = __commonJS({
    "node_modules/postcss/lib/fromJSON.js"(exports2, module2) {
      "use strict";
      var Declaration = require_declaration();
      var PreviousMap = require_previous_map();
      var Comment = require_comment();
      var AtRule = require_at_rule();
      var Input = require_input();
      var Root = require_root();
      var Rule = require_rule();
      function fromJSON(json, inputs) {
        if (Array.isArray(json))
          return json.map((n2) => fromJSON(n2));
        let { inputs: ownInputs, ...defaults2 } = json;
        if (ownInputs) {
          inputs = [];
          for (let input of ownInputs) {
            let inputHydrated = { ...input, __proto__: Input.prototype };
            if (inputHydrated.map) {
              inputHydrated.map = {
                ...inputHydrated.map,
                __proto__: PreviousMap.prototype
              };
            }
            inputs.push(inputHydrated);
          }
        }
        if (defaults2.nodes) {
          defaults2.nodes = json.nodes.map((n2) => fromJSON(n2, inputs));
        }
        if (defaults2.source) {
          let { inputId, ...source } = defaults2.source;
          defaults2.source = source;
          if (inputId != null) {
            defaults2.source.input = inputs[inputId];
          }
        }
        if (defaults2.type === "root") {
          return new Root(defaults2);
        } else if (defaults2.type === "decl") {
          return new Declaration(defaults2);
        } else if (defaults2.type === "rule") {
          return new Rule(defaults2);
        } else if (defaults2.type === "comment") {
          return new Comment(defaults2);
        } else if (defaults2.type === "atrule") {
          return new AtRule(defaults2);
        } else {
          throw new Error("Unknown node type: " + json.type);
        }
      }
      module2.exports = fromJSON;
      fromJSON.default = fromJSON;
    }
  });

  // node_modules/postcss/lib/postcss.js
  var require_postcss = __commonJS({
    "node_modules/postcss/lib/postcss.js"(exports2, module2) {
      "use strict";
      var CssSyntaxError = require_css_syntax_error();
      var Declaration = require_declaration();
      var LazyResult = require_lazy_result();
      var Container = require_container();
      var Processor = require_processor();
      var stringify = require_stringify2();
      var fromJSON = require_fromJSON();
      var Document = require_document();
      var Warning = require_warning();
      var Comment = require_comment();
      var AtRule = require_at_rule();
      var Result = require_result();
      var Input = require_input();
      var parse2 = require_parse();
      var list = require_list();
      var Rule = require_rule();
      var Root = require_root();
      var Node2 = require_node2();
      function postcss(...plugins) {
        if (plugins.length === 1 && Array.isArray(plugins[0])) {
          plugins = plugins[0];
        }
        return new Processor(plugins);
      }
      postcss.plugin = function plugin(name, initializer) {
        let warningPrinted = false;
        function creator(...args) {
          if (console && console.warn && !warningPrinted) {
            warningPrinted = true;
            console.warn(
              name + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
            );
            if (process.env.LANG && process.env.LANG.startsWith("cn")) {
              console.warn(
                name + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
              );
            }
          }
          let transformer = initializer(...args);
          transformer.postcssPlugin = name;
          transformer.postcssVersion = new Processor().version;
          return transformer;
        }
        let cache;
        Object.defineProperty(creator, "postcss", {
          get() {
            if (!cache)
              cache = creator();
            return cache;
          }
        });
        creator.process = function(css2, processOpts, pluginOpts) {
          return postcss([creator(pluginOpts)]).process(css2, processOpts);
        };
        return creator;
      };
      postcss.stringify = stringify;
      postcss.parse = parse2;
      postcss.fromJSON = fromJSON;
      postcss.list = list;
      postcss.comment = (defaults2) => new Comment(defaults2);
      postcss.atRule = (defaults2) => new AtRule(defaults2);
      postcss.decl = (defaults2) => new Declaration(defaults2);
      postcss.rule = (defaults2) => new Rule(defaults2);
      postcss.root = (defaults2) => new Root(defaults2);
      postcss.document = (defaults2) => new Document(defaults2);
      postcss.CssSyntaxError = CssSyntaxError;
      postcss.Declaration = Declaration;
      postcss.Container = Container;
      postcss.Processor = Processor;
      postcss.Document = Document;
      postcss.Comment = Comment;
      postcss.Warning = Warning;
      postcss.AtRule = AtRule;
      postcss.Result = Result;
      postcss.Input = Input;
      postcss.Rule = Rule;
      postcss.Root = Root;
      postcss.Node = Node2;
      LazyResult.registerPostcss(postcss);
      module2.exports = postcss;
      postcss.default = postcss;
    }
  });

  // node_modules/sanitize-html/index.js
  var require_sanitize_html = __commonJS({
    "node_modules/sanitize-html/index.js"(exports2, module2) {
      var htmlparser = require_lib6();
      var escapeStringRegexp = require_escape_string_regexp();
      var { isPlainObject: isPlainObject2 } = require_is_plain_object();
      var deepmerge = require_cjs();
      var parseSrcset = require_parse_srcset();
      var { parse: postcssParse } = require_postcss();
      var mediaTags = [
        "img",
        "audio",
        "video",
        "picture",
        "svg",
        "object",
        "map",
        "iframe",
        "embed"
      ];
      var vulnerableTags = ["script", "style"];
      function each(obj, cb) {
        if (obj) {
          Object.keys(obj).forEach(function(key) {
            cb(obj[key], key);
          });
        }
      }
      function has(obj, key) {
        return {}.hasOwnProperty.call(obj, key);
      }
      function filter(a2, cb) {
        const n2 = [];
        each(a2, function(v2) {
          if (cb(v2)) {
            n2.push(v2);
          }
        });
        return n2;
      }
      function isEmptyObject(obj) {
        for (const key in obj) {
          if (has(obj, key)) {
            return false;
          }
        }
        return true;
      }
      function stringifySrcset(parsedSrcset) {
        return parsedSrcset.map(function(part) {
          if (!part.url) {
            throw new Error("URL missing");
          }
          return part.url + (part.w ? ` ${part.w}w` : "") + (part.h ? ` ${part.h}h` : "") + (part.d ? ` ${part.d}x` : "");
        }).join(", ");
      }
      module2.exports = sanitizeHtml;
      var VALID_HTML_ATTRIBUTE_NAME = /^[^\0\t\n\f\r /<=>]+$/;
      function sanitizeHtml(html, options, _recursing) {
        if (html == null) {
          return "";
        }
        if (typeof html === "number") {
          html = html.toString();
        }
        let result = "";
        let tempResult = "";
        function Frame(tag, attribs) {
          const that = this;
          this.tag = tag;
          this.attribs = attribs || {};
          this.tagPosition = result.length;
          this.text = "";
          this.mediaChildren = [];
          this.updateParentNodeText = function() {
            if (stack.length) {
              const parentFrame = stack[stack.length - 1];
              parentFrame.text += that.text;
            }
          };
          this.updateParentNodeMediaChildren = function() {
            if (stack.length && mediaTags.includes(this.tag)) {
              const parentFrame = stack[stack.length - 1];
              parentFrame.mediaChildren.push(this.tag);
            }
          };
        }
        options = Object.assign({}, sanitizeHtml.defaults, options);
        options.parser = Object.assign({}, htmlParserDefaults, options.parser);
        const tagAllowed = function(name) {
          return options.allowedTags === false || (options.allowedTags || []).indexOf(name) > -1;
        };
        vulnerableTags.forEach(function(tag) {
          if (tagAllowed(tag) && !options.allowVulnerableTags) {
            console.warn(`

\u26A0\uFE0F Your \`allowedTags\` option includes, \`${tag}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
          }
        });
        const nonTextTagsArray = options.nonTextTags || [
          "script",
          "style",
          "textarea",
          "option"
        ];
        let allowedAttributesMap;
        let allowedAttributesGlobMap;
        if (options.allowedAttributes) {
          allowedAttributesMap = {};
          allowedAttributesGlobMap = {};
          each(options.allowedAttributes, function(attributes, tag) {
            allowedAttributesMap[tag] = [];
            const globRegex = [];
            attributes.forEach(function(obj) {
              if (typeof obj === "string" && obj.indexOf("*") >= 0) {
                globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
              } else {
                allowedAttributesMap[tag].push(obj);
              }
            });
            if (globRegex.length) {
              allowedAttributesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
            }
          });
        }
        const allowedClassesMap = {};
        const allowedClassesGlobMap = {};
        const allowedClassesRegexMap = {};
        each(options.allowedClasses, function(classes, tag) {
          if (allowedAttributesMap) {
            if (!has(allowedAttributesMap, tag)) {
              allowedAttributesMap[tag] = [];
            }
            allowedAttributesMap[tag].push("class");
          }
          allowedClassesMap[tag] = classes;
          if (Array.isArray(classes)) {
            const globRegex = [];
            allowedClassesMap[tag] = [];
            allowedClassesRegexMap[tag] = [];
            classes.forEach(function(obj) {
              if (typeof obj === "string" && obj.indexOf("*") >= 0) {
                globRegex.push(escapeStringRegexp(obj).replace(/\\\*/g, ".*"));
              } else if (obj instanceof RegExp) {
                allowedClassesRegexMap[tag].push(obj);
              } else {
                allowedClassesMap[tag].push(obj);
              }
            });
            if (globRegex.length) {
              allowedClassesGlobMap[tag] = new RegExp("^(" + globRegex.join("|") + ")$");
            }
          }
        });
        const transformTagsMap = {};
        let transformTagsAll;
        each(options.transformTags, function(transform, tag) {
          let transFun;
          if (typeof transform === "function") {
            transFun = transform;
          } else if (typeof transform === "string") {
            transFun = sanitizeHtml.simpleTransform(transform);
          }
          if (tag === "*") {
            transformTagsAll = transFun;
          } else {
            transformTagsMap[tag] = transFun;
          }
        });
        let depth;
        let stack;
        let skipMap;
        let transformMap;
        let skipText;
        let skipTextDepth;
        let addedText = false;
        initializeState();
        const parser = new htmlparser.Parser({
          onopentag: function(name, attribs) {
            if (options.enforceHtmlBoundary && name === "html") {
              initializeState();
            }
            if (skipText) {
              skipTextDepth++;
              return;
            }
            const frame = new Frame(name, attribs);
            stack.push(frame);
            let skip = false;
            const hasText = !!frame.text;
            let transformedTag;
            if (has(transformTagsMap, name)) {
              transformedTag = transformTagsMap[name](name, attribs);
              frame.attribs = attribs = transformedTag.attribs;
              if (transformedTag.text !== void 0) {
                frame.innerText = transformedTag.text;
              }
              if (name !== transformedTag.tagName) {
                frame.name = name = transformedTag.tagName;
                transformMap[depth] = transformedTag.tagName;
              }
            }
            if (transformTagsAll) {
              transformedTag = transformTagsAll(name, attribs);
              frame.attribs = attribs = transformedTag.attribs;
              if (name !== transformedTag.tagName) {
                frame.name = name = transformedTag.tagName;
                transformMap[depth] = transformedTag.tagName;
              }
            }
            if (!tagAllowed(name) || options.disallowedTagsMode === "recursiveEscape" && !isEmptyObject(skipMap) || options.nestingLimit != null && depth >= options.nestingLimit) {
              skip = true;
              skipMap[depth] = true;
              if (options.disallowedTagsMode === "discard") {
                if (nonTextTagsArray.indexOf(name) !== -1) {
                  skipText = true;
                  skipTextDepth = 1;
                }
              }
              skipMap[depth] = true;
            }
            depth++;
            if (skip) {
              if (options.disallowedTagsMode === "discard") {
                return;
              }
              tempResult = result;
              result = "";
            }
            result += "<" + name;
            if (name === "script") {
              if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                frame.innerText = "";
              }
            }
            if (!allowedAttributesMap || has(allowedAttributesMap, name) || allowedAttributesMap["*"]) {
              each(attribs, function(value, a2) {
                if (!VALID_HTML_ATTRIBUTE_NAME.test(a2)) {
                  delete frame.attribs[a2];
                  return;
                }
                if (value === "" && (options.nonBooleanAttributes.includes(a2) || options.nonBooleanAttributes.includes("*"))) {
                  delete frame.attribs[a2];
                  return;
                }
                let passedAllowedAttributesMapCheck = false;
                if (!allowedAttributesMap || has(allowedAttributesMap, name) && allowedAttributesMap[name].indexOf(a2) !== -1 || allowedAttributesMap["*"] && allowedAttributesMap["*"].indexOf(a2) !== -1 || has(allowedAttributesGlobMap, name) && allowedAttributesGlobMap[name].test(a2) || allowedAttributesGlobMap["*"] && allowedAttributesGlobMap["*"].test(a2)) {
                  passedAllowedAttributesMapCheck = true;
                } else if (allowedAttributesMap && allowedAttributesMap[name]) {
                  for (const o2 of allowedAttributesMap[name]) {
                    if (isPlainObject2(o2) && o2.name && o2.name === a2) {
                      passedAllowedAttributesMapCheck = true;
                      let newValue = "";
                      if (o2.multiple === true) {
                        const splitStrArray = value.split(" ");
                        for (const s2 of splitStrArray) {
                          if (o2.values.indexOf(s2) !== -1) {
                            if (newValue === "") {
                              newValue = s2;
                            } else {
                              newValue += " " + s2;
                            }
                          }
                        }
                      } else if (o2.values.indexOf(value) >= 0) {
                        newValue = value;
                      }
                      value = newValue;
                    }
                  }
                }
                if (passedAllowedAttributesMapCheck) {
                  if (options.allowedSchemesAppliedToAttributes.indexOf(a2) !== -1) {
                    if (naughtyHref(name, value)) {
                      delete frame.attribs[a2];
                      return;
                    }
                  }
                  if (name === "script" && a2 === "src") {
                    let allowed = true;
                    try {
                      const parsed = parseUrl(value);
                      if (options.allowedScriptHostnames || options.allowedScriptDomains) {
                        const allowedHostname = (options.allowedScriptHostnames || []).find(function(hostname) {
                          return hostname === parsed.url.hostname;
                        });
                        const allowedDomain = (options.allowedScriptDomains || []).find(function(domain) {
                          return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                        });
                        allowed = allowedHostname || allowedDomain;
                      }
                    } catch (e3) {
                      allowed = false;
                    }
                    if (!allowed) {
                      delete frame.attribs[a2];
                      return;
                    }
                  }
                  if (name === "iframe" && a2 === "src") {
                    let allowed = true;
                    try {
                      const parsed = parseUrl(value);
                      if (parsed.isRelativeUrl) {
                        allowed = has(options, "allowIframeRelativeUrls") ? options.allowIframeRelativeUrls : !options.allowedIframeHostnames && !options.allowedIframeDomains;
                      } else if (options.allowedIframeHostnames || options.allowedIframeDomains) {
                        const allowedHostname = (options.allowedIframeHostnames || []).find(function(hostname) {
                          return hostname === parsed.url.hostname;
                        });
                        const allowedDomain = (options.allowedIframeDomains || []).find(function(domain) {
                          return parsed.url.hostname === domain || parsed.url.hostname.endsWith(`.${domain}`);
                        });
                        allowed = allowedHostname || allowedDomain;
                      }
                    } catch (e3) {
                      allowed = false;
                    }
                    if (!allowed) {
                      delete frame.attribs[a2];
                      return;
                    }
                  }
                  if (a2 === "srcset") {
                    try {
                      let parsed = parseSrcset(value);
                      parsed.forEach(function(value2) {
                        if (naughtyHref("srcset", value2.url)) {
                          value2.evil = true;
                        }
                      });
                      parsed = filter(parsed, function(v2) {
                        return !v2.evil;
                      });
                      if (!parsed.length) {
                        delete frame.attribs[a2];
                        return;
                      } else {
                        value = stringifySrcset(filter(parsed, function(v2) {
                          return !v2.evil;
                        }));
                        frame.attribs[a2] = value;
                      }
                    } catch (e3) {
                      delete frame.attribs[a2];
                      return;
                    }
                  }
                  if (a2 === "class") {
                    const allowedSpecificClasses = allowedClassesMap[name];
                    const allowedWildcardClasses = allowedClassesMap["*"];
                    const allowedSpecificClassesGlob = allowedClassesGlobMap[name];
                    const allowedSpecificClassesRegex = allowedClassesRegexMap[name];
                    const allowedWildcardClassesGlob = allowedClassesGlobMap["*"];
                    const allowedClassesGlobs = [
                      allowedSpecificClassesGlob,
                      allowedWildcardClassesGlob
                    ].concat(allowedSpecificClassesRegex).filter(function(t2) {
                      return t2;
                    });
                    if (allowedSpecificClasses && allowedWildcardClasses) {
                      value = filterClasses(value, deepmerge(allowedSpecificClasses, allowedWildcardClasses), allowedClassesGlobs);
                    } else {
                      value = filterClasses(value, allowedSpecificClasses || allowedWildcardClasses, allowedClassesGlobs);
                    }
                    if (!value.length) {
                      delete frame.attribs[a2];
                      return;
                    }
                  }
                  if (a2 === "style") {
                    if (options.parseStyleAttributes) {
                      try {
                        const abstractSyntaxTree = postcssParse(name + " {" + value + "}");
                        const filteredAST = filterCss(abstractSyntaxTree, options.allowedStyles);
                        value = stringifyStyleAttributes(filteredAST);
                        if (value.length === 0) {
                          delete frame.attribs[a2];
                          return;
                        }
                      } catch (e3) {
                        if (typeof window !== "undefined") {
                          console.warn('Failed to parse "' + name + " {" + value + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`);
                        }
                        delete frame.attribs[a2];
                        return;
                      }
                    } else if (options.allowedStyles) {
                      throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
                    }
                  }
                  result += " " + a2;
                  if (value && value.length) {
                    result += '="' + escapeHtml(value, true) + '"';
                  }
                } else {
                  delete frame.attribs[a2];
                }
              });
            }
            if (options.selfClosing.indexOf(name) !== -1) {
              result += " />";
            } else {
              result += ">";
              if (frame.innerText && !hasText && !options.textFilter) {
                result += escapeHtml(frame.innerText);
                addedText = true;
              }
            }
            if (skip) {
              result = tempResult + escapeHtml(result);
              tempResult = "";
            }
          },
          ontext: function(text) {
            if (skipText) {
              return;
            }
            const lastFrame = stack[stack.length - 1];
            let tag;
            if (lastFrame) {
              tag = lastFrame.tag;
              text = lastFrame.innerText !== void 0 ? lastFrame.innerText : text;
            }
            if (options.disallowedTagsMode === "discard" && (tag === "script" || tag === "style")) {
              result += text;
            } else {
              const escaped = escapeHtml(text, false);
              if (options.textFilter && !addedText) {
                result += options.textFilter(escaped, tag);
              } else if (!addedText) {
                result += escaped;
              }
            }
            if (stack.length) {
              const frame = stack[stack.length - 1];
              frame.text += text;
            }
          },
          onclosetag: function(name, isImplied) {
            if (skipText) {
              skipTextDepth--;
              if (!skipTextDepth) {
                skipText = false;
              } else {
                return;
              }
            }
            const frame = stack.pop();
            if (!frame) {
              return;
            }
            if (frame.tag !== name) {
              stack.push(frame);
              return;
            }
            skipText = options.enforceHtmlBoundary ? name === "html" : false;
            depth--;
            const skip = skipMap[depth];
            if (skip) {
              delete skipMap[depth];
              if (options.disallowedTagsMode === "discard") {
                frame.updateParentNodeText();
                return;
              }
              tempResult = result;
              result = "";
            }
            if (transformMap[depth]) {
              name = transformMap[depth];
              delete transformMap[depth];
            }
            if (options.exclusiveFilter && options.exclusiveFilter(frame)) {
              result = result.substr(0, frame.tagPosition);
              return;
            }
            frame.updateParentNodeMediaChildren();
            frame.updateParentNodeText();
            if (options.selfClosing.indexOf(name) !== -1 || isImplied && !tagAllowed(name) && ["escape", "recursiveEscape"].indexOf(options.disallowedTagsMode) >= 0) {
              if (skip) {
                result = tempResult;
                tempResult = "";
              }
              return;
            }
            result += "</" + name + ">";
            if (skip) {
              result = tempResult + escapeHtml(result);
              tempResult = "";
            }
            addedText = false;
          }
        }, options.parser);
        parser.write(html);
        parser.end();
        return result;
        function initializeState() {
          result = "";
          depth = 0;
          stack = [];
          skipMap = {};
          transformMap = {};
          skipText = false;
          skipTextDepth = 0;
        }
        function escapeHtml(s2, quote) {
          if (typeof s2 !== "string") {
            s2 = s2 + "";
          }
          if (options.parser.decodeEntities) {
            s2 = s2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            if (quote) {
              s2 = s2.replace(/"/g, "&quot;");
            }
          }
          s2 = s2.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          if (quote) {
            s2 = s2.replace(/"/g, "&quot;");
          }
          return s2;
        }
        function naughtyHref(name, href) {
          href = href.replace(/[\x00-\x20]+/g, "");
          while (true) {
            const firstIndex = href.indexOf("<!--");
            if (firstIndex === -1) {
              break;
            }
            const lastIndex = href.indexOf("-->", firstIndex + 4);
            if (lastIndex === -1) {
              break;
            }
            href = href.substring(0, firstIndex) + href.substring(lastIndex + 3);
          }
          const matches = href.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
          if (!matches) {
            if (href.match(/^[/\\]{2}/)) {
              return !options.allowProtocolRelative;
            }
            return false;
          }
          const scheme = matches[1].toLowerCase();
          if (has(options.allowedSchemesByTag, name)) {
            return options.allowedSchemesByTag[name].indexOf(scheme) === -1;
          }
          return !options.allowedSchemes || options.allowedSchemes.indexOf(scheme) === -1;
        }
        function parseUrl(value) {
          value = value.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//");
          if (value.startsWith("relative:")) {
            throw new Error("relative: exploit attempt");
          }
          let base = "relative://relative-site";
          for (let i2 = 0; i2 < 100; i2++) {
            base += `/${i2}`;
          }
          const parsed = new URL(value, base);
          const isRelativeUrl = parsed && parsed.hostname === "relative-site" && parsed.protocol === "relative:";
          return {
            isRelativeUrl,
            url: parsed
          };
        }
        function filterCss(abstractSyntaxTree, allowedStyles) {
          if (!allowedStyles) {
            return abstractSyntaxTree;
          }
          const astRules = abstractSyntaxTree.nodes[0];
          let selectedRule;
          if (allowedStyles[astRules.selector] && allowedStyles["*"]) {
            selectedRule = deepmerge(
              allowedStyles[astRules.selector],
              allowedStyles["*"]
            );
          } else {
            selectedRule = allowedStyles[astRules.selector] || allowedStyles["*"];
          }
          if (selectedRule) {
            abstractSyntaxTree.nodes[0].nodes = astRules.nodes.reduce(filterDeclarations(selectedRule), []);
          }
          return abstractSyntaxTree;
        }
        function stringifyStyleAttributes(filteredAST) {
          return filteredAST.nodes[0].nodes.reduce(function(extractedAttributes, attrObject) {
            extractedAttributes.push(
              `${attrObject.prop}:${attrObject.value}${attrObject.important ? " !important" : ""}`
            );
            return extractedAttributes;
          }, []).join(";");
        }
        function filterDeclarations(selectedRule) {
          return function(allowedDeclarationsList, attributeObject) {
            if (has(selectedRule, attributeObject.prop)) {
              const matchesRegex = selectedRule[attributeObject.prop].some(function(regularExpression) {
                return regularExpression.test(attributeObject.value);
              });
              if (matchesRegex) {
                allowedDeclarationsList.push(attributeObject);
              }
            }
            return allowedDeclarationsList;
          };
        }
        function filterClasses(classes, allowed, allowedGlobs) {
          if (!allowed) {
            return classes;
          }
          classes = classes.split(/\s+/);
          return classes.filter(function(clss) {
            return allowed.indexOf(clss) !== -1 || allowedGlobs.some(function(glob) {
              return glob.test(clss);
            });
          }).join(" ");
        }
      }
      var htmlParserDefaults = {
        decodeEntities: true
      };
      sanitizeHtml.defaults = {
        allowedTags: [
          "address",
          "article",
          "aside",
          "footer",
          "header",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "hgroup",
          "main",
          "nav",
          "section",
          "blockquote",
          "dd",
          "div",
          "dl",
          "dt",
          "figcaption",
          "figure",
          "hr",
          "li",
          "main",
          "ol",
          "p",
          "pre",
          "ul",
          "a",
          "abbr",
          "b",
          "bdi",
          "bdo",
          "br",
          "cite",
          "code",
          "data",
          "dfn",
          "em",
          "i",
          "kbd",
          "mark",
          "q",
          "rb",
          "rp",
          "rt",
          "rtc",
          "ruby",
          "s",
          "samp",
          "small",
          "span",
          "strong",
          "sub",
          "sup",
          "time",
          "u",
          "var",
          "wbr",
          "caption",
          "col",
          "colgroup",
          "table",
          "tbody",
          "td",
          "tfoot",
          "th",
          "thead",
          "tr"
        ],
        nonBooleanAttributes: [
          "abbr",
          "accept",
          "accept-charset",
          "accesskey",
          "action",
          "allow",
          "alt",
          "as",
          "autocapitalize",
          "autocomplete",
          "blocking",
          "charset",
          "cite",
          "class",
          "color",
          "cols",
          "colspan",
          "content",
          "contenteditable",
          "coords",
          "crossorigin",
          "data",
          "datetime",
          "decoding",
          "dir",
          "dirname",
          "download",
          "draggable",
          "enctype",
          "enterkeyhint",
          "fetchpriority",
          "for",
          "form",
          "formaction",
          "formenctype",
          "formmethod",
          "formtarget",
          "headers",
          "height",
          "hidden",
          "high",
          "href",
          "hreflang",
          "http-equiv",
          "id",
          "imagesizes",
          "imagesrcset",
          "inputmode",
          "integrity",
          "is",
          "itemid",
          "itemprop",
          "itemref",
          "itemtype",
          "kind",
          "label",
          "lang",
          "list",
          "loading",
          "low",
          "max",
          "maxlength",
          "media",
          "method",
          "min",
          "minlength",
          "name",
          "nonce",
          "optimum",
          "pattern",
          "ping",
          "placeholder",
          "popover",
          "popovertarget",
          "popovertargetaction",
          "poster",
          "preload",
          "referrerpolicy",
          "rel",
          "rows",
          "rowspan",
          "sandbox",
          "scope",
          "shape",
          "size",
          "sizes",
          "slot",
          "span",
          "spellcheck",
          "src",
          "srcdoc",
          "srclang",
          "srcset",
          "start",
          "step",
          "style",
          "tabindex",
          "target",
          "title",
          "translate",
          "type",
          "usemap",
          "value",
          "width",
          "wrap",
          "onauxclick",
          "onafterprint",
          "onbeforematch",
          "onbeforeprint",
          "onbeforeunload",
          "onbeforetoggle",
          "onblur",
          "oncancel",
          "oncanplay",
          "oncanplaythrough",
          "onchange",
          "onclick",
          "onclose",
          "oncontextlost",
          "oncontextmenu",
          "oncontextrestored",
          "oncopy",
          "oncuechange",
          "oncut",
          "ondblclick",
          "ondrag",
          "ondragend",
          "ondragenter",
          "ondragleave",
          "ondragover",
          "ondragstart",
          "ondrop",
          "ondurationchange",
          "onemptied",
          "onended",
          "onerror",
          "onfocus",
          "onformdata",
          "onhashchange",
          "oninput",
          "oninvalid",
          "onkeydown",
          "onkeypress",
          "onkeyup",
          "onlanguagechange",
          "onload",
          "onloadeddata",
          "onloadedmetadata",
          "onloadstart",
          "onmessage",
          "onmessageerror",
          "onmousedown",
          "onmouseenter",
          "onmouseleave",
          "onmousemove",
          "onmouseout",
          "onmouseover",
          "onmouseup",
          "onoffline",
          "ononline",
          "onpagehide",
          "onpageshow",
          "onpaste",
          "onpause",
          "onplay",
          "onplaying",
          "onpopstate",
          "onprogress",
          "onratechange",
          "onreset",
          "onresize",
          "onrejectionhandled",
          "onscroll",
          "onscrollend",
          "onsecuritypolicyviolation",
          "onseeked",
          "onseeking",
          "onselect",
          "onslotchange",
          "onstalled",
          "onstorage",
          "onsubmit",
          "onsuspend",
          "ontimeupdate",
          "ontoggle",
          "onunhandledrejection",
          "onunload",
          "onvolumechange",
          "onwaiting",
          "onwheel"
        ],
        disallowedTagsMode: "discard",
        allowedAttributes: {
          a: ["href", "name", "target"],
          img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
        },
        selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
        allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
        allowedSchemesByTag: {},
        allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
        allowProtocolRelative: true,
        enforceHtmlBoundary: false,
        parseStyleAttributes: true
      };
      sanitizeHtml.simpleTransform = function(newTagName, newAttribs, merge2) {
        merge2 = merge2 === void 0 ? true : merge2;
        newAttribs = newAttribs || {};
        return function(tagName, attribs) {
          let attrib;
          if (merge2) {
            for (attrib in newAttribs) {
              attribs[attrib] = newAttribs[attrib];
            }
          } else {
            attribs = newAttribs;
          }
          return {
            tagName: newTagName,
            attribs
          };
        };
      };
    }
  });

  // node_modules/node-webvtt/lib/parser.js
  var require_parser2 = __commonJS({
    "node_modules/node-webvtt/lib/parser.js"(exports2, module2) {
      "use strict";
      function ParserError(message, error) {
        this.message = message;
        this.error = error;
      }
      ParserError.prototype = Object.create(Error.prototype);
      var TIMESTAMP_REGEXP = /([0-9]+)?:?([0-9]{2}):([0-9]{2}\.[0-9]{2,3})/;
      function parse2(input, options) {
        if (!options) {
          options = {};
        }
        const { meta = false, strict = true } = options;
        if (typeof input !== "string") {
          throw new ParserError("Input must be a string");
        }
        input = input.trim();
        input = input.replace(/\r\n/g, "\n");
        input = input.replace(/\r/g, "\n");
        const parts = input.split("\n\n");
        const header = parts.shift();
        if (!header.startsWith("WEBVTT")) {
          throw new ParserError('Must start with "WEBVTT"');
        }
        const headerParts = header.split("\n");
        const headerComments = headerParts[0].replace("WEBVTT", "");
        if (headerComments.length > 0 && (headerComments[0] !== " " && headerComments[0] !== "	")) {
          throw new ParserError("Header comment must start with space or tab");
        }
        if (parts.length === 0 && headerParts.length === 1) {
          return { valid: true, strict, cues: [], errors: [] };
        }
        if (!meta && headerParts.length > 1 && headerParts[1] !== "") {
          throw new ParserError("Missing blank line after signature");
        }
        const { cues, errors } = parseCues(parts, strict);
        if (strict && errors.length > 0) {
          throw errors[0];
        }
        const headerMeta = meta ? parseMeta(headerParts) : null;
        const result = { valid: errors.length === 0, strict, cues, errors };
        if (meta) {
          result.meta = headerMeta;
        }
        return result;
      }
      function parseMeta(headerParts) {
        const meta = {};
        headerParts.slice(1).forEach((header) => {
          const splitIdx = header.indexOf(":");
          const key = header.slice(0, splitIdx).trim();
          const value = header.slice(splitIdx + 1).trim();
          meta[key] = value;
        });
        return Object.keys(meta).length > 0 ? meta : null;
      }
      function parseCues(cues, strict) {
        const errors = [];
        const parsedCues = cues.map((cue, i2) => {
          try {
            return parseCue2(cue, i2, strict);
          } catch (e3) {
            errors.push(e3);
            return null;
          }
        }).filter(Boolean);
        return {
          cues: parsedCues,
          errors
        };
      }
      function parseCue2(cue, i2, strict) {
        let identifier = "";
        let start = 0;
        let end = 0.01;
        let text = "";
        let styles = "";
        const lines = cue.split("\n").filter(Boolean);
        if (lines.length > 0 && lines[0].trim().startsWith("NOTE")) {
          return null;
        }
        if (lines.length === 1 && !lines[0].includes("-->")) {
          throw new ParserError(`Cue identifier cannot be standalone (cue #${i2})`);
        }
        if (lines.length > 1 && !(lines[0].includes("-->") || lines[1].includes("-->"))) {
          const msg = `Cue identifier needs to be followed by timestamp (cue #${i2})`;
          throw new ParserError(msg);
        }
        if (lines.length > 1 && lines[1].includes("-->")) {
          identifier = lines.shift();
        }
        const times = typeof lines[0] === "string" && lines[0].split(" --> ");
        if (times.length !== 2 || !validTimestamp(times[0]) || !validTimestamp(times[1])) {
          throw new ParserError(`Invalid cue timestamp (cue #${i2})`);
        }
        start = parseTimestamp(times[0]);
        end = parseTimestamp(times[1]);
        if (strict) {
          if (start > end) {
            throw new ParserError(`Start timestamp greater than end (cue #${i2})`);
          }
          if (end <= start) {
            throw new ParserError(`End must be greater than start (cue #${i2})`);
          }
        }
        if (!strict && end < start) {
          throw new ParserError(
            `End must be greater or equal to start when not strict (cue #${i2})`
          );
        }
        styles = times[1].replace(TIMESTAMP_REGEXP, "").trim();
        lines.shift();
        text = lines.join("\n");
        if (!text) {
          return false;
        }
        return { identifier, start, end, text, styles };
      }
      function validTimestamp(timestamp) {
        return TIMESTAMP_REGEXP.test(timestamp);
      }
      function parseTimestamp(timestamp) {
        const matches = timestamp.match(TIMESTAMP_REGEXP);
        let secs = parseFloat(matches[1] || 0) * 60 * 60;
        secs += parseFloat(matches[2]) * 60;
        secs += parseFloat(matches[3]);
        return secs;
      }
      module2.exports = { ParserError, parse: parse2 };
    }
  });

  // node_modules/node-webvtt/lib/compiler.js
  var require_compiler = __commonJS({
    "node_modules/node-webvtt/lib/compiler.js"(exports2, module2) {
      "use strict";
      function CompilerError(message, error) {
        this.message = message;
        this.error = error;
      }
      CompilerError.prototype = Object.create(Error.prototype);
      function compile(input) {
        if (!input) {
          throw new CompilerError("Input must be non-null");
        }
        if (typeof input !== "object") {
          throw new CompilerError("Input must be an object");
        }
        if (Array.isArray(input)) {
          throw new CompilerError("Input cannot be array");
        }
        if (!input.valid) {
          throw new CompilerError("Input must be valid");
        }
        let output = "WEBVTT\n";
        if (input.meta) {
          if (typeof input.meta !== "object" || Array.isArray(input.meta)) {
            throw new CompilerError("Metadata must be an object");
          }
          Object.entries(input.meta).forEach((i2) => {
            if (typeof i2[1] !== "string") {
              throw new CompilerError(`Metadata value for "${i2[0]}" must be string`);
            }
            output += `${i2[0]}: ${i2[1]}
`;
          });
        }
        let lastTime = null;
        input.cues.forEach((cue, index2) => {
          if (lastTime && lastTime > cue.start) {
            throw new CompilerError(`Cue number ${index2} is not in chronological order`);
          }
          lastTime = cue.start;
          output += "\n";
          output += compileCue(cue);
          output += "\n";
        });
        return output;
      }
      function compileCue(cue) {
        if (typeof cue !== "object") {
          throw new CompilerError("Cue malformed: not of type object");
        }
        if (typeof cue.identifier !== "string" && typeof cue.identifier !== "number" && cue.identifier !== null) {
          throw new CompilerError(`Cue malformed: identifier value is not a string.
    ${JSON.stringify(cue)}`);
        }
        if (isNaN(cue.start)) {
          throw new CompilerError(`Cue malformed: null start value.
    ${JSON.stringify(cue)}`);
        }
        if (isNaN(cue.end)) {
          throw new CompilerError(`Cue malformed: null end value.
    ${JSON.stringify(cue)}`);
        }
        if (cue.start >= cue.end) {
          throw new CompilerError(`Cue malformed: start timestamp greater than end
    ${JSON.stringify(cue)}`);
        }
        if (typeof cue.text !== "string") {
          throw new CompilerError(`Cue malformed: null text value.
    ${JSON.stringify(cue)}`);
        }
        if (typeof cue.styles !== "string") {
          throw new CompilerError(`Cue malformed: null styles value.
    ${JSON.stringify(cue)}`);
        }
        let output = "";
        if (cue.identifier.length > 0) {
          output += `${cue.identifier}
`;
        }
        const startTimestamp = convertTimestamp(cue.start);
        const endTimestamp = convertTimestamp(cue.end);
        output += `${startTimestamp} --> ${endTimestamp}`;
        output += cue.styles ? ` ${cue.styles}` : "";
        output += `
${cue.text}`;
        return output;
      }
      function convertTimestamp(time) {
        const hours = pad(calculateHours(time), 2);
        const minutes = pad(calculateMinutes(time), 2);
        const seconds = pad(calculateSeconds(time), 2);
        const milliseconds = pad(calculateMs(time), 3);
        return `${hours}:${minutes}:${seconds}.${milliseconds}`;
      }
      function pad(num, zeroes) {
        let output = `${num}`;
        while (output.length < zeroes) {
          output = `0${output}`;
        }
        return output;
      }
      function calculateHours(time) {
        return Math.floor(time / 60 / 60);
      }
      function calculateMinutes(time) {
        return Math.floor(time / 60) % 60;
      }
      function calculateSeconds(time) {
        return Math.floor(time % 60);
      }
      function calculateMs(time) {
        return Math.floor((time % 1).toFixed(4) * 1e3);
      }
      module2.exports = { CompilerError, compile };
    }
  });

  // node_modules/node-webvtt/lib/segmenter.js
  var require_segmenter = __commonJS({
    "node_modules/node-webvtt/lib/segmenter.js"(exports2, module2) {
      "use strict";
      var parse2 = require_parser2().parse;
      function segment(input, segmentLength) {
        segmentLength = segmentLength || 10;
        const parsed = parse2(input);
        const segments = [];
        let cues = [];
        let queuedCue = null;
        let currentSegmentDuration = 0;
        let totalSegmentsDuration = 0;
        parsed.cues.forEach((cue, i2) => {
          const firstCue = i2 === 0;
          const lastCue = i2 === parsed.cues.length - 1;
          const start = cue.start;
          const end = cue.end;
          const nextStart = lastCue ? Infinity : parsed.cues[i2 + 1].start;
          const cueLength = firstCue ? end : end - start;
          const silence = firstCue ? 0 : start - parsed.cues[i2 - 1].end;
          currentSegmentDuration = currentSegmentDuration + cueLength + silence;
          debug("------------");
          debug(`Cue #${i2}, segment #${segments.length + 1}`);
          debug(`Start ${start}`);
          debug(`End ${end}`);
          debug(`Length ${cueLength}`);
          debug(`Total segment duration = ${totalSegmentsDuration}`);
          debug(`Current segment duration = ${currentSegmentDuration}`);
          debug(`Start of next = ${nextStart}`);
          if (queuedCue) {
            cues.push(queuedCue);
            currentSegmentDuration += queuedCue.end - totalSegmentsDuration;
            queuedCue = null;
          }
          cues.push(cue);
          let shouldQueue = nextStart - end < segmentLength && silence < segmentLength && currentSegmentDuration > segmentLength;
          if (shouldSegment(
            totalSegmentsDuration,
            segmentLength,
            nextStart,
            silence
          )) {
            const duration = segmentDuration(
              lastCue,
              end,
              segmentLength,
              currentSegmentDuration,
              totalSegmentsDuration
            );
            segments.push({ duration, cues });
            totalSegmentsDuration += duration;
            currentSegmentDuration = 0;
            cues = [];
          } else {
            shouldQueue = false;
          }
          if (shouldQueue) {
            queuedCue = cue;
          }
        });
        return segments;
      }
      function shouldSegment(total, length, nextStart, silence) {
        const x2 = alignToSegmentLength(silence, length);
        const nextCueIsInNextSegment = silence <= length || x2 + total < nextStart;
        return nextCueIsInNextSegment && nextStart - total >= length;
      }
      function segmentDuration(lastCue, end, length, currentSegment, totalSegments) {
        let duration = length;
        if (currentSegment > length) {
          duration = alignToSegmentLength(currentSegment - length, length);
        }
        if (lastCue) {
          duration = parseFloat((end - totalSegments).toFixed(2));
        } else {
          duration = Math.round(duration);
        }
        return duration;
      }
      function alignToSegmentLength(n2, segmentLength) {
        n2 += segmentLength - n2 % segmentLength;
        return n2;
      }
      var debugging = false;
      function debug(m2) {
        if (debugging) {
          console.log(m2);
        }
      }
      module2.exports = { segment };
    }
  });

  // node_modules/node-webvtt/lib/hls.js
  var require_hls = __commonJS({
    "node_modules/node-webvtt/lib/hls.js"(exports2, module2) {
      "use strict";
      var segment = require_segmenter().segment;
      function hlsSegment(input, segmentLength, startOffset) {
        if (typeof startOffset === "undefined") {
          startOffset = "900000";
        }
        const segments = segment(input, segmentLength);
        const result = [];
        segments.forEach((seg, i2) => {
          const content = `WEBVTT
X-TIMESTAMP-MAP=MPEGTS:${startOffset},LOCAL:00:00:00.000

${printableCues(seg.cues)}
`;
          const filename = generateSegmentFilename(i2);
          result.push({ filename, content });
        });
        return result;
      }
      function hlsSegmentPlaylist(input, segmentLength) {
        const segmented = segment(input, segmentLength);
        const printable = printableSegments(segmented);
        const longestSegment = Math.round(findLongestSegment(segmented));
        const template = `#EXTM3U
#EXT-X-TARGETDURATION:${longestSegment}
#EXT-X-VERSION:3
#EXT-X-MEDIA-SEQUENCE:0
#EXT-X-PLAYLIST-TYPE:VOD
${printable}
#EXT-X-ENDLIST
`;
        return template;
      }
      function pad(num, n2) {
        const padding = "0".repeat(Math.max(0, n2 - num.toString().length));
        return `${padding}${num}`;
      }
      function generateSegmentFilename(index2) {
        return `${index2}.vtt`;
      }
      function printableSegments(segments) {
        const result = [];
        segments.forEach((seg, i2) => {
          result.push(`#EXTINF:${seg.duration.toFixed(5)},
${generateSegmentFilename(i2)}`);
        });
        return result.join("\n");
      }
      function findLongestSegment(segments) {
        let max2 = 0;
        segments.forEach((seg) => {
          if (seg.duration > max2) {
            max2 = seg.duration;
          }
        });
        return max2;
      }
      function printableCues(cues) {
        const result = [];
        cues.forEach((cue) => {
          result.push(printableCue(cue));
        });
        return result.join("\n\n");
      }
      function printableCue(cue) {
        const printable = [];
        if (cue.identifier) {
          printable.push(cue.identifier);
        }
        const start = printableTimestamp(cue.start);
        const end = printableTimestamp(cue.end);
        const styles = cue.styles ? `${cue.styles}` : "";
        printable.push(`${start} --> ${end} ${styles}`);
        printable.push(cue.text);
        return printable.join("\n");
      }
      function printableTimestamp(timestamp) {
        const ms = (timestamp % 1).toFixed(3);
        timestamp = Math.round(timestamp - ms);
        const hours = Math.floor(timestamp / 3600);
        const mins = Math.floor((timestamp - hours * 3600) / 60);
        const secs = timestamp - hours * 3600 - mins * 60;
        const hourString = `${pad(hours, 2)}:`;
        return `${hourString}${pad(mins, 2)}:${pad(secs, 2)}.${pad(ms * 1e3, 3)}`;
      }
      module2.exports = { hlsSegment, hlsSegmentPlaylist };
    }
  });

  // node_modules/node-webvtt/index.js
  var require_node_webvtt = __commonJS({
    "node_modules/node-webvtt/index.js"(exports2, module2) {
      "use strict";
      var parse2 = require_parser2().parse;
      var compile = require_compiler().compile;
      var segment = require_segmenter().segment;
      var hls = require_hls();
      module2.exports = { parse: parse2, compile, segment, hls };
    }
  });

  // node_modules/openseadragon/build/openseadragon/openseadragon.js
  var require_openseadragon = __commonJS({
    "node_modules/openseadragon/build/openseadragon/openseadragon.js"(exports, module) {
      function OpenSeadragon(options) {
        return new OpenSeadragon.Viewer(options);
      }
      (function($3) {
        $3.version = {
          versionStr: "2.4.2",
          major: parseInt("2", 10),
          minor: parseInt("4", 10),
          revision: parseInt("2", 10)
        };
        var class2type = {
          "[object Boolean]": "boolean",
          "[object Number]": "number",
          "[object String]": "string",
          "[object Function]": "function",
          "[object Array]": "array",
          "[object Date]": "date",
          "[object RegExp]": "regexp",
          "[object Object]": "object"
        }, toString = Object.prototype.toString, hasOwn = Object.prototype.hasOwnProperty;
        $3.isFunction = function(obj) {
          return $3.type(obj) === "function";
        };
        $3.isArray = Array.isArray || function(obj) {
          return $3.type(obj) === "array";
        };
        $3.isWindow = function(obj) {
          return obj && typeof obj === "object" && "setInterval" in obj;
        };
        $3.type = function(obj) {
          return obj === null || obj === void 0 ? String(obj) : class2type[toString.call(obj)] || "object";
        };
        $3.isPlainObject = function(obj) {
          if (!obj || OpenSeadragon.type(obj) !== "object" || obj.nodeType || $3.isWindow(obj)) {
            return false;
          }
          if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
            return false;
          }
          var lastKey;
          for (var key in obj) {
            lastKey = key;
          }
          return lastKey === void 0 || hasOwn.call(obj, lastKey);
        };
        $3.isEmptyObject = function(obj) {
          for (var name in obj) {
            return false;
          }
          return true;
        };
        $3.freezeObject = function(obj) {
          if (Object.freeze) {
            $3.freezeObject = Object.freeze;
          } else {
            $3.freezeObject = function(obj2) {
              return obj2;
            };
          }
          return $3.freezeObject(obj);
        };
        $3.supportsCanvas = function() {
          var canvasElement = document.createElement("canvas");
          return !!($3.isFunction(canvasElement.getContext) && canvasElement.getContext("2d"));
        }();
        $3.isCanvasTainted = function(canvas) {
          var isTainted = false;
          try {
            canvas.getContext("2d").getImageData(0, 0, 1, 1);
          } catch (e3) {
            isTainted = true;
          }
          return isTainted;
        };
        $3.pixelDensityRatio = function() {
          if ($3.supportsCanvas) {
            var context = document.createElement("canvas").getContext("2d");
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1;
            return Math.max(devicePixelRatio, 1) / backingStoreRatio;
          } else {
            return 1;
          }
        }();
      })(OpenSeadragon);
      (function($) {
        $.extend = function() {
          var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, length = arguments.length, deep = false, i2 = 1;
          if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            i2 = 2;
          }
          if (typeof target !== "object" && !OpenSeadragon.isFunction(target)) {
            target = {};
          }
          if (length === i2) {
            target = this;
            --i2;
          }
          for (; i2 < length; i2++) {
            options = arguments[i2];
            if (options !== null || options !== void 0) {
              for (name in options) {
                src = target[name];
                copy = options[name];
                if (target === copy) {
                  continue;
                }
                if (deep && copy && (OpenSeadragon.isPlainObject(copy) || (copyIsArray = OpenSeadragon.isArray(copy)))) {
                  if (copyIsArray) {
                    copyIsArray = false;
                    clone = src && OpenSeadragon.isArray(src) ? src : [];
                  } else {
                    clone = src && OpenSeadragon.isPlainObject(src) ? src : {};
                  }
                  target[name] = OpenSeadragon.extend(deep, clone, copy);
                } else if (copy !== void 0) {
                  target[name] = copy;
                }
              }
            }
          }
          return target;
        };
        var isIOSDevice = function() {
          if (typeof navigator !== "object") {
            return false;
          }
          var userAgent = navigator.userAgent;
          if (typeof userAgent !== "string") {
            return false;
          }
          return userAgent.indexOf("iPhone") !== -1 || userAgent.indexOf("iPad") !== -1 || userAgent.indexOf("iPod") !== -1;
        };
        $.extend($, {
          DEFAULT_SETTINGS: {
            xmlPath: null,
            tileSources: null,
            tileHost: null,
            initialPage: 0,
            crossOriginPolicy: false,
            ajaxWithCredentials: false,
            loadTilesWithAjax: false,
            ajaxHeaders: {},
            panHorizontal: true,
            panVertical: true,
            constrainDuringPan: false,
            wrapHorizontal: false,
            wrapVertical: false,
            visibilityRatio: 0.5,
            minPixelRatio: 0.5,
            defaultZoomLevel: 0,
            minZoomLevel: null,
            maxZoomLevel: null,
            homeFillsViewer: false,
            clickTimeThreshold: 300,
            clickDistThreshold: 5,
            dblClickTimeThreshold: 300,
            dblClickDistThreshold: 20,
            springStiffness: 6.5,
            animationTime: 1.2,
            gestureSettingsMouse: {
              scrollToZoom: true,
              clickToZoom: true,
              dblClickToZoom: false,
              pinchToZoom: false,
              zoomToRefPoint: true,
              flickEnabled: false,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsTouch: {
              scrollToZoom: false,
              clickToZoom: false,
              dblClickToZoom: true,
              pinchToZoom: true,
              zoomToRefPoint: true,
              flickEnabled: true,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsPen: {
              scrollToZoom: false,
              clickToZoom: true,
              dblClickToZoom: false,
              pinchToZoom: false,
              zoomToRefPoint: true,
              flickEnabled: false,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            gestureSettingsUnknown: {
              scrollToZoom: false,
              clickToZoom: false,
              dblClickToZoom: true,
              pinchToZoom: true,
              zoomToRefPoint: true,
              flickEnabled: true,
              flickMinSpeed: 120,
              flickMomentum: 0.25,
              pinchRotate: false
            },
            zoomPerClick: 2,
            zoomPerScroll: 1.2,
            zoomPerSecond: 1,
            blendTime: 0,
            alwaysBlend: false,
            autoHideControls: true,
            immediateRender: false,
            minZoomImageRatio: 0.9,
            maxZoomPixelRatio: 1.1,
            smoothTileEdgesMinZoom: 1.1,
            iOSDevice: isIOSDevice(),
            pixelsPerWheelLine: 40,
            pixelsPerArrowPress: 40,
            autoResize: true,
            preserveImageSizeOnResize: false,
            minScrollDeltaTime: 50,
            rotationIncrement: 90,
            showSequenceControl: true,
            sequenceControlAnchor: null,
            preserveViewport: false,
            preserveOverlays: false,
            navPrevNextWrap: false,
            showNavigationControl: true,
            navigationControlAnchor: null,
            showZoomControl: true,
            showHomeControl: true,
            showFullPageControl: true,
            showRotationControl: false,
            showFlipControl: false,
            controlsFadeDelay: 2e3,
            controlsFadeLength: 1500,
            mouseNavEnabled: true,
            showNavigator: false,
            navigatorId: null,
            navigatorPosition: null,
            navigatorSizeRatio: 0.2,
            navigatorMaintainSizeRatio: false,
            navigatorTop: null,
            navigatorLeft: null,
            navigatorHeight: null,
            navigatorWidth: null,
            navigatorAutoResize: true,
            navigatorAutoFade: true,
            navigatorRotate: true,
            navigatorBackground: "#000",
            navigatorOpacity: 0.8,
            navigatorBorderColor: "#555",
            navigatorDisplayRegionColor: "#900",
            degrees: 0,
            flipped: false,
            opacity: 1,
            preload: false,
            compositeOperation: null,
            imageSmoothingEnabled: true,
            placeholderFillStyle: null,
            showReferenceStrip: false,
            referenceStripScroll: "horizontal",
            referenceStripElement: null,
            referenceStripHeight: null,
            referenceStripWidth: null,
            referenceStripPosition: "BOTTOM_LEFT",
            referenceStripSizeRatio: 0.2,
            collectionRows: 3,
            collectionColumns: 0,
            collectionLayout: "horizontal",
            collectionMode: false,
            collectionTileSize: 800,
            collectionTileMargin: 80,
            imageLoaderLimit: 0,
            maxImageCacheCount: 200,
            timeout: 3e4,
            useCanvas: true,
            prefixUrl: "/images/",
            navImages: {
              zoomIn: {
                REST: "zoomin_rest.png",
                GROUP: "zoomin_grouphover.png",
                HOVER: "zoomin_hover.png",
                DOWN: "zoomin_pressed.png"
              },
              zoomOut: {
                REST: "zoomout_rest.png",
                GROUP: "zoomout_grouphover.png",
                HOVER: "zoomout_hover.png",
                DOWN: "zoomout_pressed.png"
              },
              home: {
                REST: "home_rest.png",
                GROUP: "home_grouphover.png",
                HOVER: "home_hover.png",
                DOWN: "home_pressed.png"
              },
              fullpage: {
                REST: "fullpage_rest.png",
                GROUP: "fullpage_grouphover.png",
                HOVER: "fullpage_hover.png",
                DOWN: "fullpage_pressed.png"
              },
              rotateleft: {
                REST: "rotateleft_rest.png",
                GROUP: "rotateleft_grouphover.png",
                HOVER: "rotateleft_hover.png",
                DOWN: "rotateleft_pressed.png"
              },
              rotateright: {
                REST: "rotateright_rest.png",
                GROUP: "rotateright_grouphover.png",
                HOVER: "rotateright_hover.png",
                DOWN: "rotateright_pressed.png"
              },
              flip: {
                REST: "flip_rest.png",
                GROUP: "flip_grouphover.png",
                HOVER: "flip_hover.png",
                DOWN: "flip_pressed.png"
              },
              previous: {
                REST: "previous_rest.png",
                GROUP: "previous_grouphover.png",
                HOVER: "previous_hover.png",
                DOWN: "previous_pressed.png"
              },
              next: {
                REST: "next_rest.png",
                GROUP: "next_grouphover.png",
                HOVER: "next_hover.png",
                DOWN: "next_pressed.png"
              }
            },
            debugMode: false,
            debugGridColor: ["#437AB2", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"]
          },
          SIGNAL: "----seadragon----",
          delegate: function(object, method) {
            return function() {
              var args = arguments;
              if (args === void 0) {
                args = [];
              }
              return method.apply(object, args);
            };
          },
          BROWSERS: {
            UNKNOWN: 0,
            IE: 1,
            FIREFOX: 2,
            SAFARI: 3,
            CHROME: 4,
            OPERA: 5
          },
          getElement: function(element) {
            if (typeof element == "string") {
              element = document.getElementById(element);
            }
            return element;
          },
          getElementPosition: function(element) {
            var result = new $.Point(), isFixed, offsetParent;
            element = $.getElement(element);
            isFixed = $.getElementStyle(element).position == "fixed";
            offsetParent = getOffsetParent(element, isFixed);
            while (offsetParent) {
              result.x += element.offsetLeft;
              result.y += element.offsetTop;
              if (isFixed) {
                result = result.plus($.getPageScroll());
              }
              element = offsetParent;
              isFixed = $.getElementStyle(element).position == "fixed";
              offsetParent = getOffsetParent(element, isFixed);
            }
            return result;
          },
          getElementOffset: function(element) {
            element = $.getElement(element);
            var doc = element && element.ownerDocument, docElement, win, boundingRect = { top: 0, left: 0 };
            if (!doc) {
              return new $.Point();
            }
            docElement = doc.documentElement;
            if (typeof element.getBoundingClientRect !== "undefined") {
              boundingRect = element.getBoundingClientRect();
            }
            win = doc == doc.window ? doc : doc.nodeType === 9 ? doc.defaultView || doc.parentWindow : false;
            return new $.Point(
              boundingRect.left + (win.pageXOffset || docElement.scrollLeft) - (docElement.clientLeft || 0),
              boundingRect.top + (win.pageYOffset || docElement.scrollTop) - (docElement.clientTop || 0)
            );
          },
          getElementSize: function(element) {
            element = $.getElement(element);
            return new $.Point(
              element.clientWidth,
              element.clientHeight
            );
          },
          getElementStyle: document.documentElement.currentStyle ? function(element) {
            element = $.getElement(element);
            return element.currentStyle;
          } : function(element) {
            element = $.getElement(element);
            return window.getComputedStyle(element, "");
          },
          getCssPropertyWithVendorPrefix: function(property) {
            var memo2 = {};
            $.getCssPropertyWithVendorPrefix = function(property2) {
              if (memo2[property2] !== void 0) {
                return memo2[property2];
              }
              var style = document.createElement("div").style;
              var result = null;
              if (style[property2] !== void 0) {
                result = property2;
              } else {
                var prefixes = [
                  "Webkit",
                  "Moz",
                  "MS",
                  "O",
                  "webkit",
                  "moz",
                  "ms",
                  "o"
                ];
                var suffix = $.capitalizeFirstLetter(property2);
                for (var i2 = 0; i2 < prefixes.length; i2++) {
                  var prop = prefixes[i2] + suffix;
                  if (style[prop] !== void 0) {
                    result = prop;
                    break;
                  }
                }
              }
              memo2[property2] = result;
              return result;
            };
            return $.getCssPropertyWithVendorPrefix(property);
          },
          capitalizeFirstLetter: function(string2) {
            return string2.charAt(0).toUpperCase() + string2.slice(1);
          },
          positiveModulo: function(number, modulo) {
            var result = number % modulo;
            if (result < 0) {
              result += modulo;
            }
            return result;
          },
          pointInElement: function(element, point) {
            element = $.getElement(element);
            var offset2 = $.getElementOffset(element), size2 = $.getElementSize(element);
            return point.x >= offset2.x && point.x < offset2.x + size2.x && point.y < offset2.y + size2.y && point.y >= offset2.y;
          },
          getEvent: function(event) {
            if (event) {
              $.getEvent = function(event2) {
                return event2;
              };
            } else {
              $.getEvent = function() {
                return window.event;
              };
            }
            return $.getEvent(event);
          },
          getMousePosition: function(event) {
            if (typeof event.pageX == "number") {
              $.getMousePosition = function(event2) {
                var result = new $.Point();
                event2 = $.getEvent(event2);
                result.x = event2.pageX;
                result.y = event2.pageY;
                return result;
              };
            } else if (typeof event.clientX == "number") {
              $.getMousePosition = function(event2) {
                var result = new $.Point();
                event2 = $.getEvent(event2);
                result.x = event2.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                result.y = event2.clientY + document.body.scrollTop + document.documentElement.scrollTop;
                return result;
              };
            } else {
              throw new Error(
                "Unknown event mouse position, no known technique."
              );
            }
            return $.getMousePosition(event);
          },
          getPageScroll: function() {
            var docElement = document.documentElement || {}, body = document.body || {};
            if (typeof window.pageXOffset == "number") {
              $.getPageScroll = function() {
                return new $.Point(
                  window.pageXOffset,
                  window.pageYOffset
                );
              };
            } else if (body.scrollLeft || body.scrollTop) {
              $.getPageScroll = function() {
                return new $.Point(
                  document.body.scrollLeft,
                  document.body.scrollTop
                );
              };
            } else if (docElement.scrollLeft || docElement.scrollTop) {
              $.getPageScroll = function() {
                return new $.Point(
                  document.documentElement.scrollLeft,
                  document.documentElement.scrollTop
                );
              };
            } else {
              return new $.Point(0, 0);
            }
            return $.getPageScroll();
          },
          setPageScroll: function(scroll) {
            if (typeof window.scrollTo !== "undefined") {
              $.setPageScroll = function(scroll2) {
                window.scrollTo(scroll2.x, scroll2.y);
              };
            } else {
              var originalScroll = $.getPageScroll();
              if (originalScroll.x === scroll.x && originalScroll.y === scroll.y) {
                return;
              }
              document.body.scrollLeft = scroll.x;
              document.body.scrollTop = scroll.y;
              var currentScroll = $.getPageScroll();
              if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                $.setPageScroll = function(scroll2) {
                  document.body.scrollLeft = scroll2.x;
                  document.body.scrollTop = scroll2.y;
                };
                return;
              }
              document.documentElement.scrollLeft = scroll.x;
              document.documentElement.scrollTop = scroll.y;
              currentScroll = $.getPageScroll();
              if (currentScroll.x !== originalScroll.x && currentScroll.y !== originalScroll.y) {
                $.setPageScroll = function(scroll2) {
                  document.documentElement.scrollLeft = scroll2.x;
                  document.documentElement.scrollTop = scroll2.y;
                };
                return;
              }
              $.setPageScroll = function(scroll2) {
              };
            }
            return $.setPageScroll(scroll);
          },
          getWindowSize: function() {
            var docElement = document.documentElement || {}, body = document.body || {};
            if (typeof window.innerWidth == "number") {
              $.getWindowSize = function() {
                return new $.Point(
                  window.innerWidth,
                  window.innerHeight
                );
              };
            } else if (docElement.clientWidth || docElement.clientHeight) {
              $.getWindowSize = function() {
                return new $.Point(
                  document.documentElement.clientWidth,
                  document.documentElement.clientHeight
                );
              };
            } else if (body.clientWidth || body.clientHeight) {
              $.getWindowSize = function() {
                return new $.Point(
                  document.body.clientWidth,
                  document.body.clientHeight
                );
              };
            } else {
              throw new Error("Unknown window size, no known technique.");
            }
            return $.getWindowSize();
          },
          makeCenteredNode: function(element) {
            element = $.getElement(element);
            var wrappers = [
              $.makeNeutralElement("div"),
              $.makeNeutralElement("div"),
              $.makeNeutralElement("div")
            ];
            $.extend(wrappers[0].style, {
              display: "table",
              height: "100%",
              width: "100%"
            });
            $.extend(wrappers[1].style, {
              display: "table-row"
            });
            $.extend(wrappers[2].style, {
              display: "table-cell",
              verticalAlign: "middle",
              textAlign: "center"
            });
            wrappers[0].appendChild(wrappers[1]);
            wrappers[1].appendChild(wrappers[2]);
            wrappers[2].appendChild(element);
            return wrappers[0];
          },
          makeNeutralElement: function(tagName) {
            var element = document.createElement(tagName), style = element.style;
            style.background = "transparent none";
            style.border = "none";
            style.margin = "0px";
            style.padding = "0px";
            style.position = "static";
            return element;
          },
          now: function() {
            if (Date.now) {
              $.now = Date.now;
            } else {
              $.now = function() {
                return new Date().getTime();
              };
            }
            return $.now();
          },
          makeTransparentImage: function(src) {
            $.makeTransparentImage = function(src2) {
              var img = $.makeNeutralElement("img");
              img.src = src2;
              return img;
            };
            if ($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 7) {
              $.makeTransparentImage = function(src2) {
                var img = $.makeNeutralElement("img"), element = null;
                element = $.makeNeutralElement("span");
                element.style.display = "inline-block";
                img.onload = function() {
                  element.style.width = element.style.width || img.width + "px";
                  element.style.height = element.style.height || img.height + "px";
                  img.onload = null;
                  img = null;
                };
                img.src = src2;
                element.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + src2 + "', sizingMethod='scale')";
                return element;
              };
            }
            return $.makeTransparentImage(src);
          },
          setElementOpacity: function(element, opacity, usesAlpha) {
            var ieOpacity, ieFilter;
            element = $.getElement(element);
            if (usesAlpha && !$.Browser.alpha) {
              opacity = Math.round(opacity);
            }
            if ($.Browser.opacity) {
              element.style.opacity = opacity < 1 ? opacity : "";
            } else {
              if (opacity < 1) {
                ieOpacity = Math.round(100 * opacity);
                ieFilter = "alpha(opacity=" + ieOpacity + ")";
                element.style.filter = ieFilter;
              } else {
                element.style.filter = "";
              }
            }
          },
          setElementTouchActionNone: function(element) {
            element = $.getElement(element);
            if (typeof element.style.touchAction !== "undefined") {
              element.style.touchAction = "none";
            } else if (typeof element.style.msTouchAction !== "undefined") {
              element.style.msTouchAction = "none";
            }
          },
          addClass: function(element, className) {
            element = $.getElement(element);
            if (!element.className) {
              element.className = className;
            } else if ((" " + element.className + " ").indexOf(" " + className + " ") === -1) {
              element.className += " " + className;
            }
          },
          indexOf: function(array, searchElement, fromIndex) {
            if (Array.prototype.indexOf) {
              this.indexOf = function(array2, searchElement2, fromIndex2) {
                return array2.indexOf(searchElement2, fromIndex2);
              };
            } else {
              this.indexOf = function(array2, searchElement2, fromIndex2) {
                var i2, pivot = fromIndex2 ? fromIndex2 : 0, length;
                if (!array2) {
                  throw new TypeError();
                }
                length = array2.length;
                if (length === 0 || pivot >= length) {
                  return -1;
                }
                if (pivot < 0) {
                  pivot = length - Math.abs(pivot);
                }
                for (i2 = pivot; i2 < length; i2++) {
                  if (array2[i2] === searchElement2) {
                    return i2;
                  }
                }
                return -1;
              };
            }
            return this.indexOf(array, searchElement, fromIndex);
          },
          removeClass: function(element, className) {
            var oldClasses, newClasses = [], i2;
            element = $.getElement(element);
            oldClasses = element.className.split(/\s+/);
            for (i2 = 0; i2 < oldClasses.length; i2++) {
              if (oldClasses[i2] && oldClasses[i2] !== className) {
                newClasses.push(oldClasses[i2]);
              }
            }
            element.className = newClasses.join(" ");
          },
          addEvent: function() {
            if (window.addEventListener) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.addEventListener(eventName, handler, useCapture);
              };
            } else if (window.attachEvent) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.attachEvent("on" + eventName, handler);
              };
            } else {
              throw new Error("No known event model.");
            }
          }(),
          removeEvent: function() {
            if (window.removeEventListener) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.removeEventListener(eventName, handler, useCapture);
              };
            } else if (window.detachEvent) {
              return function(element, eventName, handler, useCapture) {
                element = $.getElement(element);
                element.detachEvent("on" + eventName, handler);
              };
            } else {
              throw new Error("No known event model.");
            }
          }(),
          cancelEvent: function(event) {
            event = $.getEvent(event);
            if (event.preventDefault) {
              $.cancelEvent = function(event2) {
                event2.preventDefault();
              };
            } else {
              $.cancelEvent = function(event2) {
                event2 = $.getEvent(event2);
                event2.cancel = true;
                event2.returnValue = false;
              };
            }
            $.cancelEvent(event);
          },
          stopEvent: function(event) {
            event = $.getEvent(event);
            if (event.stopPropagation) {
              $.stopEvent = function(event2) {
                event2.stopPropagation();
              };
            } else {
              $.stopEvent = function(event2) {
                event2 = $.getEvent(event2);
                event2.cancelBubble = true;
              };
            }
            $.stopEvent(event);
          },
          createCallback: function(object, method) {
            var initialArgs = [], i2;
            for (i2 = 2; i2 < arguments.length; i2++) {
              initialArgs.push(arguments[i2]);
            }
            return function() {
              var args = initialArgs.concat([]), i3;
              for (i3 = 0; i3 < arguments.length; i3++) {
                args.push(arguments[i3]);
              }
              return method.apply(object, args);
            };
          },
          getUrlParameter: function(key) {
            var value = URLPARAMS[key];
            return value ? value : null;
          },
          getUrlProtocol: function(url) {
            var match = url.match(/^([a-z]+:)\/\//i);
            if (match === null) {
              return window.location.protocol;
            }
            return match[1].toLowerCase();
          },
          createAjaxRequest: function(local) {
            var supportActiveX;
            try {
              supportActiveX = !!new ActiveXObject("Microsoft.XMLHTTP");
            } catch (e3) {
              supportActiveX = false;
            }
            if (supportActiveX) {
              if (window.XMLHttpRequest) {
                $.createAjaxRequest = function(local2) {
                  if (local2) {
                    return new ActiveXObject("Microsoft.XMLHTTP");
                  }
                  return new XMLHttpRequest();
                };
              } else {
                $.createAjaxRequest = function() {
                  return new ActiveXObject("Microsoft.XMLHTTP");
                };
              }
            } else if (window.XMLHttpRequest) {
              $.createAjaxRequest = function() {
                return new XMLHttpRequest();
              };
            } else {
              throw new Error("Browser doesn't support XMLHttpRequest.");
            }
            return $.createAjaxRequest(local);
          },
          makeAjaxRequest: function(url, onSuccess, onError) {
            var withCredentials;
            var headers;
            var responseType;
            if ($.isPlainObject(url)) {
              onSuccess = url.success;
              onError = url.error;
              withCredentials = url.withCredentials;
              headers = url.headers;
              responseType = url.responseType || null;
              url = url.url;
            }
            var protocol = $.getUrlProtocol(url);
            var request = $.createAjaxRequest(protocol === "file:");
            if (!$.isFunction(onSuccess)) {
              throw new Error("makeAjaxRequest requires a success callback");
            }
            request.onreadystatechange = function() {
              if (request.readyState == 4) {
                request.onreadystatechange = function() {
                };
                if (request.status >= 200 && request.status < 300 || request.status === 0 && protocol !== "http:" && protocol !== "https:") {
                  onSuccess(request);
                } else {
                  $.console.log("AJAX request returned %d: %s", request.status, url);
                  if ($.isFunction(onError)) {
                    onError(request);
                  }
                }
              }
            };
            try {
              request.open("GET", url, true);
              if (responseType) {
                request.responseType = responseType;
              }
              if (headers) {
                for (var headerName in headers) {
                  if (Object.prototype.hasOwnProperty.call(headers, headerName) && headers[headerName]) {
                    request.setRequestHeader(headerName, headers[headerName]);
                  }
                }
              }
              if (withCredentials) {
                request.withCredentials = true;
              }
              request.send(null);
            } catch (e3) {
              var msg = e3.message;
              var oldIE = $.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 10;
              if (oldIE && typeof e3.number != "undefined" && e3.number == -2147024891) {
                msg += "\nSee http://msdn.microsoft.com/en-us/library/ms537505(v=vs.85).aspx#xdomain";
              }
              $.console.log("%s while making AJAX request: %s", e3.name, msg);
              request.onreadystatechange = function() {
              };
              if (window.XDomainRequest) {
                var xdr = new window.XDomainRequest();
                if (xdr) {
                  xdr.onload = function(e4) {
                    if ($.isFunction(onSuccess)) {
                      onSuccess({
                        responseText: xdr.responseText,
                        status: 200,
                        statusText: "OK"
                      });
                    }
                  };
                  xdr.onerror = function(e4) {
                    if ($.isFunction(onError)) {
                      onError({
                        responseText: xdr.responseText,
                        status: 444,
                        statusText: "An error happened. Due to an XDomainRequest deficiency we can not extract any information about this error. Upgrade your browser."
                      });
                    }
                  };
                  try {
                    xdr.open("GET", url);
                    xdr.send();
                  } catch (e22) {
                    if ($.isFunction(onError)) {
                      onError(request, e3);
                    }
                  }
                }
              } else {
                if ($.isFunction(onError)) {
                  onError(request, e3);
                }
              }
            }
            return request;
          },
          jsonp: function(options) {
            var script, url = options.url, head = document.head || document.getElementsByTagName("head")[0] || document.documentElement, jsonpCallback = options.callbackName || "openseadragon" + $.now(), previous = window[jsonpCallback], replace = "$1" + jsonpCallback + "$2", callbackParam = options.param || "callback", callback = options.callback;
            url = url.replace(/(\=)\?(&|$)|\?\?/i, replace);
            url += (/\?/.test(url) ? "&" : "?") + callbackParam + "=" + jsonpCallback;
            window[jsonpCallback] = function(response) {
              if (!previous) {
                try {
                  delete window[jsonpCallback];
                } catch (e3) {
                }
              } else {
                window[jsonpCallback] = previous;
              }
              if (callback && $.isFunction(callback)) {
                callback(response);
              }
            };
            script = document.createElement("script");
            if (void 0 !== options.async || false !== options.async) {
              script.async = "async";
            }
            if (options.scriptCharset) {
              script.charset = options.scriptCharset;
            }
            script.src = url;
            script.onload = script.onreadystatechange = function(_, isAbort) {
              if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
                script.onload = script.onreadystatechange = null;
                if (head && script.parentNode) {
                  head.removeChild(script);
                }
                script = void 0;
              }
            };
            head.insertBefore(script, head.firstChild);
          },
          createFromDZI: function() {
            throw "OpenSeadragon.createFromDZI is deprecated, use Viewer.open.";
          },
          parseXml: function(string2) {
            if (window.DOMParser) {
              $.parseXml = function(string3) {
                var xmlDoc = null, parser;
                parser = new DOMParser();
                xmlDoc = parser.parseFromString(string3, "text/xml");
                return xmlDoc;
              };
            } else if (window.ActiveXObject) {
              $.parseXml = function(string3) {
                var xmlDoc = null;
                xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                xmlDoc.async = false;
                xmlDoc.loadXML(string3);
                return xmlDoc;
              };
            } else {
              throw new Error("Browser doesn't support XML DOM.");
            }
            return $.parseXml(string2);
          },
          parseJSON: function(string) {
            if (window.JSON && window.JSON.parse) {
              $.parseJSON = window.JSON.parse;
            } else {
              $.parseJSON = function(string) {
                return eval("(" + string + ")");
              };
            }
            return $.parseJSON(string);
          },
          imageFormatSupported: function(extension) {
            extension = extension ? extension : "";
            return !!FILEFORMATS[extension.toLowerCase()];
          }
        });
        var nullfunction = function(msg) {
        };
        $.console = window.console || {
          log: nullfunction,
          debug: nullfunction,
          info: nullfunction,
          warn: nullfunction,
          error: nullfunction,
          assert: nullfunction
        };
        $.Browser = {
          vendor: $.BROWSERS.UNKNOWN,
          version: 0,
          alpha: true
        };
        var FILEFORMATS = {
          "bmp": false,
          "jpeg": true,
          "jpg": true,
          "png": true,
          "tif": false,
          "wdp": false
        }, URLPARAMS = {};
        (function() {
          var ver = navigator.appVersion, ua = navigator.userAgent, regex;
          switch (navigator.appName) {
            case "Microsoft Internet Explorer":
              if (!!window.attachEvent && !!window.ActiveXObject) {
                $.Browser.vendor = $.BROWSERS.IE;
                $.Browser.version = parseFloat(
                  ua.substring(
                    ua.indexOf("MSIE") + 5,
                    ua.indexOf(";", ua.indexOf("MSIE"))
                  )
                );
              }
              break;
            case "Netscape":
              if (window.addEventListener) {
                if (ua.indexOf("Firefox") >= 0) {
                  $.Browser.vendor = $.BROWSERS.FIREFOX;
                  $.Browser.version = parseFloat(
                    ua.substring(ua.indexOf("Firefox") + 8)
                  );
                } else if (ua.indexOf("Safari") >= 0) {
                  $.Browser.vendor = ua.indexOf("Chrome") >= 0 ? $.BROWSERS.CHROME : $.BROWSERS.SAFARI;
                  $.Browser.version = parseFloat(
                    ua.substring(
                      ua.substring(0, ua.indexOf("Safari")).lastIndexOf("/") + 1,
                      ua.indexOf("Safari")
                    )
                  );
                } else {
                  regex = new RegExp("Trident/.*rv:([0-9]{1,}[.0-9]{0,})");
                  if (regex.exec(ua) !== null) {
                    $.Browser.vendor = $.BROWSERS.IE;
                    $.Browser.version = parseFloat(RegExp.$1);
                  }
                }
              }
              break;
            case "Opera":
              $.Browser.vendor = $.BROWSERS.OPERA;
              $.Browser.version = parseFloat(ver);
              break;
          }
          var query = window.location.search.substring(1), parts = query.split("&"), part, sep, i2;
          for (i2 = 0; i2 < parts.length; i2++) {
            part = parts[i2];
            sep = part.indexOf("=");
            if (sep > 0) {
              var key = part.substring(0, sep), value = part.substring(sep + 1);
              try {
                URLPARAMS[key] = decodeURIComponent(value);
              } catch (e3) {
                $.console.error("Ignoring malformed URL parameter: %s=%s", key, value);
              }
            }
          }
          $.Browser.alpha = !($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 9 || $.Browser.vendor == $.BROWSERS.CHROME && $.Browser.version < 2);
          $.Browser.opacity = !($.Browser.vendor == $.BROWSERS.IE && $.Browser.version < 9);
        })();
        (function(w2) {
          var requestAnimationFrame2 = w2.requestAnimationFrame || w2.mozRequestAnimationFrame || w2.webkitRequestAnimationFrame || w2.msRequestAnimationFrame;
          var cancelAnimationFrame2 = w2.cancelAnimationFrame || w2.mozCancelAnimationFrame || w2.webkitCancelAnimationFrame || w2.msCancelAnimationFrame;
          if (requestAnimationFrame2 && cancelAnimationFrame2) {
            $.requestAnimationFrame = function() {
              return requestAnimationFrame2.apply(w2, arguments);
            };
            $.cancelAnimationFrame = function() {
              return cancelAnimationFrame2.apply(w2, arguments);
            };
          } else {
            var aAnimQueue = [], processing = [], iRequestId = 0, iIntervalId;
            $.requestAnimationFrame = function(callback) {
              aAnimQueue.push([++iRequestId, callback]);
              if (!iIntervalId) {
                iIntervalId = setInterval(function() {
                  if (aAnimQueue.length) {
                    var time = $.now();
                    var temp = processing;
                    processing = aAnimQueue;
                    aAnimQueue = temp;
                    while (processing.length) {
                      processing.shift()[1](time);
                    }
                  } else {
                    clearInterval(iIntervalId);
                    iIntervalId = void 0;
                  }
                }, 1e3 / 50);
              }
              return iRequestId;
            };
            $.cancelAnimationFrame = function(requestId) {
              var i2, j3;
              for (i2 = 0, j3 = aAnimQueue.length; i2 < j3; i2 += 1) {
                if (aAnimQueue[i2][0] === requestId) {
                  aAnimQueue.splice(i2, 1);
                  return;
                }
              }
              for (i2 = 0, j3 = processing.length; i2 < j3; i2 += 1) {
                if (processing[i2][0] === requestId) {
                  processing.splice(i2, 1);
                  return;
                }
              }
            };
          }
        })(window);
        function getOffsetParent(element, isFixed) {
          if (isFixed && element != document.body) {
            return document.body;
          } else {
            return element.offsetParent;
          }
        }
      })(OpenSeadragon);
      (function(root2, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory();
        } else {
          root2.OpenSeadragon = factory();
        }
      })(exports, function() {
        return OpenSeadragon;
      });
      (function($3) {
        var fullScreenApi = {
          supportsFullScreen: false,
          isFullScreen: function() {
            return false;
          },
          getFullScreenElement: function() {
            return null;
          },
          requestFullScreen: function() {
          },
          exitFullScreen: function() {
          },
          cancelFullScreen: function() {
          },
          fullScreenEventName: "",
          fullScreenErrorEventName: ""
        };
        if (document.exitFullscreen) {
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
            return document.fullscreenElement;
          };
          fullScreenApi.requestFullScreen = function(element) {
            return element.requestFullscreen();
          };
          fullScreenApi.exitFullScreen = function() {
            document.exitFullscreen();
          };
          fullScreenApi.fullScreenEventName = "fullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "fullscreenerror";
        } else if (document.msExitFullscreen) {
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
            return document.msFullscreenElement;
          };
          fullScreenApi.requestFullScreen = function(element) {
            return element.msRequestFullscreen();
          };
          fullScreenApi.exitFullScreen = function() {
            document.msExitFullscreen();
          };
          fullScreenApi.fullScreenEventName = "MSFullscreenChange";
          fullScreenApi.fullScreenErrorEventName = "MSFullscreenError";
        } else if (document.webkitExitFullscreen) {
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
            return document.webkitFullscreenElement;
          };
          fullScreenApi.requestFullScreen = function(element) {
            return element.webkitRequestFullscreen();
          };
          fullScreenApi.exitFullScreen = function() {
            document.webkitExitFullscreen();
          };
          fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
        } else if (document.webkitCancelFullScreen) {
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
            return document.webkitCurrentFullScreenElement;
          };
          fullScreenApi.requestFullScreen = function(element) {
            return element.webkitRequestFullScreen();
          };
          fullScreenApi.exitFullScreen = function() {
            document.webkitCancelFullScreen();
          };
          fullScreenApi.fullScreenEventName = "webkitfullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "webkitfullscreenerror";
        } else if (document.mozCancelFullScreen) {
          fullScreenApi.supportsFullScreen = true;
          fullScreenApi.getFullScreenElement = function() {
            return document.mozFullScreenElement;
          };
          fullScreenApi.requestFullScreen = function(element) {
            return element.mozRequestFullScreen();
          };
          fullScreenApi.exitFullScreen = function() {
            document.mozCancelFullScreen();
          };
          fullScreenApi.fullScreenEventName = "mozfullscreenchange";
          fullScreenApi.fullScreenErrorEventName = "mozfullscreenerror";
        }
        fullScreenApi.isFullScreen = function() {
          return fullScreenApi.getFullScreenElement() !== null;
        };
        fullScreenApi.cancelFullScreen = function() {
          $3.console.error("cancelFullScreen is deprecated. Use exitFullScreen instead.");
          fullScreenApi.exitFullScreen();
        };
        $3.extend($3, fullScreenApi);
      })(OpenSeadragon);
      (function($3) {
        $3.EventSource = function() {
          this.events = {};
        };
        $3.EventSource.prototype = {
          addOnceHandler: function(eventName, handler, userData, times) {
            var self2 = this;
            times = times || 1;
            var count = 0;
            var onceHandler = function(event) {
              count++;
              if (count === times) {
                self2.removeHandler(eventName, onceHandler);
              }
              handler(event);
            };
            this.addHandler(eventName, onceHandler, userData);
          },
          addHandler: function(eventName, handler, userData) {
            var events = this.events[eventName];
            if (!events) {
              this.events[eventName] = events = [];
            }
            if (handler && $3.isFunction(handler)) {
              events[events.length] = { handler, userData: userData || null };
            }
          },
          removeHandler: function(eventName, handler) {
            var events = this.events[eventName], handlers = [], i2;
            if (!events) {
              return;
            }
            if ($3.isArray(events)) {
              for (i2 = 0; i2 < events.length; i2++) {
                if (events[i2].handler !== handler) {
                  handlers.push(events[i2]);
                }
              }
              this.events[eventName] = handlers;
            }
          },
          removeAllHandlers: function(eventName) {
            if (eventName) {
              this.events[eventName] = [];
            } else {
              for (var eventType in this.events) {
                this.events[eventType] = [];
              }
            }
          },
          getHandler: function(eventName) {
            var events = this.events[eventName];
            if (!events || !events.length) {
              return null;
            }
            events = events.length === 1 ? [events[0]] : Array.apply(null, events);
            return function(source, args) {
              var i2, length = events.length;
              for (i2 = 0; i2 < length; i2++) {
                if (events[i2]) {
                  args.eventSource = source;
                  args.userData = events[i2].userData;
                  events[i2].handler(args);
                }
              }
            };
          },
          raiseEvent: function(eventName, eventArgs) {
            var handler = this.getHandler(eventName);
            if (handler) {
              if (!eventArgs) {
                eventArgs = {};
              }
              handler(this, eventArgs);
            }
          }
        };
      })(OpenSeadragon);
      (function($3) {
        var MOUSETRACKERS = [];
        var THIS = {};
        $3.MouseTracker = function(options) {
          MOUSETRACKERS.push(this);
          var args = arguments;
          if (!$3.isPlainObject(options)) {
            options = {
              element: args[0],
              clickTimeThreshold: args[1],
              clickDistThreshold: args[2]
            };
          }
          this.hash = Math.random();
          this.element = $3.getElement(options.element);
          this.clickTimeThreshold = options.clickTimeThreshold || $3.DEFAULT_SETTINGS.clickTimeThreshold;
          this.clickDistThreshold = options.clickDistThreshold || $3.DEFAULT_SETTINGS.clickDistThreshold;
          this.dblClickTimeThreshold = options.dblClickTimeThreshold || $3.DEFAULT_SETTINGS.dblClickTimeThreshold;
          this.dblClickDistThreshold = options.dblClickDistThreshold || $3.DEFAULT_SETTINGS.dblClickDistThreshold;
          this.userData = options.userData || null;
          this.stopDelay = options.stopDelay || 50;
          this.enterHandler = options.enterHandler || null;
          this.exitHandler = options.exitHandler || null;
          this.pressHandler = options.pressHandler || null;
          this.nonPrimaryPressHandler = options.nonPrimaryPressHandler || null;
          this.releaseHandler = options.releaseHandler || null;
          this.nonPrimaryReleaseHandler = options.nonPrimaryReleaseHandler || null;
          this.moveHandler = options.moveHandler || null;
          this.scrollHandler = options.scrollHandler || null;
          this.clickHandler = options.clickHandler || null;
          this.dblClickHandler = options.dblClickHandler || null;
          this.dragHandler = options.dragHandler || null;
          this.dragEndHandler = options.dragEndHandler || null;
          this.pinchHandler = options.pinchHandler || null;
          this.stopHandler = options.stopHandler || null;
          this.keyDownHandler = options.keyDownHandler || null;
          this.keyUpHandler = options.keyUpHandler || null;
          this.keyHandler = options.keyHandler || null;
          this.focusHandler = options.focusHandler || null;
          this.blurHandler = options.blurHandler || null;
          var _this = this;
          THIS[this.hash] = {
            click: function(event) {
              onClick(_this, event);
            },
            dblclick: function(event) {
              onDblClick(_this, event);
            },
            keydown: function(event) {
              onKeyDown(_this, event);
            },
            keyup: function(event) {
              onKeyUp(_this, event);
            },
            keypress: function(event) {
              onKeyPress(_this, event);
            },
            focus: function(event) {
              onFocus(_this, event);
            },
            blur: function(event) {
              onBlur(_this, event);
            },
            wheel: function(event) {
              onWheel(_this, event);
            },
            mousewheel: function(event) {
              onMouseWheel(_this, event);
            },
            DOMMouseScroll: function(event) {
              onMouseWheel(_this, event);
            },
            MozMousePixelScroll: function(event) {
              onMouseWheel(_this, event);
            },
            mouseenter: function(event) {
              onMouseEnter(_this, event);
            },
            mouseleave: function(event) {
              onMouseLeave(_this, event);
            },
            mouseover: function(event) {
              onMouseOver(_this, event);
            },
            mouseout: function(event) {
              onMouseOut(_this, event);
            },
            mousedown: function(event) {
              onMouseDown(_this, event);
            },
            mouseup: function(event) {
              onMouseUp(_this, event);
            },
            mouseupcaptured: function(event) {
              onMouseUpCaptured(_this, event);
            },
            mousemove: function(event) {
              onMouseMove(_this, event);
            },
            mousemovecaptured: function(event) {
              onMouseMoveCaptured(_this, event);
            },
            touchstart: function(event) {
              onTouchStart(_this, event);
            },
            touchend: function(event) {
              onTouchEnd(_this, event);
            },
            touchendcaptured: function(event) {
              onTouchEndCaptured(_this, event);
            },
            touchmove: function(event) {
              onTouchMove(_this, event);
            },
            touchmovecaptured: function(event) {
              onTouchMoveCaptured(_this, event);
            },
            touchcancel: function(event) {
              onTouchCancel(_this, event);
            },
            gesturestart: function(event) {
              onGestureStart(_this, event);
            },
            gesturechange: function(event) {
              onGestureChange(_this, event);
            },
            pointerover: function(event) {
              onPointerOver(_this, event);
            },
            MSPointerOver: function(event) {
              onPointerOver(_this, event);
            },
            pointerout: function(event) {
              onPointerOut(_this, event);
            },
            MSPointerOut: function(event) {
              onPointerOut(_this, event);
            },
            pointerdown: function(event) {
              onPointerDown(_this, event);
            },
            MSPointerDown: function(event) {
              onPointerDown(_this, event);
            },
            pointerup: function(event) {
              onPointerUp(_this, event);
            },
            MSPointerUp: function(event) {
              onPointerUp(_this, event);
            },
            pointermove: function(event) {
              onPointerMove(_this, event);
            },
            MSPointerMove: function(event) {
              onPointerMove(_this, event);
            },
            pointercancel: function(event) {
              onPointerCancel(_this, event);
            },
            MSPointerCancel: function(event) {
              onPointerCancel(_this, event);
            },
            pointerupcaptured: function(event) {
              onPointerUpCaptured(_this, event);
            },
            pointermovecaptured: function(event) {
              onPointerMoveCaptured(_this, event);
            },
            tracking: false,
            activePointersLists: [],
            lastClickPos: null,
            dblClickTimeOut: null,
            pinchGPoints: [],
            lastPinchDist: 0,
            currentPinchDist: 0,
            lastPinchCenter: null,
            currentPinchCenter: null
          };
          if (!options.startDisabled) {
            this.setTracking(true);
          }
        };
        $3.MouseTracker.prototype = {
          destroy: function() {
            var i2;
            stopTracking(this);
            this.element = null;
            for (i2 = 0; i2 < MOUSETRACKERS.length; i2++) {
              if (MOUSETRACKERS[i2] === this) {
                MOUSETRACKERS.splice(i2, 1);
                break;
              }
            }
            THIS[this.hash] = null;
            delete THIS[this.hash];
          },
          isTracking: function() {
            return THIS[this.hash].tracking;
          },
          setTracking: function(track) {
            if (track) {
              startTracking(this);
            } else {
              stopTracking(this);
            }
            return this;
          },
          getActivePointersListsExceptType: function(type) {
            var delegate = THIS[this.hash];
            var listArray = [];
            for (var i2 = 0; i2 < delegate.activePointersLists.length; ++i2) {
              if (delegate.activePointersLists[i2].type !== type) {
                listArray.push(delegate.activePointersLists[i2]);
              }
            }
            return listArray;
          },
          getActivePointersListByType: function(type) {
            var delegate = THIS[this.hash], i2, len = delegate.activePointersLists.length, list;
            for (i2 = 0; i2 < len; i2++) {
              if (delegate.activePointersLists[i2].type === type) {
                return delegate.activePointersLists[i2];
              }
            }
            list = new $3.MouseTracker.GesturePointList(type);
            delegate.activePointersLists.push(list);
            return list;
          },
          getActivePointerCount: function() {
            var delegate = THIS[this.hash], i2, len = delegate.activePointersLists.length, count = 0;
            for (i2 = 0; i2 < len; i2++) {
              count += delegate.activePointersLists[i2].getLength();
            }
            return count;
          },
          enterHandler: function() {
          },
          exitHandler: function() {
          },
          pressHandler: function() {
          },
          nonPrimaryPressHandler: function() {
          },
          releaseHandler: function() {
          },
          nonPrimaryReleaseHandler: function() {
          },
          moveHandler: function() {
          },
          scrollHandler: function() {
          },
          clickHandler: function() {
          },
          dblClickHandler: function() {
          },
          dragHandler: function() {
          },
          dragEndHandler: function() {
          },
          pinchHandler: function() {
          },
          stopHandler: function() {
          },
          keyDownHandler: function() {
          },
          keyUpHandler: function() {
          },
          keyHandler: function() {
          },
          focusHandler: function() {
          },
          blurHandler: function() {
          }
        };
        $3.MouseTracker.resetAllMouseTrackers = function() {
          for (var i2 = 0; i2 < MOUSETRACKERS.length; i2++) {
            if (MOUSETRACKERS[i2].isTracking()) {
              MOUSETRACKERS[i2].setTracking(false);
              MOUSETRACKERS[i2].setTracking(true);
            }
          }
        };
        $3.MouseTracker.gesturePointVelocityTracker = function() {
          var trackerPoints = [], intervalId = 0, lastTime = 0;
          var _generateGuid = function(tracker, gPoint) {
            return tracker.hash.toString() + gPoint.type + gPoint.id.toString();
          };
          var _doTracking = function() {
            var i2, len = trackerPoints.length, trackPoint, gPoint, now2 = $3.now(), elapsedTime, distance, speed;
            elapsedTime = now2 - lastTime;
            lastTime = now2;
            for (i2 = 0; i2 < len; i2++) {
              trackPoint = trackerPoints[i2];
              gPoint = trackPoint.gPoint;
              gPoint.direction = Math.atan2(gPoint.currentPos.y - trackPoint.lastPos.y, gPoint.currentPos.x - trackPoint.lastPos.x);
              distance = trackPoint.lastPos.distanceTo(gPoint.currentPos);
              trackPoint.lastPos = gPoint.currentPos;
              speed = 1e3 * distance / (elapsedTime + 1);
              gPoint.speed = 0.75 * speed + 0.25 * gPoint.speed;
            }
          };
          var addPoint = function(tracker, gPoint) {
            var guid = _generateGuid(tracker, gPoint);
            trackerPoints.push(
              {
                guid,
                gPoint,
                lastPos: gPoint.currentPos
              }
            );
            if (trackerPoints.length === 1) {
              lastTime = $3.now();
              intervalId = window.setInterval(_doTracking, 50);
            }
          };
          var removePoint = function(tracker, gPoint) {
            var guid = _generateGuid(tracker, gPoint), i2, len = trackerPoints.length;
            for (i2 = 0; i2 < len; i2++) {
              if (trackerPoints[i2].guid === guid) {
                trackerPoints.splice(i2, 1);
                len--;
                if (len === 0) {
                  window.clearInterval(intervalId);
                }
                break;
              }
            }
          };
          return {
            addPoint,
            removePoint
          };
        }();
        $3.MouseTracker.captureElement = document;
        $3.MouseTracker.wheelEventName = $3.Browser.vendor == $3.BROWSERS.IE && $3.Browser.version > 8 || "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
        $3.MouseTracker.supportsMouseCapture = function() {
          var divElement = document.createElement("div");
          return $3.isFunction(divElement.setCapture) && $3.isFunction(divElement.releaseCapture);
        }();
        $3.MouseTracker.subscribeEvents = ["click", "dblclick", "keydown", "keyup", "keypress", "focus", "blur", $3.MouseTracker.wheelEventName];
        if ($3.MouseTracker.wheelEventName == "DOMMouseScroll") {
          $3.MouseTracker.subscribeEvents.push("MozMousePixelScroll");
        }
        if (window.PointerEvent && (window.navigator.pointerEnabled || $3.Browser.vendor !== $3.BROWSERS.IE)) {
          $3.MouseTracker.havePointerEvents = true;
          $3.MouseTracker.subscribeEvents.push("pointerover", "pointerout", "pointerdown", "pointerup", "pointermove", "pointercancel");
          $3.MouseTracker.unprefixedPointerEvents = true;
          if (navigator.maxTouchPoints) {
            $3.MouseTracker.maxTouchPoints = navigator.maxTouchPoints;
          } else {
            $3.MouseTracker.maxTouchPoints = 0;
          }
          $3.MouseTracker.haveMouseEnter = false;
        } else if (window.MSPointerEvent && window.navigator.msPointerEnabled) {
          $3.MouseTracker.havePointerEvents = true;
          $3.MouseTracker.subscribeEvents.push("MSPointerOver", "MSPointerOut", "MSPointerDown", "MSPointerUp", "MSPointerMove", "MSPointerCancel");
          $3.MouseTracker.unprefixedPointerEvents = false;
          if (navigator.msMaxTouchPoints) {
            $3.MouseTracker.maxTouchPoints = navigator.msMaxTouchPoints;
          } else {
            $3.MouseTracker.maxTouchPoints = 0;
          }
          $3.MouseTracker.haveMouseEnter = false;
        } else {
          $3.MouseTracker.havePointerEvents = false;
          if ($3.Browser.vendor === $3.BROWSERS.IE && $3.Browser.version < 9) {
            $3.MouseTracker.subscribeEvents.push("mouseenter", "mouseleave");
            $3.MouseTracker.haveMouseEnter = true;
          } else {
            $3.MouseTracker.subscribeEvents.push("mouseover", "mouseout");
            $3.MouseTracker.haveMouseEnter = false;
          }
          $3.MouseTracker.subscribeEvents.push("mousedown", "mouseup", "mousemove");
          if ("ontouchstart" in window) {
            $3.MouseTracker.subscribeEvents.push("touchstart", "touchend", "touchmove", "touchcancel");
          }
          if ("ongesturestart" in window) {
            $3.MouseTracker.subscribeEvents.push("gesturestart", "gesturechange");
          }
          $3.MouseTracker.mousePointerId = "legacy-mouse";
          $3.MouseTracker.maxTouchPoints = 10;
        }
        $3.MouseTracker.GesturePointList = function(type) {
          this._gPoints = [];
          this.type = type;
          this.buttons = 0;
          this.contacts = 0;
          this.clicks = 0;
          this.captureCount = 0;
        };
        $3.MouseTracker.GesturePointList.prototype = {
          getLength: function() {
            return this._gPoints.length;
          },
          asArray: function() {
            return this._gPoints;
          },
          add: function(gp) {
            return this._gPoints.push(gp);
          },
          removeById: function(id) {
            var i2, len = this._gPoints.length;
            for (i2 = 0; i2 < len; i2++) {
              if (this._gPoints[i2].id === id) {
                this._gPoints.splice(i2, 1);
                break;
              }
            }
            return this._gPoints.length;
          },
          getByIndex: function(index2) {
            if (index2 < this._gPoints.length) {
              return this._gPoints[index2];
            }
            return null;
          },
          getById: function(id) {
            var i2, len = this._gPoints.length;
            for (i2 = 0; i2 < len; i2++) {
              if (this._gPoints[i2].id === id) {
                return this._gPoints[i2];
              }
            }
            return null;
          },
          getPrimary: function(id) {
            var i2, len = this._gPoints.length;
            for (i2 = 0; i2 < len; i2++) {
              if (this._gPoints[i2].isPrimary) {
                return this._gPoints[i2];
              }
            }
            return null;
          },
          addContact: function() {
            ++this.contacts;
            if (this.contacts > 1 && (this.type === "mouse" || this.type === "pen")) {
              this.contacts = 1;
            }
          },
          removeContact: function() {
            --this.contacts;
            if (this.contacts < 0) {
              this.contacts = 0;
            }
          }
        };
        function clearTrackedPointers(tracker) {
          var delegate = THIS[tracker.hash], i2, pointerListCount = delegate.activePointersLists.length;
          for (i2 = 0; i2 < pointerListCount; i2++) {
            if (delegate.activePointersLists[i2].captureCount > 0) {
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                "mousemove",
                delegate.mousemovecaptured,
                true
              );
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                "mouseup",
                delegate.mouseupcaptured,
                true
              );
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                $3.MouseTracker.unprefixedPointerEvents ? "pointermove" : "MSPointerMove",
                delegate.pointermovecaptured,
                true
              );
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                $3.MouseTracker.unprefixedPointerEvents ? "pointerup" : "MSPointerUp",
                delegate.pointerupcaptured,
                true
              );
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                "touchmove",
                delegate.touchmovecaptured,
                true
              );
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                "touchend",
                delegate.touchendcaptured,
                true
              );
              delegate.activePointersLists[i2].captureCount = 0;
            }
          }
          for (i2 = 0; i2 < pointerListCount; i2++) {
            delegate.activePointersLists.pop();
          }
        }
        function startTracking(tracker) {
          var delegate = THIS[tracker.hash], event, i2;
          if (!delegate.tracking) {
            for (i2 = 0; i2 < $3.MouseTracker.subscribeEvents.length; i2++) {
              event = $3.MouseTracker.subscribeEvents[i2];
              $3.addEvent(
                tracker.element,
                event,
                delegate[event],
                false
              );
            }
            clearTrackedPointers(tracker);
            delegate.tracking = true;
          }
        }
        function stopTracking(tracker) {
          var delegate = THIS[tracker.hash], event, i2;
          if (delegate.tracking) {
            for (i2 = 0; i2 < $3.MouseTracker.subscribeEvents.length; i2++) {
              event = $3.MouseTracker.subscribeEvents[i2];
              $3.removeEvent(
                tracker.element,
                event,
                delegate[event],
                false
              );
            }
            clearTrackedPointers(tracker);
            delegate.tracking = false;
          }
        }
        function getCaptureEventParams(tracker, pointerType) {
          var delegate = THIS[tracker.hash];
          if (pointerType === "pointerevent") {
            return {
              upName: $3.MouseTracker.unprefixedPointerEvents ? "pointerup" : "MSPointerUp",
              upHandler: delegate.pointerupcaptured,
              moveName: $3.MouseTracker.unprefixedPointerEvents ? "pointermove" : "MSPointerMove",
              moveHandler: delegate.pointermovecaptured
            };
          } else if (pointerType === "mouse") {
            return {
              upName: "mouseup",
              upHandler: delegate.mouseupcaptured,
              moveName: "mousemove",
              moveHandler: delegate.mousemovecaptured
            };
          } else if (pointerType === "touch") {
            return {
              upName: "touchend",
              upHandler: delegate.touchendcaptured,
              moveName: "touchmove",
              moveHandler: delegate.touchmovecaptured
            };
          } else {
            throw new Error("MouseTracker.getCaptureEventParams: Unknown pointer type.");
          }
        }
        function capturePointer(tracker, pointerType, pointerCount) {
          var pointsList = tracker.getActivePointersListByType(pointerType), eventParams;
          pointsList.captureCount += pointerCount || 1;
          if (pointsList.captureCount === 1) {
            if ($3.Browser.vendor === $3.BROWSERS.IE && $3.Browser.version < 9) {
              tracker.element.setCapture(true);
            } else {
              eventParams = getCaptureEventParams(tracker, $3.MouseTracker.havePointerEvents ? "pointerevent" : pointerType);
              if (isInIframe && canAccessEvents(window.top)) {
                $3.addEvent(
                  window.top,
                  eventParams.upName,
                  eventParams.upHandler,
                  true
                );
              }
              $3.addEvent(
                $3.MouseTracker.captureElement,
                eventParams.upName,
                eventParams.upHandler,
                true
              );
              $3.addEvent(
                $3.MouseTracker.captureElement,
                eventParams.moveName,
                eventParams.moveHandler,
                true
              );
            }
          }
        }
        function releasePointer(tracker, pointerType, pointerCount) {
          var pointsList = tracker.getActivePointersListByType(pointerType), eventParams;
          pointsList.captureCount -= pointerCount || 1;
          if (pointsList.captureCount === 0) {
            if ($3.Browser.vendor === $3.BROWSERS.IE && $3.Browser.version < 9) {
              tracker.element.releaseCapture();
            } else {
              eventParams = getCaptureEventParams(tracker, $3.MouseTracker.havePointerEvents ? "pointerevent" : pointerType);
              if (isInIframe && canAccessEvents(window.top)) {
                $3.removeEvent(
                  window.top,
                  eventParams.upName,
                  eventParams.upHandler,
                  true
                );
              }
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                eventParams.moveName,
                eventParams.moveHandler,
                true
              );
              $3.removeEvent(
                $3.MouseTracker.captureElement,
                eventParams.upName,
                eventParams.upHandler,
                true
              );
            }
          }
        }
        function getPointerType(event) {
          var pointerTypeStr;
          if ($3.MouseTracker.unprefixedPointerEvents) {
            pointerTypeStr = event.pointerType;
          } else {
            switch (event.pointerType) {
              case 2:
                pointerTypeStr = "touch";
                break;
              case 3:
                pointerTypeStr = "pen";
                break;
              case 4:
                pointerTypeStr = "mouse";
                break;
              default:
                pointerTypeStr = "";
            }
          }
          return pointerTypeStr;
        }
        function getMouseAbsolute(event) {
          return $3.getMousePosition(event);
        }
        function getMouseRelative(event, element) {
          return getPointRelativeToAbsolute(getMouseAbsolute(event), element);
        }
        function getPointRelativeToAbsolute(point, element) {
          var offset2 = $3.getElementOffset(element);
          return point.minus(offset2);
        }
        function getCenterPoint(point1, point2) {
          return new $3.Point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);
        }
        function onClick(tracker, event) {
          if (tracker.clickHandler) {
            $3.cancelEvent(event);
          }
        }
        function onDblClick(tracker, event) {
          if (tracker.dblClickHandler) {
            $3.cancelEvent(event);
          }
        }
        function onKeyDown(tracker, event) {
          var propagate;
          if (tracker.keyDownHandler) {
            event = $3.getEvent(event);
            propagate = tracker.keyDownHandler(
              {
                eventSource: tracker,
                keyCode: event.keyCode ? event.keyCode : event.charCode,
                ctrl: event.ctrlKey,
                shift: event.shiftKey,
                alt: event.altKey,
                meta: event.metaKey,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (!propagate) {
              $3.cancelEvent(event);
            }
          }
        }
        function onKeyUp(tracker, event) {
          var propagate;
          if (tracker.keyUpHandler) {
            event = $3.getEvent(event);
            propagate = tracker.keyUpHandler(
              {
                eventSource: tracker,
                keyCode: event.keyCode ? event.keyCode : event.charCode,
                ctrl: event.ctrlKey,
                shift: event.shiftKey,
                alt: event.altKey,
                meta: event.metaKey,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (!propagate) {
              $3.cancelEvent(event);
            }
          }
        }
        function onKeyPress(tracker, event) {
          var propagate;
          if (tracker.keyHandler) {
            event = $3.getEvent(event);
            propagate = tracker.keyHandler(
              {
                eventSource: tracker,
                keyCode: event.keyCode ? event.keyCode : event.charCode,
                ctrl: event.ctrlKey,
                shift: event.shiftKey,
                alt: event.altKey,
                meta: event.metaKey,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (!propagate) {
              $3.cancelEvent(event);
            }
          }
        }
        function onFocus(tracker, event) {
          var propagate;
          if (tracker.focusHandler) {
            event = $3.getEvent(event);
            propagate = tracker.focusHandler(
              {
                eventSource: tracker,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $3.cancelEvent(event);
            }
          }
        }
        function onBlur(tracker, event) {
          var propagate;
          if (tracker.blurHandler) {
            event = $3.getEvent(event);
            propagate = tracker.blurHandler(
              {
                eventSource: tracker,
                originalEvent: event,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $3.cancelEvent(event);
            }
          }
        }
        function onWheel(tracker, event) {
          handleWheelEvent(tracker, event, event);
        }
        function onMouseWheel(tracker, event) {
          event = $3.getEvent(event);
          var simulatedEvent = {
            target: event.target || event.srcElement,
            type: "wheel",
            shiftKey: event.shiftKey || false,
            clientX: event.clientX,
            clientY: event.clientY,
            pageX: event.pageX ? event.pageX : event.clientX,
            pageY: event.pageY ? event.pageY : event.clientY,
            deltaMode: event.type == "MozMousePixelScroll" ? 0 : 1,
            deltaX: 0,
            deltaZ: 0
          };
          if ($3.MouseTracker.wheelEventName == "mousewheel") {
            simulatedEvent.deltaY = -event.wheelDelta / $3.DEFAULT_SETTINGS.pixelsPerWheelLine;
          } else {
            simulatedEvent.deltaY = event.detail;
          }
          handleWheelEvent(tracker, simulatedEvent, event);
        }
        function handleWheelEvent(tracker, event, originalEvent) {
          var nDelta = 0, propagate;
          nDelta = event.deltaY < 0 ? 1 : -1;
          if (tracker.scrollHandler) {
            propagate = tracker.scrollHandler(
              {
                eventSource: tracker,
                pointerType: "mouse",
                position: getMouseRelative(event, tracker.element),
                scroll: nDelta,
                shift: event.shiftKey,
                isTouchEvent: false,
                originalEvent,
                preventDefaultAction: false,
                userData: tracker.userData
              }
            );
            if (propagate === false) {
              $3.cancelEvent(originalEvent);
            }
          }
        }
        function isParentChild(parent, child) {
          if (parent === child) {
            return false;
          }
          while (child && child !== parent) {
            child = child.parentNode;
          }
          return child === parent;
        }
        function onMouseEnter(tracker, event) {
          event = $3.getEvent(event);
          handleMouseEnter(tracker, event);
        }
        function onMouseOver(tracker, event) {
          event = $3.getEvent(event);
          if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
            return;
          }
          handleMouseEnter(tracker, event);
        }
        function handleMouseEnter(tracker, event) {
          var gPoint = {
            id: $3.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          updatePointersEnter(tracker, event, [gPoint]);
        }
        function onMouseLeave(tracker, event) {
          event = $3.getEvent(event);
          handleMouseExit(tracker, event);
        }
        function onMouseOut(tracker, event) {
          event = $3.getEvent(event);
          if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
            return;
          }
          handleMouseExit(tracker, event);
        }
        function handleMouseExit(tracker, event) {
          var gPoint = {
            id: $3.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          updatePointersExit(tracker, event, [gPoint]);
        }
        function getStandardizedButton(button) {
          if ($3.Browser.vendor === $3.BROWSERS.IE && $3.Browser.version < 9) {
            if (button === 1) {
              return 0;
            } else if (button === 2) {
              return 2;
            } else if (button === 4) {
              return 1;
            } else {
              return -1;
            }
          } else {
            return button;
          }
        }
        function onMouseDown(tracker, event) {
          var gPoint;
          event = $3.getEvent(event);
          gPoint = {
            id: $3.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          if (updatePointersDown(tracker, event, [gPoint], getStandardizedButton(event.button))) {
            $3.stopEvent(event);
            capturePointer(tracker, "mouse");
          }
          if (tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler) {
            $3.cancelEvent(event);
          }
        }
        function onMouseUp(tracker, event) {
          handleMouseUp(tracker, event);
        }
        function onMouseUpCaptured(tracker, event) {
          handleMouseUp(tracker, event);
          $3.stopEvent(event);
        }
        function handleMouseUp(tracker, event) {
          var gPoint;
          event = $3.getEvent(event);
          gPoint = {
            id: $3.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          if (updatePointersUp(tracker, event, [gPoint], getStandardizedButton(event.button))) {
            releasePointer(tracker, "mouse");
          }
        }
        function onMouseMove(tracker, event) {
          handleMouseMove(tracker, event);
        }
        function onMouseMoveCaptured(tracker, event) {
          handleMouseMove(tracker, event);
          $3.stopEvent(event);
        }
        function handleMouseMove(tracker, event) {
          var gPoint;
          event = $3.getEvent(event);
          gPoint = {
            id: $3.MouseTracker.mousePointerId,
            type: "mouse",
            isPrimary: true,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          updatePointersMove(tracker, event, [gPoint]);
        }
        function abortContacts(tracker, event, pointsList) {
          var i2, gPointCount = pointsList.getLength(), abortGPoints = [];
          if (pointsList.type === "touch" || pointsList.contacts > 0) {
            for (i2 = 0; i2 < gPointCount; i2++) {
              abortGPoints.push(pointsList.getByIndex(i2));
            }
            if (abortGPoints.length > 0) {
              updatePointersUp(tracker, event, abortGPoints, 0);
              pointsList.captureCount = 1;
              releasePointer(tracker, pointsList.type);
              updatePointersExit(tracker, event, abortGPoints);
            }
          }
        }
        function onTouchStart(tracker, event) {
          var time, i2, j3, touchCount = event.changedTouches.length, gPoints = [], parentGPoints, pointsList = tracker.getActivePointersListByType("touch");
          time = $3.now();
          if (pointsList.getLength() > event.touches.length - touchCount) {
            $3.console.warn("Tracked touch contact count doesn't match event.touches.length. Removing all tracked touch pointers.");
            abortContacts(tracker, event, pointsList);
          }
          for (i2 = 0; i2 < touchCount; i2++) {
            gPoints.push({
              id: event.changedTouches[i2].identifier,
              type: "touch",
              currentPos: getMouseAbsolute(event.changedTouches[i2]),
              currentTime: time
            });
          }
          updatePointersEnter(tracker, event, gPoints);
          for (i2 = 0; i2 < MOUSETRACKERS.length; i2++) {
            if (MOUSETRACKERS[i2] !== tracker && MOUSETRACKERS[i2].isTracking() && isParentChild(MOUSETRACKERS[i2].element, tracker.element)) {
              parentGPoints = [];
              for (j3 = 0; j3 < touchCount; j3++) {
                parentGPoints.push({
                  id: event.changedTouches[j3].identifier,
                  type: "touch",
                  currentPos: getMouseAbsolute(event.changedTouches[j3]),
                  currentTime: time
                });
              }
              updatePointersEnter(MOUSETRACKERS[i2], event, parentGPoints);
            }
          }
          if (updatePointersDown(tracker, event, gPoints, 0)) {
            $3.stopEvent(event);
            capturePointer(tracker, "touch", touchCount);
          }
          $3.cancelEvent(event);
        }
        function onTouchEnd(tracker, event) {
          handleTouchEnd(tracker, event);
        }
        function onTouchEndCaptured(tracker, event) {
          handleTouchEnd(tracker, event);
          $3.stopEvent(event);
        }
        function handleTouchEnd(tracker, event) {
          var time, i2, j3, touchCount = event.changedTouches.length, gPoints = [], parentGPoints;
          time = $3.now();
          for (i2 = 0; i2 < touchCount; i2++) {
            gPoints.push({
              id: event.changedTouches[i2].identifier,
              type: "touch",
              currentPos: getMouseAbsolute(event.changedTouches[i2]),
              currentTime: time
            });
          }
          if (updatePointersUp(tracker, event, gPoints, 0)) {
            releasePointer(tracker, "touch", touchCount);
          }
          updatePointersExit(tracker, event, gPoints);
          for (i2 = 0; i2 < MOUSETRACKERS.length; i2++) {
            if (MOUSETRACKERS[i2] !== tracker && MOUSETRACKERS[i2].isTracking() && isParentChild(MOUSETRACKERS[i2].element, tracker.element)) {
              parentGPoints = [];
              for (j3 = 0; j3 < touchCount; j3++) {
                parentGPoints.push({
                  id: event.changedTouches[j3].identifier,
                  type: "touch",
                  currentPos: getMouseAbsolute(event.changedTouches[j3]),
                  currentTime: time
                });
              }
              updatePointersExit(MOUSETRACKERS[i2], event, parentGPoints);
            }
          }
          $3.cancelEvent(event);
        }
        function onTouchMove(tracker, event) {
          handleTouchMove(tracker, event);
        }
        function onTouchMoveCaptured(tracker, event) {
          handleTouchMove(tracker, event);
          $3.stopEvent(event);
        }
        function handleTouchMove(tracker, event) {
          var i2, touchCount = event.changedTouches.length, gPoints = [];
          for (i2 = 0; i2 < touchCount; i2++) {
            gPoints.push({
              id: event.changedTouches[i2].identifier,
              type: "touch",
              currentPos: getMouseAbsolute(event.changedTouches[i2]),
              currentTime: $3.now()
            });
          }
          updatePointersMove(tracker, event, gPoints);
          $3.cancelEvent(event);
        }
        function onTouchCancel(tracker, event) {
          var pointsList = tracker.getActivePointersListByType("touch");
          abortContacts(tracker, event, pointsList);
        }
        function onGestureStart(tracker, event) {
          event.stopPropagation();
          event.preventDefault();
          return false;
        }
        function onGestureChange(tracker, event) {
          event.stopPropagation();
          event.preventDefault();
          return false;
        }
        function onPointerOver(tracker, event) {
          var gPoint;
          if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
            return;
          }
          gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          updatePointersEnter(tracker, event, [gPoint]);
        }
        function onPointerOut(tracker, event) {
          var gPoint;
          if (event.currentTarget === event.relatedTarget || isParentChild(event.currentTarget, event.relatedTarget)) {
            return;
          }
          gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          updatePointersExit(tracker, event, [gPoint]);
        }
        function onPointerDown(tracker, event) {
          var gPoint;
          gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          if (updatePointersDown(tracker, event, [gPoint], event.button)) {
            $3.stopEvent(event);
            capturePointer(tracker, gPoint.type);
          }
          if (tracker.clickHandler || tracker.dblClickHandler || tracker.pressHandler || tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
            $3.cancelEvent(event);
          }
        }
        function onPointerUp(tracker, event) {
          handlePointerUp(tracker, event);
        }
        function onPointerUpCaptured(tracker, event) {
          var pointsList = tracker.getActivePointersListByType(getPointerType(event));
          if (pointsList.getById(event.pointerId)) {
            handlePointerUp(tracker, event);
          }
          $3.stopEvent(event);
        }
        function handlePointerUp(tracker, event) {
          var gPoint;
          gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          if (updatePointersUp(tracker, event, [gPoint], event.button)) {
            releasePointer(tracker, gPoint.type);
          }
        }
        function onPointerMove(tracker, event) {
          handlePointerMove(tracker, event);
        }
        function onPointerMoveCaptured(tracker, event) {
          var pointsList = tracker.getActivePointersListByType(getPointerType(event));
          if (pointsList.getById(event.pointerId)) {
            handlePointerMove(tracker, event);
          }
          $3.stopEvent(event);
        }
        function handlePointerMove(tracker, event) {
          var gPoint;
          gPoint = {
            id: event.pointerId,
            type: getPointerType(event),
            isPrimary: event.isPrimary,
            currentPos: getMouseAbsolute(event),
            currentTime: $3.now()
          };
          updatePointersMove(tracker, event, [gPoint]);
        }
        function onPointerCancel(tracker, event) {
          var gPoint;
          gPoint = {
            id: event.pointerId,
            type: getPointerType(event)
          };
          updatePointersCancel(tracker, event, [gPoint]);
        }
        function startTrackingPointer(pointsList, gPoint) {
          if (!Object.prototype.hasOwnProperty.call(gPoint, "isPrimary")) {
            if (pointsList.getLength() === 0) {
              gPoint.isPrimary = true;
            } else {
              gPoint.isPrimary = false;
            }
          }
          gPoint.speed = 0;
          gPoint.direction = 0;
          gPoint.contactPos = gPoint.currentPos;
          gPoint.contactTime = gPoint.currentTime;
          gPoint.lastPos = gPoint.currentPos;
          gPoint.lastTime = gPoint.currentTime;
          return pointsList.add(gPoint);
        }
        function stopTrackingPointer(pointsList, gPoint) {
          var listLength, primaryPoint;
          if (pointsList.getById(gPoint.id)) {
            listLength = pointsList.removeById(gPoint.id);
            if (!Object.prototype.hasOwnProperty.call(gPoint, "isPrimary")) {
              primaryPoint = pointsList.getPrimary();
              if (!primaryPoint) {
                primaryPoint = pointsList.getByIndex(0);
                if (primaryPoint) {
                  primaryPoint.isPrimary = true;
                }
              }
            }
          } else {
            listLength = pointsList.getLength();
          }
          return listLength;
        }
        function updatePointersEnter(tracker, event, gPoints) {
          var pointsList = tracker.getActivePointersListByType(gPoints[0].type), i2, gPointCount = gPoints.length, curGPoint, updateGPoint, propagate;
          for (i2 = 0; i2 < gPointCount; i2++) {
            curGPoint = gPoints[i2];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
              updateGPoint.insideElement = true;
              updateGPoint.lastPos = updateGPoint.currentPos;
              updateGPoint.lastTime = updateGPoint.currentTime;
              updateGPoint.currentPos = curGPoint.currentPos;
              updateGPoint.currentTime = curGPoint.currentTime;
              curGPoint = updateGPoint;
            } else {
              curGPoint.captured = false;
              curGPoint.insideElementPressed = false;
              curGPoint.insideElement = true;
              startTrackingPointer(pointsList, curGPoint);
            }
            if (tracker.enterHandler) {
              propagate = tracker.enterHandler(
                {
                  eventSource: tracker,
                  pointerType: curGPoint.type,
                  position: getPointRelativeToAbsolute(curGPoint.currentPos, tracker.element),
                  buttons: pointsList.buttons,
                  pointers: tracker.getActivePointerCount(),
                  insideElementPressed: curGPoint.insideElementPressed,
                  buttonDownAny: pointsList.buttons !== 0,
                  isTouchEvent: curGPoint.type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
          }
        }
        function updatePointersExit(tracker, event, gPoints) {
          var pointsList = tracker.getActivePointersListByType(gPoints[0].type), i2, gPointCount = gPoints.length, curGPoint, updateGPoint, propagate;
          for (i2 = 0; i2 < gPointCount; i2++) {
            curGPoint = gPoints[i2];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
              if (updateGPoint.captured) {
                updateGPoint.insideElement = false;
                updateGPoint.lastPos = updateGPoint.currentPos;
                updateGPoint.lastTime = updateGPoint.currentTime;
                updateGPoint.currentPos = curGPoint.currentPos;
                updateGPoint.currentTime = curGPoint.currentTime;
              } else {
                stopTrackingPointer(pointsList, updateGPoint);
              }
              curGPoint = updateGPoint;
            }
            if (tracker.exitHandler) {
              propagate = tracker.exitHandler(
                {
                  eventSource: tracker,
                  pointerType: curGPoint.type,
                  position: curGPoint.currentPos && getPointRelativeToAbsolute(curGPoint.currentPos, tracker.element),
                  buttons: pointsList.buttons,
                  pointers: tracker.getActivePointerCount(),
                  insideElementPressed: updateGPoint ? updateGPoint.insideElementPressed : false,
                  buttonDownAny: pointsList.buttons !== 0,
                  isTouchEvent: curGPoint.type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
          }
        }
        function updatePointersDown(tracker, event, gPoints, buttonChanged) {
          var delegate = THIS[tracker.hash], propagate, pointsList = tracker.getActivePointersListByType(gPoints[0].type), i2, gPointCount = gPoints.length, curGPoint, updateGPoint;
          if (typeof event.buttons !== "undefined") {
            pointsList.buttons = event.buttons;
          } else {
            if ($3.Browser.vendor === $3.BROWSERS.IE && $3.Browser.version < 9) {
              if (buttonChanged === 0) {
                pointsList.buttons += 1;
              } else if (buttonChanged === 1) {
                pointsList.buttons += 4;
              } else if (buttonChanged === 2) {
                pointsList.buttons += 2;
              } else if (buttonChanged === 3) {
                pointsList.buttons += 8;
              } else if (buttonChanged === 4) {
                pointsList.buttons += 16;
              } else if (buttonChanged === 5) {
                pointsList.buttons += 32;
              }
            } else {
              if (buttonChanged === 0) {
                pointsList.buttons |= 1;
              } else if (buttonChanged === 1) {
                pointsList.buttons |= 4;
              } else if (buttonChanged === 2) {
                pointsList.buttons |= 2;
              } else if (buttonChanged === 3) {
                pointsList.buttons |= 8;
              } else if (buttonChanged === 4) {
                pointsList.buttons |= 16;
              } else if (buttonChanged === 5) {
                pointsList.buttons |= 32;
              }
            }
          }
          var otherPointsLists = tracker.getActivePointersListsExceptType(gPoints[0].type);
          for (i2 = 0; i2 < otherPointsLists.length; i2++) {
            abortContacts(tracker, event, otherPointsLists[i2]);
          }
          if (buttonChanged !== 0) {
            if (tracker.nonPrimaryPressHandler) {
              propagate = tracker.nonPrimaryPressHandler(
                {
                  eventSource: tracker,
                  pointerType: gPoints[0].type,
                  position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                  button: buttonChanged,
                  buttons: pointsList.buttons,
                  isTouchEvent: gPoints[0].type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
            return false;
          }
          for (i2 = 0; i2 < gPointCount; i2++) {
            curGPoint = gPoints[i2];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
              updateGPoint.captured = true;
              updateGPoint.insideElementPressed = true;
              updateGPoint.insideElement = true;
              updateGPoint.contactPos = curGPoint.currentPos;
              updateGPoint.contactTime = curGPoint.currentTime;
              updateGPoint.lastPos = updateGPoint.currentPos;
              updateGPoint.lastTime = updateGPoint.currentTime;
              updateGPoint.currentPos = curGPoint.currentPos;
              updateGPoint.currentTime = curGPoint.currentTime;
              curGPoint = updateGPoint;
            } else {
              curGPoint.captured = true;
              curGPoint.insideElementPressed = true;
              curGPoint.insideElement = true;
              startTrackingPointer(pointsList, curGPoint);
            }
            pointsList.addContact();
            if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
              $3.MouseTracker.gesturePointVelocityTracker.addPoint(tracker, curGPoint);
            }
            if (pointsList.contacts === 1) {
              if (tracker.pressHandler) {
                propagate = tracker.pressHandler(
                  {
                    eventSource: tracker,
                    pointerType: curGPoint.type,
                    position: getPointRelativeToAbsolute(curGPoint.contactPos, tracker.element),
                    buttons: pointsList.buttons,
                    isTouchEvent: curGPoint.type === "touch",
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                  }
                );
                if (propagate === false) {
                  $3.cancelEvent(event);
                }
              }
            } else if (pointsList.contacts === 2) {
              if (tracker.pinchHandler && curGPoint.type === "touch") {
                delegate.pinchGPoints = pointsList.asArray();
                delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
                delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
              }
            }
          }
          return true;
        }
        function updatePointersUp(tracker, event, gPoints, buttonChanged) {
          var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoints[0].type), propagate, releasePoint, releaseTime, i2, gPointCount = gPoints.length, curGPoint, updateGPoint, releaseCapture = false, wasCaptured = false, quick;
          if (typeof event.buttons !== "undefined") {
            pointsList.buttons = event.buttons;
          } else {
            if ($3.Browser.vendor === $3.BROWSERS.IE && $3.Browser.version < 9) {
              if (buttonChanged === 0) {
                pointsList.buttons -= 1;
              } else if (buttonChanged === 1) {
                pointsList.buttons -= 4;
              } else if (buttonChanged === 2) {
                pointsList.buttons -= 2;
              } else if (buttonChanged === 3) {
                pointsList.buttons -= 8;
              } else if (buttonChanged === 4) {
                pointsList.buttons -= 16;
              } else if (buttonChanged === 5) {
                pointsList.buttons -= 32;
              }
            } else {
              if (buttonChanged === 0) {
                pointsList.buttons ^= ~1;
              } else if (buttonChanged === 1) {
                pointsList.buttons ^= ~4;
              } else if (buttonChanged === 2) {
                pointsList.buttons ^= ~2;
              } else if (buttonChanged === 3) {
                pointsList.buttons ^= ~8;
              } else if (buttonChanged === 4) {
                pointsList.buttons ^= ~16;
              } else if (buttonChanged === 5) {
                pointsList.buttons ^= ~32;
              }
            }
          }
          if (buttonChanged !== 0) {
            if (tracker.nonPrimaryReleaseHandler) {
              propagate = tracker.nonPrimaryReleaseHandler(
                {
                  eventSource: tracker,
                  pointerType: gPoints[0].type,
                  position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                  button: buttonChanged,
                  buttons: pointsList.buttons,
                  isTouchEvent: gPoints[0].type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
            var otherPointsList = tracker.getActivePointersListByType("mouse");
            abortContacts(tracker, event, otherPointsList);
            return false;
          }
          if (typeof gPoints[0].currentPos === "undefined") {
            abortContacts(tracker, event, pointsList);
            return false;
          }
          for (i2 = 0; i2 < gPointCount; i2++) {
            curGPoint = gPoints[i2];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
              if (updateGPoint.captured) {
                updateGPoint.captured = false;
                releaseCapture = true;
                wasCaptured = true;
              }
              updateGPoint.lastPos = updateGPoint.currentPos;
              updateGPoint.lastTime = updateGPoint.currentTime;
              updateGPoint.currentPos = curGPoint.currentPos;
              updateGPoint.currentTime = curGPoint.currentTime;
              if (!updateGPoint.insideElement) {
                stopTrackingPointer(pointsList, updateGPoint);
              }
              releasePoint = updateGPoint.currentPos;
              releaseTime = updateGPoint.currentTime;
              if (wasCaptured) {
                pointsList.removeContact();
                if (tracker.dragHandler || tracker.dragEndHandler || tracker.pinchHandler) {
                  $3.MouseTracker.gesturePointVelocityTracker.removePoint(tracker, updateGPoint);
                }
                if (pointsList.contacts === 0) {
                  if (tracker.releaseHandler) {
                    propagate = tracker.releaseHandler(
                      {
                        eventSource: tracker,
                        pointerType: updateGPoint.type,
                        position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                        buttons: pointsList.buttons,
                        insideElementPressed: updateGPoint.insideElementPressed,
                        insideElementReleased: updateGPoint.insideElement,
                        isTouchEvent: updateGPoint.type === "touch",
                        originalEvent: event,
                        preventDefaultAction: false,
                        userData: tracker.userData
                      }
                    );
                    if (propagate === false) {
                      $3.cancelEvent(event);
                    }
                  }
                  if (tracker.dragEndHandler && !updateGPoint.currentPos.equals(updateGPoint.contactPos)) {
                    propagate = tracker.dragEndHandler(
                      {
                        eventSource: tracker,
                        pointerType: updateGPoint.type,
                        position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                        speed: updateGPoint.speed,
                        direction: updateGPoint.direction,
                        shift: event.shiftKey,
                        isTouchEvent: updateGPoint.type === "touch",
                        originalEvent: event,
                        preventDefaultAction: false,
                        userData: tracker.userData
                      }
                    );
                    if (propagate === false) {
                      $3.cancelEvent(event);
                    }
                  }
                  if ((tracker.clickHandler || tracker.dblClickHandler) && updateGPoint.insideElement) {
                    quick = releaseTime - updateGPoint.contactTime <= tracker.clickTimeThreshold && updateGPoint.contactPos.distanceTo(releasePoint) <= tracker.clickDistThreshold;
                    if (tracker.clickHandler) {
                      propagate = tracker.clickHandler(
                        {
                          eventSource: tracker,
                          pointerType: updateGPoint.type,
                          position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                          quick,
                          shift: event.shiftKey,
                          isTouchEvent: updateGPoint.type === "touch",
                          originalEvent: event,
                          preventDefaultAction: false,
                          userData: tracker.userData
                        }
                      );
                      if (propagate === false) {
                        $3.cancelEvent(event);
                      }
                    }
                    if (tracker.dblClickHandler && quick) {
                      pointsList.clicks++;
                      if (pointsList.clicks === 1) {
                        delegate.lastClickPos = releasePoint;
                        delegate.dblClickTimeOut = setTimeout(function() {
                          pointsList.clicks = 0;
                        }, tracker.dblClickTimeThreshold);
                      } else if (pointsList.clicks === 2) {
                        clearTimeout(delegate.dblClickTimeOut);
                        pointsList.clicks = 0;
                        if (delegate.lastClickPos.distanceTo(releasePoint) <= tracker.dblClickDistThreshold) {
                          propagate = tracker.dblClickHandler(
                            {
                              eventSource: tracker,
                              pointerType: updateGPoint.type,
                              position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                              shift: event.shiftKey,
                              isTouchEvent: updateGPoint.type === "touch",
                              originalEvent: event,
                              preventDefaultAction: false,
                              userData: tracker.userData
                            }
                          );
                          if (propagate === false) {
                            $3.cancelEvent(event);
                          }
                        }
                        delegate.lastClickPos = null;
                      }
                    }
                  }
                } else if (pointsList.contacts === 2) {
                  if (tracker.pinchHandler && updateGPoint.type === "touch") {
                    delegate.pinchGPoints = pointsList.asArray();
                    delegate.lastPinchDist = delegate.currentPinchDist = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
                    delegate.lastPinchCenter = delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
                  }
                }
              } else {
                if (tracker.releaseHandler) {
                  propagate = tracker.releaseHandler(
                    {
                      eventSource: tracker,
                      pointerType: updateGPoint.type,
                      position: getPointRelativeToAbsolute(releasePoint, tracker.element),
                      buttons: pointsList.buttons,
                      insideElementPressed: updateGPoint.insideElementPressed,
                      insideElementReleased: updateGPoint.insideElement,
                      isTouchEvent: updateGPoint.type === "touch",
                      originalEvent: event,
                      preventDefaultAction: false,
                      userData: tracker.userData
                    }
                  );
                  if (propagate === false) {
                    $3.cancelEvent(event);
                  }
                }
              }
            }
          }
          return releaseCapture;
        }
        function updatePointersMove(tracker, event, gPoints) {
          var delegate = THIS[tracker.hash], pointsList = tracker.getActivePointersListByType(gPoints[0].type), i2, gPointCount = gPoints.length, curGPoint, updateGPoint, gPointArray, delta, propagate;
          if (typeof event.buttons !== "undefined") {
            pointsList.buttons = event.buttons;
          }
          for (i2 = 0; i2 < gPointCount; i2++) {
            curGPoint = gPoints[i2];
            updateGPoint = pointsList.getById(curGPoint.id);
            if (updateGPoint) {
              if (Object.prototype.hasOwnProperty.call(curGPoint, "isPrimary")) {
                updateGPoint.isPrimary = curGPoint.isPrimary;
              }
              updateGPoint.lastPos = updateGPoint.currentPos;
              updateGPoint.lastTime = updateGPoint.currentTime;
              updateGPoint.currentPos = curGPoint.currentPos;
              updateGPoint.currentTime = curGPoint.currentTime;
            } else {
              curGPoint.captured = false;
              curGPoint.insideElementPressed = false;
              curGPoint.insideElement = true;
              startTrackingPointer(pointsList, curGPoint);
            }
          }
          if (tracker.stopHandler && gPoints[0].type === "mouse") {
            clearTimeout(tracker.stopTimeOut);
            tracker.stopTimeOut = setTimeout(function() {
              handlePointerStop(tracker, event, gPoints[0].type);
            }, tracker.stopDelay);
          }
          if (pointsList.contacts === 0) {
            if (tracker.moveHandler) {
              propagate = tracker.moveHandler(
                {
                  eventSource: tracker,
                  pointerType: gPoints[0].type,
                  position: getPointRelativeToAbsolute(gPoints[0].currentPos, tracker.element),
                  buttons: pointsList.buttons,
                  isTouchEvent: gPoints[0].type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
          } else if (pointsList.contacts === 1) {
            if (tracker.moveHandler) {
              updateGPoint = pointsList.asArray()[0];
              propagate = tracker.moveHandler(
                {
                  eventSource: tracker,
                  pointerType: updateGPoint.type,
                  position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                  buttons: pointsList.buttons,
                  isTouchEvent: updateGPoint.type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
            if (tracker.dragHandler) {
              updateGPoint = pointsList.asArray()[0];
              delta = updateGPoint.currentPos.minus(updateGPoint.lastPos);
              propagate = tracker.dragHandler(
                {
                  eventSource: tracker,
                  pointerType: updateGPoint.type,
                  position: getPointRelativeToAbsolute(updateGPoint.currentPos, tracker.element),
                  buttons: pointsList.buttons,
                  delta,
                  speed: updateGPoint.speed,
                  direction: updateGPoint.direction,
                  shift: event.shiftKey,
                  isTouchEvent: updateGPoint.type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
          } else if (pointsList.contacts === 2) {
            if (tracker.moveHandler) {
              gPointArray = pointsList.asArray();
              propagate = tracker.moveHandler(
                {
                  eventSource: tracker,
                  pointerType: gPointArray[0].type,
                  position: getPointRelativeToAbsolute(getCenterPoint(gPointArray[0].currentPos, gPointArray[1].currentPos), tracker.element),
                  buttons: pointsList.buttons,
                  isTouchEvent: gPointArray[0].type === "touch",
                  originalEvent: event,
                  preventDefaultAction: false,
                  userData: tracker.userData
                }
              );
              if (propagate === false) {
                $3.cancelEvent(event);
              }
            }
            if (tracker.pinchHandler && gPoints[0].type === "touch") {
              delta = delegate.pinchGPoints[0].currentPos.distanceTo(delegate.pinchGPoints[1].currentPos);
              if (delta != delegate.currentPinchDist) {
                delegate.lastPinchDist = delegate.currentPinchDist;
                delegate.currentPinchDist = delta;
                delegate.lastPinchCenter = delegate.currentPinchCenter;
                delegate.currentPinchCenter = getCenterPoint(delegate.pinchGPoints[0].currentPos, delegate.pinchGPoints[1].currentPos);
                propagate = tracker.pinchHandler(
                  {
                    eventSource: tracker,
                    pointerType: "touch",
                    gesturePoints: delegate.pinchGPoints,
                    lastCenter: getPointRelativeToAbsolute(delegate.lastPinchCenter, tracker.element),
                    center: getPointRelativeToAbsolute(delegate.currentPinchCenter, tracker.element),
                    lastDistance: delegate.lastPinchDist,
                    distance: delegate.currentPinchDist,
                    shift: event.shiftKey,
                    originalEvent: event,
                    preventDefaultAction: false,
                    userData: tracker.userData
                  }
                );
                if (propagate === false) {
                  $3.cancelEvent(event);
                }
              }
            }
          }
        }
        function updatePointersCancel(tracker, event, gPoints) {
          updatePointersUp(tracker, event, gPoints, 0);
          updatePointersExit(tracker, event, gPoints);
        }
        function handlePointerStop(tracker, originalMoveEvent, pointerType) {
          if (tracker.stopHandler) {
            tracker.stopHandler({
              eventSource: tracker,
              pointerType,
              position: getMouseRelative(originalMoveEvent, tracker.element),
              buttons: tracker.getActivePointersListByType(pointerType).buttons,
              isTouchEvent: pointerType === "touch",
              originalEvent: originalMoveEvent,
              preventDefaultAction: false,
              userData: tracker.userData
            });
          }
        }
        var isInIframe = function() {
          try {
            return window.self !== window.top;
          } catch (e3) {
            return true;
          }
        }();
        function canAccessEvents(target) {
          try {
            return target.addEventListener && target.removeEventListener;
          } catch (e3) {
            return false;
          }
        }
      })(OpenSeadragon);
      (function($3) {
        $3.ControlAnchor = {
          NONE: 0,
          TOP_LEFT: 1,
          TOP_RIGHT: 2,
          BOTTOM_RIGHT: 3,
          BOTTOM_LEFT: 4,
          ABSOLUTE: 5
        };
        $3.Control = function(element, options, container2) {
          var parent = element.parentNode;
          if (typeof options === "number") {
            $3.console.error("Passing an anchor directly into the OpenSeadragon.Control constructor is deprecated; please use an options object instead.  Support for this deprecated variant is scheduled for removal in December 2013");
            options = { anchor: options };
          }
          options.attachToViewer = typeof options.attachToViewer === "undefined" ? true : options.attachToViewer;
          this.autoFade = typeof options.autoFade === "undefined" ? true : options.autoFade;
          this.element = element;
          this.anchor = options.anchor;
          this.container = container2;
          if (this.anchor == $3.ControlAnchor.ABSOLUTE) {
            this.wrapper = $3.makeNeutralElement("div");
            this.wrapper.style.position = "absolute";
            this.wrapper.style.top = typeof options.top == "number" ? options.top + "px" : options.top;
            this.wrapper.style.left = typeof options.left == "number" ? options.left + "px" : options.left;
            this.wrapper.style.height = typeof options.height == "number" ? options.height + "px" : options.height;
            this.wrapper.style.width = typeof options.width == "number" ? options.width + "px" : options.width;
            this.wrapper.style.margin = "0px";
            this.wrapper.style.padding = "0px";
            this.element.style.position = "relative";
            this.element.style.top = "0px";
            this.element.style.left = "0px";
            this.element.style.height = "100%";
            this.element.style.width = "100%";
          } else {
            this.wrapper = $3.makeNeutralElement("div");
            this.wrapper.style.display = "inline-block";
            if (this.anchor == $3.ControlAnchor.NONE) {
              this.wrapper.style.width = this.wrapper.style.height = "100%";
            }
          }
          this.wrapper.appendChild(this.element);
          if (options.attachToViewer) {
            if (this.anchor == $3.ControlAnchor.TOP_RIGHT || this.anchor == $3.ControlAnchor.BOTTOM_RIGHT) {
              this.container.insertBefore(
                this.wrapper,
                this.container.firstChild
              );
            } else {
              this.container.appendChild(this.wrapper);
            }
          } else {
            parent.appendChild(this.wrapper);
          }
        };
        $3.Control.prototype = {
          destroy: function() {
            this.wrapper.removeChild(this.element);
            this.container.removeChild(this.wrapper);
          },
          isVisible: function() {
            return this.wrapper.style.display != "none";
          },
          setVisible: function(visible) {
            this.wrapper.style.display = visible ? this.anchor == $3.ControlAnchor.ABSOLUTE ? "block" : "inline-block" : "none";
          },
          setOpacity: function(opacity) {
            if (this.element[$3.SIGNAL] && $3.Browser.vendor == $3.BROWSERS.IE) {
              $3.setElementOpacity(this.element, opacity, true);
            } else {
              $3.setElementOpacity(this.wrapper, opacity, true);
            }
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.ControlDock = function(options) {
          var layouts = ["topleft", "topright", "bottomright", "bottomleft"], layout, i2;
          $3.extend(true, this, {
            id: "controldock-" + $3.now() + "-" + Math.floor(Math.random() * 1e6),
            container: $3.makeNeutralElement("div"),
            controls: []
          }, options);
          this.container.onsubmit = function() {
            return false;
          };
          if (this.element) {
            this.element = $3.getElement(this.element);
            this.element.appendChild(this.container);
            this.element.style.position = "relative";
            this.container.style.width = "100%";
            this.container.style.height = "100%";
          }
          for (i2 = 0; i2 < layouts.length; i2++) {
            layout = layouts[i2];
            this.controls[layout] = $3.makeNeutralElement("div");
            this.controls[layout].style.position = "absolute";
            if (layout.match("left")) {
              this.controls[layout].style.left = "0px";
            }
            if (layout.match("right")) {
              this.controls[layout].style.right = "0px";
            }
            if (layout.match("top")) {
              this.controls[layout].style.top = "0px";
            }
            if (layout.match("bottom")) {
              this.controls[layout].style.bottom = "0px";
            }
          }
          this.container.appendChild(this.controls.topleft);
          this.container.appendChild(this.controls.topright);
          this.container.appendChild(this.controls.bottomright);
          this.container.appendChild(this.controls.bottomleft);
        };
        $3.ControlDock.prototype = {
          addControl: function(element, controlOptions) {
            element = $3.getElement(element);
            var div = null;
            if (getControlIndex(this, element) >= 0) {
              return;
            }
            switch (controlOptions.anchor) {
              case $3.ControlAnchor.TOP_RIGHT:
                div = this.controls.topright;
                element.style.position = "relative";
                element.style.paddingRight = "0px";
                element.style.paddingTop = "0px";
                break;
              case $3.ControlAnchor.BOTTOM_RIGHT:
                div = this.controls.bottomright;
                element.style.position = "relative";
                element.style.paddingRight = "0px";
                element.style.paddingBottom = "0px";
                break;
              case $3.ControlAnchor.BOTTOM_LEFT:
                div = this.controls.bottomleft;
                element.style.position = "relative";
                element.style.paddingLeft = "0px";
                element.style.paddingBottom = "0px";
                break;
              case $3.ControlAnchor.TOP_LEFT:
                div = this.controls.topleft;
                element.style.position = "relative";
                element.style.paddingLeft = "0px";
                element.style.paddingTop = "0px";
                break;
              case $3.ControlAnchor.ABSOLUTE:
                div = this.container;
                element.style.margin = "0px";
                element.style.padding = "0px";
                break;
              default:
              case $3.ControlAnchor.NONE:
                div = this.container;
                element.style.margin = "0px";
                element.style.padding = "0px";
                break;
            }
            this.controls.push(
              new $3.Control(element, controlOptions, div)
            );
            element.style.display = "inline-block";
          },
          removeControl: function(element) {
            element = $3.getElement(element);
            var i2 = getControlIndex(this, element);
            if (i2 >= 0) {
              this.controls[i2].destroy();
              this.controls.splice(i2, 1);
            }
            return this;
          },
          clearControls: function() {
            while (this.controls.length > 0) {
              this.controls.pop().destroy();
            }
            return this;
          },
          areControlsEnabled: function() {
            var i2;
            for (i2 = this.controls.length - 1; i2 >= 0; i2--) {
              if (this.controls[i2].isVisible()) {
                return true;
              }
            }
            return false;
          },
          setControlsEnabled: function(enabled) {
            var i2;
            for (i2 = this.controls.length - 1; i2 >= 0; i2--) {
              this.controls[i2].setVisible(enabled);
            }
            return this;
          }
        };
        function getControlIndex(dock, element) {
          var controls = dock.controls, i2;
          for (i2 = controls.length - 1; i2 >= 0; i2--) {
            if (controls[i2].element == element) {
              return i2;
            }
          }
          return -1;
        }
      })(OpenSeadragon);
      (function($3) {
        $3.Placement = $3.freezeObject({
          CENTER: 0,
          TOP_LEFT: 1,
          TOP: 2,
          TOP_RIGHT: 3,
          RIGHT: 4,
          BOTTOM_RIGHT: 5,
          BOTTOM: 6,
          BOTTOM_LEFT: 7,
          LEFT: 8,
          properties: {
            0: {
              isLeft: false,
              isHorizontallyCentered: true,
              isRight: false,
              isTop: false,
              isVerticallyCentered: true,
              isBottom: false
            },
            1: {
              isLeft: true,
              isHorizontallyCentered: false,
              isRight: false,
              isTop: true,
              isVerticallyCentered: false,
              isBottom: false
            },
            2: {
              isLeft: false,
              isHorizontallyCentered: true,
              isRight: false,
              isTop: true,
              isVerticallyCentered: false,
              isBottom: false
            },
            3: {
              isLeft: false,
              isHorizontallyCentered: false,
              isRight: true,
              isTop: true,
              isVerticallyCentered: false,
              isBottom: false
            },
            4: {
              isLeft: false,
              isHorizontallyCentered: false,
              isRight: true,
              isTop: false,
              isVerticallyCentered: true,
              isBottom: false
            },
            5: {
              isLeft: false,
              isHorizontallyCentered: false,
              isRight: true,
              isTop: false,
              isVerticallyCentered: false,
              isBottom: true
            },
            6: {
              isLeft: false,
              isHorizontallyCentered: true,
              isRight: false,
              isTop: false,
              isVerticallyCentered: false,
              isBottom: true
            },
            7: {
              isLeft: true,
              isHorizontallyCentered: false,
              isRight: false,
              isTop: false,
              isVerticallyCentered: false,
              isBottom: true
            },
            8: {
              isLeft: true,
              isHorizontallyCentered: false,
              isRight: false,
              isTop: false,
              isVerticallyCentered: true,
              isBottom: false
            }
          }
        });
      })(OpenSeadragon);
      (function($3) {
        var THIS = {};
        var nextHash = 1;
        $3.Viewer = function(options) {
          var args = arguments, _this = this, i2;
          if (!$3.isPlainObject(options)) {
            options = {
              id: args[0],
              xmlPath: args.length > 1 ? args[1] : void 0,
              prefixUrl: args.length > 2 ? args[2] : void 0,
              controls: args.length > 3 ? args[3] : void 0,
              overlays: args.length > 4 ? args[4] : void 0
            };
          }
          if (options.config) {
            $3.extend(true, options, options.config);
            delete options.config;
          }
          $3.extend(true, this, {
            id: options.id,
            hash: options.hash || nextHash++,
            initialPage: 0,
            element: null,
            container: null,
            canvas: null,
            overlays: [],
            overlaysContainer: null,
            previousBody: [],
            customControls: [],
            source: null,
            drawer: null,
            world: null,
            viewport: null,
            navigator: null,
            collectionViewport: null,
            collectionDrawer: null,
            navImages: null,
            buttons: null,
            profiler: null
          }, $3.DEFAULT_SETTINGS, options);
          if (typeof this.hash === "undefined") {
            throw new Error("A hash must be defined, either by specifying options.id or options.hash.");
          }
          if (typeof THIS[this.hash] !== "undefined") {
            $3.console.warn("Hash " + this.hash + " has already been used.");
          }
          THIS[this.hash] = {
            "fsBoundsDelta": new $3.Point(1, 1),
            "prevContainerSize": null,
            "animating": false,
            "forceRedraw": false,
            "mouseInside": false,
            "group": null,
            "zooming": false,
            "zoomFactor": null,
            "lastZoomTime": null,
            "fullPage": false,
            "onfullscreenchange": null
          };
          this._sequenceIndex = 0;
          this._firstOpen = true;
          this._updateRequestId = null;
          this._loadQueue = [];
          this.currentOverlays = [];
          this._lastScrollTime = $3.now();
          $3.EventSource.call(this);
          this.addHandler("open-failed", function(event) {
            var msg = $3.getString("Errors.OpenFailed", event.eventSource, event.message);
            _this._showMessage(msg);
          });
          $3.ControlDock.call(this, options);
          if (this.xmlPath) {
            this.tileSources = [this.xmlPath];
          }
          this.element = this.element || document.getElementById(this.id);
          this.canvas = $3.makeNeutralElement("div");
          this.canvas.className = "openseadragon-canvas";
          (function(style) {
            style.width = "100%";
            style.height = "100%";
            style.overflow = "hidden";
            style.position = "absolute";
            style.top = "0px";
            style.left = "0px";
          })(this.canvas.style);
          $3.setElementTouchActionNone(this.canvas);
          if (options.tabIndex !== "") {
            this.canvas.tabIndex = options.tabIndex === void 0 ? 0 : options.tabIndex;
          }
          this.container.className = "openseadragon-container";
          (function(style) {
            style.width = "100%";
            style.height = "100%";
            style.position = "relative";
            style.overflow = "hidden";
            style.left = "0px";
            style.top = "0px";
            style.textAlign = "left";
          })(this.container.style);
          this.container.insertBefore(this.canvas, this.container.firstChild);
          this.element.appendChild(this.container);
          this.bodyWidth = document.body.style.width;
          this.bodyHeight = document.body.style.height;
          this.bodyOverflow = document.body.style.overflow;
          this.docOverflow = document.documentElement.style.overflow;
          this.innerTracker = new $3.MouseTracker({
            element: this.canvas,
            startDisabled: !this.mouseNavEnabled,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            dblClickTimeThreshold: this.dblClickTimeThreshold,
            dblClickDistThreshold: this.dblClickDistThreshold,
            keyDownHandler: $3.delegate(this, onCanvasKeyDown),
            keyHandler: $3.delegate(this, onCanvasKeyPress),
            clickHandler: $3.delegate(this, onCanvasClick),
            dblClickHandler: $3.delegate(this, onCanvasDblClick),
            dragHandler: $3.delegate(this, onCanvasDrag),
            dragEndHandler: $3.delegate(this, onCanvasDragEnd),
            enterHandler: $3.delegate(this, onCanvasEnter),
            exitHandler: $3.delegate(this, onCanvasExit),
            pressHandler: $3.delegate(this, onCanvasPress),
            releaseHandler: $3.delegate(this, onCanvasRelease),
            nonPrimaryPressHandler: $3.delegate(this, onCanvasNonPrimaryPress),
            nonPrimaryReleaseHandler: $3.delegate(this, onCanvasNonPrimaryRelease),
            scrollHandler: $3.delegate(this, onCanvasScroll),
            pinchHandler: $3.delegate(this, onCanvasPinch)
          });
          this.outerTracker = new $3.MouseTracker({
            element: this.container,
            startDisabled: !this.mouseNavEnabled,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            dblClickTimeThreshold: this.dblClickTimeThreshold,
            dblClickDistThreshold: this.dblClickDistThreshold,
            enterHandler: $3.delegate(this, onContainerEnter),
            exitHandler: $3.delegate(this, onContainerExit)
          });
          if (this.toolbar) {
            this.toolbar = new $3.ControlDock({ element: this.toolbar });
          }
          this.bindStandardControls();
          THIS[this.hash].prevContainerSize = _getSafeElemSize(this.container);
          this.world = new $3.World({
            viewer: this
          });
          this.world.addHandler("add-item", function(event) {
            _this.source = _this.world.getItemAt(0).source;
            THIS[_this.hash].forceRedraw = true;
            if (!_this._updateRequestId) {
              _this._updateRequestId = scheduleUpdate(_this, updateMulti);
            }
          });
          this.world.addHandler("remove-item", function(event) {
            if (_this.world.getItemCount()) {
              _this.source = _this.world.getItemAt(0).source;
            } else {
              _this.source = null;
            }
            THIS[_this.hash].forceRedraw = true;
          });
          this.world.addHandler("metrics-change", function(event) {
            if (_this.viewport) {
              _this.viewport._setContentBounds(_this.world.getHomeBounds(), _this.world.getContentFactor());
            }
          });
          this.world.addHandler("item-index-change", function(event) {
            _this.source = _this.world.getItemAt(0).source;
          });
          this.viewport = new $3.Viewport({
            containerSize: THIS[this.hash].prevContainerSize,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime,
            minZoomImageRatio: this.minZoomImageRatio,
            maxZoomPixelRatio: this.maxZoomPixelRatio,
            visibilityRatio: this.visibilityRatio,
            wrapHorizontal: this.wrapHorizontal,
            wrapVertical: this.wrapVertical,
            defaultZoomLevel: this.defaultZoomLevel,
            minZoomLevel: this.minZoomLevel,
            maxZoomLevel: this.maxZoomLevel,
            viewer: this,
            degrees: this.degrees,
            flipped: this.flipped,
            navigatorRotate: this.navigatorRotate,
            homeFillsViewer: this.homeFillsViewer,
            margins: this.viewportMargins
          });
          this.viewport._setContentBounds(this.world.getHomeBounds(), this.world.getContentFactor());
          this.imageLoader = new $3.ImageLoader({
            jobLimit: this.imageLoaderLimit,
            timeout: options.timeout
          });
          this.tileCache = new $3.TileCache({
            maxImageCacheCount: this.maxImageCacheCount
          });
          this.drawer = new $3.Drawer({
            viewer: this,
            viewport: this.viewport,
            element: this.canvas,
            debugGridColor: this.debugGridColor
          });
          this.overlaysContainer = $3.makeNeutralElement("div");
          this.canvas.appendChild(this.overlaysContainer);
          if (!this.drawer.canRotate()) {
            if (this.rotateLeft) {
              i2 = this.buttons.buttons.indexOf(this.rotateLeft);
              this.buttons.buttons.splice(i2, 1);
              this.buttons.element.removeChild(this.rotateLeft.element);
            }
            if (this.rotateRight) {
              i2 = this.buttons.buttons.indexOf(this.rotateRight);
              this.buttons.buttons.splice(i2, 1);
              this.buttons.element.removeChild(this.rotateRight.element);
            }
          }
          if (this.showNavigator) {
            this.navigator = new $3.Navigator({
              id: this.navigatorId,
              position: this.navigatorPosition,
              sizeRatio: this.navigatorSizeRatio,
              maintainSizeRatio: this.navigatorMaintainSizeRatio,
              top: this.navigatorTop,
              left: this.navigatorLeft,
              width: this.navigatorWidth,
              height: this.navigatorHeight,
              autoResize: this.navigatorAutoResize,
              autoFade: this.navigatorAutoFade,
              prefixUrl: this.prefixUrl,
              viewer: this,
              navigatorRotate: this.navigatorRotate,
              background: this.navigatorBackground,
              opacity: this.navigatorOpacity,
              borderColor: this.navigatorBorderColor,
              displayRegionColor: this.navigatorDisplayRegionColor,
              crossOriginPolicy: this.crossOriginPolicy
            });
          }
          if (this.sequenceMode) {
            this.bindSequenceControls();
          }
          if (this.tileSources) {
            this.open(this.tileSources);
          }
          for (i2 = 0; i2 < this.customControls.length; i2++) {
            this.addControl(
              this.customControls[i2].id,
              { anchor: this.customControls[i2].anchor }
            );
          }
          $3.requestAnimationFrame(function() {
            beginControlsAutoHide(_this);
          });
          if (this.imageSmoothingEnabled !== void 0 && !this.imageSmoothingEnabled) {
            this.drawer.setImageSmoothingEnabled(this.imageSmoothingEnabled);
          }
        };
        $3.extend($3.Viewer.prototype, $3.EventSource.prototype, $3.ControlDock.prototype, {
          isOpen: function() {
            return !!this.world.getItemCount();
          },
          openDzi: function(dzi) {
            $3.console.error("[Viewer.openDzi] this function is deprecated; use Viewer.open() instead.");
            return this.open(dzi);
          },
          openTileSource: function(tileSource) {
            $3.console.error("[Viewer.openTileSource] this function is deprecated; use Viewer.open() instead.");
            return this.open(tileSource);
          },
          open: function(tileSources, initialPage) {
            var _this = this;
            this.close();
            if (!tileSources) {
              return;
            }
            if (this.sequenceMode && $3.isArray(tileSources)) {
              if (this.referenceStrip) {
                this.referenceStrip.destroy();
                this.referenceStrip = null;
              }
              if (typeof initialPage != "undefined" && !isNaN(initialPage)) {
                this.initialPage = initialPage;
              }
              this.tileSources = tileSources;
              this._sequenceIndex = Math.max(0, Math.min(this.tileSources.length - 1, this.initialPage));
              if (this.tileSources.length) {
                this.open(this.tileSources[this._sequenceIndex]);
                if (this.showReferenceStrip) {
                  this.addReferenceStrip();
                }
              }
              this._updateSequenceButtons(this._sequenceIndex);
              return;
            }
            if (!$3.isArray(tileSources)) {
              tileSources = [tileSources];
            }
            if (!tileSources.length) {
              return;
            }
            this._opening = true;
            var expected = tileSources.length;
            var successes = 0;
            var failures = 0;
            var failEvent;
            var checkCompletion = function() {
              if (successes + failures === expected) {
                if (successes) {
                  if (_this._firstOpen || !_this.preserveViewport) {
                    _this.viewport.goHome(true);
                    _this.viewport.update();
                  }
                  _this._firstOpen = false;
                  var source = tileSources[0];
                  if (source.tileSource) {
                    source = source.tileSource;
                  }
                  if (_this.overlays && !_this.preserveOverlays) {
                    for (var i3 = 0; i3 < _this.overlays.length; i3++) {
                      _this.currentOverlays[i3] = getOverlayObject(_this, _this.overlays[i3]);
                    }
                  }
                  _this._drawOverlays();
                  _this._opening = false;
                  _this.raiseEvent("open", { source });
                } else {
                  _this._opening = false;
                  _this.raiseEvent("open-failed", failEvent);
                }
              }
            };
            var doOne = function(options) {
              if (!$3.isPlainObject(options) || !options.tileSource) {
                options = {
                  tileSource: options
                };
              }
              if (options.index !== void 0) {
                $3.console.error("[Viewer.open] setting indexes here is not supported; use addTiledImage instead");
                delete options.index;
              }
              if (options.collectionImmediately === void 0) {
                options.collectionImmediately = true;
              }
              var originalSuccess = options.success;
              options.success = function(event) {
                successes++;
                if (options.tileSource.overlays) {
                  for (var i3 = 0; i3 < options.tileSource.overlays.length; i3++) {
                    _this.addOverlay(options.tileSource.overlays[i3]);
                  }
                }
                if (originalSuccess) {
                  originalSuccess(event);
                }
                checkCompletion();
              };
              var originalError = options.error;
              options.error = function(event) {
                failures++;
                if (!failEvent) {
                  failEvent = event;
                }
                if (originalError) {
                  originalError(event);
                }
                checkCompletion();
              };
              _this.addTiledImage(options);
            };
            for (var i2 = 0; i2 < tileSources.length; i2++) {
              doOne(tileSources[i2]);
            }
            return this;
          },
          close: function() {
            if (!THIS[this.hash]) {
              return this;
            }
            this._opening = false;
            if (this.navigator) {
              this.navigator.close();
            }
            if (!this.preserveOverlays) {
              this.clearOverlays();
              this.overlaysContainer.innerHTML = "";
            }
            THIS[this.hash].animating = false;
            this.world.removeAll();
            this.imageLoader.clear();
            this.raiseEvent("close");
            return this;
          },
          destroy: function() {
            if (!THIS[this.hash]) {
              return;
            }
            this.close();
            this.clearOverlays();
            this.overlaysContainer.innerHTML = "";
            if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
            }
            if (this._updateRequestId !== null) {
              $3.cancelAnimationFrame(this._updateRequestId);
              this._updateRequestId = null;
            }
            if (this.drawer) {
              this.drawer.destroy();
            }
            this.removeAllHandlers();
            if (this.element) {
              while (this.element.firstChild) {
                this.element.removeChild(this.element.firstChild);
              }
            }
            if (this.innerTracker) {
              this.innerTracker.destroy();
            }
            if (this.outerTracker) {
              this.outerTracker.destroy();
            }
            THIS[this.hash] = null;
            delete THIS[this.hash];
            this.canvas = null;
            this.container = null;
            this.element = null;
          },
          isMouseNavEnabled: function() {
            return this.innerTracker.isTracking();
          },
          setMouseNavEnabled: function(enabled) {
            this.innerTracker.setTracking(enabled);
            this.outerTracker.setTracking(enabled);
            this.raiseEvent("mouse-enabled", { enabled });
            return this;
          },
          areControlsEnabled: function() {
            var enabled = this.controls.length, i2;
            for (i2 = 0; i2 < this.controls.length; i2++) {
              enabled = enabled && this.controls[i2].isVisible();
            }
            return enabled;
          },
          setControlsEnabled: function(enabled) {
            if (enabled) {
              abortControlsAutoHide(this);
            } else {
              beginControlsAutoHide(this);
            }
            this.raiseEvent("controls-enabled", { enabled });
            return this;
          },
          setDebugMode: function(debugMode) {
            for (var i2 = 0; i2 < this.world.getItemCount(); i2++) {
              this.world.getItemAt(i2).debugMode = debugMode;
            }
            this.debugMode = debugMode;
            this.forceRedraw();
          },
          isFullPage: function() {
            return THIS[this.hash].fullPage;
          },
          setFullPage: function(fullPage) {
            var body = document.body, bodyStyle = body.style, docStyle = document.documentElement.style, _this = this, nodes, i2;
            if (fullPage == this.isFullPage()) {
              return this;
            }
            var fullPageEventArgs = {
              fullPage,
              preventDefaultAction: false
            };
            this.raiseEvent("pre-full-page", fullPageEventArgs);
            if (fullPageEventArgs.preventDefaultAction) {
              return this;
            }
            if (fullPage) {
              this.elementSize = $3.getElementSize(this.element);
              this.pageScroll = $3.getPageScroll();
              this.elementMargin = this.element.style.margin;
              this.element.style.margin = "0";
              this.elementPadding = this.element.style.padding;
              this.element.style.padding = "0";
              this.bodyMargin = bodyStyle.margin;
              this.docMargin = docStyle.margin;
              bodyStyle.margin = "0";
              docStyle.margin = "0";
              this.bodyPadding = bodyStyle.padding;
              this.docPadding = docStyle.padding;
              bodyStyle.padding = "0";
              docStyle.padding = "0";
              this.bodyWidth = bodyStyle.width;
              this.docWidth = docStyle.width;
              bodyStyle.width = "100%";
              docStyle.width = "100%";
              this.bodyHeight = bodyStyle.height;
              this.docHeight = docStyle.height;
              bodyStyle.height = "100%";
              docStyle.height = "100%";
              this.previousBody = [];
              THIS[this.hash].prevElementParent = this.element.parentNode;
              THIS[this.hash].prevNextSibling = this.element.nextSibling;
              THIS[this.hash].prevElementWidth = this.element.style.width;
              THIS[this.hash].prevElementHeight = this.element.style.height;
              nodes = body.childNodes.length;
              for (i2 = 0; i2 < nodes; i2++) {
                this.previousBody.push(body.childNodes[0]);
                body.removeChild(body.childNodes[0]);
              }
              if (this.toolbar && this.toolbar.element) {
                this.toolbar.parentNode = this.toolbar.element.parentNode;
                this.toolbar.nextSibling = this.toolbar.element.nextSibling;
                body.appendChild(this.toolbar.element);
                $3.addClass(this.toolbar.element, "fullpage");
              }
              $3.addClass(this.element, "fullpage");
              body.appendChild(this.element);
              this.element.style.height = $3.getWindowSize().y + "px";
              this.element.style.width = $3.getWindowSize().x + "px";
              if (this.toolbar && this.toolbar.element) {
                this.element.style.height = $3.getElementSize(this.element).y - $3.getElementSize(this.toolbar.element).y + "px";
              }
              THIS[this.hash].fullPage = true;
              $3.delegate(this, onContainerEnter)({});
            } else {
              this.element.style.margin = this.elementMargin;
              this.element.style.padding = this.elementPadding;
              bodyStyle.margin = this.bodyMargin;
              docStyle.margin = this.docMargin;
              bodyStyle.padding = this.bodyPadding;
              docStyle.padding = this.docPadding;
              bodyStyle.width = this.bodyWidth;
              docStyle.width = this.docWidth;
              bodyStyle.height = this.bodyHeight;
              docStyle.height = this.docHeight;
              body.removeChild(this.element);
              nodes = this.previousBody.length;
              for (i2 = 0; i2 < nodes; i2++) {
                body.appendChild(this.previousBody.shift());
              }
              $3.removeClass(this.element, "fullpage");
              THIS[this.hash].prevElementParent.insertBefore(
                this.element,
                THIS[this.hash].prevNextSibling
              );
              if (this.toolbar && this.toolbar.element) {
                body.removeChild(this.toolbar.element);
                $3.removeClass(this.toolbar.element, "fullpage");
                this.toolbar.parentNode.insertBefore(
                  this.toolbar.element,
                  this.toolbar.nextSibling
                );
                delete this.toolbar.parentNode;
                delete this.toolbar.nextSibling;
              }
              this.element.style.width = THIS[this.hash].prevElementWidth;
              this.element.style.height = THIS[this.hash].prevElementHeight;
              var restoreScrollCounter = 0;
              var restoreScroll = function() {
                $3.setPageScroll(_this.pageScroll);
                var pageScroll = $3.getPageScroll();
                restoreScrollCounter++;
                if (restoreScrollCounter < 10 && (pageScroll.x !== _this.pageScroll.x || pageScroll.y !== _this.pageScroll.y)) {
                  $3.requestAnimationFrame(restoreScroll);
                }
              };
              $3.requestAnimationFrame(restoreScroll);
              THIS[this.hash].fullPage = false;
              $3.delegate(this, onContainerExit)({});
            }
            if (this.navigator && this.viewport) {
              this.navigator.update(this.viewport);
            }
            this.raiseEvent("full-page", { fullPage });
            return this;
          },
          setFullScreen: function(fullScreen) {
            var _this = this;
            if (!$3.supportsFullScreen) {
              return this.setFullPage(fullScreen);
            }
            if ($3.isFullScreen() === fullScreen) {
              return this;
            }
            var fullScreeEventArgs = {
              fullScreen,
              preventDefaultAction: false
            };
            this.raiseEvent("pre-full-screen", fullScreeEventArgs);
            if (fullScreeEventArgs.preventDefaultAction) {
              return this;
            }
            if (fullScreen) {
              this.setFullPage(true);
              if (!this.isFullPage()) {
                return this;
              }
              this.fullPageStyleWidth = this.element.style.width;
              this.fullPageStyleHeight = this.element.style.height;
              this.element.style.width = "100%";
              this.element.style.height = "100%";
              var onFullScreenChange = function() {
                var isFullScreen = $3.isFullScreen();
                if (!isFullScreen) {
                  $3.removeEvent(document, $3.fullScreenEventName, onFullScreenChange);
                  $3.removeEvent(document, $3.fullScreenErrorEventName, onFullScreenChange);
                  _this.setFullPage(false);
                  if (_this.isFullPage()) {
                    _this.element.style.width = _this.fullPageStyleWidth;
                    _this.element.style.height = _this.fullPageStyleHeight;
                  }
                }
                if (_this.navigator && _this.viewport) {
                  setTimeout(function() {
                    _this.navigator.update(_this.viewport);
                  });
                }
                _this.raiseEvent("full-screen", { fullScreen: isFullScreen });
              };
              $3.addEvent(document, $3.fullScreenEventName, onFullScreenChange);
              $3.addEvent(document, $3.fullScreenErrorEventName, onFullScreenChange);
              $3.requestFullScreen(document.body);
            } else {
              $3.exitFullScreen();
            }
            return this;
          },
          isVisible: function() {
            return this.container.style.visibility != "hidden";
          },
          setVisible: function(visible) {
            this.container.style.visibility = visible ? "" : "hidden";
            this.raiseEvent("visible", { visible });
            return this;
          },
          addTiledImage: function(options) {
            $3.console.assert(options, "[Viewer.addTiledImage] options is required");
            $3.console.assert(options.tileSource, "[Viewer.addTiledImage] options.tileSource is required");
            $3.console.assert(
              !options.replace || options.index > -1 && options.index < this.world.getItemCount(),
              "[Viewer.addTiledImage] if options.replace is used, options.index must be a valid index in Viewer.world"
            );
            var _this = this;
            if (options.replace) {
              options.replaceItem = _this.world.getItemAt(options.index);
            }
            this._hideMessage();
            if (options.placeholderFillStyle === void 0) {
              options.placeholderFillStyle = this.placeholderFillStyle;
            }
            if (options.opacity === void 0) {
              options.opacity = this.opacity;
            }
            if (options.preload === void 0) {
              options.preload = this.preload;
            }
            if (options.compositeOperation === void 0) {
              options.compositeOperation = this.compositeOperation;
            }
            if (options.crossOriginPolicy === void 0) {
              options.crossOriginPolicy = options.tileSource.crossOriginPolicy !== void 0 ? options.tileSource.crossOriginPolicy : this.crossOriginPolicy;
            }
            if (options.ajaxWithCredentials === void 0) {
              options.ajaxWithCredentials = this.ajaxWithCredentials;
            }
            if (options.loadTilesWithAjax === void 0) {
              options.loadTilesWithAjax = this.loadTilesWithAjax;
            }
            if (options.ajaxHeaders === void 0 || options.ajaxHeaders === null) {
              options.ajaxHeaders = this.ajaxHeaders;
            } else if ($3.isPlainObject(options.ajaxHeaders) && $3.isPlainObject(this.ajaxHeaders)) {
              options.ajaxHeaders = $3.extend({}, this.ajaxHeaders, options.ajaxHeaders);
            }
            var myQueueItem = {
              options
            };
            function raiseAddItemFailed(event) {
              for (var i2 = 0; i2 < _this._loadQueue.length; i2++) {
                if (_this._loadQueue[i2] === myQueueItem) {
                  _this._loadQueue.splice(i2, 1);
                  break;
                }
              }
              if (_this._loadQueue.length === 0) {
                refreshWorld(myQueueItem);
              }
              _this.raiseEvent("add-item-failed", event);
              if (options.error) {
                options.error(event);
              }
            }
            function refreshWorld(theItem) {
              if (_this.collectionMode) {
                _this.world.arrange({
                  immediately: theItem.options.collectionImmediately,
                  rows: _this.collectionRows,
                  columns: _this.collectionColumns,
                  layout: _this.collectionLayout,
                  tileSize: _this.collectionTileSize,
                  tileMargin: _this.collectionTileMargin
                });
                _this.world.setAutoRefigureSizes(true);
              }
            }
            if ($3.isArray(options.tileSource)) {
              setTimeout(function() {
                raiseAddItemFailed({
                  message: "[Viewer.addTiledImage] Sequences can not be added; add them one at a time instead.",
                  source: options.tileSource,
                  options
                });
              });
              return;
            }
            this._loadQueue.push(myQueueItem);
            function processReadyItems() {
              var queueItem, tiledImage, optionsClone;
              while (_this._loadQueue.length) {
                queueItem = _this._loadQueue[0];
                if (!queueItem.tileSource) {
                  break;
                }
                _this._loadQueue.splice(0, 1);
                if (queueItem.options.replace) {
                  var newIndex = _this.world.getIndexOfItem(queueItem.options.replaceItem);
                  if (newIndex != -1) {
                    queueItem.options.index = newIndex;
                  }
                  _this.world.removeItem(queueItem.options.replaceItem);
                }
                tiledImage = new $3.TiledImage({
                  viewer: _this,
                  source: queueItem.tileSource,
                  viewport: _this.viewport,
                  drawer: _this.drawer,
                  tileCache: _this.tileCache,
                  imageLoader: _this.imageLoader,
                  x: queueItem.options.x,
                  y: queueItem.options.y,
                  width: queueItem.options.width,
                  height: queueItem.options.height,
                  fitBounds: queueItem.options.fitBounds,
                  fitBoundsPlacement: queueItem.options.fitBoundsPlacement,
                  clip: queueItem.options.clip,
                  placeholderFillStyle: queueItem.options.placeholderFillStyle,
                  opacity: queueItem.options.opacity,
                  preload: queueItem.options.preload,
                  degrees: queueItem.options.degrees,
                  compositeOperation: queueItem.options.compositeOperation,
                  springStiffness: _this.springStiffness,
                  animationTime: _this.animationTime,
                  minZoomImageRatio: _this.minZoomImageRatio,
                  wrapHorizontal: _this.wrapHorizontal,
                  wrapVertical: _this.wrapVertical,
                  immediateRender: _this.immediateRender,
                  blendTime: _this.blendTime,
                  alwaysBlend: _this.alwaysBlend,
                  minPixelRatio: _this.minPixelRatio,
                  smoothTileEdgesMinZoom: _this.smoothTileEdgesMinZoom,
                  iOSDevice: _this.iOSDevice,
                  crossOriginPolicy: queueItem.options.crossOriginPolicy,
                  ajaxWithCredentials: queueItem.options.ajaxWithCredentials,
                  loadTilesWithAjax: queueItem.options.loadTilesWithAjax,
                  ajaxHeaders: queueItem.options.ajaxHeaders,
                  debugMode: _this.debugMode
                });
                if (_this.collectionMode) {
                  _this.world.setAutoRefigureSizes(false);
                }
                _this.world.addItem(tiledImage, {
                  index: queueItem.options.index
                });
                if (_this._loadQueue.length === 0) {
                  refreshWorld(queueItem);
                }
                if (_this.world.getItemCount() === 1 && !_this.preserveViewport) {
                  _this.viewport.goHome(true);
                }
                if (_this.navigator) {
                  optionsClone = $3.extend({}, queueItem.options, {
                    replace: false,
                    originalTiledImage: tiledImage,
                    tileSource: queueItem.tileSource
                  });
                  _this.navigator.addTiledImage(optionsClone);
                }
                if (queueItem.options.success) {
                  queueItem.options.success({
                    item: tiledImage
                  });
                }
              }
            }
            getTileSourceImplementation(this, options.tileSource, options, function(tileSource) {
              myQueueItem.tileSource = tileSource;
              processReadyItems();
            }, function(event) {
              event.options = options;
              raiseAddItemFailed(event);
              processReadyItems();
            });
          },
          addSimpleImage: function(options) {
            $3.console.assert(options, "[Viewer.addSimpleImage] options is required");
            $3.console.assert(options.url, "[Viewer.addSimpleImage] options.url is required");
            var opts = $3.extend({}, options, {
              tileSource: {
                type: "image",
                url: options.url
              }
            });
            delete opts.url;
            this.addTiledImage(opts);
          },
          addLayer: function(options) {
            var _this = this;
            $3.console.error("[Viewer.addLayer] this function is deprecated; use Viewer.addTiledImage() instead.");
            var optionsClone = $3.extend({}, options, {
              success: function(event) {
                _this.raiseEvent("add-layer", {
                  options,
                  drawer: event.item
                });
              },
              error: function(event) {
                _this.raiseEvent("add-layer-failed", event);
              }
            });
            this.addTiledImage(optionsClone);
            return this;
          },
          getLayerAtLevel: function(level) {
            $3.console.error("[Viewer.getLayerAtLevel] this function is deprecated; use World.getItemAt() instead.");
            return this.world.getItemAt(level);
          },
          getLevelOfLayer: function(drawer) {
            $3.console.error("[Viewer.getLevelOfLayer] this function is deprecated; use World.getIndexOfItem() instead.");
            return this.world.getIndexOfItem(drawer);
          },
          getLayersCount: function() {
            $3.console.error("[Viewer.getLayersCount] this function is deprecated; use World.getItemCount() instead.");
            return this.world.getItemCount();
          },
          setLayerLevel: function(drawer, level) {
            $3.console.error("[Viewer.setLayerLevel] this function is deprecated; use World.setItemIndex() instead.");
            return this.world.setItemIndex(drawer, level);
          },
          removeLayer: function(drawer) {
            $3.console.error("[Viewer.removeLayer] this function is deprecated; use World.removeItem() instead.");
            return this.world.removeItem(drawer);
          },
          forceRedraw: function() {
            THIS[this.hash].forceRedraw = true;
            return this;
          },
          bindSequenceControls: function() {
            var onFocusHandler = $3.delegate(this, onFocus), onBlurHandler = $3.delegate(this, onBlur), onNextHandler = $3.delegate(this, onNext), onPreviousHandler = $3.delegate(this, onPrevious), navImages = this.navImages, useGroup = true;
            if (this.showSequenceControl) {
              if (this.previousButton || this.nextButton) {
                useGroup = false;
              }
              this.previousButton = new $3.Button({
                element: this.previousButton ? $3.getElement(this.previousButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $3.getString("Tooltips.PreviousPage"),
                srcRest: resolveUrl(this.prefixUrl, navImages.previous.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.previous.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.previous.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.previous.DOWN),
                onRelease: onPreviousHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              });
              this.nextButton = new $3.Button({
                element: this.nextButton ? $3.getElement(this.nextButton) : null,
                clickTimeThreshold: this.clickTimeThreshold,
                clickDistThreshold: this.clickDistThreshold,
                tooltip: $3.getString("Tooltips.NextPage"),
                srcRest: resolveUrl(this.prefixUrl, navImages.next.REST),
                srcGroup: resolveUrl(this.prefixUrl, navImages.next.GROUP),
                srcHover: resolveUrl(this.prefixUrl, navImages.next.HOVER),
                srcDown: resolveUrl(this.prefixUrl, navImages.next.DOWN),
                onRelease: onNextHandler,
                onFocus: onFocusHandler,
                onBlur: onBlurHandler
              });
              if (!this.navPrevNextWrap) {
                this.previousButton.disable();
              }
              if (!this.tileSources || !this.tileSources.length) {
                this.nextButton.disable();
              }
              if (useGroup) {
                this.paging = new $3.ButtonGroup({
                  buttons: [
                    this.previousButton,
                    this.nextButton
                  ],
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold
                });
                this.pagingControl = this.paging.element;
                if (this.toolbar) {
                  this.toolbar.addControl(
                    this.pagingControl,
                    { anchor: $3.ControlAnchor.BOTTOM_RIGHT }
                  );
                } else {
                  this.addControl(
                    this.pagingControl,
                    { anchor: this.sequenceControlAnchor || $3.ControlAnchor.TOP_LEFT }
                  );
                }
              }
            }
            return this;
          },
          bindStandardControls: function() {
            var beginZoomingInHandler = $3.delegate(this, beginZoomingIn), endZoomingHandler = $3.delegate(this, endZooming), doSingleZoomInHandler = $3.delegate(this, doSingleZoomIn), beginZoomingOutHandler = $3.delegate(this, beginZoomingOut), doSingleZoomOutHandler = $3.delegate(this, doSingleZoomOut), onHomeHandler = $3.delegate(this, onHome), onFullScreenHandler = $3.delegate(this, onFullScreen), onRotateLeftHandler = $3.delegate(this, onRotateLeft), onRotateRightHandler = $3.delegate(this, onRotateRight), onFlipHandler = $3.delegate(this, onFlip), onFocusHandler = $3.delegate(this, onFocus), onBlurHandler = $3.delegate(this, onBlur), navImages = this.navImages, buttons = [], useGroup = true;
            if (this.showNavigationControl) {
              if (this.zoomInButton || this.zoomOutButton || this.homeButton || this.fullPageButton || this.rotateLeftButton || this.rotateRightButton || this.flipButton) {
                useGroup = false;
              }
              if (this.showZoomControl) {
                buttons.push(this.zoomInButton = new $3.Button({
                  element: this.zoomInButton ? $3.getElement(this.zoomInButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $3.getString("Tooltips.ZoomIn"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.zoomIn.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.zoomIn.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.zoomIn.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.zoomIn.DOWN),
                  onPress: beginZoomingInHandler,
                  onRelease: endZoomingHandler,
                  onClick: doSingleZoomInHandler,
                  onEnter: beginZoomingInHandler,
                  onExit: endZoomingHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
                buttons.push(this.zoomOutButton = new $3.Button({
                  element: this.zoomOutButton ? $3.getElement(this.zoomOutButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $3.getString("Tooltips.ZoomOut"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.zoomOut.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.zoomOut.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.zoomOut.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.zoomOut.DOWN),
                  onPress: beginZoomingOutHandler,
                  onRelease: endZoomingHandler,
                  onClick: doSingleZoomOutHandler,
                  onEnter: beginZoomingOutHandler,
                  onExit: endZoomingHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showHomeControl) {
                buttons.push(this.homeButton = new $3.Button({
                  element: this.homeButton ? $3.getElement(this.homeButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $3.getString("Tooltips.Home"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.home.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.home.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.home.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.home.DOWN),
                  onRelease: onHomeHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showFullPageControl) {
                buttons.push(this.fullPageButton = new $3.Button({
                  element: this.fullPageButton ? $3.getElement(this.fullPageButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $3.getString("Tooltips.FullPage"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.fullpage.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.fullpage.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.fullpage.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.fullpage.DOWN),
                  onRelease: onFullScreenHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showRotationControl) {
                buttons.push(this.rotateLeftButton = new $3.Button({
                  element: this.rotateLeftButton ? $3.getElement(this.rotateLeftButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $3.getString("Tooltips.RotateLeft"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.rotateleft.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.rotateleft.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.rotateleft.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.rotateleft.DOWN),
                  onRelease: onRotateLeftHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
                buttons.push(this.rotateRightButton = new $3.Button({
                  element: this.rotateRightButton ? $3.getElement(this.rotateRightButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $3.getString("Tooltips.RotateRight"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.rotateright.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.rotateright.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.rotateright.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.rotateright.DOWN),
                  onRelease: onRotateRightHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (this.showFlipControl) {
                buttons.push(this.flipButton = new $3.Button({
                  element: this.flipButton ? $3.getElement(this.flipButton) : null,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold,
                  tooltip: $3.getString("Tooltips.Flip"),
                  srcRest: resolveUrl(this.prefixUrl, navImages.flip.REST),
                  srcGroup: resolveUrl(this.prefixUrl, navImages.flip.GROUP),
                  srcHover: resolveUrl(this.prefixUrl, navImages.flip.HOVER),
                  srcDown: resolveUrl(this.prefixUrl, navImages.flip.DOWN),
                  onRelease: onFlipHandler,
                  onFocus: onFocusHandler,
                  onBlur: onBlurHandler
                }));
              }
              if (useGroup) {
                this.buttons = new $3.ButtonGroup({
                  buttons,
                  clickTimeThreshold: this.clickTimeThreshold,
                  clickDistThreshold: this.clickDistThreshold
                });
                this.navControl = this.buttons.element;
                this.addHandler("open", $3.delegate(this, lightUp));
                if (this.toolbar) {
                  this.toolbar.addControl(
                    this.navControl,
                    { anchor: this.navigationControlAnchor || $3.ControlAnchor.TOP_LEFT }
                  );
                } else {
                  this.addControl(
                    this.navControl,
                    { anchor: this.navigationControlAnchor || $3.ControlAnchor.TOP_LEFT }
                  );
                }
              }
            }
            return this;
          },
          currentPage: function() {
            return this._sequenceIndex;
          },
          goToPage: function(page) {
            if (this.tileSources && page >= 0 && page < this.tileSources.length) {
              this._sequenceIndex = page;
              this._updateSequenceButtons(page);
              this.open(this.tileSources[page]);
              if (this.referenceStrip) {
                this.referenceStrip.setFocus(page);
              }
              this.raiseEvent("page", { page });
            }
            return this;
          },
          addOverlay: function(element, location2, placement, onDraw) {
            var options;
            if ($3.isPlainObject(element)) {
              options = element;
            } else {
              options = {
                element,
                location: location2,
                placement,
                onDraw
              };
            }
            element = $3.getElement(options.element);
            if (getOverlayIndex(this.currentOverlays, element) >= 0) {
              return this;
            }
            var overlay = getOverlayObject(this, options);
            this.currentOverlays.push(overlay);
            overlay.drawHTML(this.overlaysContainer, this.viewport);
            this.raiseEvent("add-overlay", {
              element,
              location: options.location,
              placement: options.placement
            });
            return this;
          },
          updateOverlay: function(element, location2, placement) {
            var i2;
            element = $3.getElement(element);
            i2 = getOverlayIndex(this.currentOverlays, element);
            if (i2 >= 0) {
              this.currentOverlays[i2].update(location2, placement);
              THIS[this.hash].forceRedraw = true;
              this.raiseEvent("update-overlay", {
                element,
                location: location2,
                placement
              });
            }
            return this;
          },
          removeOverlay: function(element) {
            var i2;
            element = $3.getElement(element);
            i2 = getOverlayIndex(this.currentOverlays, element);
            if (i2 >= 0) {
              this.currentOverlays[i2].destroy();
              this.currentOverlays.splice(i2, 1);
              THIS[this.hash].forceRedraw = true;
              this.raiseEvent("remove-overlay", {
                element
              });
            }
            return this;
          },
          clearOverlays: function() {
            while (this.currentOverlays.length > 0) {
              this.currentOverlays.pop().destroy();
            }
            THIS[this.hash].forceRedraw = true;
            this.raiseEvent("clear-overlay", {});
            return this;
          },
          getOverlayById: function(element) {
            var i2;
            element = $3.getElement(element);
            i2 = getOverlayIndex(this.currentOverlays, element);
            if (i2 >= 0) {
              return this.currentOverlays[i2];
            } else {
              return null;
            }
          },
          _updateSequenceButtons: function(page) {
            if (this.nextButton) {
              if (!this.tileSources || this.tileSources.length - 1 === page) {
                if (!this.navPrevNextWrap) {
                  this.nextButton.disable();
                }
              } else {
                this.nextButton.enable();
              }
            }
            if (this.previousButton) {
              if (page > 0) {
                this.previousButton.enable();
              } else {
                if (!this.navPrevNextWrap) {
                  this.previousButton.disable();
                }
              }
            }
          },
          _showMessage: function(message) {
            this._hideMessage();
            var div = $3.makeNeutralElement("div");
            div.appendChild(document.createTextNode(message));
            this.messageDiv = $3.makeCenteredNode(div);
            $3.addClass(this.messageDiv, "openseadragon-message");
            this.container.appendChild(this.messageDiv);
          },
          _hideMessage: function() {
            var div = this.messageDiv;
            if (div) {
              div.parentNode.removeChild(div);
              delete this.messageDiv;
            }
          },
          gestureSettingsByDeviceType: function(type) {
            switch (type) {
              case "mouse":
                return this.gestureSettingsMouse;
              case "touch":
                return this.gestureSettingsTouch;
              case "pen":
                return this.gestureSettingsPen;
              default:
                return this.gestureSettingsUnknown;
            }
          },
          _drawOverlays: function() {
            var i2, length = this.currentOverlays.length;
            for (i2 = 0; i2 < length; i2++) {
              this.currentOverlays[i2].drawHTML(this.overlaysContainer, this.viewport);
            }
          },
          _cancelPendingImages: function() {
            this._loadQueue = [];
          },
          removeReferenceStrip: function() {
            this.showReferenceStrip = false;
            if (this.referenceStrip) {
              this.referenceStrip.destroy();
              this.referenceStrip = null;
            }
          },
          addReferenceStrip: function() {
            this.showReferenceStrip = true;
            if (this.sequenceMode) {
              if (this.referenceStrip) {
                return;
              }
              if (this.tileSources.length && this.tileSources.length > 1) {
                this.referenceStrip = new $3.ReferenceStrip({
                  id: this.referenceStripElement,
                  position: this.referenceStripPosition,
                  sizeRatio: this.referenceStripSizeRatio,
                  scroll: this.referenceStripScroll,
                  height: this.referenceStripHeight,
                  width: this.referenceStripWidth,
                  tileSources: this.tileSources,
                  prefixUrl: this.prefixUrl,
                  useCanvas: this.useCanvas,
                  viewer: this
                });
                this.referenceStrip.setFocus(this._sequenceIndex);
              }
            } else {
              $3.console.warn('Attempting to display a reference strip while "sequenceMode" is off.');
            }
          }
        });
        function _getSafeElemSize(oElement) {
          oElement = $3.getElement(oElement);
          return new $3.Point(
            oElement.clientWidth === 0 ? 1 : oElement.clientWidth,
            oElement.clientHeight === 0 ? 1 : oElement.clientHeight
          );
        }
        function getTileSourceImplementation(viewer, tileSource, imgOptions, successCallback, failCallback) {
          var _this = viewer;
          if ($3.type(tileSource) == "string") {
            if (tileSource.match(/^\s*<.*>\s*$/)) {
              tileSource = $3.parseXml(tileSource);
            } else if (tileSource.match(/^\s*[\{\[].*[\}\]]\s*$/)) {
              try {
                var tileSourceJ = $3.parseJSON(tileSource);
                tileSource = tileSourceJ;
              } catch (e3) {
              }
            }
          }
          function waitUntilReady(tileSource2, originalTileSource) {
            if (tileSource2.ready) {
              successCallback(tileSource2);
            } else {
              tileSource2.addHandler("ready", function() {
                successCallback(tileSource2);
              });
              tileSource2.addHandler("open-failed", function(event) {
                failCallback({
                  message: event.message,
                  source: originalTileSource
                });
              });
            }
          }
          setTimeout(function() {
            if ($3.type(tileSource) == "string") {
              tileSource = new $3.TileSource({
                url: tileSource,
                crossOriginPolicy: imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy,
                ajaxWithCredentials: viewer.ajaxWithCredentials,
                ajaxHeaders: viewer.ajaxHeaders,
                useCanvas: viewer.useCanvas,
                success: function(event) {
                  successCallback(event.tileSource);
                }
              });
              tileSource.addHandler("open-failed", function(event) {
                failCallback(event);
              });
            } else if ($3.isPlainObject(tileSource) || tileSource.nodeType) {
              if (tileSource.crossOriginPolicy === void 0 && (imgOptions.crossOriginPolicy !== void 0 || viewer.crossOriginPolicy !== void 0)) {
                tileSource.crossOriginPolicy = imgOptions.crossOriginPolicy !== void 0 ? imgOptions.crossOriginPolicy : viewer.crossOriginPolicy;
              }
              if (tileSource.ajaxWithCredentials === void 0) {
                tileSource.ajaxWithCredentials = viewer.ajaxWithCredentials;
              }
              if (tileSource.useCanvas === void 0) {
                tileSource.useCanvas = viewer.useCanvas;
              }
              if ($3.isFunction(tileSource.getTileUrl)) {
                var customTileSource = new $3.TileSource(tileSource);
                customTileSource.getTileUrl = tileSource.getTileUrl;
                successCallback(customTileSource);
              } else {
                var $TileSource = $3.TileSource.determineType(_this, tileSource);
                if (!$TileSource) {
                  failCallback({
                    message: "Unable to load TileSource",
                    source: tileSource
                  });
                  return;
                }
                var options = $TileSource.prototype.configure.apply(_this, [tileSource]);
                waitUntilReady(new $TileSource(options), tileSource);
              }
            } else {
              waitUntilReady(tileSource, tileSource);
            }
          });
        }
        function getOverlayObject(viewer, overlay) {
          if (overlay instanceof $3.Overlay) {
            return overlay;
          }
          var element = null;
          if (overlay.element) {
            element = $3.getElement(overlay.element);
          } else {
            var id = overlay.id ? overlay.id : "openseadragon-overlay-" + Math.floor(Math.random() * 1e7);
            element = $3.getElement(overlay.id);
            if (!element) {
              element = document.createElement("a");
              element.href = "#/overlay/" + id;
            }
            element.id = id;
            $3.addClass(
              element,
              overlay.className ? overlay.className : "openseadragon-overlay"
            );
          }
          var location2 = overlay.location;
          var width = overlay.width;
          var height = overlay.height;
          if (!location2) {
            var x2 = overlay.x;
            var y2 = overlay.y;
            if (overlay.px !== void 0) {
              var rect = viewer.viewport.imageToViewportRectangle(new $3.Rect(
                overlay.px,
                overlay.py,
                width || 0,
                height || 0
              ));
              x2 = rect.x;
              y2 = rect.y;
              width = width !== void 0 ? rect.width : void 0;
              height = height !== void 0 ? rect.height : void 0;
            }
            location2 = new $3.Point(x2, y2);
          }
          var placement = overlay.placement;
          if (placement && $3.type(placement) === "string") {
            placement = $3.Placement[overlay.placement.toUpperCase()];
          }
          return new $3.Overlay({
            element,
            location: location2,
            placement,
            onDraw: overlay.onDraw,
            checkResize: overlay.checkResize,
            width,
            height,
            rotationMode: overlay.rotationMode
          });
        }
        function getOverlayIndex(overlays, element) {
          var i2;
          for (i2 = overlays.length - 1; i2 >= 0; i2--) {
            if (overlays[i2].element === element) {
              return i2;
            }
          }
          return -1;
        }
        function scheduleUpdate(viewer, updateFunc) {
          return $3.requestAnimationFrame(function() {
            updateFunc(viewer);
          });
        }
        function scheduleControlsFade(viewer) {
          $3.requestAnimationFrame(function() {
            updateControlsFade(viewer);
          });
        }
        function beginControlsAutoHide(viewer) {
          if (!viewer.autoHideControls) {
            return;
          }
          viewer.controlsShouldFade = true;
          viewer.controlsFadeBeginTime = $3.now() + viewer.controlsFadeDelay;
          window.setTimeout(function() {
            scheduleControlsFade(viewer);
          }, viewer.controlsFadeDelay);
        }
        function updateControlsFade(viewer) {
          var currentTime, deltaTime, opacity, i2;
          if (viewer.controlsShouldFade) {
            currentTime = $3.now();
            deltaTime = currentTime - viewer.controlsFadeBeginTime;
            opacity = 1 - deltaTime / viewer.controlsFadeLength;
            opacity = Math.min(1, opacity);
            opacity = Math.max(0, opacity);
            for (i2 = viewer.controls.length - 1; i2 >= 0; i2--) {
              if (viewer.controls[i2].autoFade) {
                viewer.controls[i2].setOpacity(opacity);
              }
            }
            if (opacity > 0) {
              scheduleControlsFade(viewer);
            }
          }
        }
        function abortControlsAutoHide(viewer) {
          var i2;
          viewer.controlsShouldFade = false;
          for (i2 = viewer.controls.length - 1; i2 >= 0; i2--) {
            viewer.controls[i2].setOpacity(1);
          }
        }
        function onFocus() {
          abortControlsAutoHide(this);
        }
        function onBlur() {
          beginControlsAutoHide(this);
        }
        function onCanvasKeyDown(event) {
          var canvasKeyDownEventArgs = {
            originalEvent: event.originalEvent,
            preventDefaultAction: event.preventDefaultAction,
            preventVerticalPan: event.preventVerticalPan,
            preventHorizontalPan: event.preventHorizontalPan
          };
          this.raiseEvent("canvas-key", canvasKeyDownEventArgs);
          if (!canvasKeyDownEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
            switch (event.keyCode) {
              case 38:
                if (!canvasKeyDownEventArgs.preventVerticalPan) {
                  if (event.shift) {
                    this.viewport.zoomBy(1.1);
                  } else {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(0, -this.pixelsPerArrowPress)));
                  }
                  this.viewport.applyConstraints();
                }
                return false;
              case 40:
                if (!canvasKeyDownEventArgs.preventVerticalPan) {
                  if (event.shift) {
                    this.viewport.zoomBy(0.9);
                  } else {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(0, this.pixelsPerArrowPress)));
                  }
                  this.viewport.applyConstraints();
                }
                return false;
              case 37:
                if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(-this.pixelsPerArrowPress, 0)));
                  this.viewport.applyConstraints();
                }
                return false;
              case 39:
                if (!canvasKeyDownEventArgs.preventHorizontalPan) {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(this.pixelsPerArrowPress, 0)));
                  this.viewport.applyConstraints();
                }
                return false;
              default:
                return true;
            }
          } else {
            return true;
          }
        }
        function onCanvasKeyPress(event) {
          var canvasKeyPressEventArgs = {
            originalEvent: event.originalEvent,
            preventDefaultAction: event.preventDefaultAction,
            preventVerticalPan: event.preventVerticalPan,
            preventHorizontalPan: event.preventHorizontalPan
          };
          this.raiseEvent("canvas-key", canvasKeyPressEventArgs);
          if (!canvasKeyPressEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
            switch (event.keyCode) {
              case 43:
              case 61:
                this.viewport.zoomBy(1.1);
                this.viewport.applyConstraints();
                return false;
              case 45:
                this.viewport.zoomBy(0.9);
                this.viewport.applyConstraints();
                return false;
              case 48:
                this.viewport.goHome();
                this.viewport.applyConstraints();
                return false;
              case 119:
              case 87:
                if (!canvasKeyPressEventArgs.preventVerticalPan) {
                  if (event.shift) {
                    this.viewport.zoomBy(1.1);
                  } else {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(0, -40)));
                  }
                  this.viewport.applyConstraints();
                }
                return false;
              case 115:
              case 83:
                if (!canvasKeyPressEventArgs.preventVerticalPan) {
                  if (event.shift) {
                    this.viewport.zoomBy(0.9);
                  } else {
                    this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(0, 40)));
                  }
                  this.viewport.applyConstraints();
                }
                return false;
              case 97:
                if (!canvasKeyPressEventArgs.preventHorizontalPan) {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(-40, 0)));
                  this.viewport.applyConstraints();
                }
                return false;
              case 100:
                if (!canvasKeyPressEventArgs.preventHorizontalPan) {
                  this.viewport.panBy(this.viewport.deltaPointsFromPixels(new $3.Point(40, 0)));
                  this.viewport.applyConstraints();
                }
                return false;
              case 114:
                if (this.viewport.flipped) {
                  this.viewport.setRotation($3.positiveModulo(this.viewport.degrees - this.rotationIncrement, 360));
                } else {
                  this.viewport.setRotation($3.positiveModulo(this.viewport.degrees + this.rotationIncrement, 360));
                }
                this.viewport.applyConstraints();
                return false;
              case 82:
                if (this.viewport.flipped) {
                  this.viewport.setRotation($3.positiveModulo(this.viewport.degrees + this.rotationIncrement, 360));
                } else {
                  this.viewport.setRotation($3.positiveModulo(this.viewport.degrees - this.rotationIncrement, 360));
                }
                this.viewport.applyConstraints();
                return false;
              case 102:
                this.viewport.toggleFlip();
                return false;
              default:
                return true;
            }
          } else {
            return true;
          }
        }
        function onCanvasClick(event) {
          var gestureSettings;
          var haveKeyboardFocus = document.activeElement == this.canvas;
          if (!haveKeyboardFocus) {
            this.canvas.focus();
          }
          if (this.viewport.flipped) {
            event.position.x = this.viewport.getContainerSize().x - event.position.x;
          }
          var canvasClickEventArgs = {
            tracker: event.eventSource,
            position: event.position,
            quick: event.quick,
            shift: event.shift,
            originalEvent: event.originalEvent,
            preventDefaultAction: event.preventDefaultAction
          };
          this.raiseEvent("canvas-click", canvasClickEventArgs);
          if (!canvasClickEventArgs.preventDefaultAction && this.viewport && event.quick) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.clickToZoom) {
              this.viewport.zoomBy(
                event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
              );
              this.viewport.applyConstraints();
            }
          }
        }
        function onCanvasDblClick(event) {
          var gestureSettings;
          var canvasDblClickEventArgs = {
            tracker: event.eventSource,
            position: event.position,
            shift: event.shift,
            originalEvent: event.originalEvent,
            preventDefaultAction: event.preventDefaultAction
          };
          this.raiseEvent("canvas-double-click", canvasDblClickEventArgs);
          if (!canvasDblClickEventArgs.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.dblClickToZoom) {
              this.viewport.zoomBy(
                event.shift ? 1 / this.zoomPerClick : this.zoomPerClick,
                gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
              );
              this.viewport.applyConstraints();
            }
          }
        }
        function onCanvasDrag(event) {
          var gestureSettings;
          var canvasDragEventArgs = {
            tracker: event.eventSource,
            position: event.position,
            delta: event.delta,
            speed: event.speed,
            direction: event.direction,
            shift: event.shift,
            originalEvent: event.originalEvent,
            preventDefaultAction: event.preventDefaultAction
          };
          this.raiseEvent("canvas-drag", canvasDragEventArgs);
          if (!canvasDragEventArgs.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (!this.panHorizontal) {
              event.delta.x = 0;
            }
            if (!this.panVertical) {
              event.delta.y = 0;
            }
            if (this.viewport.flipped) {
              event.delta.x = -event.delta.x;
            }
            if (this.constrainDuringPan) {
              var delta = this.viewport.deltaPointsFromPixels(event.delta.negate());
              this.viewport.centerSpringX.target.value += delta.x;
              this.viewport.centerSpringY.target.value += delta.y;
              var bounds = this.viewport.getBounds();
              var constrainedBounds = this.viewport.getConstrainedBounds();
              this.viewport.centerSpringX.target.value -= delta.x;
              this.viewport.centerSpringY.target.value -= delta.y;
              if (bounds.x != constrainedBounds.x) {
                event.delta.x = 0;
              }
              if (bounds.y != constrainedBounds.y) {
                event.delta.y = 0;
              }
            }
            this.viewport.panBy(this.viewport.deltaPointsFromPixels(event.delta.negate()), gestureSettings.flickEnabled && !this.constrainDuringPan);
          }
        }
        function onCanvasDragEnd(event) {
          if (!event.preventDefaultAction && this.viewport) {
            var gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.flickEnabled && event.speed >= gestureSettings.flickMinSpeed) {
              var amplitudeX = 0;
              if (this.panHorizontal) {
                amplitudeX = gestureSettings.flickMomentum * event.speed * Math.cos(event.direction);
              }
              var amplitudeY = 0;
              if (this.panVertical) {
                amplitudeY = gestureSettings.flickMomentum * event.speed * Math.sin(event.direction);
              }
              var center2 = this.viewport.pixelFromPoint(
                this.viewport.getCenter(true)
              );
              var target = this.viewport.pointFromPixel(
                new $3.Point(center2.x - amplitudeX, center2.y - amplitudeY)
              );
              this.viewport.panTo(target, false);
            }
            this.viewport.applyConstraints();
          }
          this.raiseEvent("canvas-drag-end", {
            tracker: event.eventSource,
            position: event.position,
            speed: event.speed,
            direction: event.direction,
            shift: event.shift,
            originalEvent: event.originalEvent
          });
        }
        function onCanvasEnter(event) {
          this.raiseEvent("canvas-enter", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
          });
        }
        function onCanvasExit(event) {
          if (window.location != window.parent.location) {
            $3.MouseTracker.resetAllMouseTrackers();
          }
          this.raiseEvent("canvas-exit", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
          });
        }
        function onCanvasPress(event) {
          this.raiseEvent("canvas-press", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            insideElementPressed: event.insideElementPressed,
            insideElementReleased: event.insideElementReleased,
            originalEvent: event.originalEvent
          });
        }
        function onCanvasRelease(event) {
          this.raiseEvent("canvas-release", {
            tracker: event.eventSource,
            pointerType: event.pointerType,
            position: event.position,
            insideElementPressed: event.insideElementPressed,
            insideElementReleased: event.insideElementReleased,
            originalEvent: event.originalEvent
          });
        }
        function onCanvasNonPrimaryPress(event) {
          this.raiseEvent("canvas-nonprimary-press", {
            tracker: event.eventSource,
            position: event.position,
            pointerType: event.pointerType,
            button: event.button,
            buttons: event.buttons,
            originalEvent: event.originalEvent
          });
        }
        function onCanvasNonPrimaryRelease(event) {
          this.raiseEvent("canvas-nonprimary-release", {
            tracker: event.eventSource,
            position: event.position,
            pointerType: event.pointerType,
            button: event.button,
            buttons: event.buttons,
            originalEvent: event.originalEvent
          });
        }
        function onCanvasPinch(event) {
          var gestureSettings, centerPt, lastCenterPt, panByPt;
          if (!event.preventDefaultAction && this.viewport) {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings.pinchToZoom) {
              centerPt = this.viewport.pointFromPixel(event.center, true);
              lastCenterPt = this.viewport.pointFromPixel(event.lastCenter, true);
              panByPt = lastCenterPt.minus(centerPt);
              if (!this.panHorizontal) {
                panByPt.x = 0;
              }
              if (!this.panVertical) {
                panByPt.y = 0;
              }
              this.viewport.zoomBy(event.distance / event.lastDistance, centerPt, true);
              if (gestureSettings.zoomToRefPoint) {
                this.viewport.panBy(panByPt, true);
              }
              this.viewport.applyConstraints();
            }
            if (gestureSettings.pinchRotate) {
              var angle1 = Math.atan2(
                event.gesturePoints[0].currentPos.y - event.gesturePoints[1].currentPos.y,
                event.gesturePoints[0].currentPos.x - event.gesturePoints[1].currentPos.x
              );
              var angle2 = Math.atan2(
                event.gesturePoints[0].lastPos.y - event.gesturePoints[1].lastPos.y,
                event.gesturePoints[0].lastPos.x - event.gesturePoints[1].lastPos.x
              );
              this.viewport.setRotation(this.viewport.getRotation() + (angle1 - angle2) * (180 / Math.PI));
            }
          }
          this.raiseEvent("canvas-pinch", {
            tracker: event.eventSource,
            gesturePoints: event.gesturePoints,
            lastCenter: event.lastCenter,
            center: event.center,
            lastDistance: event.lastDistance,
            distance: event.distance,
            shift: event.shift,
            originalEvent: event.originalEvent
          });
          return false;
        }
        function onCanvasScroll(event) {
          var gestureSettings, factor, thisScrollTime, deltaScrollTime;
          thisScrollTime = $3.now();
          deltaScrollTime = thisScrollTime - this._lastScrollTime;
          if (deltaScrollTime > this.minScrollDeltaTime) {
            this._lastScrollTime = thisScrollTime;
            if (this.viewport.flipped) {
              event.position.x = this.viewport.getContainerSize().x - event.position.x;
            }
            if (!event.preventDefaultAction && this.viewport) {
              gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
              if (gestureSettings.scrollToZoom) {
                factor = Math.pow(this.zoomPerScroll, event.scroll);
                this.viewport.zoomBy(
                  factor,
                  gestureSettings.zoomToRefPoint ? this.viewport.pointFromPixel(event.position, true) : null
                );
                this.viewport.applyConstraints();
              }
            }
            this.raiseEvent("canvas-scroll", {
              tracker: event.eventSource,
              position: event.position,
              scroll: event.scroll,
              shift: event.shift,
              originalEvent: event.originalEvent
            });
            if (gestureSettings && gestureSettings.scrollToZoom) {
              return false;
            }
          } else {
            gestureSettings = this.gestureSettingsByDeviceType(event.pointerType);
            if (gestureSettings && gestureSettings.scrollToZoom) {
              return false;
            }
          }
        }
        function onContainerEnter(event) {
          THIS[this.hash].mouseInside = true;
          abortControlsAutoHide(this);
          this.raiseEvent("container-enter", {
            tracker: event.eventSource,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
          });
        }
        function onContainerExit(event) {
          if (event.pointers < 1) {
            THIS[this.hash].mouseInside = false;
            if (!THIS[this.hash].animating) {
              beginControlsAutoHide(this);
            }
          }
          this.raiseEvent("container-exit", {
            tracker: event.eventSource,
            position: event.position,
            buttons: event.buttons,
            pointers: event.pointers,
            insideElementPressed: event.insideElementPressed,
            buttonDownAny: event.buttonDownAny,
            originalEvent: event.originalEvent
          });
        }
        function updateMulti(viewer) {
          updateOnce(viewer);
          if (viewer.isOpen()) {
            viewer._updateRequestId = scheduleUpdate(viewer, updateMulti);
          } else {
            viewer._updateRequestId = false;
          }
        }
        function updateOnce(viewer) {
          if (viewer._opening) {
            return;
          }
          if (viewer.autoResize) {
            var containerSize = _getSafeElemSize(viewer.container);
            var prevContainerSize = THIS[viewer.hash].prevContainerSize;
            if (!containerSize.equals(prevContainerSize)) {
              var viewport = viewer.viewport;
              if (viewer.preserveImageSizeOnResize) {
                var resizeRatio = prevContainerSize.x / containerSize.x;
                var zoom = viewport.getZoom() * resizeRatio;
                var center2 = viewport.getCenter();
                viewport.resize(containerSize, false);
                viewport.zoomTo(zoom, null, true);
                viewport.panTo(center2, true);
              } else {
                var oldBounds = viewport.getBounds();
                viewport.resize(containerSize, true);
                viewport.fitBoundsWithConstraints(oldBounds, true);
              }
              THIS[viewer.hash].prevContainerSize = containerSize;
              THIS[viewer.hash].forceRedraw = true;
            }
          }
          var viewportChange = viewer.viewport.update();
          var animated = viewer.world.update() || viewportChange;
          if (viewportChange) {
            viewer.raiseEvent("viewport-change");
          }
          if (viewer.referenceStrip) {
            animated = viewer.referenceStrip.update(viewer.viewport) || animated;
          }
          if (!THIS[viewer.hash].animating && animated) {
            viewer.raiseEvent("animation-start");
            abortControlsAutoHide(viewer);
          }
          if (animated || THIS[viewer.hash].forceRedraw || viewer.world.needsDraw()) {
            drawWorld(viewer);
            viewer._drawOverlays();
            if (viewer.navigator) {
              viewer.navigator.update(viewer.viewport);
            }
            THIS[viewer.hash].forceRedraw = false;
            if (animated) {
              viewer.raiseEvent("animation");
            }
          }
          if (THIS[viewer.hash].animating && !animated) {
            viewer.raiseEvent("animation-finish");
            if (!THIS[viewer.hash].mouseInside) {
              beginControlsAutoHide(viewer);
            }
          }
          THIS[viewer.hash].animating = animated;
        }
        function drawWorld(viewer) {
          viewer.imageLoader.clear();
          viewer.drawer.clear();
          viewer.world.draw();
          viewer.raiseEvent("update-viewport", {});
        }
        function resolveUrl(prefix, url) {
          return prefix ? prefix + url : url;
        }
        function beginZoomingIn() {
          THIS[this.hash].lastZoomTime = $3.now();
          THIS[this.hash].zoomFactor = this.zoomPerSecond;
          THIS[this.hash].zooming = true;
          scheduleZoom(this);
        }
        function beginZoomingOut() {
          THIS[this.hash].lastZoomTime = $3.now();
          THIS[this.hash].zoomFactor = 1 / this.zoomPerSecond;
          THIS[this.hash].zooming = true;
          scheduleZoom(this);
        }
        function endZooming() {
          THIS[this.hash].zooming = false;
        }
        function scheduleZoom(viewer) {
          $3.requestAnimationFrame($3.delegate(viewer, doZoom));
        }
        function doZoom() {
          var currentTime, deltaTime, adjustedFactor;
          if (THIS[this.hash].zooming && this.viewport) {
            currentTime = $3.now();
            deltaTime = currentTime - THIS[this.hash].lastZoomTime;
            adjustedFactor = Math.pow(THIS[this.hash].zoomFactor, deltaTime / 1e3);
            this.viewport.zoomBy(adjustedFactor);
            this.viewport.applyConstraints();
            THIS[this.hash].lastZoomTime = currentTime;
            scheduleZoom(this);
          }
        }
        function doSingleZoomIn() {
          if (this.viewport) {
            THIS[this.hash].zooming = false;
            this.viewport.zoomBy(
              this.zoomPerClick / 1
            );
            this.viewport.applyConstraints();
          }
        }
        function doSingleZoomOut() {
          if (this.viewport) {
            THIS[this.hash].zooming = false;
            this.viewport.zoomBy(
              1 / this.zoomPerClick
            );
            this.viewport.applyConstraints();
          }
        }
        function lightUp() {
          this.buttons.emulateEnter();
          this.buttons.emulateExit();
        }
        function onHome() {
          if (this.viewport) {
            this.viewport.goHome();
          }
        }
        function onFullScreen() {
          if (this.isFullPage() && !$3.isFullScreen()) {
            this.setFullPage(false);
          } else {
            this.setFullScreen(!this.isFullPage());
          }
          if (this.buttons) {
            this.buttons.emulateExit();
          }
          this.fullPageButton.element.focus();
          if (this.viewport) {
            this.viewport.applyConstraints();
          }
        }
        function onRotateLeft() {
          if (this.viewport) {
            var currRotation = this.viewport.getRotation();
            if (this.viewport.flipped) {
              currRotation = $3.positiveModulo(currRotation + this.rotationIncrement, 360);
            } else {
              currRotation = $3.positiveModulo(currRotation - this.rotationIncrement, 360);
            }
            this.viewport.setRotation(currRotation);
          }
        }
        function onRotateRight() {
          if (this.viewport) {
            var currRotation = this.viewport.getRotation();
            if (this.viewport.flipped) {
              currRotation = $3.positiveModulo(currRotation - this.rotationIncrement, 360);
            } else {
              currRotation = $3.positiveModulo(currRotation + this.rotationIncrement, 360);
            }
            this.viewport.setRotation(currRotation);
          }
        }
        function onFlip() {
          this.viewport.toggleFlip();
        }
        function onPrevious() {
          var previous = this._sequenceIndex - 1;
          if (this.navPrevNextWrap && previous < 0) {
            previous += this.tileSources.length;
          }
          this.goToPage(previous);
        }
        function onNext() {
          var next = this._sequenceIndex + 1;
          if (this.navPrevNextWrap && next >= this.tileSources.length) {
            next = 0;
          }
          this.goToPage(next);
        }
      })(OpenSeadragon);
      (function($3) {
        $3.Navigator = function(options) {
          var viewer = options.viewer, _this = this, viewerSize, navigatorSize;
          if (!options.id) {
            options.id = "navigator-" + $3.now();
            this.element = $3.makeNeutralElement("div");
            options.controlOptions = {
              anchor: $3.ControlAnchor.TOP_RIGHT,
              attachToViewer: true,
              autoFade: options.autoFade
            };
            if (options.position) {
              if ("BOTTOM_RIGHT" == options.position) {
                options.controlOptions.anchor = $3.ControlAnchor.BOTTOM_RIGHT;
              } else if ("BOTTOM_LEFT" == options.position) {
                options.controlOptions.anchor = $3.ControlAnchor.BOTTOM_LEFT;
              } else if ("TOP_RIGHT" == options.position) {
                options.controlOptions.anchor = $3.ControlAnchor.TOP_RIGHT;
              } else if ("TOP_LEFT" == options.position) {
                options.controlOptions.anchor = $3.ControlAnchor.TOP_LEFT;
              } else if ("ABSOLUTE" == options.position) {
                options.controlOptions.anchor = $3.ControlAnchor.ABSOLUTE;
                options.controlOptions.top = options.top;
                options.controlOptions.left = options.left;
                options.controlOptions.height = options.height;
                options.controlOptions.width = options.width;
              }
            }
          } else {
            this.element = document.getElementById(options.id);
            options.controlOptions = {
              anchor: $3.ControlAnchor.NONE,
              attachToViewer: false,
              autoFade: false
            };
          }
          this.element.id = options.id;
          this.element.className += " navigator";
          options = $3.extend(true, {
            sizeRatio: $3.DEFAULT_SETTINGS.navigatorSizeRatio
          }, options, {
            element: this.element,
            tabIndex: -1,
            showNavigator: false,
            mouseNavEnabled: false,
            showNavigationControl: false,
            showSequenceControl: false,
            immediateRender: true,
            blendTime: 0,
            animationTime: 0,
            autoResize: options.autoResize,
            minZoomImageRatio: 1,
            background: options.background,
            opacity: options.opacity,
            borderColor: options.borderColor,
            displayRegionColor: options.displayRegionColor
          });
          options.minPixelRatio = this.minPixelRatio = viewer.minPixelRatio;
          $3.setElementTouchActionNone(this.element);
          this.borderWidth = 2;
          this.fudge = new $3.Point(1, 1);
          this.totalBorderWidths = new $3.Point(this.borderWidth * 2, this.borderWidth * 2).minus(this.fudge);
          if (options.controlOptions.anchor != $3.ControlAnchor.NONE) {
            (function(style, borderWidth) {
              style.margin = "0px";
              style.border = borderWidth + "px solid " + options.borderColor;
              style.padding = "0px";
              style.background = options.background;
              style.opacity = options.opacity;
              style.overflow = "hidden";
            })(this.element.style, this.borderWidth);
          }
          this.displayRegion = $3.makeNeutralElement("div");
          this.displayRegion.id = this.element.id + "-displayregion";
          this.displayRegion.className = "displayregion";
          (function(style, borderWidth) {
            style.position = "relative";
            style.top = "0px";
            style.left = "0px";
            style.fontSize = "0px";
            style.overflow = "hidden";
            style.border = borderWidth + "px solid " + options.displayRegionColor;
            style.margin = "0px";
            style.padding = "0px";
            style.background = "transparent";
            style["float"] = "left";
            style.cssFloat = "left";
            style.styleFloat = "left";
            style.zIndex = 999999999;
            style.cursor = "default";
          })(this.displayRegion.style, this.borderWidth);
          this.displayRegionContainer = $3.makeNeutralElement("div");
          this.displayRegionContainer.id = this.element.id + "-displayregioncontainer";
          this.displayRegionContainer.className = "displayregioncontainer";
          this.displayRegionContainer.style.width = "100%";
          this.displayRegionContainer.style.height = "100%";
          viewer.addControl(
            this.element,
            options.controlOptions
          );
          this._resizeWithViewer = options.controlOptions.anchor != $3.ControlAnchor.ABSOLUTE && options.controlOptions.anchor != $3.ControlAnchor.NONE;
          if (options.width && options.height) {
            this.setWidth(options.width);
            this.setHeight(options.height);
          } else if (this._resizeWithViewer) {
            viewerSize = $3.getElementSize(viewer.element);
            this.element.style.height = Math.round(viewerSize.y * options.sizeRatio) + "px";
            this.element.style.width = Math.round(viewerSize.x * options.sizeRatio) + "px";
            this.oldViewerSize = viewerSize;
            navigatorSize = $3.getElementSize(this.element);
            this.elementArea = navigatorSize.x * navigatorSize.y;
          }
          this.oldContainerSize = new $3.Point(0, 0);
          $3.Viewer.apply(this, [options]);
          this.displayRegionContainer.appendChild(this.displayRegion);
          this.element.getElementsByTagName("div")[0].appendChild(this.displayRegionContainer);
          function rotate(degrees2) {
            _setTransformRotate(_this.displayRegionContainer, degrees2);
            _setTransformRotate(_this.displayRegion, -degrees2);
            _this.viewport.setRotation(degrees2);
          }
          if (options.navigatorRotate) {
            var degrees = options.viewer.viewport ? options.viewer.viewport.getRotation() : options.viewer.degrees || 0;
            rotate(degrees);
            options.viewer.addHandler("rotate", function(args) {
              rotate(args.degrees);
            });
          }
          this.innerTracker.destroy();
          this.innerTracker = new $3.MouseTracker({
            element: this.element,
            dragHandler: $3.delegate(this, onCanvasDrag),
            clickHandler: $3.delegate(this, onCanvasClick),
            releaseHandler: $3.delegate(this, onCanvasRelease),
            scrollHandler: $3.delegate(this, onCanvasScroll)
          });
          this.addHandler("reset-size", function() {
            if (_this.viewport) {
              _this.viewport.goHome(true);
            }
          });
          viewer.world.addHandler("item-index-change", function(event) {
            window.setTimeout(function() {
              var item = _this.world.getItemAt(event.previousIndex);
              _this.world.setItemIndex(item, event.newIndex);
            }, 1);
          });
          viewer.world.addHandler("remove-item", function(event) {
            var theirItem = event.item;
            var myItem = _this._getMatchingItem(theirItem);
            if (myItem) {
              _this.world.removeItem(myItem);
            }
          });
          this.update(viewer.viewport);
        };
        $3.extend($3.Navigator.prototype, $3.EventSource.prototype, $3.Viewer.prototype, {
          updateSize: function() {
            if (this.viewport) {
              var containerSize = new $3.Point(
                this.container.clientWidth === 0 ? 1 : this.container.clientWidth,
                this.container.clientHeight === 0 ? 1 : this.container.clientHeight
              );
              if (!containerSize.equals(this.oldContainerSize)) {
                this.viewport.resize(containerSize, true);
                this.viewport.goHome(true);
                this.oldContainerSize = containerSize;
                this.drawer.clear();
                this.world.draw();
              }
            }
          },
          setWidth: function(width) {
            this.width = width;
            this.element.style.width = typeof width == "number" ? width + "px" : width;
            this._resizeWithViewer = false;
          },
          setHeight: function(height) {
            this.height = height;
            this.element.style.height = typeof height == "number" ? height + "px" : height;
            this._resizeWithViewer = false;
          },
          setFlip: function(state) {
            this.viewport.setFlip(state);
            this.setDisplayTransform(this.viewer.viewport.getFlip() ? "scale(-1,1)" : "scale(1,1)");
            return this;
          },
          setDisplayTransform: function(rule) {
            setElementTransform(this.displayRegion, rule);
            setElementTransform(this.canvas, rule);
            setElementTransform(this.element, rule);
          },
          update: function(viewport) {
            var viewerSize, newWidth, newHeight, bounds, topleft, bottomright;
            viewerSize = $3.getElementSize(this.viewer.element);
            if (this._resizeWithViewer && viewerSize.x && viewerSize.y && !viewerSize.equals(this.oldViewerSize)) {
              this.oldViewerSize = viewerSize;
              if (this.maintainSizeRatio || !this.elementArea) {
                newWidth = viewerSize.x * this.sizeRatio;
                newHeight = viewerSize.y * this.sizeRatio;
              } else {
                newWidth = Math.sqrt(this.elementArea * (viewerSize.x / viewerSize.y));
                newHeight = this.elementArea / newWidth;
              }
              this.element.style.width = Math.round(newWidth) + "px";
              this.element.style.height = Math.round(newHeight) + "px";
              if (!this.elementArea) {
                this.elementArea = newWidth * newHeight;
              }
              this.updateSize();
            }
            if (viewport && this.viewport) {
              bounds = viewport.getBoundsNoRotate(true);
              topleft = this.viewport.pixelFromPointNoRotate(bounds.getTopLeft(), false);
              bottomright = this.viewport.pixelFromPointNoRotate(bounds.getBottomRight(), false).minus(this.totalBorderWidths);
              var style = this.displayRegion.style;
              style.display = this.world.getItemCount() ? "block" : "none";
              style.top = Math.round(topleft.y) + "px";
              style.left = Math.round(topleft.x) + "px";
              var width = Math.abs(topleft.x - bottomright.x);
              var height = Math.abs(topleft.y - bottomright.y);
              style.width = Math.round(Math.max(width, 0)) + "px";
              style.height = Math.round(Math.max(height, 0)) + "px";
            }
          },
          addTiledImage: function(options) {
            var _this = this;
            var original = options.originalTiledImage;
            delete options.original;
            var optionsClone = $3.extend({}, options, {
              success: function(event) {
                var myItem = event.item;
                myItem._originalForNavigator = original;
                _this._matchBounds(myItem, original, true);
                function matchBounds() {
                  _this._matchBounds(myItem, original);
                }
                function matchOpacity() {
                  _this._matchOpacity(myItem, original);
                }
                function matchCompositeOperation() {
                  _this._matchCompositeOperation(myItem, original);
                }
                original.addHandler("bounds-change", matchBounds);
                original.addHandler("clip-change", matchBounds);
                original.addHandler("opacity-change", matchOpacity);
                original.addHandler("composite-operation-change", matchCompositeOperation);
              }
            });
            return $3.Viewer.prototype.addTiledImage.apply(this, [optionsClone]);
          },
          _getMatchingItem: function(theirItem) {
            var count = this.world.getItemCount();
            var item;
            for (var i2 = 0; i2 < count; i2++) {
              item = this.world.getItemAt(i2);
              if (item._originalForNavigator === theirItem) {
                return item;
              }
            }
            return null;
          },
          _matchBounds: function(myItem, theirItem, immediately) {
            var bounds = theirItem.getBoundsNoRotate();
            myItem.setPosition(bounds.getTopLeft(), immediately);
            myItem.setWidth(bounds.width, immediately);
            myItem.setRotation(theirItem.getRotation(), immediately);
            myItem.setClip(theirItem.getClip());
          },
          _matchOpacity: function(myItem, theirItem) {
            myItem.setOpacity(theirItem.opacity);
          },
          _matchCompositeOperation: function(myItem, theirItem) {
            myItem.setCompositeOperation(theirItem.compositeOperation);
          }
        });
        function onCanvasClick(event) {
          var canvasClickEventArgs = {
            tracker: event.eventSource,
            position: event.position,
            quick: event.quick,
            shift: event.shift,
            originalEvent: event.originalEvent,
            preventDefaultAction: event.preventDefaultAction
          };
          this.viewer.raiseEvent("navigator-click", canvasClickEventArgs);
          if (!canvasClickEventArgs.preventDefaultAction && event.quick && this.viewer.viewport && (this.panVertical || this.panHorizontal)) {
            if (this.viewer.viewport.flipped) {
              event.position.x = this.viewport.getContainerSize().x - event.position.x;
            }
            var target = this.viewport.pointFromPixel(event.position);
            if (!this.panVertical) {
              target.y = this.viewer.viewport.getCenter(true).y;
            } else if (!this.panHorizontal) {
              target.x = this.viewer.viewport.getCenter(true).x;
            }
            this.viewer.viewport.panTo(target);
            this.viewer.viewport.applyConstraints();
          }
        }
        function onCanvasDrag(event) {
          var canvasDragEventArgs = {
            tracker: event.eventSource,
            position: event.position,
            delta: event.delta,
            speed: event.speed,
            direction: event.direction,
            shift: event.shift,
            originalEvent: event.originalEvent,
            preventDefaultAction: event.preventDefaultAction
          };
          this.viewer.raiseEvent("navigator-drag", canvasDragEventArgs);
          if (!canvasDragEventArgs.preventDefaultAction && this.viewer.viewport) {
            if (!this.panHorizontal) {
              event.delta.x = 0;
            }
            if (!this.panVertical) {
              event.delta.y = 0;
            }
            if (this.viewer.viewport.flipped) {
              event.delta.x = -event.delta.x;
            }
            this.viewer.viewport.panBy(
              this.viewport.deltaPointsFromPixels(
                event.delta
              )
            );
            if (this.viewer.constrainDuringPan) {
              this.viewer.viewport.applyConstraints();
            }
          }
        }
        function onCanvasRelease(event) {
          if (event.insideElementPressed && this.viewer.viewport) {
            this.viewer.viewport.applyConstraints();
          }
        }
        function onCanvasScroll(event) {
          this.viewer.raiseEvent("navigator-scroll", {
            tracker: event.eventSource,
            position: event.position,
            scroll: event.scroll,
            shift: event.shift,
            originalEvent: event.originalEvent
          });
          return false;
        }
        function _setTransformRotate(element, degrees) {
          setElementTransform(element, "rotate(" + degrees + "deg)");
        }
        function setElementTransform(element, rule) {
          element.style.webkitTransform = rule;
          element.style.mozTransform = rule;
          element.style.msTransform = rule;
          element.style.oTransform = rule;
          element.style.transform = rule;
        }
      })(OpenSeadragon);
      (function($3) {
        var I18N = {
          Errors: {
            Dzc: "Sorry, we don't support Deep Zoom Collections!",
            Dzi: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
            Xml: "Hmm, this doesn't appear to be a valid Deep Zoom Image.",
            ImageFormat: "Sorry, we don't support {0}-based Deep Zoom Images.",
            Security: "It looks like a security restriction stopped us from loading this Deep Zoom Image.",
            Status: "This space unintentionally left blank ({0} {1}).",
            OpenFailed: "Unable to open {0}: {1}"
          },
          Tooltips: {
            FullPage: "Toggle full page",
            Home: "Go home",
            ZoomIn: "Zoom in",
            ZoomOut: "Zoom out",
            NextPage: "Next page",
            PreviousPage: "Previous page",
            RotateLeft: "Rotate left",
            RotateRight: "Rotate right",
            Flip: "Flip Horizontally"
          }
        };
        $3.extend($3, {
          getString: function(prop) {
            var props = prop.split("."), string2 = null, args = arguments, container2 = I18N, i2;
            for (i2 = 0; i2 < props.length - 1; i2++) {
              container2 = container2[props[i2]] || {};
            }
            string2 = container2[props[i2]];
            if (typeof string2 != "string") {
              $3.console.log("Untranslated source string:", prop);
              string2 = "";
            }
            return string2.replace(/\{\d+\}/g, function(capture) {
              var i3 = parseInt(capture.match(/\d+/), 10) + 1;
              return i3 < args.length ? args[i3] : "";
            });
          },
          setString: function(prop, value) {
            var props = prop.split("."), container2 = I18N, i2;
            for (i2 = 0; i2 < props.length - 1; i2++) {
              if (!container2[props[i2]]) {
                container2[props[i2]] = {};
              }
              container2 = container2[props[i2]];
            }
            container2[props[i2]] = value;
          }
        });
      })(OpenSeadragon);
      (function($3) {
        $3.Point = function(x2, y2) {
          this.x = typeof x2 == "number" ? x2 : 0;
          this.y = typeof y2 == "number" ? y2 : 0;
        };
        $3.Point.prototype = {
          clone: function() {
            return new $3.Point(this.x, this.y);
          },
          plus: function(point) {
            return new $3.Point(
              this.x + point.x,
              this.y + point.y
            );
          },
          minus: function(point) {
            return new $3.Point(
              this.x - point.x,
              this.y - point.y
            );
          },
          times: function(factor) {
            return new $3.Point(
              this.x * factor,
              this.y * factor
            );
          },
          divide: function(factor) {
            return new $3.Point(
              this.x / factor,
              this.y / factor
            );
          },
          negate: function() {
            return new $3.Point(-this.x, -this.y);
          },
          distanceTo: function(point) {
            return Math.sqrt(
              Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2)
            );
          },
          squaredDistanceTo: function(point) {
            return Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2);
          },
          apply: function(func) {
            return new $3.Point(func(this.x), func(this.y));
          },
          equals: function(point) {
            return point instanceof $3.Point && this.x === point.x && this.y === point.y;
          },
          rotate: function(degrees, pivot) {
            pivot = pivot || new $3.Point(0, 0);
            var cos;
            var sin;
            if (degrees % 90 === 0) {
              var d3 = $3.positiveModulo(degrees, 360);
              switch (d3) {
                case 0:
                  cos = 1;
                  sin = 0;
                  break;
                case 90:
                  cos = 0;
                  sin = 1;
                  break;
                case 180:
                  cos = -1;
                  sin = 0;
                  break;
                case 270:
                  cos = 0;
                  sin = -1;
                  break;
              }
            } else {
              var angle = degrees * Math.PI / 180;
              cos = Math.cos(angle);
              sin = Math.sin(angle);
            }
            var x2 = cos * (this.x - pivot.x) - sin * (this.y - pivot.y) + pivot.x;
            var y2 = sin * (this.x - pivot.x) + cos * (this.y - pivot.y) + pivot.y;
            return new $3.Point(x2, y2);
          },
          toString: function() {
            return "(" + Math.round(this.x * 100) / 100 + "," + Math.round(this.y * 100) / 100 + ")";
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.TileSource = function(width, height, tileSize, tileOverlap, minLevel, maxLevel) {
          var _this = this;
          var args = arguments, options, i2;
          if ($3.isPlainObject(width)) {
            options = width;
          } else {
            options = {
              width: args[0],
              height: args[1],
              tileSize: args[2],
              tileOverlap: args[3],
              minLevel: args[4],
              maxLevel: args[5]
            };
          }
          $3.EventSource.call(this);
          $3.extend(true, this, options);
          if (!this.success) {
            for (i2 = 0; i2 < arguments.length; i2++) {
              if ($3.isFunction(arguments[i2])) {
                this.success = arguments[i2];
                break;
              }
            }
          }
          if (this.success) {
            this.addHandler("ready", function(event) {
              _this.success(event);
            });
          }
          if ("string" == $3.type(arguments[0])) {
            this.url = arguments[0];
          }
          if (this.url) {
            this.aspectRatio = 1;
            this.dimensions = new $3.Point(10, 10);
            this._tileWidth = 0;
            this._tileHeight = 0;
            this.tileOverlap = 0;
            this.minLevel = 0;
            this.maxLevel = 0;
            this.ready = false;
            this.getImageInfo(this.url);
          } else {
            this.ready = true;
            this.aspectRatio = options.width && options.height ? options.width / options.height : 1;
            this.dimensions = new $3.Point(options.width, options.height);
            if (this.tileSize) {
              this._tileWidth = this._tileHeight = this.tileSize;
              delete this.tileSize;
            } else {
              if (this.tileWidth) {
                this._tileWidth = this.tileWidth;
                delete this.tileWidth;
              } else {
                this._tileWidth = 0;
              }
              if (this.tileHeight) {
                this._tileHeight = this.tileHeight;
                delete this.tileHeight;
              } else {
                this._tileHeight = 0;
              }
            }
            this.tileOverlap = options.tileOverlap ? options.tileOverlap : 0;
            this.minLevel = options.minLevel ? options.minLevel : 0;
            this.maxLevel = void 0 !== options.maxLevel && null !== options.maxLevel ? options.maxLevel : options.width && options.height ? Math.ceil(
              Math.log(Math.max(options.width, options.height)) / Math.log(2)
            ) : 0;
            if (this.success && $3.isFunction(this.success)) {
              this.success(this);
            }
          }
        };
        $3.TileSource.prototype = {
          getTileSize: function(level) {
            $3.console.error(
              "[TileSource.getTileSize] is deprecated. Use TileSource.getTileWidth() and TileSource.getTileHeight() instead"
            );
            return this._tileWidth;
          },
          getTileWidth: function(level) {
            if (!this._tileWidth) {
              return this.getTileSize(level);
            }
            return this._tileWidth;
          },
          getTileHeight: function(level) {
            if (!this._tileHeight) {
              return this.getTileSize(level);
            }
            return this._tileHeight;
          },
          getLevelScale: function(level) {
            var levelScaleCache = {}, i2;
            for (i2 = 0; i2 <= this.maxLevel; i2++) {
              levelScaleCache[i2] = 1 / Math.pow(2, this.maxLevel - i2);
            }
            this.getLevelScale = function(_level) {
              return levelScaleCache[_level];
            };
            return this.getLevelScale(level);
          },
          getNumTiles: function(level) {
            var scale = this.getLevelScale(level), x2 = Math.ceil(scale * this.dimensions.x / this.getTileWidth(level)), y2 = Math.ceil(scale * this.dimensions.y / this.getTileHeight(level));
            return new $3.Point(x2, y2);
          },
          getPixelRatio: function(level) {
            var imageSizeScaled = this.dimensions.times(this.getLevelScale(level)), rx = 1 / imageSizeScaled.x, ry = 1 / imageSizeScaled.y;
            return new $3.Point(rx, ry);
          },
          getClosestLevel: function() {
            var i2, tiles;
            for (i2 = this.minLevel + 1; i2 <= this.maxLevel; i2++) {
              tiles = this.getNumTiles(i2);
              if (tiles.x > 1 || tiles.y > 1) {
                break;
              }
            }
            return i2 - 1;
          },
          getTileAtPoint: function(level, point) {
            var validPoint = point.x >= 0 && point.x <= 1 && point.y >= 0 && point.y <= 1 / this.aspectRatio;
            $3.console.assert(validPoint, "[TileSource.getTileAtPoint] must be called with a valid point.");
            var widthScaled = this.dimensions.x * this.getLevelScale(level);
            var pixelX = point.x * widthScaled;
            var pixelY = point.y * widthScaled;
            var x2 = Math.floor(pixelX / this.getTileWidth(level));
            var y2 = Math.floor(pixelY / this.getTileHeight(level));
            if (point.x >= 1) {
              x2 = this.getNumTiles(level).x - 1;
            }
            var EPSILON = 1e-15;
            if (point.y >= 1 / this.aspectRatio - EPSILON) {
              y2 = this.getNumTiles(level).y - 1;
            }
            return new $3.Point(x2, y2);
          },
          getTileBounds: function(level, x2, y2, isSource) {
            var dimensionsScaled = this.dimensions.times(this.getLevelScale(level)), tileWidth = this.getTileWidth(level), tileHeight = this.getTileHeight(level), px = x2 === 0 ? 0 : tileWidth * x2 - this.tileOverlap, py = y2 === 0 ? 0 : tileHeight * y2 - this.tileOverlap, sx = tileWidth + (x2 === 0 ? 1 : 2) * this.tileOverlap, sy = tileHeight + (y2 === 0 ? 1 : 2) * this.tileOverlap, scale = 1 / dimensionsScaled.x;
            sx = Math.min(sx, dimensionsScaled.x - px);
            sy = Math.min(sy, dimensionsScaled.y - py);
            if (isSource) {
              return new $3.Rect(0, 0, sx, sy);
            }
            return new $3.Rect(px * scale, py * scale, sx * scale, sy * scale);
          },
          getImageInfo: function(url) {
            var _this = this, callbackName, callback, readySource, options, urlParts, filename, lastDot;
            if (url) {
              urlParts = url.split("/");
              filename = urlParts[urlParts.length - 1];
              lastDot = filename.lastIndexOf(".");
              if (lastDot > -1) {
                urlParts[urlParts.length - 1] = filename.slice(0, lastDot);
              }
            }
            callback = function(data) {
              if (typeof data === "string") {
                data = $3.parseXml(data);
              }
              var $TileSource = $3.TileSource.determineType(_this, data, url);
              if (!$TileSource) {
                _this.raiseEvent("open-failed", { message: "Unable to load TileSource", source: url });
                return;
              }
              options = $TileSource.prototype.configure.apply(_this, [data, url]);
              if (options.ajaxWithCredentials === void 0) {
                options.ajaxWithCredentials = _this.ajaxWithCredentials;
              }
              readySource = new $TileSource(options);
              _this.ready = true;
              _this.raiseEvent("ready", { tileSource: readySource });
            };
            if (url.match(/\.js$/)) {
              callbackName = url.split("/").pop().replace(".js", "");
              $3.jsonp({
                url,
                async: false,
                callbackName,
                callback
              });
            } else {
              $3.makeAjaxRequest({
                url,
                withCredentials: this.ajaxWithCredentials,
                headers: this.ajaxHeaders,
                success: function(xhr) {
                  var data = processResponse(xhr);
                  callback(data);
                },
                error: function(xhr, exc) {
                  var msg;
                  try {
                    msg = "HTTP " + xhr.status + " attempting to load TileSource";
                  } catch (e3) {
                    var formattedExc;
                    if (typeof exc == "undefined" || !exc.toString) {
                      formattedExc = "Unknown error";
                    } else {
                      formattedExc = exc.toString();
                    }
                    msg = formattedExc + " attempting to load TileSource";
                  }
                  _this.raiseEvent("open-failed", {
                    message: msg,
                    source: url
                  });
                }
              });
            }
          },
          supports: function(data, url) {
            return false;
          },
          configure: function(data, url) {
            throw new Error("Method not implemented.");
          },
          getTileUrl: function(level, x2, y2) {
            throw new Error("Method not implemented.");
          },
          getTileAjaxHeaders: function(level, x2, y2) {
            return {};
          },
          tileExists: function(level, x2, y2) {
            var numTiles = this.getNumTiles(level);
            return level >= this.minLevel && level <= this.maxLevel && x2 >= 0 && y2 >= 0 && x2 < numTiles.x && y2 < numTiles.y;
          }
        };
        $3.extend(true, $3.TileSource.prototype, $3.EventSource.prototype);
        function processResponse(xhr) {
          var responseText = xhr.responseText, status2 = xhr.status, statusText, data;
          if (!xhr) {
            throw new Error($3.getString("Errors.Security"));
          } else if (xhr.status !== 200 && xhr.status !== 0) {
            status2 = xhr.status;
            statusText = status2 == 404 ? "Not Found" : xhr.statusText;
            throw new Error($3.getString("Errors.Status", status2, statusText));
          }
          if (responseText.match(/\s*<.*/)) {
            try {
              data = xhr.responseXML && xhr.responseXML.documentElement ? xhr.responseXML : $3.parseXml(responseText);
            } catch (e3) {
              data = xhr.responseText;
            }
          } else if (responseText.match(/\s*[\{\[].*/)) {
            try {
              data = $3.parseJSON(responseText);
            } catch (e3) {
              data = responseText;
            }
          } else {
            data = responseText;
          }
          return data;
        }
        $3.TileSource.determineType = function(tileSource, data, url) {
          var property;
          for (property in OpenSeadragon) {
            if (property.match(/.+TileSource$/) && $3.isFunction(OpenSeadragon[property]) && $3.isFunction(OpenSeadragon[property].prototype.supports) && OpenSeadragon[property].prototype.supports.call(tileSource, data, url)) {
              return OpenSeadragon[property];
            }
          }
          $3.console.error("No TileSource was able to open %s %s", url, data);
        };
      })(OpenSeadragon);
      (function($3) {
        $3.DziTileSource = function(width, height, tileSize, tileOverlap, tilesUrl, fileFormat, displayRects, minLevel, maxLevel) {
          var i2, rect, level, options;
          if ($3.isPlainObject(width)) {
            options = width;
          } else {
            options = {
              width: arguments[0],
              height: arguments[1],
              tileSize: arguments[2],
              tileOverlap: arguments[3],
              tilesUrl: arguments[4],
              fileFormat: arguments[5],
              displayRects: arguments[6],
              minLevel: arguments[7],
              maxLevel: arguments[8]
            };
          }
          this._levelRects = {};
          this.tilesUrl = options.tilesUrl;
          this.fileFormat = options.fileFormat;
          this.displayRects = options.displayRects;
          if (this.displayRects) {
            for (i2 = this.displayRects.length - 1; i2 >= 0; i2--) {
              rect = this.displayRects[i2];
              for (level = rect.minLevel; level <= rect.maxLevel; level++) {
                if (!this._levelRects[level]) {
                  this._levelRects[level] = [];
                }
                this._levelRects[level].push(rect);
              }
            }
          }
          $3.TileSource.apply(this, [options]);
        };
        $3.extend($3.DziTileSource.prototype, $3.TileSource.prototype, {
          supports: function(data, url) {
            var ns;
            if (data.Image) {
              ns = data.Image.xmlns;
            } else if (data.documentElement) {
              if ("Image" == data.documentElement.localName || "Image" == data.documentElement.tagName) {
                ns = data.documentElement.namespaceURI;
              }
            }
            ns = (ns || "").toLowerCase();
            return ns.indexOf("schemas.microsoft.com/deepzoom/2008") !== -1 || ns.indexOf("schemas.microsoft.com/deepzoom/2009") !== -1;
          },
          configure: function(data, url) {
            var options;
            if (!$3.isPlainObject(data)) {
              options = configureFromXML(this, data);
            } else {
              options = configureFromObject(this, data);
            }
            if (url && !options.tilesUrl) {
              options.tilesUrl = url.replace(
                /([^\/]+?)(\.(dzi|xml|js)?(\?[^\/]*)?)?\/?$/,
                "$1_files/"
              );
              if (url.search(/\.(dzi|xml|js)\?/) != -1) {
                options.queryParams = url.match(/\?.*/);
              } else {
                options.queryParams = "";
              }
            }
            return options;
          },
          getTileUrl: function(level, x2, y2) {
            return [this.tilesUrl, level, "/", x2, "_", y2, ".", this.fileFormat, this.queryParams].join("");
          },
          tileExists: function(level, x2, y2) {
            var rects = this._levelRects[level], rect, scale, xMin, yMin, xMax, yMax, i2;
            if (this.minLevel && level < this.minLevel || this.maxLevel && level > this.maxLevel) {
              return false;
            }
            if (!rects || !rects.length) {
              return true;
            }
            for (i2 = rects.length - 1; i2 >= 0; i2--) {
              rect = rects[i2];
              if (level < rect.minLevel || level > rect.maxLevel) {
                continue;
              }
              scale = this.getLevelScale(level);
              xMin = rect.x * scale;
              yMin = rect.y * scale;
              xMax = xMin + rect.width * scale;
              yMax = yMin + rect.height * scale;
              xMin = Math.floor(xMin / this._tileWidth);
              yMin = Math.floor(yMin / this._tileWidth);
              xMax = Math.ceil(xMax / this._tileWidth);
              yMax = Math.ceil(yMax / this._tileWidth);
              if (xMin <= x2 && x2 < xMax && yMin <= y2 && y2 < yMax) {
                return true;
              }
            }
            return false;
          }
        });
        function configureFromXML(tileSource, xmlDoc) {
          if (!xmlDoc || !xmlDoc.documentElement) {
            throw new Error($3.getString("Errors.Xml"));
          }
          var root2 = xmlDoc.documentElement, rootName = root2.localName || root2.tagName, ns = xmlDoc.documentElement.namespaceURI, configuration2 = null, displayRects = [], dispRectNodes, dispRectNode, rectNode, sizeNode, i2;
          if (rootName == "Image") {
            try {
              sizeNode = root2.getElementsByTagName("Size")[0];
              if (sizeNode === void 0) {
                sizeNode = root2.getElementsByTagNameNS(ns, "Size")[0];
              }
              configuration2 = {
                Image: {
                  xmlns: "http://schemas.microsoft.com/deepzoom/2008",
                  Url: root2.getAttribute("Url"),
                  Format: root2.getAttribute("Format"),
                  DisplayRect: null,
                  Overlap: parseInt(root2.getAttribute("Overlap"), 10),
                  TileSize: parseInt(root2.getAttribute("TileSize"), 10),
                  Size: {
                    Height: parseInt(sizeNode.getAttribute("Height"), 10),
                    Width: parseInt(sizeNode.getAttribute("Width"), 10)
                  }
                }
              };
              if (!$3.imageFormatSupported(configuration2.Image.Format)) {
                throw new Error(
                  $3.getString("Errors.ImageFormat", configuration2.Image.Format.toUpperCase())
                );
              }
              dispRectNodes = root2.getElementsByTagName("DisplayRect");
              if (dispRectNodes === void 0) {
                dispRectNodes = root2.getElementsByTagNameNS(ns, "DisplayRect")[0];
              }
              for (i2 = 0; i2 < dispRectNodes.length; i2++) {
                dispRectNode = dispRectNodes[i2];
                rectNode = dispRectNode.getElementsByTagName("Rect")[0];
                if (rectNode === void 0) {
                  rectNode = dispRectNode.getElementsByTagNameNS(ns, "Rect")[0];
                }
                displayRects.push({
                  Rect: {
                    X: parseInt(rectNode.getAttribute("X"), 10),
                    Y: parseInt(rectNode.getAttribute("Y"), 10),
                    Width: parseInt(rectNode.getAttribute("Width"), 10),
                    Height: parseInt(rectNode.getAttribute("Height"), 10),
                    MinLevel: parseInt(dispRectNode.getAttribute("MinLevel"), 10),
                    MaxLevel: parseInt(dispRectNode.getAttribute("MaxLevel"), 10)
                  }
                });
              }
              if (displayRects.length) {
                configuration2.Image.DisplayRect = displayRects;
              }
              return configureFromObject(tileSource, configuration2);
            } catch (e3) {
              throw e3 instanceof Error ? e3 : new Error($3.getString("Errors.Dzi"));
            }
          } else if (rootName == "Collection") {
            throw new Error($3.getString("Errors.Dzc"));
          } else if (rootName == "Error") {
            var messageNode = root2.getElementsByTagName("Message")[0];
            var message = messageNode.firstChild.nodeValue;
            throw new Error(message);
          }
          throw new Error($3.getString("Errors.Dzi"));
        }
        function configureFromObject(tileSource, configuration2) {
          var imageData = configuration2.Image, tilesUrl = imageData.Url, fileFormat = imageData.Format, sizeData = imageData.Size, dispRectData = imageData.DisplayRect || [], width = parseInt(sizeData.Width, 10), height = parseInt(sizeData.Height, 10), tileSize = parseInt(imageData.TileSize, 10), tileOverlap = parseInt(imageData.Overlap, 10), displayRects = [], rectData, i2;
          for (i2 = 0; i2 < dispRectData.length; i2++) {
            rectData = dispRectData[i2].Rect;
            displayRects.push(new $3.DisplayRect(
              parseInt(rectData.X, 10),
              parseInt(rectData.Y, 10),
              parseInt(rectData.Width, 10),
              parseInt(rectData.Height, 10),
              parseInt(rectData.MinLevel, 10),
              parseInt(rectData.MaxLevel, 10)
            ));
          }
          return $3.extend(true, {
            width,
            height,
            tileSize,
            tileOverlap,
            minLevel: null,
            maxLevel: null,
            tilesUrl,
            fileFormat,
            displayRects
          }, configuration2);
        }
      })(OpenSeadragon);
      (function($3) {
        $3.IIIFTileSource = function(options) {
          $3.extend(true, this, options);
          if (!(this.height && this.width && this["@id"])) {
            throw new Error("IIIF required parameters not provided.");
          }
          options.tileSizePerScaleFactor = {};
          this.tileFormat = this.tileFormat || "jpg";
          this.version = options.version;
          if (this.tile_width && this.tile_height) {
            options.tileWidth = this.tile_width;
            options.tileHeight = this.tile_height;
          } else if (this.tile_width) {
            options.tileSize = this.tile_width;
          } else if (this.tile_height) {
            options.tileSize = this.tile_height;
          } else if (this.tiles) {
            if (this.tiles.length == 1) {
              options.tileWidth = this.tiles[0].width;
              options.tileHeight = this.tiles[0].height || this.tiles[0].width;
              this.scale_factors = this.tiles[0].scaleFactors;
            } else {
              this.scale_factors = [];
              for (var t2 = 0; t2 < this.tiles.length; t2++) {
                for (var sf = 0; sf < this.tiles[t2].scaleFactors.length; sf++) {
                  var scaleFactor = this.tiles[t2].scaleFactors[sf];
                  this.scale_factors.push(scaleFactor);
                  options.tileSizePerScaleFactor[scaleFactor] = {
                    width: this.tiles[t2].width,
                    height: this.tiles[t2].height || this.tiles[t2].width
                  };
                }
              }
            }
          } else if (canBeTiled(options)) {
            var shortDim = Math.min(this.height, this.width), tileOptions = [256, 512, 1024], smallerTiles = [];
            for (var c2 = 0; c2 < tileOptions.length; c2++) {
              if (tileOptions[c2] <= shortDim) {
                smallerTiles.push(tileOptions[c2]);
              }
            }
            if (smallerTiles.length > 0) {
              options.tileSize = Math.max.apply(null, smallerTiles);
            } else {
              options.tileSize = shortDim;
            }
          } else if (this.sizes && this.sizes.length > 0) {
            this.emulateLegacyImagePyramid = true;
            options.levels = constructLevels(this);
            $3.extend(true, options, {
              width: options.levels[options.levels.length - 1].width,
              height: options.levels[options.levels.length - 1].height,
              tileSize: Math.max(options.height, options.width),
              tileOverlap: 0,
              minLevel: 0,
              maxLevel: options.levels.length - 1
            });
            this.levels = options.levels;
          } else {
            $3.console.error("Nothing in the info.json to construct image pyramids from");
          }
          if (!options.maxLevel && !this.emulateLegacyImagePyramid) {
            if (!this.scale_factors) {
              options.maxLevel = Number(Math.ceil(Math.log(Math.max(this.width, this.height), 2)));
            } else {
              var maxScaleFactor = Math.max.apply(null, this.scale_factors);
              options.maxLevel = Math.round(Math.log(maxScaleFactor) * Math.LOG2E);
            }
          }
          $3.TileSource.apply(this, [options]);
        };
        $3.extend($3.IIIFTileSource.prototype, $3.TileSource.prototype, {
          supports: function(data, url) {
            if (data.protocol && data.protocol == "http://iiif.io/api/image") {
              return true;
            } else if (data["@context"] && (data["@context"] == "http://library.stanford.edu/iiif/image-api/1.1/context.json" || data["@context"] == "http://iiif.io/api/image/1/context.json")) {
              return true;
            } else if (data.profile && data.profile.indexOf("http://library.stanford.edu/iiif/image-api/compliance.html") === 0) {
              return true;
            } else if (data.identifier && data.width && data.height) {
              return true;
            } else if (data.documentElement && "info" == data.documentElement.tagName && "http://library.stanford.edu/iiif/image-api/ns/" == data.documentElement.namespaceURI) {
              return true;
            } else {
              return false;
            }
          },
          configure: function(data, url) {
            if (!$3.isPlainObject(data)) {
              var options = configureFromXml10(data);
              options["@context"] = "http://iiif.io/api/image/1.0/context.json";
              options["@id"] = url.replace("/info.xml", "");
              options.version = 1;
              return options;
            } else {
              if (!data["@context"]) {
                data["@context"] = "http://iiif.io/api/image/1.0/context.json";
                data["@id"] = url.replace("/info.json", "");
                data.version = 1;
              } else {
                var context = data["@context"];
                if (Array.isArray(context)) {
                  for (var i2 = 0; i2 < context.length; i2++) {
                    if (typeof context[i2] === "string" && (/^http:\/\/iiif\.io\/api\/image\/[1-3]\/context\.json$/.test(context[i2]) || context[i2] === "http://library.stanford.edu/iiif/image-api/1.1/context.json")) {
                      context = context[i2];
                      break;
                    }
                  }
                }
                switch (context) {
                  case "http://iiif.io/api/image/1/context.json":
                  case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
                    data.version = 1;
                    break;
                  case "http://iiif.io/api/image/2/context.json":
                    data.version = 2;
                    break;
                  case "http://iiif.io/api/image/3/context.json":
                    data.version = 3;
                    break;
                  default:
                    $3.console.error("Data has a @context property which contains no known IIIF context URI.");
                }
              }
              if (!data["@id"] && data["id"]) {
                data["@id"] = data["id"];
              }
              if (data.preferredFormats) {
                for (var f2 = 0; f2 < data.preferredFormats.length; f2++) {
                  if (OpenSeadragon.imageFormatSupported(data.preferredFormats[f2])) {
                    data.tileFormat = data.preferredFormats[f2];
                    break;
                  }
                }
              }
              return data;
            }
          },
          getTileWidth: function(level) {
            if (this.emulateLegacyImagePyramid) {
              return $3.TileSource.prototype.getTileWidth.call(this, level);
            }
            var scaleFactor = Math.pow(2, this.maxLevel - level);
            if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].width;
            }
            return this._tileWidth;
          },
          getTileHeight: function(level) {
            if (this.emulateLegacyImagePyramid) {
              return $3.TileSource.prototype.getTileHeight.call(this, level);
            }
            var scaleFactor = Math.pow(2, this.maxLevel - level);
            if (this.tileSizePerScaleFactor && this.tileSizePerScaleFactor[scaleFactor]) {
              return this.tileSizePerScaleFactor[scaleFactor].height;
            }
            return this._tileHeight;
          },
          getLevelScale: function(level) {
            if (this.emulateLegacyImagePyramid) {
              var levelScale = NaN;
              if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
                levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
              }
              return levelScale;
            }
            return $3.TileSource.prototype.getLevelScale.call(this, level);
          },
          getNumTiles: function(level) {
            if (this.emulateLegacyImagePyramid) {
              var scale = this.getLevelScale(level);
              if (scale) {
                return new $3.Point(1, 1);
              } else {
                return new $3.Point(0, 0);
              }
            }
            return $3.TileSource.prototype.getNumTiles.call(this, level);
          },
          getTileAtPoint: function(level, point) {
            if (this.emulateLegacyImagePyramid) {
              return new $3.Point(0, 0);
            }
            return $3.TileSource.prototype.getTileAtPoint.call(this, level, point);
          },
          getTileUrl: function(level, x2, y2) {
            if (this.emulateLegacyImagePyramid) {
              var url = null;
              if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
                url = this.levels[level].url;
              }
              return url;
            }
            var IIIF_ROTATION = "0", scale = Math.pow(0.5, this.maxLevel - level), levelWidth = Math.ceil(this.width * scale), levelHeight = Math.ceil(this.height * scale), tileWidth, tileHeight, iiifTileSizeWidth, iiifTileSizeHeight, iiifRegion, iiifTileX, iiifTileY, iiifTileW, iiifTileH, iiifSize, iiifSizeW, iiifSizeH, iiifQuality, uri;
            tileWidth = this.getTileWidth(level);
            tileHeight = this.getTileHeight(level);
            iiifTileSizeWidth = Math.ceil(tileWidth / scale);
            iiifTileSizeHeight = Math.ceil(tileHeight / scale);
            if (this.version === 1) {
              iiifQuality = "native." + this.tileFormat;
            } else {
              iiifQuality = "default." + this.tileFormat;
            }
            if (levelWidth < tileWidth && levelHeight < tileHeight) {
              if (this.version === 2 && levelWidth === this.width) {
                iiifSize = "max";
              } else if (this.version === 3 && levelWidth === this.width && levelHeight === this.height) {
                iiifSize = "max";
              } else if (this.version === 3) {
                iiifSize = levelWidth + "," + levelHeight;
              } else {
                iiifSize = levelWidth + ",";
              }
              iiifRegion = "full";
            } else {
              iiifTileX = x2 * iiifTileSizeWidth;
              iiifTileY = y2 * iiifTileSizeHeight;
              iiifTileW = Math.min(iiifTileSizeWidth, this.width - iiifTileX);
              iiifTileH = Math.min(iiifTileSizeHeight, this.height - iiifTileY);
              if (x2 === 0 && y2 === 0 && iiifTileW === this.width && iiifTileH === this.height) {
                iiifRegion = "full";
              } else {
                iiifRegion = [iiifTileX, iiifTileY, iiifTileW, iiifTileH].join(",");
              }
              iiifSizeW = Math.ceil(iiifTileW * scale);
              iiifSizeH = Math.ceil(iiifTileH * scale);
              if (this.version === 2 && iiifSizeW === this.width) {
                iiifSize = "max";
              } else if (this.version === 3 && iiifSizeW === this.width && iiifSizeH === this.height) {
                iiifSize = "max";
              } else if (this.version === 3) {
                iiifSize = iiifSizeW + "," + iiifSizeH;
              } else {
                iiifSize = iiifSizeW + ",";
              }
            }
            uri = [this["@id"], iiifRegion, iiifSize, IIIF_ROTATION, iiifQuality].join("/");
            return uri;
          },
          __testonly__: {
            canBeTiled,
            constructLevels
          }
        });
        function canBeTiled(options) {
          var level0Profiles = [
            "http://library.stanford.edu/iiif/image-api/compliance.html#level0",
            "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",
            "http://iiif.io/api/image/2/level0.json",
            "level0",
            "https://iiif.io/api/image/3/level0.json"
          ];
          var profileLevel = Array.isArray(options.profile) ? options.profile[0] : options.profile;
          var isLevel0 = level0Profiles.indexOf(profileLevel) !== -1;
          var hasCanoncicalSizeFeature = false;
          if (options.version === 2 && options.profile.length > 1 && options.profile[1].supports) {
            hasCanoncicalSizeFeature = options.profile[1].supports.indexOf("sizeByW") !== -1;
          }
          if (options.version === 3 && options.extraFeatures) {
            hasCanoncicalSizeFeature = options.extraFeatures.indexOf("sizeByWh") !== -1;
          }
          return !isLevel0 || hasCanoncicalSizeFeature;
        }
        function constructLevels(options) {
          var levels = [];
          for (var i2 = 0; i2 < options.sizes.length; i2++) {
            levels.push({
              url: options["@id"] + "/full/" + options.sizes[i2].width + "," + (options.version === 3 ? options.sizes[i2].height : "") + "/0/default." + options.tileFormat,
              width: options.sizes[i2].width,
              height: options.sizes[i2].height
            });
          }
          return levels.sort(function(a2, b3) {
            return a2.width - b3.width;
          });
        }
        function configureFromXml10(xmlDoc) {
          if (!xmlDoc || !xmlDoc.documentElement) {
            throw new Error($3.getString("Errors.Xml"));
          }
          var root2 = xmlDoc.documentElement, rootName = root2.tagName, configuration2 = null;
          if (rootName == "info") {
            try {
              configuration2 = {};
              parseXML10(root2, configuration2);
              return configuration2;
            } catch (e3) {
              throw e3 instanceof Error ? e3 : new Error($3.getString("Errors.IIIF"));
            }
          }
          throw new Error($3.getString("Errors.IIIF"));
        }
        function parseXML10(node, configuration2, property) {
          var i2, value;
          if (node.nodeType == 3 && property) {
            value = node.nodeValue.trim();
            if (value.match(/^\d*$/)) {
              value = Number(value);
            }
            if (!configuration2[property]) {
              configuration2[property] = value;
            } else {
              if (!$3.isArray(configuration2[property])) {
                configuration2[property] = [configuration2[property]];
              }
              configuration2[property].push(value);
            }
          } else if (node.nodeType == 1) {
            for (i2 = 0; i2 < node.childNodes.length; i2++) {
              parseXML10(node.childNodes[i2], configuration2, node.nodeName);
            }
          }
        }
      })(OpenSeadragon);
      (function($3) {
        $3.OsmTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
          var options;
          if ($3.isPlainObject(width)) {
            options = width;
          } else {
            options = {
              width: arguments[0],
              height: arguments[1],
              tileSize: arguments[2],
              tileOverlap: arguments[3],
              tilesUrl: arguments[4]
            };
          }
          if (!options.width || !options.height) {
            options.width = 65572864;
            options.height = 65572864;
          }
          if (!options.tileSize) {
            options.tileSize = 256;
            options.tileOverlap = 0;
          }
          if (!options.tilesUrl) {
            options.tilesUrl = "http://tile.openstreetmap.org/";
          }
          options.minLevel = 8;
          $3.TileSource.apply(this, [options]);
        };
        $3.extend($3.OsmTileSource.prototype, $3.TileSource.prototype, {
          supports: function(data, url) {
            return data.type && "openstreetmaps" == data.type;
          },
          configure: function(data, url) {
            return data;
          },
          getTileUrl: function(level, x2, y2) {
            return this.tilesUrl + (level - 8) + "/" + x2 + "/" + y2 + ".png";
          }
        });
      })(OpenSeadragon);
      (function($3) {
        $3.TmsTileSource = function(width, height, tileSize, tileOverlap, tilesUrl) {
          var options;
          if ($3.isPlainObject(width)) {
            options = width;
          } else {
            options = {
              width: arguments[0],
              height: arguments[1],
              tileSize: arguments[2],
              tileOverlap: arguments[3],
              tilesUrl: arguments[4]
            };
          }
          var bufferedWidth = Math.ceil(options.width / 256) * 256, bufferedHeight = Math.ceil(options.height / 256) * 256, max2;
          if (bufferedWidth > bufferedHeight) {
            max2 = bufferedWidth / 256;
          } else {
            max2 = bufferedHeight / 256;
          }
          options.maxLevel = Math.ceil(Math.log(max2) / Math.log(2)) - 1;
          options.tileSize = 256;
          options.width = bufferedWidth;
          options.height = bufferedHeight;
          $3.TileSource.apply(this, [options]);
        };
        $3.extend($3.TmsTileSource.prototype, $3.TileSource.prototype, {
          supports: function(data, url) {
            return data.type && "tiledmapservice" == data.type;
          },
          configure: function(data, url) {
            return data;
          },
          getTileUrl: function(level, x2, y2) {
            var yTiles = this.getNumTiles(level).y - 1;
            return this.tilesUrl + level + "/" + x2 + "/" + (yTiles - y2) + ".png";
          }
        });
      })(OpenSeadragon);
      (function($3) {
        $3.ZoomifyTileSource = function(options) {
          options.tileSize = 256;
          var currentImageSize = {
            x: options.width,
            y: options.height
          };
          options.imageSizes = [{
            x: options.width,
            y: options.height
          }];
          options.gridSize = [this._getGridSize(options.width, options.height, options.tileSize)];
          while (parseInt(currentImageSize.x, 10) > options.tileSize || parseInt(currentImageSize.y, 10) > options.tileSize) {
            currentImageSize.x = Math.floor(currentImageSize.x / 2);
            currentImageSize.y = Math.floor(currentImageSize.y / 2);
            options.imageSizes.push({
              x: currentImageSize.x,
              y: currentImageSize.y
            });
            options.gridSize.push(this._getGridSize(currentImageSize.x, currentImageSize.y, options.tileSize));
          }
          options.imageSizes.reverse();
          options.gridSize.reverse();
          options.minLevel = 0;
          options.maxLevel = options.gridSize.length - 1;
          OpenSeadragon.TileSource.apply(this, [options]);
        };
        $3.extend($3.ZoomifyTileSource.prototype, $3.TileSource.prototype, {
          _getGridSize: function(width, height, tileSize) {
            return {
              x: Math.ceil(width / tileSize),
              y: Math.ceil(height / tileSize)
            };
          },
          _calculateAbsoluteTileNumber: function(level, x2, y2) {
            var num = 0;
            var size2 = {};
            for (var z3 = 0; z3 < level; z3++) {
              size2 = this.gridSize[z3];
              num += size2.x * size2.y;
            }
            size2 = this.gridSize[level];
            num += size2.x * y2 + x2;
            return num;
          },
          supports: function(data, url) {
            return data.type && "zoomifytileservice" == data.type;
          },
          configure: function(data, url) {
            return data;
          },
          getTileUrl: function(level, x2, y2) {
            var result = 0;
            var num = this._calculateAbsoluteTileNumber(level, x2, y2);
            result = Math.floor(num / 256);
            return this.tilesUrl + "TileGroup" + result + "/" + level + "-" + x2 + "-" + y2 + ".jpg";
          }
        });
      })(OpenSeadragon);
      (function($3) {
        $3.LegacyTileSource = function(levels) {
          var options, width, height;
          if ($3.isArray(levels)) {
            options = {
              type: "legacy-image-pyramid",
              levels
            };
          }
          options.levels = filterFiles(options.levels);
          if (options.levels.length > 0) {
            width = options.levels[options.levels.length - 1].width;
            height = options.levels[options.levels.length - 1].height;
          } else {
            width = 0;
            height = 0;
            $3.console.error("No supported image formats found");
          }
          $3.extend(true, options, {
            width,
            height,
            tileSize: Math.max(height, width),
            tileOverlap: 0,
            minLevel: 0,
            maxLevel: options.levels.length > 0 ? options.levels.length - 1 : 0
          });
          $3.TileSource.apply(this, [options]);
          this.levels = options.levels;
        };
        $3.extend($3.LegacyTileSource.prototype, $3.TileSource.prototype, {
          supports: function(data, url) {
            return data.type && "legacy-image-pyramid" == data.type || data.documentElement && "legacy-image-pyramid" == data.documentElement.getAttribute("type");
          },
          configure: function(configuration2, dataUrl) {
            var options;
            if (!$3.isPlainObject(configuration2)) {
              options = configureFromXML(this, configuration2);
            } else {
              options = configureFromObject(this, configuration2);
            }
            return options;
          },
          getLevelScale: function(level) {
            var levelScale = NaN;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            }
            return levelScale;
          },
          getNumTiles: function(level) {
            var scale = this.getLevelScale(level);
            if (scale) {
              return new $3.Point(1, 1);
            } else {
              return new $3.Point(0, 0);
            }
          },
          getTileUrl: function(level, x2, y2) {
            var url = null;
            if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {
              url = this.levels[level].url;
            }
            return url;
          }
        });
        function filterFiles(files) {
          var filtered = [], file, i2;
          for (i2 = 0; i2 < files.length; i2++) {
            file = files[i2];
            if (file.height && file.width && file.url) {
              filtered.push({
                url: file.url,
                width: Number(file.width),
                height: Number(file.height)
              });
            } else {
              $3.console.error("Unsupported image format: %s", file.url ? file.url : "<no URL>");
            }
          }
          return filtered.sort(function(a2, b3) {
            return a2.height - b3.height;
          });
        }
        function configureFromXML(tileSource, xmlDoc) {
          if (!xmlDoc || !xmlDoc.documentElement) {
            throw new Error($3.getString("Errors.Xml"));
          }
          var root2 = xmlDoc.documentElement, rootName = root2.tagName, conf = null, levels = [], level, i2;
          if (rootName == "image") {
            try {
              conf = {
                type: root2.getAttribute("type"),
                levels: []
              };
              levels = root2.getElementsByTagName("level");
              for (i2 = 0; i2 < levels.length; i2++) {
                level = levels[i2];
                conf.levels.push({
                  url: level.getAttribute("url"),
                  width: parseInt(level.getAttribute("width"), 10),
                  height: parseInt(level.getAttribute("height"), 10)
                });
              }
              return configureFromObject(tileSource, conf);
            } catch (e3) {
              throw e3 instanceof Error ? e3 : new Error("Unknown error parsing Legacy Image Pyramid XML.");
            }
          } else if (rootName == "collection") {
            throw new Error("Legacy Image Pyramid Collections not yet supported.");
          } else if (rootName == "error") {
            throw new Error("Error: " + xmlDoc);
          }
          throw new Error("Unknown element " + rootName);
        }
        function configureFromObject(tileSource, configuration2) {
          return configuration2.levels;
        }
      })(OpenSeadragon);
      (function($3) {
        $3.ImageTileSource = function(options) {
          options = $3.extend({
            buildPyramid: true,
            crossOriginPolicy: false,
            ajaxWithCredentials: false,
            useCanvas: true
          }, options);
          $3.TileSource.apply(this, [options]);
        };
        $3.extend($3.ImageTileSource.prototype, $3.TileSource.prototype, {
          supports: function(data, url) {
            return data.type && data.type === "image";
          },
          configure: function(options, dataUrl) {
            return options;
          },
          getImageInfo: function(url) {
            var image = this._image = new Image();
            var _this = this;
            if (this.crossOriginPolicy) {
              image.crossOrigin = this.crossOriginPolicy;
            }
            if (this.ajaxWithCredentials) {
              image.useCredentials = this.ajaxWithCredentials;
            }
            $3.addEvent(image, "load", function() {
              _this.width = Object.prototype.hasOwnProperty.call(image, "naturalWidth") ? image.naturalWidth : image.width;
              _this.height = Object.prototype.hasOwnProperty.call(image, "naturalHeight") ? image.naturalHeight : image.height;
              _this.aspectRatio = _this.width / _this.height;
              _this.dimensions = new $3.Point(_this.width, _this.height);
              _this._tileWidth = _this.width;
              _this._tileHeight = _this.height;
              _this.tileOverlap = 0;
              _this.minLevel = 0;
              _this.levels = _this._buildLevels();
              _this.maxLevel = _this.levels.length - 1;
              _this.ready = true;
              _this.raiseEvent("ready", { tileSource: _this });
            });
            $3.addEvent(image, "error", function() {
              _this.raiseEvent("open-failed", {
                message: "Error loading image at " + url,
                source: url
              });
            });
            image.src = url;
          },
          getLevelScale: function(level) {
            var levelScale = NaN;
            if (level >= this.minLevel && level <= this.maxLevel) {
              levelScale = this.levels[level].width / this.levels[this.maxLevel].width;
            }
            return levelScale;
          },
          getNumTiles: function(level) {
            var scale = this.getLevelScale(level);
            if (scale) {
              return new $3.Point(1, 1);
            } else {
              return new $3.Point(0, 0);
            }
          },
          getTileUrl: function(level, x2, y2) {
            var url = null;
            if (level >= this.minLevel && level <= this.maxLevel) {
              url = this.levels[level].url;
            }
            return url;
          },
          getContext2D: function(level, x2, y2) {
            var context = null;
            if (level >= this.minLevel && level <= this.maxLevel) {
              context = this.levels[level].context2D;
            }
            return context;
          },
          _buildLevels: function() {
            var levels = [{
              url: this._image.src,
              width: Object.prototype.hasOwnProperty.call(this._image, "naturalWidth") ? this._image.naturalWidth : this._image.width,
              height: Object.prototype.hasOwnProperty.call(this._image, "naturalHeight") ? this._image.naturalHeight : this._image.height
            }];
            if (!this.buildPyramid || !$3.supportsCanvas || !this.useCanvas) {
              delete this._image;
              return levels;
            }
            var currentWidth = Object.prototype.hasOwnProperty.call(this._image, "naturalWidth") ? this._image.naturalWidth : this._image.width;
            var currentHeight = Object.prototype.hasOwnProperty.call(this._image, "naturalHeight") ? this._image.naturalHeight : this._image.height;
            var bigCanvas = document.createElement("canvas");
            var bigContext = bigCanvas.getContext("2d");
            bigCanvas.width = currentWidth;
            bigCanvas.height = currentHeight;
            bigContext.drawImage(this._image, 0, 0, currentWidth, currentHeight);
            levels[0].context2D = bigContext;
            delete this._image;
            if ($3.isCanvasTainted(bigCanvas)) {
              return levels;
            }
            while (currentWidth >= 2 && currentHeight >= 2) {
              currentWidth = Math.floor(currentWidth / 2);
              currentHeight = Math.floor(currentHeight / 2);
              var smallCanvas = document.createElement("canvas");
              var smallContext = smallCanvas.getContext("2d");
              smallCanvas.width = currentWidth;
              smallCanvas.height = currentHeight;
              smallContext.drawImage(bigCanvas, 0, 0, currentWidth, currentHeight);
              levels.splice(0, 0, {
                context2D: smallContext,
                width: currentWidth,
                height: currentHeight
              });
              bigCanvas = smallCanvas;
              bigContext = smallContext;
            }
            return levels;
          }
        });
      })(OpenSeadragon);
      (function($3) {
        $3.TileSourceCollection = function(tileSize, tileSources, rows, layout) {
          $3.console.error("TileSourceCollection is deprecated; use World instead");
        };
      })(OpenSeadragon);
      (function($3) {
        $3.ButtonState = {
          REST: 0,
          GROUP: 1,
          HOVER: 2,
          DOWN: 3
        };
        $3.Button = function(options) {
          var _this = this;
          $3.EventSource.call(this);
          $3.extend(true, this, {
            tooltip: null,
            srcRest: null,
            srcGroup: null,
            srcHover: null,
            srcDown: null,
            clickTimeThreshold: $3.DEFAULT_SETTINGS.clickTimeThreshold,
            clickDistThreshold: $3.DEFAULT_SETTINGS.clickDistThreshold,
            fadeDelay: 0,
            fadeLength: 2e3,
            onPress: null,
            onRelease: null,
            onClick: null,
            onEnter: null,
            onExit: null,
            onFocus: null,
            onBlur: null
          }, options);
          this.element = options.element || $3.makeNeutralElement("div");
          if (!options.element) {
            this.imgRest = $3.makeTransparentImage(this.srcRest);
            this.imgGroup = $3.makeTransparentImage(this.srcGroup);
            this.imgHover = $3.makeTransparentImage(this.srcHover);
            this.imgDown = $3.makeTransparentImage(this.srcDown);
            this.imgRest.alt = this.imgGroup.alt = this.imgHover.alt = this.imgDown.alt = this.tooltip;
            this.element.style.position = "relative";
            $3.setElementTouchActionNone(this.element);
            this.imgGroup.style.position = this.imgHover.style.position = this.imgDown.style.position = "absolute";
            this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "0px";
            this.imgGroup.style.left = this.imgHover.style.left = this.imgDown.style.left = "0px";
            this.imgHover.style.visibility = this.imgDown.style.visibility = "hidden";
            if ($3.Browser.vendor == $3.BROWSERS.FIREFOX && $3.Browser.version < 3) {
              this.imgGroup.style.top = this.imgHover.style.top = this.imgDown.style.top = "";
            }
            this.element.appendChild(this.imgRest);
            this.element.appendChild(this.imgGroup);
            this.element.appendChild(this.imgHover);
            this.element.appendChild(this.imgDown);
          }
          this.addHandler("press", this.onPress);
          this.addHandler("release", this.onRelease);
          this.addHandler("click", this.onClick);
          this.addHandler("enter", this.onEnter);
          this.addHandler("exit", this.onExit);
          this.addHandler("focus", this.onFocus);
          this.addHandler("blur", this.onBlur);
          this.currentState = $3.ButtonState.GROUP;
          this.fadeBeginTime = null;
          this.shouldFade = false;
          this.element.style.display = "inline-block";
          this.element.style.position = "relative";
          this.element.title = this.tooltip;
          this.tracker = new $3.MouseTracker({
            element: this.element,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            enterHandler: function(event) {
              if (event.insideElementPressed) {
                inTo(_this, $3.ButtonState.DOWN);
                _this.raiseEvent("enter", { originalEvent: event.originalEvent });
              } else if (!event.buttonDownAny) {
                inTo(_this, $3.ButtonState.HOVER);
              }
            },
            focusHandler: function(event) {
              this.enterHandler(event);
              _this.raiseEvent("focus", { originalEvent: event.originalEvent });
            },
            exitHandler: function(event) {
              outTo(_this, $3.ButtonState.GROUP);
              if (event.insideElementPressed) {
                _this.raiseEvent("exit", { originalEvent: event.originalEvent });
              }
            },
            blurHandler: function(event) {
              this.exitHandler(event);
              _this.raiseEvent("blur", { originalEvent: event.originalEvent });
            },
            pressHandler: function(event) {
              inTo(_this, $3.ButtonState.DOWN);
              _this.raiseEvent("press", { originalEvent: event.originalEvent });
            },
            releaseHandler: function(event) {
              if (event.insideElementPressed && event.insideElementReleased) {
                outTo(_this, $3.ButtonState.HOVER);
                _this.raiseEvent("release", { originalEvent: event.originalEvent });
              } else if (event.insideElementPressed) {
                outTo(_this, $3.ButtonState.GROUP);
              } else {
                inTo(_this, $3.ButtonState.HOVER);
              }
            },
            clickHandler: function(event) {
              if (event.quick) {
                _this.raiseEvent("click", { originalEvent: event.originalEvent });
              }
            },
            keyHandler: function(event) {
              if (13 === event.keyCode) {
                _this.raiseEvent("click", { originalEvent: event.originalEvent });
                _this.raiseEvent("release", { originalEvent: event.originalEvent });
                return false;
              }
              return true;
            }
          });
          outTo(this, $3.ButtonState.REST);
        };
        $3.extend($3.Button.prototype, $3.EventSource.prototype, {
          notifyGroupEnter: function() {
            inTo(this, $3.ButtonState.GROUP);
          },
          notifyGroupExit: function() {
            outTo(this, $3.ButtonState.REST);
          },
          disable: function() {
            this.notifyGroupExit();
            this.element.disabled = true;
            $3.setElementOpacity(this.element, 0.2, true);
          },
          enable: function() {
            this.element.disabled = false;
            $3.setElementOpacity(this.element, 1, true);
            this.notifyGroupEnter();
          }
        });
        function scheduleFade(button) {
          $3.requestAnimationFrame(function() {
            updateFade(button);
          });
        }
        function updateFade(button) {
          var currentTime, deltaTime, opacity;
          if (button.shouldFade) {
            currentTime = $3.now();
            deltaTime = currentTime - button.fadeBeginTime;
            opacity = 1 - deltaTime / button.fadeLength;
            opacity = Math.min(1, opacity);
            opacity = Math.max(0, opacity);
            if (button.imgGroup) {
              $3.setElementOpacity(button.imgGroup, opacity, true);
            }
            if (opacity > 0) {
              scheduleFade(button);
            }
          }
        }
        function beginFading(button) {
          button.shouldFade = true;
          button.fadeBeginTime = $3.now() + button.fadeDelay;
          window.setTimeout(function() {
            scheduleFade(button);
          }, button.fadeDelay);
        }
        function stopFading(button) {
          button.shouldFade = false;
          if (button.imgGroup) {
            $3.setElementOpacity(button.imgGroup, 1, true);
          }
        }
        function inTo(button, newState) {
          if (button.element.disabled) {
            return;
          }
          if (newState >= $3.ButtonState.GROUP && button.currentState == $3.ButtonState.REST) {
            stopFading(button);
            button.currentState = $3.ButtonState.GROUP;
          }
          if (newState >= $3.ButtonState.HOVER && button.currentState == $3.ButtonState.GROUP) {
            if (button.imgHover) {
              button.imgHover.style.visibility = "";
            }
            button.currentState = $3.ButtonState.HOVER;
          }
          if (newState >= $3.ButtonState.DOWN && button.currentState == $3.ButtonState.HOVER) {
            if (button.imgDown) {
              button.imgDown.style.visibility = "";
            }
            button.currentState = $3.ButtonState.DOWN;
          }
        }
        function outTo(button, newState) {
          if (button.element.disabled) {
            return;
          }
          if (newState <= $3.ButtonState.HOVER && button.currentState == $3.ButtonState.DOWN) {
            if (button.imgDown) {
              button.imgDown.style.visibility = "hidden";
            }
            button.currentState = $3.ButtonState.HOVER;
          }
          if (newState <= $3.ButtonState.GROUP && button.currentState == $3.ButtonState.HOVER) {
            if (button.imgHover) {
              button.imgHover.style.visibility = "hidden";
            }
            button.currentState = $3.ButtonState.GROUP;
          }
          if (newState <= $3.ButtonState.REST && button.currentState == $3.ButtonState.GROUP) {
            beginFading(button);
            button.currentState = $3.ButtonState.REST;
          }
        }
      })(OpenSeadragon);
      (function($3) {
        $3.ButtonGroup = function(options) {
          $3.extend(true, this, {
            buttons: [],
            clickTimeThreshold: $3.DEFAULT_SETTINGS.clickTimeThreshold,
            clickDistThreshold: $3.DEFAULT_SETTINGS.clickDistThreshold,
            labelText: ""
          }, options);
          var buttons = this.buttons.concat([]), _this = this, i2;
          this.element = options.element || $3.makeNeutralElement("div");
          if (!options.group) {
            this.element.style.display = "inline-block";
            for (i2 = 0; i2 < buttons.length; i2++) {
              this.element.appendChild(buttons[i2].element);
            }
          }
          $3.setElementTouchActionNone(this.element);
          this.tracker = new $3.MouseTracker({
            element: this.element,
            clickTimeThreshold: this.clickTimeThreshold,
            clickDistThreshold: this.clickDistThreshold,
            enterHandler: function(event) {
              var i3;
              for (i3 = 0; i3 < _this.buttons.length; i3++) {
                _this.buttons[i3].notifyGroupEnter();
              }
            },
            exitHandler: function(event) {
              var i3;
              if (!event.insideElementPressed) {
                for (i3 = 0; i3 < _this.buttons.length; i3++) {
                  _this.buttons[i3].notifyGroupExit();
                }
              }
            }
          });
        };
        $3.ButtonGroup.prototype = {
          emulateEnter: function() {
            this.tracker.enterHandler({ eventSource: this.tracker });
          },
          emulateExit: function() {
            this.tracker.exitHandler({ eventSource: this.tracker });
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.Rect = function(x2, y2, width, height, degrees) {
          this.x = typeof x2 === "number" ? x2 : 0;
          this.y = typeof y2 === "number" ? y2 : 0;
          this.width = typeof width === "number" ? width : 0;
          this.height = typeof height === "number" ? height : 0;
          this.degrees = typeof degrees === "number" ? degrees : 0;
          this.degrees = $3.positiveModulo(this.degrees, 360);
          var newTopLeft, newWidth;
          if (this.degrees >= 270) {
            newTopLeft = this.getTopRight();
            this.x = newTopLeft.x;
            this.y = newTopLeft.y;
            newWidth = this.height;
            this.height = this.width;
            this.width = newWidth;
            this.degrees -= 270;
          } else if (this.degrees >= 180) {
            newTopLeft = this.getBottomRight();
            this.x = newTopLeft.x;
            this.y = newTopLeft.y;
            this.degrees -= 180;
          } else if (this.degrees >= 90) {
            newTopLeft = this.getBottomLeft();
            this.x = newTopLeft.x;
            this.y = newTopLeft.y;
            newWidth = this.height;
            this.height = this.width;
            this.width = newWidth;
            this.degrees -= 90;
          }
        };
        $3.Rect.fromSummits = function(topLeft, topRight, bottomLeft) {
          var width = topLeft.distanceTo(topRight);
          var height = topLeft.distanceTo(bottomLeft);
          var diff = topRight.minus(topLeft);
          var radians = Math.atan(diff.y / diff.x);
          if (diff.x < 0) {
            radians += Math.PI;
          } else if (diff.y < 0) {
            radians += 2 * Math.PI;
          }
          return new $3.Rect(
            topLeft.x,
            topLeft.y,
            width,
            height,
            radians / Math.PI * 180
          );
        };
        $3.Rect.prototype = {
          clone: function() {
            return new $3.Rect(
              this.x,
              this.y,
              this.width,
              this.height,
              this.degrees
            );
          },
          getAspectRatio: function() {
            return this.width / this.height;
          },
          getTopLeft: function() {
            return new $3.Point(
              this.x,
              this.y
            );
          },
          getBottomRight: function() {
            return new $3.Point(this.x + this.width, this.y + this.height).rotate(this.degrees, this.getTopLeft());
          },
          getTopRight: function() {
            return new $3.Point(this.x + this.width, this.y).rotate(this.degrees, this.getTopLeft());
          },
          getBottomLeft: function() {
            return new $3.Point(this.x, this.y + this.height).rotate(this.degrees, this.getTopLeft());
          },
          getCenter: function() {
            return new $3.Point(
              this.x + this.width / 2,
              this.y + this.height / 2
            ).rotate(this.degrees, this.getTopLeft());
          },
          getSize: function() {
            return new $3.Point(this.width, this.height);
          },
          equals: function(other) {
            return other instanceof $3.Rect && this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height && this.degrees === other.degrees;
          },
          times: function(factor) {
            return new $3.Rect(
              this.x * factor,
              this.y * factor,
              this.width * factor,
              this.height * factor,
              this.degrees
            );
          },
          translate: function(delta) {
            return new $3.Rect(
              this.x + delta.x,
              this.y + delta.y,
              this.width,
              this.height,
              this.degrees
            );
          },
          union: function(rect) {
            var thisBoundingBox = this.getBoundingBox();
            var otherBoundingBox = rect.getBoundingBox();
            var left = Math.min(thisBoundingBox.x, otherBoundingBox.x);
            var top = Math.min(thisBoundingBox.y, otherBoundingBox.y);
            var right = Math.max(
              thisBoundingBox.x + thisBoundingBox.width,
              otherBoundingBox.x + otherBoundingBox.width
            );
            var bottom = Math.max(
              thisBoundingBox.y + thisBoundingBox.height,
              otherBoundingBox.y + otherBoundingBox.height
            );
            return new $3.Rect(
              left,
              top,
              right - left,
              bottom - top
            );
          },
          intersection: function(rect) {
            var EPSILON = 1e-10;
            var intersectionPoints = [];
            var thisTopLeft = this.getTopLeft();
            if (rect.containsPoint(thisTopLeft, EPSILON)) {
              intersectionPoints.push(thisTopLeft);
            }
            var thisTopRight = this.getTopRight();
            if (rect.containsPoint(thisTopRight, EPSILON)) {
              intersectionPoints.push(thisTopRight);
            }
            var thisBottomLeft = this.getBottomLeft();
            if (rect.containsPoint(thisBottomLeft, EPSILON)) {
              intersectionPoints.push(thisBottomLeft);
            }
            var thisBottomRight = this.getBottomRight();
            if (rect.containsPoint(thisBottomRight, EPSILON)) {
              intersectionPoints.push(thisBottomRight);
            }
            var rectTopLeft = rect.getTopLeft();
            if (this.containsPoint(rectTopLeft, EPSILON)) {
              intersectionPoints.push(rectTopLeft);
            }
            var rectTopRight = rect.getTopRight();
            if (this.containsPoint(rectTopRight, EPSILON)) {
              intersectionPoints.push(rectTopRight);
            }
            var rectBottomLeft = rect.getBottomLeft();
            if (this.containsPoint(rectBottomLeft, EPSILON)) {
              intersectionPoints.push(rectBottomLeft);
            }
            var rectBottomRight = rect.getBottomRight();
            if (this.containsPoint(rectBottomRight, EPSILON)) {
              intersectionPoints.push(rectBottomRight);
            }
            var thisSegments = this._getSegments();
            var rectSegments = rect._getSegments();
            for (var i2 = 0; i2 < thisSegments.length; i2++) {
              var thisSegment = thisSegments[i2];
              for (var j3 = 0; j3 < rectSegments.length; j3++) {
                var rectSegment = rectSegments[j3];
                var intersect = getIntersection(
                  thisSegment[0],
                  thisSegment[1],
                  rectSegment[0],
                  rectSegment[1]
                );
                if (intersect) {
                  intersectionPoints.push(intersect);
                }
              }
            }
            function getIntersection(a2, b3, c2, d3) {
              var abVector = b3.minus(a2);
              var cdVector = d3.minus(c2);
              var denom = -cdVector.x * abVector.y + abVector.x * cdVector.y;
              if (denom === 0) {
                return null;
              }
              var s2 = (abVector.x * (a2.y - c2.y) - abVector.y * (a2.x - c2.x)) / denom;
              var t2 = (cdVector.x * (a2.y - c2.y) - cdVector.y * (a2.x - c2.x)) / denom;
              if (-EPSILON <= s2 && s2 <= 1 - EPSILON && -EPSILON <= t2 && t2 <= 1 - EPSILON) {
                return new $3.Point(a2.x + t2 * abVector.x, a2.y + t2 * abVector.y);
              }
              return null;
            }
            if (intersectionPoints.length === 0) {
              return null;
            }
            var minX = intersectionPoints[0].x;
            var maxX = intersectionPoints[0].x;
            var minY = intersectionPoints[0].y;
            var maxY = intersectionPoints[0].y;
            for (var k3 = 1; k3 < intersectionPoints.length; k3++) {
              var point = intersectionPoints[k3];
              if (point.x < minX) {
                minX = point.x;
              }
              if (point.x > maxX) {
                maxX = point.x;
              }
              if (point.y < minY) {
                minY = point.y;
              }
              if (point.y > maxY) {
                maxY = point.y;
              }
            }
            return new $3.Rect(minX, minY, maxX - minX, maxY - minY);
          },
          _getSegments: function() {
            var topLeft = this.getTopLeft();
            var topRight = this.getTopRight();
            var bottomLeft = this.getBottomLeft();
            var bottomRight = this.getBottomRight();
            return [
              [topLeft, topRight],
              [topRight, bottomRight],
              [bottomRight, bottomLeft],
              [bottomLeft, topLeft]
            ];
          },
          rotate: function(degrees, pivot) {
            degrees = $3.positiveModulo(degrees, 360);
            if (degrees === 0) {
              return this.clone();
            }
            pivot = pivot || this.getCenter();
            var newTopLeft = this.getTopLeft().rotate(degrees, pivot);
            var newTopRight = this.getTopRight().rotate(degrees, pivot);
            var diff = newTopRight.minus(newTopLeft);
            diff = diff.apply(function(x2) {
              var EPSILON = 1e-15;
              return Math.abs(x2) < EPSILON ? 0 : x2;
            });
            var radians = Math.atan(diff.y / diff.x);
            if (diff.x < 0) {
              radians += Math.PI;
            } else if (diff.y < 0) {
              radians += 2 * Math.PI;
            }
            return new $3.Rect(
              newTopLeft.x,
              newTopLeft.y,
              this.width,
              this.height,
              radians / Math.PI * 180
            );
          },
          getBoundingBox: function() {
            if (this.degrees === 0) {
              return this.clone();
            }
            var topLeft = this.getTopLeft();
            var topRight = this.getTopRight();
            var bottomLeft = this.getBottomLeft();
            var bottomRight = this.getBottomRight();
            var minX = Math.min(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            var maxX = Math.max(topLeft.x, topRight.x, bottomLeft.x, bottomRight.x);
            var minY = Math.min(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            var maxY = Math.max(topLeft.y, topRight.y, bottomLeft.y, bottomRight.y);
            return new $3.Rect(
              minX,
              minY,
              maxX - minX,
              maxY - minY
            );
          },
          getIntegerBoundingBox: function() {
            var boundingBox = this.getBoundingBox();
            var x2 = Math.floor(boundingBox.x);
            var y2 = Math.floor(boundingBox.y);
            var width = Math.ceil(boundingBox.width + boundingBox.x - x2);
            var height = Math.ceil(boundingBox.height + boundingBox.y - y2);
            return new $3.Rect(x2, y2, width, height);
          },
          containsPoint: function(point, epsilon) {
            epsilon = epsilon || 0;
            var topLeft = this.getTopLeft();
            var topRight = this.getTopRight();
            var bottomLeft = this.getBottomLeft();
            var topDiff = topRight.minus(topLeft);
            var leftDiff = bottomLeft.minus(topLeft);
            return (point.x - topLeft.x) * topDiff.x + (point.y - topLeft.y) * topDiff.y >= -epsilon && (point.x - topRight.x) * topDiff.x + (point.y - topRight.y) * topDiff.y <= epsilon && (point.x - topLeft.x) * leftDiff.x + (point.y - topLeft.y) * leftDiff.y >= -epsilon && (point.x - bottomLeft.x) * leftDiff.x + (point.y - bottomLeft.y) * leftDiff.y <= epsilon;
          },
          toString: function() {
            return "[" + Math.round(this.x * 100) / 100 + ", " + Math.round(this.y * 100) / 100 + ", " + Math.round(this.width * 100) / 100 + "x" + Math.round(this.height * 100) / 100 + ", " + Math.round(this.degrees * 100) / 100 + "deg]";
          }
        };
      })(OpenSeadragon);
      (function($3) {
        var THIS = {};
        $3.ReferenceStrip = function(options) {
          var _this = this, viewer = options.viewer, viewerSize = $3.getElementSize(viewer.element), element, style, i2;
          if (!options.id) {
            options.id = "referencestrip-" + $3.now();
            this.element = $3.makeNeutralElement("div");
            this.element.id = options.id;
            this.element.className = "referencestrip";
          }
          options = $3.extend(true, {
            sizeRatio: $3.DEFAULT_SETTINGS.referenceStripSizeRatio,
            position: $3.DEFAULT_SETTINGS.referenceStripPosition,
            scroll: $3.DEFAULT_SETTINGS.referenceStripScroll,
            clickTimeThreshold: $3.DEFAULT_SETTINGS.clickTimeThreshold
          }, options, {
            element: this.element,
            showNavigator: false,
            mouseNavEnabled: false,
            showNavigationControl: false,
            showSequenceControl: false
          });
          $3.extend(this, options);
          THIS[this.id] = {
            "animating": false
          };
          this.minPixelRatio = this.viewer.minPixelRatio;
          style = this.element.style;
          style.marginTop = "0px";
          style.marginRight = "0px";
          style.marginBottom = "0px";
          style.marginLeft = "0px";
          style.left = "0px";
          style.bottom = "0px";
          style.border = "0px";
          style.background = "#000";
          style.position = "relative";
          $3.setElementTouchActionNone(this.element);
          $3.setElementOpacity(this.element, 0.8);
          this.viewer = viewer;
          this.innerTracker = new $3.MouseTracker({
            element: this.element,
            dragHandler: $3.delegate(this, onStripDrag),
            scrollHandler: $3.delegate(this, onStripScroll),
            enterHandler: $3.delegate(this, onStripEnter),
            exitHandler: $3.delegate(this, onStripExit),
            keyDownHandler: $3.delegate(this, onKeyDown),
            keyHandler: $3.delegate(this, onKeyPress)
          });
          if (options.width && options.height) {
            this.element.style.width = options.width + "px";
            this.element.style.height = options.height + "px";
            viewer.addControl(
              this.element,
              { anchor: $3.ControlAnchor.BOTTOM_LEFT }
            );
          } else {
            if ("horizontal" == options.scroll) {
              this.element.style.width = viewerSize.x * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
              this.element.style.height = viewerSize.y * options.sizeRatio + "px";
              viewer.addControl(
                this.element,
                { anchor: $3.ControlAnchor.BOTTOM_LEFT }
              );
            } else {
              this.element.style.height = viewerSize.y * options.sizeRatio * viewer.tileSources.length + 12 * viewer.tileSources.length + "px";
              this.element.style.width = viewerSize.x * options.sizeRatio + "px";
              viewer.addControl(
                this.element,
                { anchor: $3.ControlAnchor.TOP_LEFT }
              );
            }
          }
          this.panelWidth = viewerSize.x * this.sizeRatio + 8;
          this.panelHeight = viewerSize.y * this.sizeRatio + 8;
          this.panels = [];
          this.miniViewers = {};
          for (i2 = 0; i2 < viewer.tileSources.length; i2++) {
            element = $3.makeNeutralElement("div");
            element.id = this.element.id + "-" + i2;
            element.style.width = _this.panelWidth + "px";
            element.style.height = _this.panelHeight + "px";
            element.style.display = "inline";
            element.style.float = "left";
            element.style.cssFloat = "left";
            element.style.styleFloat = "left";
            element.style.padding = "2px";
            $3.setElementTouchActionNone(element);
            element.innerTracker = new $3.MouseTracker({
              element,
              clickTimeThreshold: this.clickTimeThreshold,
              clickDistThreshold: this.clickDistThreshold,
              pressHandler: function(event) {
                event.eventSource.dragging = $3.now();
              },
              releaseHandler: function(event) {
                var tracker = event.eventSource, id = tracker.element.id, page = Number(id.split("-")[2]), now2 = $3.now();
                if (event.insideElementPressed && event.insideElementReleased && tracker.dragging && now2 - tracker.dragging < tracker.clickTimeThreshold) {
                  tracker.dragging = null;
                  viewer.goToPage(page);
                }
              }
            });
            this.element.appendChild(element);
            element.activePanel = false;
            this.panels.push(element);
          }
          loadPanels(this, this.scroll == "vertical" ? viewerSize.y : viewerSize.x, 0);
          this.setFocus(0);
        };
        $3.extend($3.ReferenceStrip.prototype, $3.EventSource.prototype, $3.Viewer.prototype, {
          setFocus: function(page) {
            var element = this.element.querySelector("#" + this.element.id + "-" + page), viewerSize = $3.getElementSize(this.viewer.canvas), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), offsetLeft = -Number(this.element.style.marginLeft.replace("px", "")), offsetTop = -Number(this.element.style.marginTop.replace("px", "")), offset2;
            if (this.currentSelected !== element) {
              if (this.currentSelected) {
                this.currentSelected.style.background = "#000";
              }
              this.currentSelected = element;
              this.currentSelected.style.background = "#999";
              if ("horizontal" == this.scroll) {
                offset2 = Number(page) * (this.panelWidth + 3);
                if (offset2 > offsetLeft + viewerSize.x - this.panelWidth) {
                  offset2 = Math.min(offset2, scrollWidth - viewerSize.x);
                  this.element.style.marginLeft = -offset2 + "px";
                  loadPanels(this, viewerSize.x, -offset2);
                } else if (offset2 < offsetLeft) {
                  offset2 = Math.max(0, offset2 - viewerSize.x / 2);
                  this.element.style.marginLeft = -offset2 + "px";
                  loadPanels(this, viewerSize.x, -offset2);
                }
              } else {
                offset2 = Number(page) * (this.panelHeight + 3);
                if (offset2 > offsetTop + viewerSize.y - this.panelHeight) {
                  offset2 = Math.min(offset2, scrollHeight - viewerSize.y);
                  this.element.style.marginTop = -offset2 + "px";
                  loadPanels(this, viewerSize.y, -offset2);
                } else if (offset2 < offsetTop) {
                  offset2 = Math.max(0, offset2 - viewerSize.y / 2);
                  this.element.style.marginTop = -offset2 + "px";
                  loadPanels(this, viewerSize.y, -offset2);
                }
              }
              this.currentPage = page;
              onStripEnter.call(this, { eventSource: this.innerTracker });
            }
          },
          update: function() {
            if (THIS[this.id].animating) {
              $3.console.log("image reference strip update");
              return true;
            }
            return false;
          },
          destroy: function() {
            if (this.miniViewers) {
              for (var key in this.miniViewers) {
                this.miniViewers[key].destroy();
              }
            }
            if (this.element) {
              this.element.parentNode.removeChild(this.element);
            }
          }
        });
        function onStripDrag(event) {
          var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $3.getElementSize(this.viewer.canvas);
          this.dragging = true;
          if (this.element) {
            if ("horizontal" == this.scroll) {
              if (-event.delta.x > 0) {
                if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                  this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                  loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
                }
              } else if (-event.delta.x < 0) {
                if (offsetLeft < 0) {
                  this.element.style.marginLeft = offsetLeft + event.delta.x * 2 + "px";
                  loadPanels(this, viewerSize.x, offsetLeft + event.delta.x * 2);
                }
              }
            } else {
              if (-event.delta.y > 0) {
                if (offsetTop > -(scrollHeight - viewerSize.y)) {
                  this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                  loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
                }
              } else if (-event.delta.y < 0) {
                if (offsetTop < 0) {
                  this.element.style.marginTop = offsetTop + event.delta.y * 2 + "px";
                  loadPanels(this, viewerSize.y, offsetTop + event.delta.y * 2);
                }
              }
            }
          }
          return false;
        }
        function onStripScroll(event) {
          var offsetLeft = Number(this.element.style.marginLeft.replace("px", "")), offsetTop = Number(this.element.style.marginTop.replace("px", "")), scrollWidth = Number(this.element.style.width.replace("px", "")), scrollHeight = Number(this.element.style.height.replace("px", "")), viewerSize = $3.getElementSize(this.viewer.canvas);
          if (this.element) {
            if ("horizontal" == this.scroll) {
              if (event.scroll > 0) {
                if (offsetLeft > -(scrollWidth - viewerSize.x)) {
                  this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
                  loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
                }
              } else if (event.scroll < 0) {
                if (offsetLeft < 0) {
                  this.element.style.marginLeft = offsetLeft - event.scroll * 60 + "px";
                  loadPanels(this, viewerSize.x, offsetLeft - event.scroll * 60);
                }
              }
            } else {
              if (event.scroll < 0) {
                if (offsetTop > viewerSize.y - scrollHeight) {
                  this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                  loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
                }
              } else if (event.scroll > 0) {
                if (offsetTop < 0) {
                  this.element.style.marginTop = offsetTop + event.scroll * 60 + "px";
                  loadPanels(this, viewerSize.y, offsetTop + event.scroll * 60);
                }
              }
            }
          }
          return false;
        }
        function loadPanels(strip, viewerSize, scroll) {
          var panelSize, activePanelsStart, activePanelsEnd, miniViewer, style, i2, element;
          if ("horizontal" == strip.scroll) {
            panelSize = strip.panelWidth;
          } else {
            panelSize = strip.panelHeight;
          }
          activePanelsStart = Math.ceil(viewerSize / panelSize) + 5;
          activePanelsEnd = Math.ceil((Math.abs(scroll) + viewerSize) / panelSize) + 1;
          activePanelsStart = activePanelsEnd - activePanelsStart;
          activePanelsStart = activePanelsStart < 0 ? 0 : activePanelsStart;
          for (i2 = activePanelsStart; i2 < activePanelsEnd && i2 < strip.panels.length; i2++) {
            element = strip.panels[i2];
            if (!element.activePanel) {
              var miniTileSource;
              var originalTileSource = strip.viewer.tileSources[i2];
              if (originalTileSource.referenceStripThumbnailUrl) {
                miniTileSource = {
                  type: "image",
                  url: originalTileSource.referenceStripThumbnailUrl
                };
              } else {
                miniTileSource = originalTileSource;
              }
              miniViewer = new $3.Viewer({
                id: element.id,
                tileSources: [miniTileSource],
                element,
                navigatorSizeRatio: strip.sizeRatio,
                showNavigator: false,
                mouseNavEnabled: false,
                showNavigationControl: false,
                showSequenceControl: false,
                immediateRender: true,
                blendTime: 0,
                animationTime: 0,
                loadTilesWithAjax: strip.viewer.loadTilesWithAjax,
                ajaxHeaders: strip.viewer.ajaxHeaders,
                useCanvas: strip.useCanvas
              });
              miniViewer.displayRegion = $3.makeNeutralElement("div");
              miniViewer.displayRegion.id = element.id + "-displayregion";
              miniViewer.displayRegion.className = "displayregion";
              style = miniViewer.displayRegion.style;
              style.position = "relative";
              style.top = "0px";
              style.left = "0px";
              style.fontSize = "0px";
              style.overflow = "hidden";
              style.float = "left";
              style.cssFloat = "left";
              style.styleFloat = "left";
              style.zIndex = 999999999;
              style.cursor = "default";
              style.width = strip.panelWidth - 4 + "px";
              style.height = strip.panelHeight - 4 + "px";
              miniViewer.displayRegion.innerTracker = new $3.MouseTracker({
                element: miniViewer.displayRegion,
                startDisabled: true
              });
              element.getElementsByTagName("div")[0].appendChild(
                miniViewer.displayRegion
              );
              strip.miniViewers[element.id] = miniViewer;
              element.activePanel = true;
            }
          }
        }
        function onStripEnter(event) {
          var element = event.eventSource.element;
          if ("horizontal" == this.scroll) {
            element.style.marginBottom = "0px";
          } else {
            element.style.marginLeft = "0px";
          }
          return false;
        }
        function onStripExit(event) {
          var element = event.eventSource.element;
          if ("horizontal" == this.scroll) {
            element.style.marginBottom = "-" + $3.getElementSize(element).y / 2 + "px";
          } else {
            element.style.marginLeft = "-" + $3.getElementSize(element).x / 2 + "px";
          }
          return false;
        }
        function onKeyDown(event) {
          if (!event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
            switch (event.keyCode) {
              case 38:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
                return false;
              case 40:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
                return false;
              case 37:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
                return false;
              case 39:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
                return false;
              default:
                return true;
            }
          } else {
            return true;
          }
        }
        function onKeyPress(event) {
          if (!event.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {
            switch (event.keyCode) {
              case 61:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
                return false;
              case 45:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
                return false;
              case 48:
              case 119:
              case 87:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
                return false;
              case 115:
              case 83:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
                return false;
              case 97:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: -1, shift: null });
                return false;
              case 100:
                onStripScroll.call(this, { eventSource: this.tracker, position: null, scroll: 1, shift: null });
                return false;
              default:
                return true;
            }
          } else {
            return true;
          }
        }
      })(OpenSeadragon);
      (function($3) {
        $3.DisplayRect = function(x2, y2, width, height, minLevel, maxLevel) {
          $3.Rect.apply(this, [x2, y2, width, height]);
          this.minLevel = minLevel;
          this.maxLevel = maxLevel;
        };
        $3.extend($3.DisplayRect.prototype, $3.Rect.prototype);
      })(OpenSeadragon);
      (function($3) {
        $3.Spring = function(options) {
          var args = arguments;
          if (typeof options != "object") {
            options = {
              initial: args.length && typeof args[0] == "number" ? args[0] : void 0,
              springStiffness: args.length > 1 ? args[1].springStiffness : 5,
              animationTime: args.length > 1 ? args[1].animationTime : 1.5
            };
          }
          $3.console.assert(
            typeof options.springStiffness === "number" && options.springStiffness !== 0,
            "[OpenSeadragon.Spring] options.springStiffness must be a non-zero number"
          );
          $3.console.assert(
            typeof options.animationTime === "number" && options.animationTime >= 0,
            "[OpenSeadragon.Spring] options.animationTime must be a number greater than or equal to 0"
          );
          if (options.exponential) {
            this._exponential = true;
            delete options.exponential;
          }
          $3.extend(true, this, options);
          this.current = {
            value: typeof this.initial == "number" ? this.initial : this._exponential ? 0 : 1,
            time: $3.now()
          };
          $3.console.assert(
            !this._exponential || this.current.value !== 0,
            "[OpenSeadragon.Spring] value must be non-zero for exponential springs"
          );
          this.start = {
            value: this.current.value,
            time: this.current.time
          };
          this.target = {
            value: this.current.value,
            time: this.current.time
          };
          if (this._exponential) {
            this.start._logValue = Math.log(this.start.value);
            this.target._logValue = Math.log(this.target.value);
            this.current._logValue = Math.log(this.current.value);
          }
        };
        $3.Spring.prototype = {
          resetTo: function(target) {
            $3.console.assert(
              !this._exponential || target !== 0,
              "[OpenSeadragon.Spring.resetTo] target must be non-zero for exponential springs"
            );
            this.start.value = this.target.value = this.current.value = target;
            this.start.time = this.target.time = this.current.time = $3.now();
            if (this._exponential) {
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
              this.current._logValue = Math.log(this.current.value);
            }
          },
          springTo: function(target) {
            $3.console.assert(
              !this._exponential || target !== 0,
              "[OpenSeadragon.Spring.springTo] target must be non-zero for exponential springs"
            );
            this.start.value = this.current.value;
            this.start.time = this.current.time;
            this.target.value = target;
            this.target.time = this.start.time + 1e3 * this.animationTime;
            if (this._exponential) {
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
            }
          },
          shiftBy: function(delta) {
            this.start.value += delta;
            this.target.value += delta;
            if (this._exponential) {
              $3.console.assert(
                this.target.value !== 0 && this.start.value !== 0,
                "[OpenSeadragon.Spring.shiftBy] spring value must be non-zero for exponential springs"
              );
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
            }
          },
          setExponential: function(value) {
            this._exponential = value;
            if (this._exponential) {
              $3.console.assert(
                this.current.value !== 0 && this.target.value !== 0 && this.start.value !== 0,
                "[OpenSeadragon.Spring.setExponential] spring value must be non-zero for exponential springs"
              );
              this.start._logValue = Math.log(this.start.value);
              this.target._logValue = Math.log(this.target.value);
              this.current._logValue = Math.log(this.current.value);
            }
          },
          update: function() {
            this.current.time = $3.now();
            var startValue, targetValue;
            if (this._exponential) {
              startValue = this.start._logValue;
              targetValue = this.target._logValue;
            } else {
              startValue = this.start.value;
              targetValue = this.target.value;
            }
            var currentValue = this.current.time >= this.target.time ? targetValue : startValue + (targetValue - startValue) * transform(
              this.springStiffness,
              (this.current.time - this.start.time) / (this.target.time - this.start.time)
            );
            var oldValue = this.current.value;
            if (this._exponential) {
              this.current.value = Math.exp(currentValue);
            } else {
              this.current.value = currentValue;
            }
            return oldValue != this.current.value;
          },
          isAtTargetValue: function() {
            return this.current.value === this.target.value;
          }
        };
        function transform(stiffness, x2) {
          return (1 - Math.exp(stiffness * -x2)) / (1 - Math.exp(-stiffness));
        }
      })(OpenSeadragon);
      (function($3) {
        function ImageJob(options) {
          $3.extend(true, this, {
            timeout: $3.DEFAULT_SETTINGS.timeout,
            jobId: null
          }, options);
          this.image = null;
        }
        ImageJob.prototype = {
          errorMsg: null,
          start: function() {
            var self2 = this;
            var selfAbort = this.abort;
            this.image = new Image();
            this.image.onload = function() {
              self2.finish(true);
            };
            this.image.onabort = this.image.onerror = function() {
              self2.errorMsg = "Image load aborted";
              self2.finish(false);
            };
            this.jobId = window.setTimeout(function() {
              self2.errorMsg = "Image load exceeded timeout (" + self2.timeout + " ms)";
              self2.finish(false);
            }, this.timeout);
            if (this.loadWithAjax) {
              this.request = $3.makeAjaxRequest({
                url: this.src,
                withCredentials: this.ajaxWithCredentials,
                headers: this.ajaxHeaders,
                responseType: "arraybuffer",
                success: function(request) {
                  var blb;
                  try {
                    blb = new window.Blob([request.response]);
                  } catch (e3) {
                    var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
                    if (e3.name === "TypeError" && BlobBuilder) {
                      var bb = new BlobBuilder();
                      bb.append(request.response);
                      blb = bb.getBlob();
                    }
                  }
                  if (blb.size === 0) {
                    self2.errorMsg = "Empty image response.";
                    self2.finish(false);
                  }
                  var url = (window.URL || window.webkitURL).createObjectURL(blb);
                  self2.image.src = url;
                },
                error: function(request) {
                  self2.errorMsg = "Image load aborted - XHR error";
                  self2.finish(false);
                }
              });
              this.abort = function() {
                self2.request.abort();
                if (typeof selfAbort === "function") {
                  selfAbort();
                }
              };
            } else {
              if (this.crossOriginPolicy !== false) {
                this.image.crossOrigin = this.crossOriginPolicy;
              }
              this.image.src = this.src;
            }
          },
          finish: function(successful) {
            this.image.onload = this.image.onerror = this.image.onabort = null;
            if (!successful) {
              this.image = null;
            }
            if (this.jobId) {
              window.clearTimeout(this.jobId);
            }
            this.callback(this);
          }
        };
        $3.ImageLoader = function(options) {
          $3.extend(true, this, {
            jobLimit: $3.DEFAULT_SETTINGS.imageLoaderLimit,
            timeout: $3.DEFAULT_SETTINGS.timeout,
            jobQueue: [],
            jobsInProgress: 0
          }, options);
        };
        $3.ImageLoader.prototype = {
          addJob: function(options) {
            var _this = this, complete = function(job) {
              completeJob(_this, job, options.callback);
            }, jobOptions = {
              src: options.src,
              loadWithAjax: options.loadWithAjax,
              ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,
              crossOriginPolicy: options.crossOriginPolicy,
              ajaxWithCredentials: options.ajaxWithCredentials,
              callback: complete,
              abort: options.abort,
              timeout: this.timeout
            }, newJob = new ImageJob(jobOptions);
            if (!this.jobLimit || this.jobsInProgress < this.jobLimit) {
              newJob.start();
              this.jobsInProgress++;
            } else {
              this.jobQueue.push(newJob);
            }
          },
          clear: function() {
            for (var i2 = 0; i2 < this.jobQueue.length; i2++) {
              var job = this.jobQueue[i2];
              if (typeof job.abort === "function") {
                job.abort();
              }
            }
            this.jobQueue = [];
          }
        };
        function completeJob(loader, job, callback) {
          var nextJob;
          loader.jobsInProgress--;
          if ((!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) && loader.jobQueue.length > 0) {
            nextJob = loader.jobQueue.shift();
            nextJob.start();
            loader.jobsInProgress++;
          }
          callback(job.image, job.errorMsg, job.request);
        }
      })(OpenSeadragon);
      (function($3) {
        $3.Tile = function(level, x2, y2, bounds, exists, url, context2D, loadWithAjax, ajaxHeaders, sourceBounds) {
          this.level = level;
          this.x = x2;
          this.y = y2;
          this.bounds = bounds;
          this.sourceBounds = sourceBounds;
          this.exists = exists;
          this.url = url;
          this.context2D = context2D;
          this.loadWithAjax = loadWithAjax;
          this.ajaxHeaders = ajaxHeaders;
          if (this.ajaxHeaders) {
            this.cacheKey = this.url + "+" + JSON.stringify(this.ajaxHeaders);
          } else {
            this.cacheKey = this.url;
          }
          this.loaded = false;
          this.loading = false;
          this.element = null;
          this.imgElement = null;
          this.image = null;
          this.style = null;
          this.position = null;
          this.size = null;
          this.blendStart = null;
          this.opacity = null;
          this.squaredDistance = null;
          this.visibility = null;
          this.beingDrawn = false;
          this.lastTouchTime = 0;
          this.isRightMost = false;
          this.isBottomMost = false;
        };
        $3.Tile.prototype = {
          toString: function() {
            return this.level + "/" + this.x + "_" + this.y;
          },
          _hasTransparencyChannel: function() {
            return !!this.context2D || this.url.match(".png");
          },
          drawHTML: function(container2) {
            if (!this.cacheImageRecord) {
              $3.console.warn(
                "[Tile.drawHTML] attempting to draw tile %s when it's not cached",
                this.toString()
              );
              return;
            }
            if (!this.loaded) {
              $3.console.warn(
                "Attempting to draw tile %s when it's not yet loaded.",
                this.toString()
              );
              return;
            }
            if (!this.element) {
              this.element = $3.makeNeutralElement("div");
              this.imgElement = this.cacheImageRecord.getImage().cloneNode();
              this.imgElement.style.msInterpolationMode = "nearest-neighbor";
              this.imgElement.style.width = "100%";
              this.imgElement.style.height = "100%";
              this.style = this.element.style;
              this.style.position = "absolute";
            }
            if (this.element.parentNode != container2) {
              container2.appendChild(this.element);
            }
            if (this.imgElement.parentNode != this.element) {
              this.element.appendChild(this.imgElement);
            }
            this.style.top = this.position.y + "px";
            this.style.left = this.position.x + "px";
            this.style.height = this.size.y + "px";
            this.style.width = this.size.x + "px";
            $3.setElementOpacity(this.element, this.opacity);
          },
          drawCanvas: function(context, drawingHandler, scale, translate) {
            var position = this.position.times($3.pixelDensityRatio), size2 = this.size.times($3.pixelDensityRatio), rendered;
            if (!this.context2D && !this.cacheImageRecord) {
              $3.console.warn(
                "[Tile.drawCanvas] attempting to draw tile %s when it's not cached",
                this.toString()
              );
              return;
            }
            rendered = this.context2D || this.cacheImageRecord.getRenderedContext();
            if (!this.loaded || !rendered) {
              $3.console.warn(
                "Attempting to draw tile %s when it's not yet loaded.",
                this.toString()
              );
              return;
            }
            context.save();
            context.globalAlpha = this.opacity;
            if (typeof scale === "number" && scale !== 1) {
              position = position.times(scale);
              size2 = size2.times(scale);
            }
            if (translate instanceof $3.Point) {
              position = position.plus(translate);
            }
            if (context.globalAlpha === 1 && this._hasTransparencyChannel()) {
              context.clearRect(
                position.x,
                position.y,
                size2.x,
                size2.y
              );
            }
            drawingHandler({ context, tile: this, rendered });
            var sourceWidth, sourceHeight;
            if (this.sourceBounds) {
              sourceWidth = Math.min(this.sourceBounds.width, rendered.canvas.width);
              sourceHeight = Math.min(this.sourceBounds.height, rendered.canvas.height);
            } else {
              sourceWidth = rendered.canvas.width;
              sourceHeight = rendered.canvas.height;
            }
            context.drawImage(
              rendered.canvas,
              0,
              0,
              sourceWidth,
              sourceHeight,
              position.x,
              position.y,
              size2.x,
              size2.y
            );
            context.restore();
          },
          getScaleForEdgeSmoothing: function() {
            var context;
            if (this.cacheImageRecord) {
              context = this.cacheImageRecord.getRenderedContext();
            } else if (this.context2D) {
              context = this.context2D;
            } else {
              $3.console.warn(
                "[Tile.drawCanvas] attempting to get tile scale %s when tile's not cached",
                this.toString()
              );
              return 1;
            }
            return context.canvas.width / (this.size.x * $3.pixelDensityRatio);
          },
          getTranslationForEdgeSmoothing: function(scale, canvasSize, sketchCanvasSize) {
            var x2 = Math.max(1, Math.ceil((sketchCanvasSize.x - canvasSize.x) / 2));
            var y2 = Math.max(1, Math.ceil((sketchCanvasSize.y - canvasSize.y) / 2));
            return new $3.Point(x2, y2).minus(
              this.position.times($3.pixelDensityRatio).times(scale || 1).apply(function(x3) {
                return x3 % 1;
              })
            );
          },
          unload: function() {
            if (this.imgElement && this.imgElement.parentNode) {
              this.imgElement.parentNode.removeChild(this.imgElement);
            }
            if (this.element && this.element.parentNode) {
              this.element.parentNode.removeChild(this.element);
            }
            this.element = null;
            this.imgElement = null;
            this.loaded = false;
            this.loading = false;
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.OverlayPlacement = $3.Placement;
        $3.OverlayRotationMode = $3.freezeObject({
          NO_ROTATION: 1,
          EXACT: 2,
          BOUNDING_BOX: 3
        });
        $3.Overlay = function(element, location2, placement) {
          var options;
          if ($3.isPlainObject(element)) {
            options = element;
          } else {
            options = {
              element,
              location: location2,
              placement
            };
          }
          this.element = options.element;
          this.style = options.element.style;
          this._init(options);
        };
        $3.Overlay.prototype = {
          _init: function(options) {
            this.location = options.location;
            this.placement = options.placement === void 0 ? $3.Placement.TOP_LEFT : options.placement;
            this.onDraw = options.onDraw;
            this.checkResize = options.checkResize === void 0 ? true : options.checkResize;
            this.width = options.width === void 0 ? null : options.width;
            this.height = options.height === void 0 ? null : options.height;
            this.rotationMode = options.rotationMode || $3.OverlayRotationMode.EXACT;
            if (this.location instanceof $3.Rect) {
              this.width = this.location.width;
              this.height = this.location.height;
              this.location = this.location.getTopLeft();
              this.placement = $3.Placement.TOP_LEFT;
            }
            this.scales = this.width !== null && this.height !== null;
            this.bounds = new $3.Rect(
              this.location.x,
              this.location.y,
              this.width,
              this.height
            );
            this.position = this.location;
          },
          adjust: function(position, size2) {
            var properties = $3.Placement.properties[this.placement];
            if (!properties) {
              return;
            }
            if (properties.isHorizontallyCentered) {
              position.x -= size2.x / 2;
            } else if (properties.isRight) {
              position.x -= size2.x;
            }
            if (properties.isVerticallyCentered) {
              position.y -= size2.y / 2;
            } else if (properties.isBottom) {
              position.y -= size2.y;
            }
          },
          destroy: function() {
            var element = this.element;
            var style = this.style;
            if (element.parentNode) {
              element.parentNode.removeChild(element);
              if (element.prevElementParent) {
                style.display = "none";
                document.body.appendChild(element);
              }
            }
            this.onDraw = null;
            style.top = "";
            style.left = "";
            style.position = "";
            if (this.width !== null) {
              style.width = "";
            }
            if (this.height !== null) {
              style.height = "";
            }
            var transformOriginProp = $3.getCssPropertyWithVendorPrefix(
              "transformOrigin"
            );
            var transformProp = $3.getCssPropertyWithVendorPrefix(
              "transform"
            );
            if (transformOriginProp && transformProp) {
              style[transformOriginProp] = "";
              style[transformProp] = "";
            }
          },
          drawHTML: function(container2, viewport) {
            var element = this.element;
            if (element.parentNode !== container2) {
              element.prevElementParent = element.parentNode;
              element.prevNextSibling = element.nextSibling;
              container2.appendChild(element);
              this.style.position = "absolute";
              this.size = $3.getElementSize(element);
            }
            var positionAndSize = this._getOverlayPositionAndSize(viewport);
            var position = positionAndSize.position;
            var size2 = this.size = positionAndSize.size;
            var rotate = positionAndSize.rotate;
            if (this.onDraw) {
              this.onDraw(position, size2, this.element);
            } else {
              var style = this.style;
              style.left = position.x + "px";
              style.top = position.y + "px";
              if (this.width !== null) {
                style.width = size2.x + "px";
              }
              if (this.height !== null) {
                style.height = size2.y + "px";
              }
              var transformOriginProp = $3.getCssPropertyWithVendorPrefix(
                "transformOrigin"
              );
              var transformProp = $3.getCssPropertyWithVendorPrefix(
                "transform"
              );
              if (transformOriginProp && transformProp) {
                if (rotate) {
                  style[transformOriginProp] = this._getTransformOrigin();
                  style[transformProp] = "rotate(" + rotate + "deg)";
                } else {
                  style[transformOriginProp] = "";
                  style[transformProp] = "";
                }
              }
              if (style.display !== "none") {
                style.display = "block";
              }
            }
          },
          _getOverlayPositionAndSize: function(viewport) {
            var position = viewport.pixelFromPoint(this.location, true);
            var size2 = this._getSizeInPixels(viewport);
            this.adjust(position, size2);
            var rotate = 0;
            if (viewport.degrees && this.rotationMode !== $3.OverlayRotationMode.NO_ROTATION) {
              if (this.rotationMode === $3.OverlayRotationMode.BOUNDING_BOX && this.width !== null && this.height !== null) {
                var rect = new $3.Rect(position.x, position.y, size2.x, size2.y);
                var boundingBox = this._getBoundingBox(rect, viewport.degrees);
                position = boundingBox.getTopLeft();
                size2 = boundingBox.getSize();
              } else {
                rotate = viewport.degrees;
              }
            }
            return {
              position,
              size: size2,
              rotate
            };
          },
          _getSizeInPixels: function(viewport) {
            var width = this.size.x;
            var height = this.size.y;
            if (this.width !== null || this.height !== null) {
              var scaledSize = viewport.deltaPixelsFromPointsNoRotate(
                new $3.Point(this.width || 0, this.height || 0),
                true
              );
              if (this.width !== null) {
                width = scaledSize.x;
              }
              if (this.height !== null) {
                height = scaledSize.y;
              }
            }
            if (this.checkResize && (this.width === null || this.height === null)) {
              var eltSize = this.size = $3.getElementSize(this.element);
              if (this.width === null) {
                width = eltSize.x;
              }
              if (this.height === null) {
                height = eltSize.y;
              }
            }
            return new $3.Point(width, height);
          },
          _getBoundingBox: function(rect, degrees) {
            var refPoint = this._getPlacementPoint(rect);
            return rect.rotate(degrees, refPoint).getBoundingBox();
          },
          _getPlacementPoint: function(rect) {
            var result = new $3.Point(rect.x, rect.y);
            var properties = $3.Placement.properties[this.placement];
            if (properties) {
              if (properties.isHorizontallyCentered) {
                result.x += rect.width / 2;
              } else if (properties.isRight) {
                result.x += rect.width;
              }
              if (properties.isVerticallyCentered) {
                result.y += rect.height / 2;
              } else if (properties.isBottom) {
                result.y += rect.height;
              }
            }
            return result;
          },
          _getTransformOrigin: function() {
            var result = "";
            var properties = $3.Placement.properties[this.placement];
            if (!properties) {
              return result;
            }
            if (properties.isLeft) {
              result = "left";
            } else if (properties.isRight) {
              result = "right";
            }
            if (properties.isTop) {
              result += " top";
            } else if (properties.isBottom) {
              result += " bottom";
            }
            return result;
          },
          update: function(location2, placement) {
            var options = $3.isPlainObject(location2) ? location2 : {
              location: location2,
              placement
            };
            this._init({
              location: options.location || this.location,
              placement: options.placement !== void 0 ? options.placement : this.placement,
              onDraw: options.onDraw || this.onDraw,
              checkResize: options.checkResize || this.checkResize,
              width: options.width !== void 0 ? options.width : this.width,
              height: options.height !== void 0 ? options.height : this.height,
              rotationMode: options.rotationMode || this.rotationMode
            });
          },
          getBounds: function(viewport) {
            $3.console.assert(
              viewport,
              "A viewport must now be passed to Overlay.getBounds."
            );
            var width = this.width;
            var height = this.height;
            if (width === null || height === null) {
              var size2 = viewport.deltaPointsFromPixelsNoRotate(this.size, true);
              if (width === null) {
                width = size2.x;
              }
              if (height === null) {
                height = size2.y;
              }
            }
            var location2 = this.location.clone();
            this.adjust(location2, new $3.Point(width, height));
            return this._adjustBoundsForRotation(
              viewport,
              new $3.Rect(location2.x, location2.y, width, height)
            );
          },
          _adjustBoundsForRotation: function(viewport, bounds) {
            if (!viewport || viewport.degrees === 0 || this.rotationMode === $3.OverlayRotationMode.EXACT) {
              return bounds;
            }
            if (this.rotationMode === $3.OverlayRotationMode.BOUNDING_BOX) {
              if (this.width === null || this.height === null) {
                return bounds;
              }
              var positionAndSize = this._getOverlayPositionAndSize(viewport);
              return viewport.viewerElementToViewportRectangle(new $3.Rect(
                positionAndSize.position.x,
                positionAndSize.position.y,
                positionAndSize.size.x,
                positionAndSize.size.y
              ));
            }
            return bounds.rotate(
              -viewport.degrees,
              this._getPlacementPoint(bounds)
            );
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.Drawer = function(options) {
          $3.console.assert(options.viewer, "[Drawer] options.viewer is required");
          var args = arguments;
          if (!$3.isPlainObject(options)) {
            options = {
              source: args[0],
              viewport: args[1],
              element: args[2]
            };
          }
          $3.console.assert(options.viewport, "[Drawer] options.viewport is required");
          $3.console.assert(options.element, "[Drawer] options.element is required");
          if (options.source) {
            $3.console.error("[Drawer] options.source is no longer accepted; use TiledImage instead");
          }
          this.viewer = options.viewer;
          this.viewport = options.viewport;
          this.debugGridColor = typeof options.debugGridColor === "string" ? [options.debugGridColor] : options.debugGridColor || $3.DEFAULT_SETTINGS.debugGridColor;
          if (options.opacity) {
            $3.console.error("[Drawer] options.opacity is no longer accepted; set the opacity on the TiledImage instead");
          }
          this.useCanvas = $3.supportsCanvas && (this.viewer ? this.viewer.useCanvas : true);
          this.container = $3.getElement(options.element);
          this.canvas = $3.makeNeutralElement(this.useCanvas ? "canvas" : "div");
          this.context = this.useCanvas ? this.canvas.getContext("2d") : null;
          this.sketchCanvas = null;
          this.sketchContext = null;
          this.element = this.container;
          this.container.dir = "ltr";
          if (this.useCanvas) {
            var viewportSize = this._calculateCanvasSize();
            this.canvas.width = viewportSize.x;
            this.canvas.height = viewportSize.y;
          }
          this.canvas.style.width = "100%";
          this.canvas.style.height = "100%";
          this.canvas.style.position = "absolute";
          $3.setElementOpacity(this.canvas, this.opacity, true);
          this.container.style.textAlign = "left";
          this.container.appendChild(this.canvas);
          this._imageSmoothingEnabled = true;
        };
        $3.Drawer.prototype = {
          addOverlay: function(element, location2, placement, onDraw) {
            $3.console.error("drawer.addOverlay is deprecated. Use viewer.addOverlay instead.");
            this.viewer.addOverlay(element, location2, placement, onDraw);
            return this;
          },
          updateOverlay: function(element, location2, placement) {
            $3.console.error("drawer.updateOverlay is deprecated. Use viewer.updateOverlay instead.");
            this.viewer.updateOverlay(element, location2, placement);
            return this;
          },
          removeOverlay: function(element) {
            $3.console.error("drawer.removeOverlay is deprecated. Use viewer.removeOverlay instead.");
            this.viewer.removeOverlay(element);
            return this;
          },
          clearOverlays: function() {
            $3.console.error("drawer.clearOverlays is deprecated. Use viewer.clearOverlays instead.");
            this.viewer.clearOverlays();
            return this;
          },
          viewportCoordToDrawerCoord: function(point) {
            var vpPoint = this.viewport.pixelFromPointNoRotate(point, true);
            return new $3.Point(
              vpPoint.x * $3.pixelDensityRatio,
              vpPoint.y * $3.pixelDensityRatio
            );
          },
          clipWithPolygons: function(polygons, useSketch) {
            if (!this.useCanvas) {
              return;
            }
            var context = this._getContext(useSketch);
            context.beginPath();
            polygons.forEach(function(polygon) {
              polygon.forEach(function(coord, i2) {
                context[i2 === 0 ? "moveTo" : "lineTo"](coord.x, coord.y);
              });
            });
            context.clip();
          },
          setOpacity: function(opacity) {
            $3.console.error("drawer.setOpacity is deprecated. Use tiledImage.setOpacity instead.");
            var world = this.viewer.world;
            for (var i2 = 0; i2 < world.getItemCount(); i2++) {
              world.getItemAt(i2).setOpacity(opacity);
            }
            return this;
          },
          getOpacity: function() {
            $3.console.error("drawer.getOpacity is deprecated. Use tiledImage.getOpacity instead.");
            var world = this.viewer.world;
            var maxOpacity = 0;
            for (var i2 = 0; i2 < world.getItemCount(); i2++) {
              var opacity = world.getItemAt(i2).getOpacity();
              if (opacity > maxOpacity) {
                maxOpacity = opacity;
              }
            }
            return maxOpacity;
          },
          needsUpdate: function() {
            $3.console.error("[Drawer.needsUpdate] this function is deprecated. Use World.needsDraw instead.");
            return this.viewer.world.needsDraw();
          },
          numTilesLoaded: function() {
            $3.console.error("[Drawer.numTilesLoaded] this function is deprecated. Use TileCache.numTilesLoaded instead.");
            return this.viewer.tileCache.numTilesLoaded();
          },
          reset: function() {
            $3.console.error("[Drawer.reset] this function is deprecated. Use World.resetItems instead.");
            this.viewer.world.resetItems();
            return this;
          },
          update: function() {
            $3.console.error("[Drawer.update] this function is deprecated. Use Drawer.clear and World.draw instead.");
            this.clear();
            this.viewer.world.draw();
            return this;
          },
          canRotate: function() {
            return this.useCanvas;
          },
          destroy: function() {
            this.canvas.width = 1;
            this.canvas.height = 1;
            this.sketchCanvas = null;
            this.sketchContext = null;
          },
          clear: function() {
            this.canvas.innerHTML = "";
            if (this.useCanvas) {
              var viewportSize = this._calculateCanvasSize();
              if (this.canvas.width != viewportSize.x || this.canvas.height != viewportSize.y) {
                this.canvas.width = viewportSize.x;
                this.canvas.height = viewportSize.y;
                this._updateImageSmoothingEnabled(this.context);
                if (this.sketchCanvas !== null) {
                  var sketchCanvasSize = this._calculateSketchCanvasSize();
                  this.sketchCanvas.width = sketchCanvasSize.x;
                  this.sketchCanvas.height = sketchCanvasSize.y;
                  this._updateImageSmoothingEnabled(this.sketchContext);
                }
              }
              this._clear();
            }
          },
          _clear: function(useSketch, bounds) {
            if (!this.useCanvas) {
              return;
            }
            var context = this._getContext(useSketch);
            if (bounds) {
              context.clearRect(bounds.x, bounds.y, bounds.width, bounds.height);
            } else {
              var canvas = context.canvas;
              context.clearRect(0, 0, canvas.width, canvas.height);
            }
          },
          viewportToDrawerRectangle: function(rectangle) {
            var topLeft = this.viewport.pixelFromPointNoRotate(rectangle.getTopLeft(), true);
            var size2 = this.viewport.deltaPixelsFromPointsNoRotate(rectangle.getSize(), true);
            return new $3.Rect(
              topLeft.x * $3.pixelDensityRatio,
              topLeft.y * $3.pixelDensityRatio,
              size2.x * $3.pixelDensityRatio,
              size2.y * $3.pixelDensityRatio
            );
          },
          drawTile: function(tile, drawingHandler, useSketch, scale, translate) {
            $3.console.assert(tile, "[Drawer.drawTile] tile is required");
            $3.console.assert(drawingHandler, "[Drawer.drawTile] drawingHandler is required");
            if (this.useCanvas) {
              var context = this._getContext(useSketch);
              scale = scale || 1;
              tile.drawCanvas(context, drawingHandler, scale, translate);
            } else {
              tile.drawHTML(this.canvas);
            }
          },
          _getContext: function(useSketch) {
            var context = this.context;
            if (useSketch) {
              if (this.sketchCanvas === null) {
                this.sketchCanvas = document.createElement("canvas");
                var sketchCanvasSize = this._calculateSketchCanvasSize();
                this.sketchCanvas.width = sketchCanvasSize.x;
                this.sketchCanvas.height = sketchCanvasSize.y;
                this.sketchContext = this.sketchCanvas.getContext("2d");
                if (this.viewport.getRotation() === 0) {
                  var self2 = this;
                  this.viewer.addHandler("rotate", function resizeSketchCanvas() {
                    if (self2.viewport.getRotation() === 0) {
                      return;
                    }
                    self2.viewer.removeHandler("rotate", resizeSketchCanvas);
                    var sketchCanvasSize2 = self2._calculateSketchCanvasSize();
                    self2.sketchCanvas.width = sketchCanvasSize2.x;
                    self2.sketchCanvas.height = sketchCanvasSize2.y;
                  });
                }
                this._updateImageSmoothingEnabled(this.sketchContext);
              }
              context = this.sketchContext;
            }
            return context;
          },
          saveContext: function(useSketch) {
            if (!this.useCanvas) {
              return;
            }
            this._getContext(useSketch).save();
          },
          restoreContext: function(useSketch) {
            if (!this.useCanvas) {
              return;
            }
            this._getContext(useSketch).restore();
          },
          setClip: function(rect, useSketch) {
            if (!this.useCanvas) {
              return;
            }
            var context = this._getContext(useSketch);
            context.beginPath();
            context.rect(rect.x, rect.y, rect.width, rect.height);
            context.clip();
          },
          drawRectangle: function(rect, fillStyle, useSketch) {
            if (!this.useCanvas) {
              return;
            }
            var context = this._getContext(useSketch);
            context.save();
            context.fillStyle = fillStyle;
            context.fillRect(rect.x, rect.y, rect.width, rect.height);
            context.restore();
          },
          blendSketch: function(opacity, scale, translate, compositeOperation) {
            var options = opacity;
            if (!$3.isPlainObject(options)) {
              options = {
                opacity,
                scale,
                translate,
                compositeOperation
              };
            }
            if (!this.useCanvas || !this.sketchCanvas) {
              return;
            }
            opacity = options.opacity;
            compositeOperation = options.compositeOperation;
            var bounds = options.bounds;
            this.context.save();
            this.context.globalAlpha = opacity;
            if (compositeOperation) {
              this.context.globalCompositeOperation = compositeOperation;
            }
            if (bounds) {
              if (bounds.x < 0) {
                bounds.width += bounds.x;
                bounds.x = 0;
              }
              if (bounds.x + bounds.width > this.canvas.width) {
                bounds.width = this.canvas.width - bounds.x;
              }
              if (bounds.y < 0) {
                bounds.height += bounds.y;
                bounds.y = 0;
              }
              if (bounds.y + bounds.height > this.canvas.height) {
                bounds.height = this.canvas.height - bounds.y;
              }
              this.context.drawImage(
                this.sketchCanvas,
                bounds.x,
                bounds.y,
                bounds.width,
                bounds.height,
                bounds.x,
                bounds.y,
                bounds.width,
                bounds.height
              );
            } else {
              scale = options.scale || 1;
              translate = options.translate;
              var position = translate instanceof $3.Point ? translate : new $3.Point(0, 0);
              var widthExt = 0;
              var heightExt = 0;
              if (translate) {
                var widthDiff = this.sketchCanvas.width - this.canvas.width;
                var heightDiff = this.sketchCanvas.height - this.canvas.height;
                widthExt = Math.round(widthDiff / 2);
                heightExt = Math.round(heightDiff / 2);
              }
              this.context.drawImage(
                this.sketchCanvas,
                position.x - widthExt * scale,
                position.y - heightExt * scale,
                (this.canvas.width + 2 * widthExt) * scale,
                (this.canvas.height + 2 * heightExt) * scale,
                -widthExt,
                -heightExt,
                this.canvas.width + 2 * widthExt,
                this.canvas.height + 2 * heightExt
              );
            }
            this.context.restore();
          },
          drawDebugInfo: function(tile, count, i2, tiledImage) {
            if (!this.useCanvas) {
              return;
            }
            var colorIndex = this.viewer.world.getIndexOfItem(tiledImage) % this.debugGridColor.length;
            var context = this.context;
            context.save();
            context.lineWidth = 2 * $3.pixelDensityRatio;
            context.font = "small-caps bold " + 13 * $3.pixelDensityRatio + "px arial";
            context.strokeStyle = this.debugGridColor[colorIndex];
            context.fillStyle = this.debugGridColor[colorIndex];
            if (this.viewport.degrees !== 0) {
              this._offsetForRotation({ degrees: this.viewport.degrees });
            }
            if (tiledImage.getRotation(true) % 360 !== 0) {
              this._offsetForRotation({
                degrees: tiledImage.getRotation(true),
                point: tiledImage.viewport.pixelFromPointNoRotate(
                  tiledImage._getRotationPoint(true),
                  true
                )
              });
            }
            if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
              if (tiledImage._drawer.viewer.viewport.getFlip()) {
                tiledImage._drawer._flip();
              }
            }
            context.strokeRect(
              tile.position.x * $3.pixelDensityRatio,
              tile.position.y * $3.pixelDensityRatio,
              tile.size.x * $3.pixelDensityRatio,
              tile.size.y * $3.pixelDensityRatio
            );
            var tileCenterX = (tile.position.x + tile.size.x / 2) * $3.pixelDensityRatio;
            var tileCenterY = (tile.position.y + tile.size.y / 2) * $3.pixelDensityRatio;
            context.translate(tileCenterX, tileCenterY);
            context.rotate(Math.PI / 180 * -this.viewport.degrees);
            context.translate(-tileCenterX, -tileCenterY);
            if (tile.x === 0 && tile.y === 0) {
              context.fillText(
                "Zoom: " + this.viewport.getZoom(),
                tile.position.x * $3.pixelDensityRatio,
                (tile.position.y - 30) * $3.pixelDensityRatio
              );
              context.fillText(
                "Pan: " + this.viewport.getBounds().toString(),
                tile.position.x * $3.pixelDensityRatio,
                (tile.position.y - 20) * $3.pixelDensityRatio
              );
            }
            context.fillText(
              "Level: " + tile.level,
              (tile.position.x + 10) * $3.pixelDensityRatio,
              (tile.position.y + 20) * $3.pixelDensityRatio
            );
            context.fillText(
              "Column: " + tile.x,
              (tile.position.x + 10) * $3.pixelDensityRatio,
              (tile.position.y + 30) * $3.pixelDensityRatio
            );
            context.fillText(
              "Row: " + tile.y,
              (tile.position.x + 10) * $3.pixelDensityRatio,
              (tile.position.y + 40) * $3.pixelDensityRatio
            );
            context.fillText(
              "Order: " + i2 + " of " + count,
              (tile.position.x + 10) * $3.pixelDensityRatio,
              (tile.position.y + 50) * $3.pixelDensityRatio
            );
            context.fillText(
              "Size: " + tile.size.toString(),
              (tile.position.x + 10) * $3.pixelDensityRatio,
              (tile.position.y + 60) * $3.pixelDensityRatio
            );
            context.fillText(
              "Position: " + tile.position.toString(),
              (tile.position.x + 10) * $3.pixelDensityRatio,
              (tile.position.y + 70) * $3.pixelDensityRatio
            );
            if (this.viewport.degrees !== 0) {
              this._restoreRotationChanges();
            }
            if (tiledImage.getRotation(true) % 360 !== 0) {
              this._restoreRotationChanges();
            }
            if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
              if (tiledImage._drawer.viewer.viewport.getFlip()) {
                tiledImage._drawer._flip();
              }
            }
            context.restore();
          },
          debugRect: function(rect) {
            if (this.useCanvas) {
              var context = this.context;
              context.save();
              context.lineWidth = 2 * $3.pixelDensityRatio;
              context.strokeStyle = this.debugGridColor[0];
              context.fillStyle = this.debugGridColor[0];
              context.strokeRect(
                rect.x * $3.pixelDensityRatio,
                rect.y * $3.pixelDensityRatio,
                rect.width * $3.pixelDensityRatio,
                rect.height * $3.pixelDensityRatio
              );
              context.restore();
            }
          },
          setImageSmoothingEnabled: function(imageSmoothingEnabled) {
            if (this.useCanvas) {
              this._imageSmoothingEnabled = imageSmoothingEnabled;
              this._updateImageSmoothingEnabled(this.context);
              this.viewer.forceRedraw();
            }
          },
          _updateImageSmoothingEnabled: function(context) {
            context.msImageSmoothingEnabled = this._imageSmoothingEnabled;
            context.imageSmoothingEnabled = this._imageSmoothingEnabled;
          },
          getCanvasSize: function(sketch) {
            var canvas = this._getContext(sketch).canvas;
            return new $3.Point(canvas.width, canvas.height);
          },
          getCanvasCenter: function() {
            return new $3.Point(this.canvas.width / 2, this.canvas.height / 2);
          },
          _offsetForRotation: function(options) {
            var point = options.point ? options.point.times($3.pixelDensityRatio) : this.getCanvasCenter();
            var context = this._getContext(options.useSketch);
            context.save();
            context.translate(point.x, point.y);
            if (this.viewer.viewport.flipped) {
              context.rotate(Math.PI / 180 * -options.degrees);
              context.scale(-1, 1);
            } else {
              context.rotate(Math.PI / 180 * options.degrees);
            }
            context.translate(-point.x, -point.y);
          },
          _flip: function(options) {
            options = options || {};
            var point = options.point ? options.point.times($3.pixelDensityRatio) : this.getCanvasCenter();
            var context = this._getContext(options.useSketch);
            context.translate(point.x, 0);
            context.scale(-1, 1);
            context.translate(-point.x, 0);
          },
          _restoreRotationChanges: function(useSketch) {
            var context = this._getContext(useSketch);
            context.restore();
          },
          _calculateCanvasSize: function() {
            var pixelDensityRatio = $3.pixelDensityRatio;
            var viewportSize = this.viewport.getContainerSize();
            return {
              x: Math.round(viewportSize.x * pixelDensityRatio),
              y: Math.round(viewportSize.y * pixelDensityRatio)
            };
          },
          _calculateSketchCanvasSize: function() {
            var canvasSize = this._calculateCanvasSize();
            if (this.viewport.getRotation() === 0) {
              return canvasSize;
            }
            var sketchCanvasSize = Math.ceil(Math.sqrt(
              canvasSize.x * canvasSize.x + canvasSize.y * canvasSize.y
            ));
            return {
              x: sketchCanvasSize,
              y: sketchCanvasSize
            };
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.Viewport = function(options) {
          var args = arguments;
          if (args.length && args[0] instanceof $3.Point) {
            options = {
              containerSize: args[0],
              contentSize: args[1],
              config: args[2]
            };
          }
          if (options.config) {
            $3.extend(true, options, options.config);
            delete options.config;
          }
          this._margins = $3.extend({
            left: 0,
            top: 0,
            right: 0,
            bottom: 0
          }, options.margins || {});
          delete options.margins;
          $3.extend(true, this, {
            containerSize: null,
            contentSize: null,
            zoomPoint: null,
            viewer: null,
            springStiffness: $3.DEFAULT_SETTINGS.springStiffness,
            animationTime: $3.DEFAULT_SETTINGS.animationTime,
            minZoomImageRatio: $3.DEFAULT_SETTINGS.minZoomImageRatio,
            maxZoomPixelRatio: $3.DEFAULT_SETTINGS.maxZoomPixelRatio,
            visibilityRatio: $3.DEFAULT_SETTINGS.visibilityRatio,
            wrapHorizontal: $3.DEFAULT_SETTINGS.wrapHorizontal,
            wrapVertical: $3.DEFAULT_SETTINGS.wrapVertical,
            defaultZoomLevel: $3.DEFAULT_SETTINGS.defaultZoomLevel,
            minZoomLevel: $3.DEFAULT_SETTINGS.minZoomLevel,
            maxZoomLevel: $3.DEFAULT_SETTINGS.maxZoomLevel,
            degrees: $3.DEFAULT_SETTINGS.degrees,
            flipped: $3.DEFAULT_SETTINGS.flipped,
            homeFillsViewer: $3.DEFAULT_SETTINGS.homeFillsViewer
          }, options);
          this._updateContainerInnerSize();
          this.centerSpringX = new $3.Spring({
            initial: 0,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
          });
          this.centerSpringY = new $3.Spring({
            initial: 0,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
          });
          this.zoomSpring = new $3.Spring({
            exponential: true,
            initial: 1,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
          });
          this._oldCenterX = this.centerSpringX.current.value;
          this._oldCenterY = this.centerSpringY.current.value;
          this._oldZoom = this.zoomSpring.current.value;
          this._setContentBounds(new $3.Rect(0, 0, 1, 1), 1);
          this.goHome(true);
          this.update();
        };
        $3.Viewport.prototype = {
          resetContentSize: function(contentSize) {
            $3.console.assert(contentSize, "[Viewport.resetContentSize] contentSize is required");
            $3.console.assert(contentSize instanceof $3.Point, "[Viewport.resetContentSize] contentSize must be an OpenSeadragon.Point");
            $3.console.assert(contentSize.x > 0, "[Viewport.resetContentSize] contentSize.x must be greater than 0");
            $3.console.assert(contentSize.y > 0, "[Viewport.resetContentSize] contentSize.y must be greater than 0");
            this._setContentBounds(new $3.Rect(0, 0, 1, contentSize.y / contentSize.x), contentSize.x);
            return this;
          },
          setHomeBounds: function(bounds, contentFactor) {
            $3.console.error("[Viewport.setHomeBounds] this function is deprecated; The content bounds should not be set manually.");
            this._setContentBounds(bounds, contentFactor);
          },
          _setContentBounds: function(bounds, contentFactor) {
            $3.console.assert(bounds, "[Viewport._setContentBounds] bounds is required");
            $3.console.assert(bounds instanceof $3.Rect, "[Viewport._setContentBounds] bounds must be an OpenSeadragon.Rect");
            $3.console.assert(bounds.width > 0, "[Viewport._setContentBounds] bounds.width must be greater than 0");
            $3.console.assert(bounds.height > 0, "[Viewport._setContentBounds] bounds.height must be greater than 0");
            this._contentBoundsNoRotate = bounds.clone();
            this._contentSizeNoRotate = this._contentBoundsNoRotate.getSize().times(
              contentFactor
            );
            this._contentBounds = bounds.rotate(this.degrees).getBoundingBox();
            this._contentSize = this._contentBounds.getSize().times(contentFactor);
            this._contentAspectRatio = this._contentSize.x / this._contentSize.y;
            if (this.viewer) {
              this.viewer.raiseEvent("reset-size", {
                contentSize: this._contentSizeNoRotate.clone(),
                contentFactor,
                homeBounds: this._contentBoundsNoRotate.clone(),
                contentBounds: this._contentBounds.clone()
              });
            }
          },
          getHomeZoom: function() {
            if (this.defaultZoomLevel) {
              return this.defaultZoomLevel;
            }
            var aspectFactor = this._contentAspectRatio / this.getAspectRatio();
            var output;
            if (this.homeFillsViewer) {
              output = aspectFactor >= 1 ? aspectFactor : 1;
            } else {
              output = aspectFactor >= 1 ? 1 : aspectFactor;
            }
            return output / this._contentBounds.width;
          },
          getHomeBounds: function() {
            return this.getHomeBoundsNoRotate().rotate(-this.getRotation());
          },
          getHomeBoundsNoRotate: function() {
            var center2 = this._contentBounds.getCenter();
            var width = 1 / this.getHomeZoom();
            var height = width / this.getAspectRatio();
            return new $3.Rect(
              center2.x - width / 2,
              center2.y - height / 2,
              width,
              height
            );
          },
          goHome: function(immediately) {
            if (this.viewer) {
              this.viewer.raiseEvent("home", {
                immediately
              });
            }
            return this.fitBounds(this.getHomeBounds(), immediately);
          },
          getMinZoom: function() {
            var homeZoom = this.getHomeZoom(), zoom = this.minZoomLevel ? this.minZoomLevel : this.minZoomImageRatio * homeZoom;
            return zoom;
          },
          getMaxZoom: function() {
            var zoom = this.maxZoomLevel;
            if (!zoom) {
              zoom = this._contentSize.x * this.maxZoomPixelRatio / this._containerInnerSize.x;
              zoom /= this._contentBounds.width;
            }
            return Math.max(zoom, this.getHomeZoom());
          },
          getAspectRatio: function() {
            return this._containerInnerSize.x / this._containerInnerSize.y;
          },
          getContainerSize: function() {
            return new $3.Point(
              this.containerSize.x,
              this.containerSize.y
            );
          },
          getMargins: function() {
            return $3.extend({}, this._margins);
          },
          setMargins: function(margins) {
            $3.console.assert($3.type(margins) === "object", "[Viewport.setMargins] margins must be an object");
            this._margins = $3.extend({
              left: 0,
              top: 0,
              right: 0,
              bottom: 0
            }, margins);
            this._updateContainerInnerSize();
            if (this.viewer) {
              this.viewer.forceRedraw();
            }
          },
          getBounds: function(current) {
            return this.getBoundsNoRotate(current).rotate(-this.getRotation());
          },
          getBoundsNoRotate: function(current) {
            var center2 = this.getCenter(current);
            var width = 1 / this.getZoom(current);
            var height = width / this.getAspectRatio();
            return new $3.Rect(
              center2.x - width / 2,
              center2.y - height / 2,
              width,
              height
            );
          },
          getBoundsWithMargins: function(current) {
            return this.getBoundsNoRotateWithMargins(current).rotate(
              -this.getRotation(),
              this.getCenter(current)
            );
          },
          getBoundsNoRotateWithMargins: function(current) {
            var bounds = this.getBoundsNoRotate(current);
            var factor = this._containerInnerSize.x * this.getZoom(current);
            bounds.x -= this._margins.left / factor;
            bounds.y -= this._margins.top / factor;
            bounds.width += (this._margins.left + this._margins.right) / factor;
            bounds.height += (this._margins.top + this._margins.bottom) / factor;
            return bounds;
          },
          getCenter: function(current) {
            var centerCurrent = new $3.Point(
              this.centerSpringX.current.value,
              this.centerSpringY.current.value
            ), centerTarget = new $3.Point(
              this.centerSpringX.target.value,
              this.centerSpringY.target.value
            ), oldZoomPixel, zoom, width, height, bounds, newZoomPixel, deltaZoomPixels, deltaZoomPoints;
            if (current) {
              return centerCurrent;
            } else if (!this.zoomPoint) {
              return centerTarget;
            }
            oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
            zoom = this.getZoom();
            width = 1 / zoom;
            height = width / this.getAspectRatio();
            bounds = new $3.Rect(
              centerCurrent.x - width / 2,
              centerCurrent.y - height / 2,
              width,
              height
            );
            newZoomPixel = this._pixelFromPoint(this.zoomPoint, bounds);
            deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
            deltaZoomPoints = deltaZoomPixels.divide(this._containerInnerSize.x * zoom);
            return centerTarget.plus(deltaZoomPoints);
          },
          getZoom: function(current) {
            if (current) {
              return this.zoomSpring.current.value;
            } else {
              return this.zoomSpring.target.value;
            }
          },
          _applyZoomConstraints: function(zoom) {
            return Math.max(
              Math.min(zoom, this.getMaxZoom()),
              this.getMinZoom()
            );
          },
          _applyBoundaryConstraints: function(bounds) {
            var newBounds = new $3.Rect(
              bounds.x,
              bounds.y,
              bounds.width,
              bounds.height
            );
            if (this.wrapHorizontal) {
            } else {
              var horizontalThreshold = this.visibilityRatio * newBounds.width;
              var boundsRight = newBounds.x + newBounds.width;
              var contentRight = this._contentBoundsNoRotate.x + this._contentBoundsNoRotate.width;
              var leftDx = this._contentBoundsNoRotate.x - boundsRight + horizontalThreshold;
              var rightDx = contentRight - newBounds.x - horizontalThreshold;
              if (horizontalThreshold > this._contentBoundsNoRotate.width) {
                newBounds.x += (leftDx + rightDx) / 2;
              } else if (rightDx < 0) {
                newBounds.x += rightDx;
              } else if (leftDx > 0) {
                newBounds.x += leftDx;
              }
            }
            if (this.wrapVertical) {
            } else {
              var verticalThreshold = this.visibilityRatio * newBounds.height;
              var boundsBottom = newBounds.y + newBounds.height;
              var contentBottom = this._contentBoundsNoRotate.y + this._contentBoundsNoRotate.height;
              var topDy = this._contentBoundsNoRotate.y - boundsBottom + verticalThreshold;
              var bottomDy = contentBottom - newBounds.y - verticalThreshold;
              if (verticalThreshold > this._contentBoundsNoRotate.height) {
                newBounds.y += (topDy + bottomDy) / 2;
              } else if (bottomDy < 0) {
                newBounds.y += bottomDy;
              } else if (topDy > 0) {
                newBounds.y += topDy;
              }
            }
            return newBounds;
          },
          _raiseConstraintsEvent: function(immediately) {
            if (this.viewer) {
              this.viewer.raiseEvent("constrain", {
                immediately
              });
            }
          },
          applyConstraints: function(immediately) {
            var actualZoom = this.getZoom();
            var constrainedZoom = this._applyZoomConstraints(actualZoom);
            if (actualZoom !== constrainedZoom) {
              this.zoomTo(constrainedZoom, this.zoomPoint, immediately);
            }
            var bounds = this.getBoundsNoRotate();
            var constrainedBounds = this._applyBoundaryConstraints(bounds);
            this._raiseConstraintsEvent(immediately);
            if (bounds.x !== constrainedBounds.x || bounds.y !== constrainedBounds.y || immediately) {
              this.fitBounds(
                constrainedBounds.rotate(-this.getRotation()),
                immediately
              );
            }
            return this;
          },
          ensureVisible: function(immediately) {
            return this.applyConstraints(immediately);
          },
          _fitBounds: function(bounds, options) {
            options = options || {};
            var immediately = options.immediately || false;
            var constraints = options.constraints || false;
            var aspect = this.getAspectRatio();
            var center2 = bounds.getCenter();
            var newBounds = new $3.Rect(
              bounds.x,
              bounds.y,
              bounds.width,
              bounds.height,
              bounds.degrees + this.getRotation()
            ).getBoundingBox();
            if (newBounds.getAspectRatio() >= aspect) {
              newBounds.height = newBounds.width / aspect;
            } else {
              newBounds.width = newBounds.height * aspect;
            }
            newBounds.x = center2.x - newBounds.width / 2;
            newBounds.y = center2.y - newBounds.height / 2;
            var newZoom = 1 / newBounds.width;
            if (constraints) {
              var newBoundsAspectRatio = newBounds.getAspectRatio();
              var newConstrainedZoom = this._applyZoomConstraints(newZoom);
              if (newZoom !== newConstrainedZoom) {
                newZoom = newConstrainedZoom;
                newBounds.width = 1 / newZoom;
                newBounds.x = center2.x - newBounds.width / 2;
                newBounds.height = newBounds.width / newBoundsAspectRatio;
                newBounds.y = center2.y - newBounds.height / 2;
              }
              newBounds = this._applyBoundaryConstraints(newBounds);
              center2 = newBounds.getCenter();
              this._raiseConstraintsEvent(immediately);
            }
            if (immediately) {
              this.panTo(center2, true);
              return this.zoomTo(newZoom, null, true);
            }
            this.panTo(this.getCenter(true), true);
            this.zoomTo(this.getZoom(true), null, true);
            var oldBounds = this.getBounds();
            var oldZoom = this.getZoom();
            if (oldZoom === 0 || Math.abs(newZoom / oldZoom - 1) < 1e-8) {
              this.zoomTo(newZoom, true);
              return this.panTo(center2, immediately);
            }
            newBounds = newBounds.rotate(-this.getRotation());
            var referencePoint = newBounds.getTopLeft().times(newZoom).minus(oldBounds.getTopLeft().times(oldZoom)).divide(newZoom - oldZoom);
            return this.zoomTo(newZoom, referencePoint, immediately);
          },
          fitBounds: function(bounds, immediately) {
            return this._fitBounds(bounds, {
              immediately,
              constraints: false
            });
          },
          fitBoundsWithConstraints: function(bounds, immediately) {
            return this._fitBounds(bounds, {
              immediately,
              constraints: true
            });
          },
          fitVertically: function(immediately) {
            var box = new $3.Rect(
              this._contentBounds.x + this._contentBounds.width / 2,
              this._contentBounds.y,
              0,
              this._contentBounds.height
            );
            return this.fitBounds(box, immediately);
          },
          fitHorizontally: function(immediately) {
            var box = new $3.Rect(
              this._contentBounds.x,
              this._contentBounds.y + this._contentBounds.height / 2,
              this._contentBounds.width,
              0
            );
            return this.fitBounds(box, immediately);
          },
          getConstrainedBounds: function(current) {
            var bounds, constrainedBounds;
            bounds = this.getBounds(current);
            constrainedBounds = this._applyBoundaryConstraints(bounds);
            return constrainedBounds;
          },
          panBy: function(delta, immediately) {
            var center2 = new $3.Point(
              this.centerSpringX.target.value,
              this.centerSpringY.target.value
            );
            return this.panTo(center2.plus(delta), immediately);
          },
          panTo: function(center2, immediately) {
            if (immediately) {
              this.centerSpringX.resetTo(center2.x);
              this.centerSpringY.resetTo(center2.y);
            } else {
              this.centerSpringX.springTo(center2.x);
              this.centerSpringY.springTo(center2.y);
            }
            if (this.viewer) {
              this.viewer.raiseEvent("pan", {
                center: center2,
                immediately
              });
            }
            return this;
          },
          zoomBy: function(factor, refPoint, immediately) {
            return this.zoomTo(
              this.zoomSpring.target.value * factor,
              refPoint,
              immediately
            );
          },
          zoomTo: function(zoom, refPoint, immediately) {
            var _this = this;
            this.zoomPoint = refPoint instanceof $3.Point && !isNaN(refPoint.x) && !isNaN(refPoint.y) ? refPoint : null;
            if (immediately) {
              this._adjustCenterSpringsForZoomPoint(function() {
                _this.zoomSpring.resetTo(zoom);
              });
            } else {
              this.zoomSpring.springTo(zoom);
            }
            if (this.viewer) {
              this.viewer.raiseEvent("zoom", {
                zoom,
                refPoint,
                immediately
              });
            }
            return this;
          },
          setRotation: function(degrees) {
            if (!this.viewer || !this.viewer.drawer.canRotate()) {
              return this;
            }
            this.degrees = $3.positiveModulo(degrees, 360);
            this._setContentBounds(
              this.viewer.world.getHomeBounds(),
              this.viewer.world.getContentFactor()
            );
            this.viewer.forceRedraw();
            this.viewer.raiseEvent("rotate", { "degrees": degrees });
            return this;
          },
          getRotation: function() {
            return this.degrees;
          },
          resize: function(newContainerSize, maintain) {
            var oldBounds = this.getBoundsNoRotate(), newBounds = oldBounds, widthDeltaFactor;
            this.containerSize.x = newContainerSize.x;
            this.containerSize.y = newContainerSize.y;
            this._updateContainerInnerSize();
            if (maintain) {
              widthDeltaFactor = newContainerSize.x / this.containerSize.x;
              newBounds.width = oldBounds.width * widthDeltaFactor;
              newBounds.height = newBounds.width / this.getAspectRatio();
            }
            if (this.viewer) {
              this.viewer.raiseEvent("resize", {
                newContainerSize,
                maintain
              });
            }
            return this.fitBounds(newBounds, true);
          },
          _updateContainerInnerSize: function() {
            this._containerInnerSize = new $3.Point(
              Math.max(1, this.containerSize.x - (this._margins.left + this._margins.right)),
              Math.max(1, this.containerSize.y - (this._margins.top + this._margins.bottom))
            );
          },
          update: function() {
            var _this = this;
            this._adjustCenterSpringsForZoomPoint(function() {
              _this.zoomSpring.update();
            });
            this.centerSpringX.update();
            this.centerSpringY.update();
            var changed = this.centerSpringX.current.value !== this._oldCenterX || this.centerSpringY.current.value !== this._oldCenterY || this.zoomSpring.current.value !== this._oldZoom;
            this._oldCenterX = this.centerSpringX.current.value;
            this._oldCenterY = this.centerSpringY.current.value;
            this._oldZoom = this.zoomSpring.current.value;
            return changed;
          },
          _adjustCenterSpringsForZoomPoint: function(zoomSpringHandler) {
            if (this.zoomPoint) {
              var oldZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
              zoomSpringHandler();
              var newZoomPixel = this.pixelFromPoint(this.zoomPoint, true);
              var deltaZoomPixels = newZoomPixel.minus(oldZoomPixel);
              var deltaZoomPoints = this.deltaPointsFromPixels(
                deltaZoomPixels,
                true
              );
              this.centerSpringX.shiftBy(deltaZoomPoints.x);
              this.centerSpringY.shiftBy(deltaZoomPoints.y);
              if (this.zoomSpring.isAtTargetValue()) {
                this.zoomPoint = null;
              }
            } else {
              zoomSpringHandler();
            }
          },
          deltaPixelsFromPointsNoRotate: function(deltaPoints, current) {
            return deltaPoints.times(
              this._containerInnerSize.x * this.getZoom(current)
            );
          },
          deltaPixelsFromPoints: function(deltaPoints, current) {
            return this.deltaPixelsFromPointsNoRotate(
              deltaPoints.rotate(this.getRotation()),
              current
            );
          },
          deltaPointsFromPixelsNoRotate: function(deltaPixels, current) {
            return deltaPixels.divide(
              this._containerInnerSize.x * this.getZoom(current)
            );
          },
          deltaPointsFromPixels: function(deltaPixels, current) {
            return this.deltaPointsFromPixelsNoRotate(deltaPixels, current).rotate(-this.getRotation());
          },
          pixelFromPointNoRotate: function(point, current) {
            return this._pixelFromPointNoRotate(
              point,
              this.getBoundsNoRotate(current)
            );
          },
          pixelFromPoint: function(point, current) {
            return this._pixelFromPoint(point, this.getBoundsNoRotate(current));
          },
          _pixelFromPointNoRotate: function(point, bounds) {
            return point.minus(
              bounds.getTopLeft()
            ).times(
              this._containerInnerSize.x / bounds.width
            ).plus(
              new $3.Point(this._margins.left, this._margins.top)
            );
          },
          _pixelFromPoint: function(point, bounds) {
            return this._pixelFromPointNoRotate(
              point.rotate(this.getRotation(), this.getCenter(true)),
              bounds
            );
          },
          pointFromPixelNoRotate: function(pixel, current) {
            var bounds = this.getBoundsNoRotate(current);
            return pixel.minus(
              new $3.Point(this._margins.left, this._margins.top)
            ).divide(
              this._containerInnerSize.x / bounds.width
            ).plus(
              bounds.getTopLeft()
            );
          },
          pointFromPixel: function(pixel, current) {
            return this.pointFromPixelNoRotate(pixel, current).rotate(
              -this.getRotation(),
              this.getCenter(true)
            );
          },
          _viewportToImageDelta: function(viewerX, viewerY) {
            var scale = this._contentBoundsNoRotate.width;
            return new $3.Point(
              viewerX * this._contentSizeNoRotate.x / scale,
              viewerY * this._contentSizeNoRotate.x / scale
            );
          },
          viewportToImageCoordinates: function(viewerX, viewerY) {
            if (viewerX instanceof $3.Point) {
              return this.viewportToImageCoordinates(viewerX.x, viewerX.y);
            }
            if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                $3.console.error("[Viewport.viewportToImageCoordinates] is not accurate with multi-image; use TiledImage.viewportToImageCoordinates instead.");
              } else if (count === 1) {
                var item = this.viewer.world.getItemAt(0);
                return item.viewportToImageCoordinates(viewerX, viewerY, true);
              }
            }
            return this._viewportToImageDelta(
              viewerX - this._contentBoundsNoRotate.x,
              viewerY - this._contentBoundsNoRotate.y
            );
          },
          _imageToViewportDelta: function(imageX, imageY) {
            var scale = this._contentBoundsNoRotate.width;
            return new $3.Point(
              imageX / this._contentSizeNoRotate.x * scale,
              imageY / this._contentSizeNoRotate.x * scale
            );
          },
          imageToViewportCoordinates: function(imageX, imageY) {
            if (imageX instanceof $3.Point) {
              return this.imageToViewportCoordinates(imageX.x, imageX.y);
            }
            if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                $3.console.error("[Viewport.imageToViewportCoordinates] is not accurate with multi-image; use TiledImage.imageToViewportCoordinates instead.");
              } else if (count === 1) {
                var item = this.viewer.world.getItemAt(0);
                return item.imageToViewportCoordinates(imageX, imageY, true);
              }
            }
            var point = this._imageToViewportDelta(imageX, imageY);
            point.x += this._contentBoundsNoRotate.x;
            point.y += this._contentBoundsNoRotate.y;
            return point;
          },
          imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight) {
            var rect = imageX;
            if (!(rect instanceof $3.Rect)) {
              rect = new $3.Rect(imageX, imageY, pixelWidth, pixelHeight);
            }
            if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                $3.console.error("[Viewport.imageToViewportRectangle] is not accurate with multi-image; use TiledImage.imageToViewportRectangle instead.");
              } else if (count === 1) {
                var item = this.viewer.world.getItemAt(0);
                return item.imageToViewportRectangle(
                  imageX,
                  imageY,
                  pixelWidth,
                  pixelHeight,
                  true
                );
              }
            }
            var coordA = this.imageToViewportCoordinates(rect.x, rect.y);
            var coordB = this._imageToViewportDelta(rect.width, rect.height);
            return new $3.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees
            );
          },
          viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight) {
            var rect = viewerX;
            if (!(rect instanceof $3.Rect)) {
              rect = new $3.Rect(viewerX, viewerY, pointWidth, pointHeight);
            }
            if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                $3.console.error("[Viewport.viewportToImageRectangle] is not accurate with multi-image; use TiledImage.viewportToImageRectangle instead.");
              } else if (count === 1) {
                var item = this.viewer.world.getItemAt(0);
                return item.viewportToImageRectangle(
                  viewerX,
                  viewerY,
                  pointWidth,
                  pointHeight,
                  true
                );
              }
            }
            var coordA = this.viewportToImageCoordinates(rect.x, rect.y);
            var coordB = this._viewportToImageDelta(rect.width, rect.height);
            return new $3.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees
            );
          },
          viewerElementToImageCoordinates: function(pixel) {
            var point = this.pointFromPixel(pixel, true);
            return this.viewportToImageCoordinates(point);
          },
          imageToViewerElementCoordinates: function(pixel) {
            var point = this.imageToViewportCoordinates(pixel);
            return this.pixelFromPoint(point, true);
          },
          windowToImageCoordinates: function(pixel) {
            $3.console.assert(
              this.viewer,
              "[Viewport.windowToImageCoordinates] the viewport must have a viewer."
            );
            var viewerCoordinates = pixel.minus(
              $3.getElementPosition(this.viewer.element)
            );
            return this.viewerElementToImageCoordinates(viewerCoordinates);
          },
          imageToWindowCoordinates: function(pixel) {
            $3.console.assert(
              this.viewer,
              "[Viewport.imageToWindowCoordinates] the viewport must have a viewer."
            );
            var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
            return viewerCoordinates.plus(
              $3.getElementPosition(this.viewer.element)
            );
          },
          viewerElementToViewportCoordinates: function(pixel) {
            return this.pointFromPixel(pixel, true);
          },
          viewportToViewerElementCoordinates: function(point) {
            return this.pixelFromPoint(point, true);
          },
          viewerElementToViewportRectangle: function(rectangle) {
            return $3.Rect.fromSummits(
              this.pointFromPixel(rectangle.getTopLeft(), true),
              this.pointFromPixel(rectangle.getTopRight(), true),
              this.pointFromPixel(rectangle.getBottomLeft(), true)
            );
          },
          viewportToViewerElementRectangle: function(rectangle) {
            return $3.Rect.fromSummits(
              this.pixelFromPoint(rectangle.getTopLeft(), true),
              this.pixelFromPoint(rectangle.getTopRight(), true),
              this.pixelFromPoint(rectangle.getBottomLeft(), true)
            );
          },
          windowToViewportCoordinates: function(pixel) {
            $3.console.assert(
              this.viewer,
              "[Viewport.windowToViewportCoordinates] the viewport must have a viewer."
            );
            var viewerCoordinates = pixel.minus(
              $3.getElementPosition(this.viewer.element)
            );
            return this.viewerElementToViewportCoordinates(viewerCoordinates);
          },
          viewportToWindowCoordinates: function(point) {
            $3.console.assert(
              this.viewer,
              "[Viewport.viewportToWindowCoordinates] the viewport must have a viewer."
            );
            var viewerCoordinates = this.viewportToViewerElementCoordinates(point);
            return viewerCoordinates.plus(
              $3.getElementPosition(this.viewer.element)
            );
          },
          viewportToImageZoom: function(viewportZoom) {
            if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                $3.console.error("[Viewport.viewportToImageZoom] is not accurate with multi-image.");
              } else if (count === 1) {
                var item = this.viewer.world.getItemAt(0);
                return item.viewportToImageZoom(viewportZoom);
              }
            }
            var imageWidth = this._contentSizeNoRotate.x;
            var containerWidth = this._containerInnerSize.x;
            var scale = this._contentBoundsNoRotate.width;
            var viewportToImageZoomRatio = containerWidth / imageWidth * scale;
            return viewportZoom * viewportToImageZoomRatio;
          },
          imageToViewportZoom: function(imageZoom) {
            if (this.viewer) {
              var count = this.viewer.world.getItemCount();
              if (count > 1) {
                $3.console.error("[Viewport.imageToViewportZoom] is not accurate with multi-image.");
              } else if (count === 1) {
                var item = this.viewer.world.getItemAt(0);
                return item.imageToViewportZoom(imageZoom);
              }
            }
            var imageWidth = this._contentSizeNoRotate.x;
            var containerWidth = this._containerInnerSize.x;
            var scale = this._contentBoundsNoRotate.width;
            var viewportToImageZoomRatio = imageWidth / containerWidth / scale;
            return imageZoom * viewportToImageZoomRatio;
          },
          toggleFlip: function() {
            this.setFlip(!this.getFlip());
            return this;
          },
          getFlip: function() {
            return this.flipped;
          },
          setFlip: function(state) {
            if (this.flipped === state) {
              return this;
            }
            this.flipped = state;
            if (this.viewer.navigator) {
              this.viewer.navigator.setFlip(this.getFlip());
            }
            this.viewer.forceRedraw();
            this.viewer.raiseEvent("flip", { "flipped": state });
            return this;
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.TiledImage = function(options) {
          var _this = this;
          $3.console.assert(options.tileCache, "[TiledImage] options.tileCache is required");
          $3.console.assert(options.drawer, "[TiledImage] options.drawer is required");
          $3.console.assert(options.viewer, "[TiledImage] options.viewer is required");
          $3.console.assert(options.imageLoader, "[TiledImage] options.imageLoader is required");
          $3.console.assert(options.source, "[TiledImage] options.source is required");
          $3.console.assert(
            !options.clip || options.clip instanceof $3.Rect,
            "[TiledImage] options.clip must be an OpenSeadragon.Rect if present"
          );
          $3.EventSource.call(this);
          this._tileCache = options.tileCache;
          delete options.tileCache;
          this._drawer = options.drawer;
          delete options.drawer;
          this._imageLoader = options.imageLoader;
          delete options.imageLoader;
          if (options.clip instanceof $3.Rect) {
            this._clip = options.clip.clone();
          }
          delete options.clip;
          var x2 = options.x || 0;
          delete options.x;
          var y2 = options.y || 0;
          delete options.y;
          this.normHeight = options.source.dimensions.y / options.source.dimensions.x;
          this.contentAspectX = options.source.dimensions.x / options.source.dimensions.y;
          var scale = 1;
          if (options.width) {
            scale = options.width;
            delete options.width;
            if (options.height) {
              $3.console.error("specifying both width and height to a tiledImage is not supported");
              delete options.height;
            }
          } else if (options.height) {
            scale = options.height / this.normHeight;
            delete options.height;
          }
          var fitBounds = options.fitBounds;
          delete options.fitBounds;
          var fitBoundsPlacement = options.fitBoundsPlacement || OpenSeadragon.Placement.CENTER;
          delete options.fitBoundsPlacement;
          var degrees = options.degrees || 0;
          delete options.degrees;
          $3.extend(true, this, {
            viewer: null,
            tilesMatrix: {},
            coverage: {},
            loadingCoverage: {},
            lastDrawn: [],
            lastResetTime: 0,
            _midDraw: false,
            _needsDraw: true,
            _hasOpaqueTile: false,
            _tilesLoading: 0,
            springStiffness: $3.DEFAULT_SETTINGS.springStiffness,
            animationTime: $3.DEFAULT_SETTINGS.animationTime,
            minZoomImageRatio: $3.DEFAULT_SETTINGS.minZoomImageRatio,
            wrapHorizontal: $3.DEFAULT_SETTINGS.wrapHorizontal,
            wrapVertical: $3.DEFAULT_SETTINGS.wrapVertical,
            immediateRender: $3.DEFAULT_SETTINGS.immediateRender,
            blendTime: $3.DEFAULT_SETTINGS.blendTime,
            alwaysBlend: $3.DEFAULT_SETTINGS.alwaysBlend,
            minPixelRatio: $3.DEFAULT_SETTINGS.minPixelRatio,
            smoothTileEdgesMinZoom: $3.DEFAULT_SETTINGS.smoothTileEdgesMinZoom,
            iOSDevice: $3.DEFAULT_SETTINGS.iOSDevice,
            debugMode: $3.DEFAULT_SETTINGS.debugMode,
            crossOriginPolicy: $3.DEFAULT_SETTINGS.crossOriginPolicy,
            ajaxWithCredentials: $3.DEFAULT_SETTINGS.ajaxWithCredentials,
            placeholderFillStyle: $3.DEFAULT_SETTINGS.placeholderFillStyle,
            opacity: $3.DEFAULT_SETTINGS.opacity,
            preload: $3.DEFAULT_SETTINGS.preload,
            compositeOperation: $3.DEFAULT_SETTINGS.compositeOperation
          }, options);
          this._preload = this.preload;
          delete this.preload;
          this._fullyLoaded = false;
          this._xSpring = new $3.Spring({
            initial: x2,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
          });
          this._ySpring = new $3.Spring({
            initial: y2,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
          });
          this._scaleSpring = new $3.Spring({
            initial: scale,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
          });
          this._degreesSpring = new $3.Spring({
            initial: degrees,
            springStiffness: this.springStiffness,
            animationTime: this.animationTime
          });
          this._updateForScale();
          if (fitBounds) {
            this.fitBounds(fitBounds, fitBoundsPlacement, true);
          }
          this._drawingHandler = function(args) {
            _this.viewer.raiseEvent("tile-drawing", $3.extend({
              tiledImage: _this
            }, args));
          };
        };
        $3.extend($3.TiledImage.prototype, $3.EventSource.prototype, {
          needsDraw: function() {
            return this._needsDraw;
          },
          getFullyLoaded: function() {
            return this._fullyLoaded;
          },
          _setFullyLoaded: function(flag) {
            if (flag === this._fullyLoaded) {
              return;
            }
            this._fullyLoaded = flag;
            this.raiseEvent("fully-loaded-change", {
              fullyLoaded: this._fullyLoaded
            });
          },
          reset: function() {
            this._tileCache.clearTilesFor(this);
            this.lastResetTime = $3.now();
            this._needsDraw = true;
          },
          update: function() {
            var xUpdated = this._xSpring.update();
            var yUpdated = this._ySpring.update();
            var scaleUpdated = this._scaleSpring.update();
            var degreesUpdated = this._degreesSpring.update();
            if (xUpdated || yUpdated || scaleUpdated || degreesUpdated) {
              this._updateForScale();
              this._needsDraw = true;
              return true;
            }
            return false;
          },
          draw: function() {
            if (this.opacity !== 0 || this._preload) {
              this._midDraw = true;
              this._updateViewport();
              this._midDraw = false;
            } else {
              this._needsDraw = false;
            }
          },
          destroy: function() {
            this.reset();
          },
          getBounds: function(current) {
            return this.getBoundsNoRotate(current).rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          getBoundsNoRotate: function(current) {
            return current ? new $3.Rect(
              this._xSpring.current.value,
              this._ySpring.current.value,
              this._worldWidthCurrent,
              this._worldHeightCurrent
            ) : new $3.Rect(
              this._xSpring.target.value,
              this._ySpring.target.value,
              this._worldWidthTarget,
              this._worldHeightTarget
            );
          },
          getWorldBounds: function() {
            $3.console.error("[TiledImage.getWorldBounds] is deprecated; use TiledImage.getBounds instead");
            return this.getBounds();
          },
          getClippedBounds: function(current) {
            var bounds = this.getBoundsNoRotate(current);
            if (this._clip) {
              var worldWidth = current ? this._worldWidthCurrent : this._worldWidthTarget;
              var ratio = worldWidth / this.source.dimensions.x;
              var clip = this._clip.times(ratio);
              bounds = new $3.Rect(
                bounds.x + clip.x,
                bounds.y + clip.y,
                clip.width,
                clip.height
              );
            }
            return bounds.rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          getContentSize: function() {
            return new $3.Point(this.source.dimensions.x, this.source.dimensions.y);
          },
          _viewportToImageDelta: function(viewerX, viewerY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $3.Point(
              viewerX * (this.source.dimensions.x / scale),
              viewerY * (this.source.dimensions.y * this.contentAspectX / scale)
            );
          },
          viewportToImageCoordinates: function(viewerX, viewerY, current) {
            var point;
            if (viewerX instanceof $3.Point) {
              current = viewerY;
              point = viewerX;
            } else {
              point = new $3.Point(viewerX, viewerY);
            }
            point = point.rotate(-this.getRotation(current), this._getRotationPoint(current));
            return current ? this._viewportToImageDelta(
              point.x - this._xSpring.current.value,
              point.y - this._ySpring.current.value
            ) : this._viewportToImageDelta(
              point.x - this._xSpring.target.value,
              point.y - this._ySpring.target.value
            );
          },
          _imageToViewportDelta: function(imageX, imageY, current) {
            var scale = current ? this._scaleSpring.current.value : this._scaleSpring.target.value;
            return new $3.Point(
              imageX / this.source.dimensions.x * scale,
              imageY / this.source.dimensions.y / this.contentAspectX * scale
            );
          },
          imageToViewportCoordinates: function(imageX, imageY, current) {
            if (imageX instanceof $3.Point) {
              current = imageY;
              imageY = imageX.y;
              imageX = imageX.x;
            }
            var point = this._imageToViewportDelta(imageX, imageY);
            if (current) {
              point.x += this._xSpring.current.value;
              point.y += this._ySpring.current.value;
            } else {
              point.x += this._xSpring.target.value;
              point.y += this._ySpring.target.value;
            }
            return point.rotate(this.getRotation(current), this._getRotationPoint(current));
          },
          imageToViewportRectangle: function(imageX, imageY, pixelWidth, pixelHeight, current) {
            var rect = imageX;
            if (rect instanceof $3.Rect) {
              current = imageY;
            } else {
              rect = new $3.Rect(imageX, imageY, pixelWidth, pixelHeight);
            }
            var coordA = this.imageToViewportCoordinates(rect.getTopLeft(), current);
            var coordB = this._imageToViewportDelta(rect.width, rect.height, current);
            return new $3.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees + this.getRotation(current)
            );
          },
          viewportToImageRectangle: function(viewerX, viewerY, pointWidth, pointHeight, current) {
            var rect = viewerX;
            if (viewerX instanceof $3.Rect) {
              current = viewerY;
            } else {
              rect = new $3.Rect(viewerX, viewerY, pointWidth, pointHeight);
            }
            var coordA = this.viewportToImageCoordinates(rect.getTopLeft(), current);
            var coordB = this._viewportToImageDelta(rect.width, rect.height, current);
            return new $3.Rect(
              coordA.x,
              coordA.y,
              coordB.x,
              coordB.y,
              rect.degrees - this.getRotation(current)
            );
          },
          viewerElementToImageCoordinates: function(pixel) {
            var point = this.viewport.pointFromPixel(pixel, true);
            return this.viewportToImageCoordinates(point);
          },
          imageToViewerElementCoordinates: function(pixel) {
            var point = this.imageToViewportCoordinates(pixel);
            return this.viewport.pixelFromPoint(point, true);
          },
          windowToImageCoordinates: function(pixel) {
            var viewerCoordinates = pixel.minus(
              OpenSeadragon.getElementPosition(this.viewer.element)
            );
            return this.viewerElementToImageCoordinates(viewerCoordinates);
          },
          imageToWindowCoordinates: function(pixel) {
            var viewerCoordinates = this.imageToViewerElementCoordinates(pixel);
            return viewerCoordinates.plus(
              OpenSeadragon.getElementPosition(this.viewer.element)
            );
          },
          _viewportToTiledImageRectangle: function(rect) {
            var scale = this._scaleSpring.current.value;
            rect = rect.rotate(-this.getRotation(true), this._getRotationPoint(true));
            return new $3.Rect(
              (rect.x - this._xSpring.current.value) / scale,
              (rect.y - this._ySpring.current.value) / scale,
              rect.width / scale,
              rect.height / scale,
              rect.degrees
            );
          },
          viewportToImageZoom: function(viewportZoom) {
            var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return ratio * viewportZoom;
          },
          imageToViewportZoom: function(imageZoom) {
            var ratio = this._scaleSpring.current.value * this.viewport._containerInnerSize.x / this.source.dimensions.x;
            return imageZoom / ratio;
          },
          setPosition: function(position, immediately) {
            var sameTarget = this._xSpring.target.value === position.x && this._ySpring.target.value === position.y;
            if (immediately) {
              if (sameTarget && this._xSpring.current.value === position.x && this._ySpring.current.value === position.y) {
                return;
              }
              this._xSpring.resetTo(position.x);
              this._ySpring.resetTo(position.y);
              this._needsDraw = true;
            } else {
              if (sameTarget) {
                return;
              }
              this._xSpring.springTo(position.x);
              this._ySpring.springTo(position.y);
              this._needsDraw = true;
            }
            if (!sameTarget) {
              this._raiseBoundsChange();
            }
          },
          setWidth: function(width, immediately) {
            this._setScale(width, immediately);
          },
          setHeight: function(height, immediately) {
            this._setScale(height / this.normHeight, immediately);
          },
          setCroppingPolygons: function(polygons) {
            var isXYObject = function(obj) {
              return obj instanceof $3.Point || typeof obj.x === "number" && typeof obj.y === "number";
            };
            var objectToSimpleXYObject = function(objs) {
              return objs.map(function(obj) {
                try {
                  if (isXYObject(obj)) {
                    return { x: obj.x, y: obj.y };
                  } else {
                    throw new Error();
                  }
                } catch (e3) {
                  throw new Error("A Provided cropping polygon point is not supported");
                }
              });
            };
            try {
              if (!$3.isArray(polygons)) {
                throw new Error("Provided cropping polygon is not an array");
              }
              this._croppingPolygons = polygons.map(function(polygon) {
                return objectToSimpleXYObject(polygon);
              });
            } catch (e3) {
              $3.console.error("[TiledImage.setCroppingPolygons] Cropping polygon format not supported");
              $3.console.error(e3);
              this._croppingPolygons = null;
            }
          },
          resetCroppingPolygons: function() {
            this._croppingPolygons = null;
          },
          fitBounds: function(bounds, anchor, immediately) {
            anchor = anchor || $3.Placement.CENTER;
            var anchorProperties = $3.Placement.properties[anchor];
            var aspectRatio = this.contentAspectX;
            var xOffset = 0;
            var yOffset = 0;
            var displayedWidthRatio = 1;
            var displayedHeightRatio = 1;
            if (this._clip) {
              aspectRatio = this._clip.getAspectRatio();
              displayedWidthRatio = this._clip.width / this.source.dimensions.x;
              displayedHeightRatio = this._clip.height / this.source.dimensions.y;
              if (bounds.getAspectRatio() > aspectRatio) {
                xOffset = this._clip.x / this._clip.height * bounds.height;
                yOffset = this._clip.y / this._clip.height * bounds.height;
              } else {
                xOffset = this._clip.x / this._clip.width * bounds.width;
                yOffset = this._clip.y / this._clip.width * bounds.width;
              }
            }
            if (bounds.getAspectRatio() > aspectRatio) {
              var height = bounds.height / displayedHeightRatio;
              var marginLeft = 0;
              if (anchorProperties.isHorizontallyCentered) {
                marginLeft = (bounds.width - bounds.height * aspectRatio) / 2;
              } else if (anchorProperties.isRight) {
                marginLeft = bounds.width - bounds.height * aspectRatio;
              }
              this.setPosition(
                new $3.Point(bounds.x - xOffset + marginLeft, bounds.y - yOffset),
                immediately
              );
              this.setHeight(height, immediately);
            } else {
              var width = bounds.width / displayedWidthRatio;
              var marginTop = 0;
              if (anchorProperties.isVerticallyCentered) {
                marginTop = (bounds.height - bounds.width / aspectRatio) / 2;
              } else if (anchorProperties.isBottom) {
                marginTop = bounds.height - bounds.width / aspectRatio;
              }
              this.setPosition(
                new $3.Point(bounds.x - xOffset, bounds.y - yOffset + marginTop),
                immediately
              );
              this.setWidth(width, immediately);
            }
          },
          getClip: function() {
            if (this._clip) {
              return this._clip.clone();
            }
            return null;
          },
          setClip: function(newClip) {
            $3.console.assert(
              !newClip || newClip instanceof $3.Rect,
              "[TiledImage.setClip] newClip must be an OpenSeadragon.Rect or null"
            );
            if (newClip instanceof $3.Rect) {
              this._clip = newClip.clone();
            } else {
              this._clip = null;
            }
            this._needsDraw = true;
            this.raiseEvent("clip-change");
          },
          getOpacity: function() {
            return this.opacity;
          },
          setOpacity: function(opacity) {
            if (opacity === this.opacity) {
              return;
            }
            this.opacity = opacity;
            this._needsDraw = true;
            this.raiseEvent("opacity-change", {
              opacity: this.opacity
            });
          },
          getPreload: function() {
            return this._preload;
          },
          setPreload: function(preload) {
            this._preload = !!preload;
            this._needsDraw = true;
          },
          getRotation: function(current) {
            return current ? this._degreesSpring.current.value : this._degreesSpring.target.value;
          },
          setRotation: function(degrees, immediately) {
            if (this._degreesSpring.target.value === degrees && this._degreesSpring.isAtTargetValue()) {
              return;
            }
            if (immediately) {
              this._degreesSpring.resetTo(degrees);
            } else {
              this._degreesSpring.springTo(degrees);
            }
            this._needsDraw = true;
            this._raiseBoundsChange();
          },
          _getRotationPoint: function(current) {
            return this.getBoundsNoRotate(current).getCenter();
          },
          getCompositeOperation: function() {
            return this.compositeOperation;
          },
          setCompositeOperation: function(compositeOperation) {
            if (compositeOperation === this.compositeOperation) {
              return;
            }
            this.compositeOperation = compositeOperation;
            this._needsDraw = true;
            this.raiseEvent("composite-operation-change", {
              compositeOperation: this.compositeOperation
            });
          },
          _setScale: function(scale, immediately) {
            var sameTarget = this._scaleSpring.target.value === scale;
            if (immediately) {
              if (sameTarget && this._scaleSpring.current.value === scale) {
                return;
              }
              this._scaleSpring.resetTo(scale);
              this._updateForScale();
              this._needsDraw = true;
            } else {
              if (sameTarget) {
                return;
              }
              this._scaleSpring.springTo(scale);
              this._updateForScale();
              this._needsDraw = true;
            }
            if (!sameTarget) {
              this._raiseBoundsChange();
            }
          },
          _updateForScale: function() {
            this._worldWidthTarget = this._scaleSpring.target.value;
            this._worldHeightTarget = this.normHeight * this._scaleSpring.target.value;
            this._worldWidthCurrent = this._scaleSpring.current.value;
            this._worldHeightCurrent = this.normHeight * this._scaleSpring.current.value;
          },
          _raiseBoundsChange: function() {
            this.raiseEvent("bounds-change");
          },
          _isBottomItem: function() {
            return this.viewer.world.getItemAt(0) === this;
          },
          _getLevelsInterval: function() {
            var lowestLevel = Math.max(
              this.source.minLevel,
              Math.floor(Math.log(this.minZoomImageRatio) / Math.log(2))
            );
            var currentZeroRatio = this.viewport.deltaPixelsFromPointsNoRotate(
              this.source.getPixelRatio(0),
              true
            ).x * this._scaleSpring.current.value;
            var highestLevel = Math.min(
              Math.abs(this.source.maxLevel),
              Math.abs(Math.floor(
                Math.log(currentZeroRatio / this.minPixelRatio) / Math.log(2)
              ))
            );
            highestLevel = Math.max(highestLevel, this.source.minLevel || 0);
            lowestLevel = Math.min(lowestLevel, highestLevel);
            return {
              lowestLevel,
              highestLevel
            };
          },
          _updateViewport: function() {
            this._needsDraw = false;
            this._tilesLoading = 0;
            this.loadingCoverage = {};
            while (this.lastDrawn.length > 0) {
              var tile = this.lastDrawn.pop();
              tile.beingDrawn = false;
            }
            var viewport = this.viewport;
            var drawArea = this._viewportToTiledImageRectangle(
              viewport.getBoundsWithMargins(true)
            );
            if (!this.wrapHorizontal && !this.wrapVertical) {
              var tiledImageBounds = this._viewportToTiledImageRectangle(
                this.getClippedBounds(true)
              );
              drawArea = drawArea.intersection(tiledImageBounds);
              if (drawArea === null) {
                return;
              }
            }
            var levelsInterval = this._getLevelsInterval();
            var lowestLevel = levelsInterval.lowestLevel;
            var highestLevel = levelsInterval.highestLevel;
            var bestTile = null;
            var haveDrawn = false;
            var currentTime = $3.now();
            for (var level = highestLevel; level >= lowestLevel; level--) {
              var drawLevel = false;
              var currentRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(level),
                true
              ).x * this._scaleSpring.current.value;
              if (level === lowestLevel || !haveDrawn && currentRenderPixelRatio >= this.minPixelRatio) {
                drawLevel = true;
                haveDrawn = true;
              } else if (!haveDrawn) {
                continue;
              }
              var targetRenderPixelRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(level),
                false
              ).x * this._scaleSpring.current.value;
              var targetZeroRatio = viewport.deltaPixelsFromPointsNoRotate(
                this.source.getPixelRatio(
                  Math.max(
                    this.source.getClosestLevel(),
                    0
                  )
                ),
                false
              ).x * this._scaleSpring.current.value;
              var optimalRatio = this.immediateRender ? 1 : targetZeroRatio;
              var levelOpacity = Math.min(1, (currentRenderPixelRatio - 0.5) / 0.5);
              var levelVisibility = optimalRatio / Math.abs(
                optimalRatio - targetRenderPixelRatio
              );
              bestTile = updateLevel(
                this,
                haveDrawn,
                drawLevel,
                level,
                levelOpacity,
                levelVisibility,
                drawArea,
                currentTime,
                bestTile
              );
              if (providesCoverage(this.coverage, level)) {
                break;
              }
            }
            drawTiles(this, this.lastDrawn);
            if (bestTile && !bestTile.context2D) {
              loadTile(this, bestTile, currentTime);
              this._needsDraw = true;
              this._setFullyLoaded(false);
            } else {
              this._setFullyLoaded(this._tilesLoading === 0);
            }
          },
          _getCornerTiles: function(level, topLeftBound, bottomRightBound) {
            var leftX;
            var rightX;
            if (this.wrapHorizontal) {
              leftX = $3.positiveModulo(topLeftBound.x, 1);
              rightX = $3.positiveModulo(bottomRightBound.x, 1);
            } else {
              leftX = Math.max(0, topLeftBound.x);
              rightX = Math.min(1, bottomRightBound.x);
            }
            var topY;
            var bottomY;
            var aspectRatio = 1 / this.source.aspectRatio;
            if (this.wrapVertical) {
              topY = $3.positiveModulo(topLeftBound.y, aspectRatio);
              bottomY = $3.positiveModulo(bottomRightBound.y, aspectRatio);
            } else {
              topY = Math.max(0, topLeftBound.y);
              bottomY = Math.min(aspectRatio, bottomRightBound.y);
            }
            var topLeftTile = this.source.getTileAtPoint(level, new $3.Point(leftX, topY));
            var bottomRightTile = this.source.getTileAtPoint(level, new $3.Point(rightX, bottomY));
            var numTiles = this.source.getNumTiles(level);
            if (this.wrapHorizontal) {
              topLeftTile.x += numTiles.x * Math.floor(topLeftBound.x);
              bottomRightTile.x += numTiles.x * Math.floor(bottomRightBound.x);
            }
            if (this.wrapVertical) {
              topLeftTile.y += numTiles.y * Math.floor(topLeftBound.y / aspectRatio);
              bottomRightTile.y += numTiles.y * Math.floor(bottomRightBound.y / aspectRatio);
            }
            return {
              topLeft: topLeftTile,
              bottomRight: bottomRightTile
            };
          }
        });
        function updateLevel(tiledImage, haveDrawn, drawLevel, level, levelOpacity, levelVisibility, drawArea, currentTime, best) {
          var topLeftBound = drawArea.getBoundingBox().getTopLeft();
          var bottomRightBound = drawArea.getBoundingBox().getBottomRight();
          if (tiledImage.viewer) {
            tiledImage.viewer.raiseEvent("update-level", {
              tiledImage,
              havedrawn: haveDrawn,
              level,
              opacity: levelOpacity,
              visibility: levelVisibility,
              drawArea,
              topleft: topLeftBound,
              bottomright: bottomRightBound,
              currenttime: currentTime,
              best
            });
          }
          resetCoverage(tiledImage.coverage, level);
          resetCoverage(tiledImage.loadingCoverage, level);
          var cornerTiles = tiledImage._getCornerTiles(level, topLeftBound, bottomRightBound);
          var topLeftTile = cornerTiles.topLeft;
          var bottomRightTile = cornerTiles.bottomRight;
          var numberOfTiles = tiledImage.source.getNumTiles(level);
          var viewportCenter = tiledImage.viewport.pixelFromPoint(
            tiledImage.viewport.getCenter()
          );
          for (var x2 = topLeftTile.x; x2 <= bottomRightTile.x; x2++) {
            for (var y2 = topLeftTile.y; y2 <= bottomRightTile.y; y2++) {
              if (!tiledImage.wrapHorizontal && !tiledImage.wrapVertical) {
                var tileBounds = tiledImage.source.getTileBounds(level, x2, y2);
                if (drawArea.intersection(tileBounds) === null) {
                  continue;
                }
              }
              best = updateTile(
                tiledImage,
                drawLevel,
                haveDrawn,
                x2,
                y2,
                level,
                levelOpacity,
                levelVisibility,
                viewportCenter,
                numberOfTiles,
                currentTime,
                best
              );
            }
          }
          return best;
        }
        function updateTile(tiledImage, haveDrawn, drawLevel, x2, y2, level, levelOpacity, levelVisibility, viewportCenter, numberOfTiles, currentTime, best) {
          var tile = getTile(
            x2,
            y2,
            level,
            tiledImage,
            tiledImage.source,
            tiledImage.tilesMatrix,
            currentTime,
            numberOfTiles,
            tiledImage._worldWidthCurrent,
            tiledImage._worldHeightCurrent
          ), drawTile = drawLevel;
          if (tiledImage.viewer) {
            tiledImage.viewer.raiseEvent("update-tile", {
              tiledImage,
              tile
            });
          }
          setCoverage(tiledImage.coverage, level, x2, y2, false);
          var loadingCoverage = tile.loaded || tile.loading || isCovered(tiledImage.loadingCoverage, level, x2, y2);
          setCoverage(tiledImage.loadingCoverage, level, x2, y2, loadingCoverage);
          if (!tile.exists) {
            return best;
          }
          if (haveDrawn && !drawTile) {
            if (isCovered(tiledImage.coverage, level, x2, y2)) {
              setCoverage(tiledImage.coverage, level, x2, y2, true);
            } else {
              drawTile = true;
            }
          }
          if (!drawTile) {
            return best;
          }
          positionTile(
            tile,
            tiledImage.source.tileOverlap,
            tiledImage.viewport,
            viewportCenter,
            levelVisibility,
            tiledImage
          );
          if (!tile.loaded) {
            if (tile.context2D) {
              setTileLoaded(tiledImage, tile);
            } else {
              var imageRecord = tiledImage._tileCache.getImageRecord(tile.cacheKey);
              if (imageRecord) {
                var image = imageRecord.getImage();
                setTileLoaded(tiledImage, tile, image);
              }
            }
          }
          if (tile.loaded) {
            var needsDraw = blendTile(
              tiledImage,
              tile,
              x2,
              y2,
              level,
              levelOpacity,
              currentTime
            );
            if (needsDraw) {
              tiledImage._needsDraw = true;
            }
          } else if (tile.loading) {
            tiledImage._tilesLoading++;
          } else if (!loadingCoverage) {
            best = compareTiles(best, tile);
          }
          return best;
        }
        function getTile(x2, y2, level, tiledImage, tileSource, tilesMatrix, time, numTiles, worldWidth, worldHeight) {
          var xMod, yMod, bounds, sourceBounds, exists, url, ajaxHeaders, context2D, tile;
          if (!tilesMatrix[level]) {
            tilesMatrix[level] = {};
          }
          if (!tilesMatrix[level][x2]) {
            tilesMatrix[level][x2] = {};
          }
          if (!tilesMatrix[level][x2][y2]) {
            xMod = (numTiles.x + x2 % numTiles.x) % numTiles.x;
            yMod = (numTiles.y + y2 % numTiles.y) % numTiles.y;
            bounds = tileSource.getTileBounds(level, xMod, yMod);
            sourceBounds = tileSource.getTileBounds(level, xMod, yMod, true);
            exists = tileSource.tileExists(level, xMod, yMod);
            url = tileSource.getTileUrl(level, xMod, yMod);
            if (tiledImage.loadTilesWithAjax) {
              ajaxHeaders = tileSource.getTileAjaxHeaders(level, xMod, yMod);
              if ($3.isPlainObject(tiledImage.ajaxHeaders)) {
                ajaxHeaders = $3.extend({}, tiledImage.ajaxHeaders, ajaxHeaders);
              }
            } else {
              ajaxHeaders = null;
            }
            context2D = tileSource.getContext2D ? tileSource.getContext2D(level, xMod, yMod) : void 0;
            bounds.x += (x2 - xMod) / numTiles.x;
            bounds.y += worldHeight / worldWidth * ((y2 - yMod) / numTiles.y);
            tile = new $3.Tile(
              level,
              x2,
              y2,
              bounds,
              exists,
              url,
              context2D,
              tiledImage.loadTilesWithAjax,
              ajaxHeaders,
              sourceBounds
            );
            if (xMod === numTiles.x - 1) {
              tile.isRightMost = true;
            }
            if (yMod === numTiles.y - 1) {
              tile.isBottomMost = true;
            }
            tilesMatrix[level][x2][y2] = tile;
          }
          tile = tilesMatrix[level][x2][y2];
          tile.lastTouchTime = time;
          return tile;
        }
        function loadTile(tiledImage, tile, time) {
          tile.loading = true;
          tiledImage._imageLoader.addJob({
            src: tile.url,
            loadWithAjax: tile.loadWithAjax,
            ajaxHeaders: tile.ajaxHeaders,
            crossOriginPolicy: tiledImage.crossOriginPolicy,
            ajaxWithCredentials: tiledImage.ajaxWithCredentials,
            callback: function(image, errorMsg, tileRequest) {
              onTileLoad(tiledImage, tile, time, image, errorMsg, tileRequest);
            },
            abort: function() {
              tile.loading = false;
            }
          });
        }
        function onTileLoad(tiledImage, tile, time, image, errorMsg, tileRequest) {
          if (!image) {
            $3.console.log("Tile %s failed to load: %s - error: %s", tile, tile.url, errorMsg);
            tiledImage.viewer.raiseEvent("tile-load-failed", {
              tile,
              tiledImage,
              time,
              message: errorMsg,
              tileRequest
            });
            tile.loading = false;
            tile.exists = false;
            return;
          }
          if (time < tiledImage.lastResetTime) {
            $3.console.log("Ignoring tile %s loaded before reset: %s", tile, tile.url);
            tile.loading = false;
            return;
          }
          var finish = function() {
            var cutoff = tiledImage.source.getClosestLevel();
            setTileLoaded(tiledImage, tile, image, cutoff, tileRequest);
          };
          if (!tiledImage._midDraw) {
            finish();
          } else {
            window.setTimeout(finish, 1);
          }
        }
        function setTileLoaded(tiledImage, tile, image, cutoff, tileRequest) {
          var increment = 0;
          function getCompletionCallback() {
            increment++;
            return completionCallback;
          }
          function completionCallback() {
            increment--;
            if (increment === 0) {
              tile.loading = false;
              tile.loaded = true;
              if (!tile.context2D) {
                tiledImage._tileCache.cacheTile({
                  image,
                  tile,
                  cutoff,
                  tiledImage
                });
              }
              tiledImage._needsDraw = true;
            }
          }
          tiledImage.viewer.raiseEvent("tile-loaded", {
            tile,
            tiledImage,
            tileRequest,
            image,
            getCompletionCallback
          });
          getCompletionCallback()();
        }
        function positionTile(tile, overlap, viewport, viewportCenter, levelVisibility, tiledImage) {
          var boundsTL = tile.bounds.getTopLeft();
          boundsTL.x *= tiledImage._scaleSpring.current.value;
          boundsTL.y *= tiledImage._scaleSpring.current.value;
          boundsTL.x += tiledImage._xSpring.current.value;
          boundsTL.y += tiledImage._ySpring.current.value;
          var boundsSize = tile.bounds.getSize();
          boundsSize.x *= tiledImage._scaleSpring.current.value;
          boundsSize.y *= tiledImage._scaleSpring.current.value;
          var positionC = viewport.pixelFromPointNoRotate(boundsTL, true), positionT = viewport.pixelFromPointNoRotate(boundsTL, false), sizeC = viewport.deltaPixelsFromPointsNoRotate(boundsSize, true), sizeT = viewport.deltaPixelsFromPointsNoRotate(boundsSize, false), tileCenter = positionT.plus(sizeT.divide(2)), tileSquaredDistance = viewportCenter.squaredDistanceTo(tileCenter);
          if (!overlap) {
            sizeC = sizeC.plus(new $3.Point(1, 1));
          }
          if (tile.isRightMost && tiledImage.wrapHorizontal) {
            sizeC.x += 0.75;
          }
          if (tile.isBottomMost && tiledImage.wrapVertical) {
            sizeC.y += 0.75;
          }
          tile.position = positionC;
          tile.size = sizeC;
          tile.squaredDistance = tileSquaredDistance;
          tile.visibility = levelVisibility;
        }
        function blendTile(tiledImage, tile, x2, y2, level, levelOpacity, currentTime) {
          var blendTimeMillis = 1e3 * tiledImage.blendTime, deltaTime, opacity;
          if (!tile.blendStart) {
            tile.blendStart = currentTime;
          }
          deltaTime = currentTime - tile.blendStart;
          opacity = blendTimeMillis ? Math.min(1, deltaTime / blendTimeMillis) : 1;
          if (tiledImage.alwaysBlend) {
            opacity *= levelOpacity;
          }
          tile.opacity = opacity;
          tiledImage.lastDrawn.push(tile);
          if (opacity === 1) {
            setCoverage(tiledImage.coverage, level, x2, y2, true);
            tiledImage._hasOpaqueTile = true;
          } else if (deltaTime < blendTimeMillis) {
            return true;
          }
          return false;
        }
        function providesCoverage(coverage, level, x2, y2) {
          var rows, cols, i2, j3;
          if (!coverage[level]) {
            return false;
          }
          if (x2 === void 0 || y2 === void 0) {
            rows = coverage[level];
            for (i2 in rows) {
              if (Object.prototype.hasOwnProperty.call(rows, i2)) {
                cols = rows[i2];
                for (j3 in cols) {
                  if (Object.prototype.hasOwnProperty.call(cols, j3) && !cols[j3]) {
                    return false;
                  }
                }
              }
            }
            return true;
          }
          return coverage[level][x2] === void 0 || coverage[level][x2][y2] === void 0 || coverage[level][x2][y2] === true;
        }
        function isCovered(coverage, level, x2, y2) {
          if (x2 === void 0 || y2 === void 0) {
            return providesCoverage(coverage, level + 1);
          } else {
            return providesCoverage(coverage, level + 1, 2 * x2, 2 * y2) && providesCoverage(coverage, level + 1, 2 * x2, 2 * y2 + 1) && providesCoverage(coverage, level + 1, 2 * x2 + 1, 2 * y2) && providesCoverage(coverage, level + 1, 2 * x2 + 1, 2 * y2 + 1);
          }
        }
        function setCoverage(coverage, level, x2, y2, covers) {
          if (!coverage[level]) {
            $3.console.warn(
              "Setting coverage for a tile before its level's coverage has been reset: %s",
              level
            );
            return;
          }
          if (!coverage[level][x2]) {
            coverage[level][x2] = {};
          }
          coverage[level][x2][y2] = covers;
        }
        function resetCoverage(coverage, level) {
          coverage[level] = {};
        }
        function compareTiles(previousBest, tile) {
          if (!previousBest) {
            return tile;
          }
          if (tile.visibility > previousBest.visibility) {
            return tile;
          } else if (tile.visibility == previousBest.visibility) {
            if (tile.squaredDistance < previousBest.squaredDistance) {
              return tile;
            }
          }
          return previousBest;
        }
        function drawTiles(tiledImage, lastDrawn) {
          if (tiledImage.opacity === 0 || lastDrawn.length === 0 && !tiledImage.placeholderFillStyle) {
            return;
          }
          var tile = lastDrawn[0];
          var useSketch;
          if (tile) {
            useSketch = tiledImage.opacity < 1 || tiledImage.compositeOperation && tiledImage.compositeOperation !== "source-over" || !tiledImage._isBottomItem() && tile._hasTransparencyChannel();
          }
          var sketchScale;
          var sketchTranslate;
          var zoom = tiledImage.viewport.getZoom(true);
          var imageZoom = tiledImage.viewportToImageZoom(zoom);
          if (lastDrawn.length > 1 && imageZoom > tiledImage.smoothTileEdgesMinZoom && !tiledImage.iOSDevice && tiledImage.getRotation(true) % 360 === 0 && $3.supportsCanvas) {
            useSketch = true;
            sketchScale = tile.getScaleForEdgeSmoothing();
            sketchTranslate = tile.getTranslationForEdgeSmoothing(
              sketchScale,
              tiledImage._drawer.getCanvasSize(false),
              tiledImage._drawer.getCanvasSize(true)
            );
          }
          var bounds;
          if (useSketch) {
            if (!sketchScale) {
              bounds = tiledImage.viewport.viewportToViewerElementRectangle(
                tiledImage.getClippedBounds(true)
              ).getIntegerBoundingBox();
              if (tiledImage._drawer.viewer.viewport.getFlip()) {
                if (tiledImage.viewport.degrees !== 0 || tiledImage.getRotation(true) % 360 !== 0) {
                  bounds.x = tiledImage._drawer.viewer.container.clientWidth - (bounds.x + bounds.width);
                }
              }
              bounds = bounds.times($3.pixelDensityRatio);
            }
            tiledImage._drawer._clear(true, bounds);
          }
          if (!sketchScale) {
            if (tiledImage.viewport.degrees !== 0) {
              tiledImage._drawer._offsetForRotation({
                degrees: tiledImage.viewport.degrees,
                useSketch
              });
            }
            if (tiledImage.getRotation(true) % 360 !== 0) {
              tiledImage._drawer._offsetForRotation({
                degrees: tiledImage.getRotation(true),
                point: tiledImage.viewport.pixelFromPointNoRotate(
                  tiledImage._getRotationPoint(true),
                  true
                ),
                useSketch
              });
            }
            if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
              if (tiledImage._drawer.viewer.viewport.getFlip()) {
                tiledImage._drawer._flip();
              }
            }
          }
          var usedClip = false;
          if (tiledImage._clip) {
            tiledImage._drawer.saveContext(useSketch);
            var box = tiledImage.imageToViewportRectangle(tiledImage._clip, true);
            box = box.rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
            var clipRect = tiledImage._drawer.viewportToDrawerRectangle(box);
            if (sketchScale) {
              clipRect = clipRect.times(sketchScale);
            }
            if (sketchTranslate) {
              clipRect = clipRect.translate(sketchTranslate);
            }
            tiledImage._drawer.setClip(clipRect, useSketch);
            usedClip = true;
          }
          if (tiledImage._croppingPolygons) {
            tiledImage._drawer.saveContext(useSketch);
            try {
              var polygons = tiledImage._croppingPolygons.map(function(polygon) {
                return polygon.map(function(coord) {
                  var point = tiledImage.imageToViewportCoordinates(coord.x, coord.y, true).rotate(-tiledImage.getRotation(true), tiledImage._getRotationPoint(true));
                  var clipPoint = tiledImage._drawer.viewportCoordToDrawerCoord(point);
                  if (sketchScale) {
                    clipPoint = clipPoint.times(sketchScale);
                  }
                  return clipPoint;
                });
              });
              tiledImage._drawer.clipWithPolygons(polygons, useSketch);
            } catch (e3) {
              $3.console.error(e3);
            }
            usedClip = true;
          }
          if (tiledImage.placeholderFillStyle && tiledImage._hasOpaqueTile === false) {
            var placeholderRect = tiledImage._drawer.viewportToDrawerRectangle(tiledImage.getBounds(true));
            if (sketchScale) {
              placeholderRect = placeholderRect.times(sketchScale);
            }
            if (sketchTranslate) {
              placeholderRect = placeholderRect.translate(sketchTranslate);
            }
            var fillStyle = null;
            if (typeof tiledImage.placeholderFillStyle === "function") {
              fillStyle = tiledImage.placeholderFillStyle(tiledImage, tiledImage._drawer.context);
            } else {
              fillStyle = tiledImage.placeholderFillStyle;
            }
            tiledImage._drawer.drawRectangle(placeholderRect, fillStyle, useSketch);
          }
          for (var i2 = lastDrawn.length - 1; i2 >= 0; i2--) {
            tile = lastDrawn[i2];
            tiledImage._drawer.drawTile(tile, tiledImage._drawingHandler, useSketch, sketchScale, sketchTranslate);
            tile.beingDrawn = true;
            if (tiledImage.viewer) {
              tiledImage.viewer.raiseEvent("tile-drawn", {
                tiledImage,
                tile
              });
            }
          }
          if (usedClip) {
            tiledImage._drawer.restoreContext(useSketch);
          }
          if (!sketchScale) {
            if (tiledImage.getRotation(true) % 360 !== 0) {
              tiledImage._drawer._restoreRotationChanges(useSketch);
            }
            if (tiledImage.viewport.degrees !== 0) {
              tiledImage._drawer._restoreRotationChanges(useSketch);
            }
          }
          if (useSketch) {
            if (sketchScale) {
              if (tiledImage.viewport.degrees !== 0) {
                tiledImage._drawer._offsetForRotation({
                  degrees: tiledImage.viewport.degrees,
                  useSketch: false
                });
              }
              if (tiledImage.getRotation(true) % 360 !== 0) {
                tiledImage._drawer._offsetForRotation({
                  degrees: tiledImage.getRotation(true),
                  point: tiledImage.viewport.pixelFromPointNoRotate(
                    tiledImage._getRotationPoint(true),
                    true
                  ),
                  useSketch: false
                });
              }
            }
            tiledImage._drawer.blendSketch({
              opacity: tiledImage.opacity,
              scale: sketchScale,
              translate: sketchTranslate,
              compositeOperation: tiledImage.compositeOperation,
              bounds
            });
            if (sketchScale) {
              if (tiledImage.getRotation(true) % 360 !== 0) {
                tiledImage._drawer._restoreRotationChanges(false);
              }
              if (tiledImage.viewport.degrees !== 0) {
                tiledImage._drawer._restoreRotationChanges(false);
              }
            }
          }
          if (!sketchScale) {
            if (tiledImage.viewport.degrees === 0 && tiledImage.getRotation(true) % 360 === 0) {
              if (tiledImage._drawer.viewer.viewport.getFlip()) {
                tiledImage._drawer._flip();
              }
            }
          }
          drawDebugInfo(tiledImage, lastDrawn);
        }
        function drawDebugInfo(tiledImage, lastDrawn) {
          if (tiledImage.debugMode) {
            for (var i2 = lastDrawn.length - 1; i2 >= 0; i2--) {
              var tile = lastDrawn[i2];
              try {
                tiledImage._drawer.drawDebugInfo(
                  tile,
                  lastDrawn.length,
                  i2,
                  tiledImage
                );
              } catch (e3) {
                $3.console.error(e3);
              }
            }
          }
        }
      })(OpenSeadragon);
      (function($3) {
        var TileRecord = function(options) {
          $3.console.assert(options, "[TileCache.cacheTile] options is required");
          $3.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
          $3.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
          this.tile = options.tile;
          this.tiledImage = options.tiledImage;
        };
        var ImageRecord = function(options) {
          $3.console.assert(options, "[ImageRecord] options is required");
          $3.console.assert(options.image, "[ImageRecord] options.image is required");
          this._image = options.image;
          this._tiles = [];
        };
        ImageRecord.prototype = {
          destroy: function() {
            this._image = null;
            this._renderedContext = null;
            this._tiles = null;
          },
          getImage: function() {
            return this._image;
          },
          getRenderedContext: function() {
            if (!this._renderedContext) {
              var canvas = document.createElement("canvas");
              canvas.width = this._image.width;
              canvas.height = this._image.height;
              this._renderedContext = canvas.getContext("2d");
              this._renderedContext.drawImage(this._image, 0, 0);
              this._image = null;
            }
            return this._renderedContext;
          },
          setRenderedContext: function(renderedContext) {
            $3.console.error("ImageRecord.setRenderedContext is deprecated. The rendered context should be created by the ImageRecord itself when calling ImageRecord.getRenderedContext.");
            this._renderedContext = renderedContext;
          },
          addTile: function(tile) {
            $3.console.assert(tile, "[ImageRecord.addTile] tile is required");
            this._tiles.push(tile);
          },
          removeTile: function(tile) {
            for (var i2 = 0; i2 < this._tiles.length; i2++) {
              if (this._tiles[i2] === tile) {
                this._tiles.splice(i2, 1);
                return;
              }
            }
            $3.console.warn("[ImageRecord.removeTile] trying to remove unknown tile", tile);
          },
          getTileCount: function() {
            return this._tiles.length;
          }
        };
        $3.TileCache = function(options) {
          options = options || {};
          this._maxImageCacheCount = options.maxImageCacheCount || $3.DEFAULT_SETTINGS.maxImageCacheCount;
          this._tilesLoaded = [];
          this._imagesLoaded = [];
          this._imagesLoadedCount = 0;
        };
        $3.TileCache.prototype = {
          numTilesLoaded: function() {
            return this._tilesLoaded.length;
          },
          cacheTile: function(options) {
            $3.console.assert(options, "[TileCache.cacheTile] options is required");
            $3.console.assert(options.tile, "[TileCache.cacheTile] options.tile is required");
            $3.console.assert(options.tile.cacheKey, "[TileCache.cacheTile] options.tile.cacheKey is required");
            $3.console.assert(options.tiledImage, "[TileCache.cacheTile] options.tiledImage is required");
            var cutoff = options.cutoff || 0;
            var insertionIndex = this._tilesLoaded.length;
            var imageRecord = this._imagesLoaded[options.tile.cacheKey];
            if (!imageRecord) {
              $3.console.assert(options.image, "[TileCache.cacheTile] options.image is required to create an ImageRecord");
              imageRecord = this._imagesLoaded[options.tile.cacheKey] = new ImageRecord({
                image: options.image
              });
              this._imagesLoadedCount++;
            }
            imageRecord.addTile(options.tile);
            options.tile.cacheImageRecord = imageRecord;
            if (this._imagesLoadedCount > this._maxImageCacheCount) {
              var worstTile = null;
              var worstTileIndex = -1;
              var worstTileRecord = null;
              var prevTile, worstTime, worstLevel, prevTime, prevLevel, prevTileRecord;
              for (var i2 = this._tilesLoaded.length - 1; i2 >= 0; i2--) {
                prevTileRecord = this._tilesLoaded[i2];
                prevTile = prevTileRecord.tile;
                if (prevTile.level <= cutoff || prevTile.beingDrawn) {
                  continue;
                } else if (!worstTile) {
                  worstTile = prevTile;
                  worstTileIndex = i2;
                  worstTileRecord = prevTileRecord;
                  continue;
                }
                prevTime = prevTile.lastTouchTime;
                worstTime = worstTile.lastTouchTime;
                prevLevel = prevTile.level;
                worstLevel = worstTile.level;
                if (prevTime < worstTime || prevTime == worstTime && prevLevel > worstLevel) {
                  worstTile = prevTile;
                  worstTileIndex = i2;
                  worstTileRecord = prevTileRecord;
                }
              }
              if (worstTile && worstTileIndex >= 0) {
                this._unloadTile(worstTileRecord);
                insertionIndex = worstTileIndex;
              }
            }
            this._tilesLoaded[insertionIndex] = new TileRecord({
              tile: options.tile,
              tiledImage: options.tiledImage
            });
          },
          clearTilesFor: function(tiledImage) {
            $3.console.assert(tiledImage, "[TileCache.clearTilesFor] tiledImage is required");
            var tileRecord;
            for (var i2 = 0; i2 < this._tilesLoaded.length; ++i2) {
              tileRecord = this._tilesLoaded[i2];
              if (tileRecord.tiledImage === tiledImage) {
                this._unloadTile(tileRecord);
                this._tilesLoaded.splice(i2, 1);
                i2--;
              }
            }
          },
          getImageRecord: function(cacheKey) {
            $3.console.assert(cacheKey, "[TileCache.getImageRecord] cacheKey is required");
            return this._imagesLoaded[cacheKey];
          },
          _unloadTile: function(tileRecord) {
            $3.console.assert(tileRecord, "[TileCache._unloadTile] tileRecord is required");
            var tile = tileRecord.tile;
            var tiledImage = tileRecord.tiledImage;
            tile.unload();
            tile.cacheImageRecord = null;
            var imageRecord = this._imagesLoaded[tile.cacheKey];
            imageRecord.removeTile(tile);
            if (!imageRecord.getTileCount()) {
              imageRecord.destroy();
              delete this._imagesLoaded[tile.cacheKey];
              this._imagesLoadedCount--;
            }
            tiledImage.viewer.raiseEvent("tile-unloaded", {
              tile,
              tiledImage
            });
          }
        };
      })(OpenSeadragon);
      (function($3) {
        $3.World = function(options) {
          var _this = this;
          $3.console.assert(options.viewer, "[World] options.viewer is required");
          $3.EventSource.call(this);
          this.viewer = options.viewer;
          this._items = [];
          this._needsDraw = false;
          this._autoRefigureSizes = true;
          this._needsSizesFigured = false;
          this._delegatedFigureSizes = function(event) {
            if (_this._autoRefigureSizes) {
              _this._figureSizes();
            } else {
              _this._needsSizesFigured = true;
            }
          };
          this._figureSizes();
        };
        $3.extend($3.World.prototype, $3.EventSource.prototype, {
          addItem: function(item, options) {
            $3.console.assert(item, "[World.addItem] item is required");
            $3.console.assert(item instanceof $3.TiledImage, "[World.addItem] only TiledImages supported at this time");
            options = options || {};
            if (options.index !== void 0) {
              var index2 = Math.max(0, Math.min(this._items.length, options.index));
              this._items.splice(index2, 0, item);
            } else {
              this._items.push(item);
            }
            if (this._autoRefigureSizes) {
              this._figureSizes();
            } else {
              this._needsSizesFigured = true;
            }
            this._needsDraw = true;
            item.addHandler("bounds-change", this._delegatedFigureSizes);
            item.addHandler("clip-change", this._delegatedFigureSizes);
            this.raiseEvent("add-item", {
              item
            });
          },
          getItemAt: function(index2) {
            $3.console.assert(index2 !== void 0, "[World.getItemAt] index is required");
            return this._items[index2];
          },
          getIndexOfItem: function(item) {
            $3.console.assert(item, "[World.getIndexOfItem] item is required");
            return $3.indexOf(this._items, item);
          },
          getItemCount: function() {
            return this._items.length;
          },
          setItemIndex: function(item, index2) {
            $3.console.assert(item, "[World.setItemIndex] item is required");
            $3.console.assert(index2 !== void 0, "[World.setItemIndex] index is required");
            var oldIndex = this.getIndexOfItem(item);
            if (index2 >= this._items.length) {
              throw new Error("Index bigger than number of layers.");
            }
            if (index2 === oldIndex || oldIndex === -1) {
              return;
            }
            this._items.splice(oldIndex, 1);
            this._items.splice(index2, 0, item);
            this._needsDraw = true;
            this.raiseEvent("item-index-change", {
              item,
              previousIndex: oldIndex,
              newIndex: index2
            });
          },
          removeItem: function(item) {
            $3.console.assert(item, "[World.removeItem] item is required");
            var index2 = $3.indexOf(this._items, item);
            if (index2 === -1) {
              return;
            }
            item.removeHandler("bounds-change", this._delegatedFigureSizes);
            item.removeHandler("clip-change", this._delegatedFigureSizes);
            item.destroy();
            this._items.splice(index2, 1);
            this._figureSizes();
            this._needsDraw = true;
            this._raiseRemoveItem(item);
          },
          removeAll: function() {
            this.viewer._cancelPendingImages();
            var item;
            var i2;
            for (i2 = 0; i2 < this._items.length; i2++) {
              item = this._items[i2];
              item.removeHandler("bounds-change", this._delegatedFigureSizes);
              item.removeHandler("clip-change", this._delegatedFigureSizes);
              item.destroy();
            }
            var removedItems = this._items;
            this._items = [];
            this._figureSizes();
            this._needsDraw = true;
            for (i2 = 0; i2 < removedItems.length; i2++) {
              item = removedItems[i2];
              this._raiseRemoveItem(item);
            }
          },
          resetItems: function() {
            for (var i2 = 0; i2 < this._items.length; i2++) {
              this._items[i2].reset();
            }
          },
          update: function() {
            var animated = false;
            for (var i2 = 0; i2 < this._items.length; i2++) {
              animated = this._items[i2].update() || animated;
            }
            return animated;
          },
          draw: function() {
            for (var i2 = 0; i2 < this._items.length; i2++) {
              this._items[i2].draw();
            }
            this._needsDraw = false;
          },
          needsDraw: function() {
            for (var i2 = 0; i2 < this._items.length; i2++) {
              if (this._items[i2].needsDraw()) {
                return true;
              }
            }
            return this._needsDraw;
          },
          getHomeBounds: function() {
            return this._homeBounds.clone();
          },
          getContentFactor: function() {
            return this._contentFactor;
          },
          setAutoRefigureSizes: function(value) {
            this._autoRefigureSizes = value;
            if (value & this._needsSizesFigured) {
              this._figureSizes();
              this._needsSizesFigured = false;
            }
          },
          arrange: function(options) {
            options = options || {};
            var immediately = options.immediately || false;
            var layout = options.layout || $3.DEFAULT_SETTINGS.collectionLayout;
            var rows = options.rows || $3.DEFAULT_SETTINGS.collectionRows;
            var columns = options.columns || $3.DEFAULT_SETTINGS.collectionColumns;
            var tileSize = options.tileSize || $3.DEFAULT_SETTINGS.collectionTileSize;
            var tileMargin = options.tileMargin || $3.DEFAULT_SETTINGS.collectionTileMargin;
            var increment = tileSize + tileMargin;
            var wrap;
            if (!options.rows && columns) {
              wrap = columns;
            } else {
              wrap = Math.ceil(this._items.length / rows);
            }
            var x2 = 0;
            var y2 = 0;
            var item, box, width, height, position;
            this.setAutoRefigureSizes(false);
            for (var i2 = 0; i2 < this._items.length; i2++) {
              if (i2 && i2 % wrap === 0) {
                if (layout === "horizontal") {
                  y2 += increment;
                  x2 = 0;
                } else {
                  x2 += increment;
                  y2 = 0;
                }
              }
              item = this._items[i2];
              box = item.getBounds();
              if (box.width > box.height) {
                width = tileSize;
              } else {
                width = tileSize * (box.width / box.height);
              }
              height = width * (box.height / box.width);
              position = new $3.Point(
                x2 + (tileSize - width) / 2,
                y2 + (tileSize - height) / 2
              );
              item.setPosition(position, immediately);
              item.setWidth(width, immediately);
              if (layout === "horizontal") {
                x2 += increment;
              } else {
                y2 += increment;
              }
            }
            this.setAutoRefigureSizes(true);
          },
          _figureSizes: function() {
            var oldHomeBounds = this._homeBounds ? this._homeBounds.clone() : null;
            var oldContentSize = this._contentSize ? this._contentSize.clone() : null;
            var oldContentFactor = this._contentFactor || 0;
            if (!this._items.length) {
              this._homeBounds = new $3.Rect(0, 0, 1, 1);
              this._contentSize = new $3.Point(1, 1);
              this._contentFactor = 1;
            } else {
              var item = this._items[0];
              var bounds = item.getBounds();
              this._contentFactor = item.getContentSize().x / bounds.width;
              var clippedBounds = item.getClippedBounds().getBoundingBox();
              var left = clippedBounds.x;
              var top = clippedBounds.y;
              var right = clippedBounds.x + clippedBounds.width;
              var bottom = clippedBounds.y + clippedBounds.height;
              for (var i2 = 1; i2 < this._items.length; i2++) {
                item = this._items[i2];
                bounds = item.getBounds();
                this._contentFactor = Math.max(
                  this._contentFactor,
                  item.getContentSize().x / bounds.width
                );
                clippedBounds = item.getClippedBounds().getBoundingBox();
                left = Math.min(left, clippedBounds.x);
                top = Math.min(top, clippedBounds.y);
                right = Math.max(right, clippedBounds.x + clippedBounds.width);
                bottom = Math.max(bottom, clippedBounds.y + clippedBounds.height);
              }
              this._homeBounds = new $3.Rect(left, top, right - left, bottom - top);
              this._contentSize = new $3.Point(
                this._homeBounds.width * this._contentFactor,
                this._homeBounds.height * this._contentFactor
              );
            }
            if (this._contentFactor !== oldContentFactor || !this._homeBounds.equals(oldHomeBounds) || !this._contentSize.equals(oldContentSize)) {
              this.raiseEvent("metrics-change", {});
            }
          },
          _raiseRemoveItem: function(item) {
            this.raiseEvent("remove-item", { item });
          }
        });
      })(OpenSeadragon);
    }
  });

  // node_modules/axios/lib/helpers/bind.js
  var require_bind = __commonJS({
    "node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
      "use strict";
      module2.exports = function bind(fn2, thisArg) {
        return function wrap() {
          var args = new Array(arguments.length);
          for (var i2 = 0; i2 < args.length; i2++) {
            args[i2] = arguments[i2];
          }
          return fn2.apply(thisArg, args);
        };
      };
    }
  });

  // node_modules/axios/lib/utils.js
  var require_utils = __commonJS({
    "node_modules/axios/lib/utils.js"(exports2, module2) {
      "use strict";
      var bind = require_bind();
      var toString = Object.prototype.toString;
      var kindOf2 = function(cache) {
        return function(thing) {
          var str = toString.call(thing);
          return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
        };
      }(/* @__PURE__ */ Object.create(null));
      function kindOfTest(type) {
        type = type.toLowerCase();
        return function isKindOf(thing) {
          return kindOf2(thing) === type;
        };
      }
      function isArray(val) {
        return Array.isArray(val);
      }
      function isUndefined(val) {
        return typeof val === "undefined";
      }
      function isBuffer(val) {
        return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
      }
      var isArrayBuffer = kindOfTest("ArrayBuffer");
      function isArrayBufferView(val) {
        var result;
        if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
          result = ArrayBuffer.isView(val);
        } else {
          result = val && val.buffer && isArrayBuffer(val.buffer);
        }
        return result;
      }
      function isString(val) {
        return typeof val === "string";
      }
      function isNumber(val) {
        return typeof val === "number";
      }
      function isObject2(val) {
        return val !== null && typeof val === "object";
      }
      function isPlainObject2(val) {
        if (kindOf2(val) !== "object") {
          return false;
        }
        var prototype = Object.getPrototypeOf(val);
        return prototype === null || prototype === Object.prototype;
      }
      var isDate2 = kindOfTest("Date");
      var isFile = kindOfTest("File");
      var isBlob = kindOfTest("Blob");
      var isFileList = kindOfTest("FileList");
      function isFunction(val) {
        return toString.call(val) === "[object Function]";
      }
      function isStream(val) {
        return isObject2(val) && isFunction(val.pipe);
      }
      function isFormData(thing) {
        var pattern = "[object FormData]";
        return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
      }
      var isURLSearchParams = kindOfTest("URLSearchParams");
      function trim(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
      }
      function isStandardBrowserEnv() {
        if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
          return false;
        }
        return typeof window !== "undefined" && typeof document !== "undefined";
      }
      function forEach(obj, fn2) {
        if (obj === null || typeof obj === "undefined") {
          return;
        }
        if (typeof obj !== "object") {
          obj = [obj];
        }
        if (isArray(obj)) {
          for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
            fn2.call(null, obj[i2], i2, obj);
          }
        } else {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              fn2.call(null, obj[key], key, obj);
            }
          }
        }
      }
      function merge2() {
        var result = {};
        function assignValue(val, key) {
          if (isPlainObject2(result[key]) && isPlainObject2(val)) {
            result[key] = merge2(result[key], val);
          } else if (isPlainObject2(val)) {
            result[key] = merge2({}, val);
          } else if (isArray(val)) {
            result[key] = val.slice();
          } else {
            result[key] = val;
          }
        }
        for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
          forEach(arguments[i2], assignValue);
        }
        return result;
      }
      function extend(a2, b3, thisArg) {
        forEach(b3, function assignValue(val, key) {
          if (thisArg && typeof val === "function") {
            a2[key] = bind(val, thisArg);
          } else {
            a2[key] = val;
          }
        });
        return a2;
      }
      function stripBOM(content) {
        if (content.charCodeAt(0) === 65279) {
          content = content.slice(1);
        }
        return content;
      }
      function inherits(constructor, superConstructor, props, descriptors) {
        constructor.prototype = Object.create(superConstructor.prototype, descriptors);
        constructor.prototype.constructor = constructor;
        props && Object.assign(constructor.prototype, props);
      }
      function toFlatObject(sourceObj, destObj, filter) {
        var props;
        var i2;
        var prop;
        var merged = {};
        destObj = destObj || {};
        do {
          props = Object.getOwnPropertyNames(sourceObj);
          i2 = props.length;
          while (i2-- > 0) {
            prop = props[i2];
            if (!merged[prop]) {
              destObj[prop] = sourceObj[prop];
              merged[prop] = true;
            }
          }
          sourceObj = Object.getPrototypeOf(sourceObj);
        } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
        return destObj;
      }
      function endsWith(str, searchString, position) {
        str = String(str);
        if (position === void 0 || position > str.length) {
          position = str.length;
        }
        position -= searchString.length;
        var lastIndex = str.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
      }
      function toArray(thing) {
        if (!thing)
          return null;
        var i2 = thing.length;
        if (isUndefined(i2))
          return null;
        var arr = new Array(i2);
        while (i2-- > 0) {
          arr[i2] = thing[i2];
        }
        return arr;
      }
      var isTypedArray = function(TypedArray) {
        return function(thing) {
          return TypedArray && thing instanceof TypedArray;
        };
      }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
      module2.exports = {
        isArray,
        isArrayBuffer,
        isBuffer,
        isFormData,
        isArrayBufferView,
        isString,
        isNumber,
        isObject: isObject2,
        isPlainObject: isPlainObject2,
        isUndefined,
        isDate: isDate2,
        isFile,
        isBlob,
        isFunction,
        isStream,
        isURLSearchParams,
        isStandardBrowserEnv,
        forEach,
        merge: merge2,
        extend,
        trim,
        stripBOM,
        inherits,
        toFlatObject,
        kindOf: kindOf2,
        kindOfTest,
        endsWith,
        toArray,
        isTypedArray,
        isFileList
      };
    }
  });

  // node_modules/axios/lib/helpers/buildURL.js
  var require_buildURL = __commonJS({
    "node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      function encode(val) {
        return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
      }
      module2.exports = function buildURL(url, params, paramsSerializer) {
        if (!params) {
          return url;
        }
        var serializedParams;
        if (paramsSerializer) {
          serializedParams = paramsSerializer(params);
        } else if (utils.isURLSearchParams(params)) {
          serializedParams = params.toString();
        } else {
          var parts = [];
          utils.forEach(params, function serialize2(val, key) {
            if (val === null || typeof val === "undefined") {
              return;
            }
            if (utils.isArray(val)) {
              key = key + "[]";
            } else {
              val = [val];
            }
            utils.forEach(val, function parseValue(v2) {
              if (utils.isDate(v2)) {
                v2 = v2.toISOString();
              } else if (utils.isObject(v2)) {
                v2 = JSON.stringify(v2);
              }
              parts.push(encode(key) + "=" + encode(v2));
            });
          });
          serializedParams = parts.join("&");
        }
        if (serializedParams) {
          var hashmarkIndex = url.indexOf("#");
          if (hashmarkIndex !== -1) {
            url = url.slice(0, hashmarkIndex);
          }
          url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
        }
        return url;
      };
    }
  });

  // node_modules/axios/lib/core/InterceptorManager.js
  var require_InterceptorManager = __commonJS({
    "node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      function InterceptorManager() {
        this.handlers = [];
      }
      InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      };
      InterceptorManager.prototype.eject = function eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      };
      InterceptorManager.prototype.forEach = function forEach(fn2) {
        utils.forEach(this.handlers, function forEachHandler(h2) {
          if (h2 !== null) {
            fn2(h2);
          }
        });
      };
      module2.exports = InterceptorManager;
    }
  });

  // node_modules/axios/lib/helpers/normalizeHeaderName.js
  var require_normalizeHeaderName = __commonJS({
    "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      module2.exports = function normalizeHeaderName(headers, normalizedName) {
        utils.forEach(headers, function processHeader(value, name) {
          if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
            headers[normalizedName] = value;
            delete headers[name];
          }
        });
      };
    }
  });

  // node_modules/axios/lib/core/AxiosError.js
  var require_AxiosError = __commonJS({
    "node_modules/axios/lib/core/AxiosError.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      function AxiosError(message, code, config, request, response) {
        Error.call(this);
        this.message = message;
        this.name = "AxiosError";
        code && (this.code = code);
        config && (this.config = config);
        request && (this.request = request);
        response && (this.response = response);
      }
      utils.inherits(AxiosError, Error, {
        toJSON: function toJSON() {
          return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: this.config,
            code: this.code,
            status: this.response && this.response.status ? this.response.status : null
          };
        }
      });
      var prototype = AxiosError.prototype;
      var descriptors = {};
      [
        "ERR_BAD_OPTION_VALUE",
        "ERR_BAD_OPTION",
        "ECONNABORTED",
        "ETIMEDOUT",
        "ERR_NETWORK",
        "ERR_FR_TOO_MANY_REDIRECTS",
        "ERR_DEPRECATED",
        "ERR_BAD_RESPONSE",
        "ERR_BAD_REQUEST",
        "ERR_CANCELED"
      ].forEach(function(code) {
        descriptors[code] = { value: code };
      });
      Object.defineProperties(AxiosError, descriptors);
      Object.defineProperty(prototype, "isAxiosError", { value: true });
      AxiosError.from = function(error, code, config, request, response, customProps) {
        var axiosError = Object.create(prototype);
        utils.toFlatObject(error, axiosError, function filter(obj) {
          return obj !== Error.prototype;
        });
        AxiosError.call(axiosError, error.message, code, config, request, response);
        axiosError.name = error.name;
        customProps && Object.assign(axiosError, customProps);
        return axiosError;
      };
      module2.exports = AxiosError;
    }
  });

  // node_modules/axios/lib/defaults/transitional.js
  var require_transitional = __commonJS({
    "node_modules/axios/lib/defaults/transitional.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      };
    }
  });

  // node_modules/axios/lib/helpers/toFormData.js
  var require_toFormData = __commonJS({
    "node_modules/axios/lib/helpers/toFormData.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      function toFormData(obj, formData) {
        formData = formData || new FormData();
        var stack = [];
        function convertValue(value) {
          if (value === null)
            return "";
          if (utils.isDate(value)) {
            return value.toISOString();
          }
          if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
            return typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
          }
          return value;
        }
        function build(data, parentKey) {
          if (utils.isPlainObject(data) || utils.isArray(data)) {
            if (stack.indexOf(data) !== -1) {
              throw Error("Circular reference detected in " + parentKey);
            }
            stack.push(data);
            utils.forEach(data, function each(value, key) {
              if (utils.isUndefined(value))
                return;
              var fullKey = parentKey ? parentKey + "." + key : key;
              var arr;
              if (value && !parentKey && typeof value === "object") {
                if (utils.endsWith(key, "{}")) {
                  value = JSON.stringify(value);
                } else if (utils.endsWith(key, "[]") && (arr = utils.toArray(value))) {
                  arr.forEach(function(el) {
                    !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
                  });
                  return;
                }
              }
              build(value, fullKey);
            });
            stack.pop();
          } else {
            formData.append(parentKey, convertValue(data));
          }
        }
        build(obj);
        return formData;
      }
      module2.exports = toFormData;
    }
  });

  // node_modules/axios/lib/core/settle.js
  var require_settle = __commonJS({
    "node_modules/axios/lib/core/settle.js"(exports2, module2) {
      "use strict";
      var AxiosError = require_AxiosError();
      module2.exports = function settle(resolve, reject, response) {
        var validateStatus = response.config.validateStatus;
        if (!response.status || !validateStatus || validateStatus(response.status)) {
          resolve(response);
        } else {
          reject(new AxiosError(
            "Request failed with status code " + response.status,
            [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
            response.config,
            response.request,
            response
          ));
        }
      };
    }
  });

  // node_modules/axios/lib/helpers/cookies.js
  var require_cookies = __commonJS({
    "node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }() : function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }();
    }
  });

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  var require_isAbsoluteURL = __commonJS({
    "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
      "use strict";
      module2.exports = function isAbsoluteURL(url) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
      };
    }
  });

  // node_modules/axios/lib/helpers/combineURLs.js
  var require_combineURLs = __commonJS({
    "node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
      "use strict";
      module2.exports = function combineURLs(baseURL, relativeURL) {
        return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
      };
    }
  });

  // node_modules/axios/lib/core/buildFullPath.js
  var require_buildFullPath = __commonJS({
    "node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
      "use strict";
      var isAbsoluteURL = require_isAbsoluteURL();
      var combineURLs = require_combineURLs();
      module2.exports = function buildFullPath(baseURL, requestedURL) {
        if (baseURL && !isAbsoluteURL(requestedURL)) {
          return combineURLs(baseURL, requestedURL);
        }
        return requestedURL;
      };
    }
  });

  // node_modules/axios/lib/helpers/parseHeaders.js
  var require_parseHeaders = __commonJS({
    "node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var ignoreDuplicateOf = [
        "age",
        "authorization",
        "content-length",
        "content-type",
        "etag",
        "expires",
        "from",
        "host",
        "if-modified-since",
        "if-unmodified-since",
        "last-modified",
        "location",
        "max-forwards",
        "proxy-authorization",
        "referer",
        "retry-after",
        "user-agent"
      ];
      module2.exports = function parseHeaders(headers) {
        var parsed = {};
        var key;
        var val;
        var i2;
        if (!headers) {
          return parsed;
        }
        utils.forEach(headers.split("\n"), function parser(line) {
          i2 = line.indexOf(":");
          key = utils.trim(line.substr(0, i2)).toLowerCase();
          val = utils.trim(line.substr(i2 + 1));
          if (key) {
            if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
              return;
            }
            if (key === "set-cookie") {
              parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
            } else {
              parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
            }
          }
        });
        return parsed;
      };
    }
  });

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var require_isURLSameOrigin = __commonJS({
    "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }() : function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }();
    }
  });

  // node_modules/axios/lib/cancel/CanceledError.js
  var require_CanceledError = __commonJS({
    "node_modules/axios/lib/cancel/CanceledError.js"(exports2, module2) {
      "use strict";
      var AxiosError = require_AxiosError();
      var utils = require_utils();
      function CanceledError(message) {
        AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED);
        this.name = "CanceledError";
      }
      utils.inherits(CanceledError, AxiosError, {
        __CANCEL__: true
      });
      module2.exports = CanceledError;
    }
  });

  // node_modules/axios/lib/helpers/parseProtocol.js
  var require_parseProtocol = __commonJS({
    "node_modules/axios/lib/helpers/parseProtocol.js"(exports2, module2) {
      "use strict";
      module2.exports = function parseProtocol(url) {
        var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
        return match && match[1] || "";
      };
    }
  });

  // node_modules/axios/lib/adapters/xhr.js
  var require_xhr = __commonJS({
    "node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var settle = require_settle();
      var cookies = require_cookies();
      var buildURL = require_buildURL();
      var buildFullPath = require_buildFullPath();
      var parseHeaders = require_parseHeaders();
      var isURLSameOrigin = require_isURLSameOrigin();
      var transitionalDefaults = require_transitional();
      var AxiosError = require_AxiosError();
      var CanceledError = require_CanceledError();
      var parseProtocol = require_parseProtocol();
      module2.exports = function xhrAdapter(config) {
        return new Promise(function dispatchXhrRequest(resolve, reject) {
          var requestData = config.data;
          var requestHeaders = config.headers;
          var responseType = config.responseType;
          var onCanceled;
          function done() {
            if (config.cancelToken) {
              config.cancelToken.unsubscribe(onCanceled);
            }
            if (config.signal) {
              config.signal.removeEventListener("abort", onCanceled);
            }
          }
          if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
            delete requestHeaders["Content-Type"];
          }
          var request = new XMLHttpRequest();
          if (config.auth) {
            var username = config.auth.username || "";
            var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
            requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
          }
          var fullPath = buildFullPath(config.baseURL, config.url);
          request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
          request.timeout = config.timeout;
          function onloadend() {
            if (!request) {
              return;
            }
            var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
            var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
            var response = {
              data: responseData,
              status: request.status,
              statusText: request.statusText,
              headers: responseHeaders,
              config,
              request
            };
            settle(function _resolve(value) {
              resolve(value);
              done();
            }, function _reject(err) {
              reject(err);
              done();
            }, response);
            request = null;
          }
          if ("onloadend" in request) {
            request.onloadend = onloadend;
          } else {
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                return;
              }
              setTimeout(onloadend);
            };
          }
          request.onabort = function handleAbort() {
            if (!request) {
              return;
            }
            reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
            request = null;
          };
          request.onerror = function handleError() {
            reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request, request));
            request = null;
          };
          request.ontimeout = function handleTimeout() {
            var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            var transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            reject(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              request
            ));
            request = null;
          };
          if (utils.isStandardBrowserEnv()) {
            var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
          if ("setRequestHeader" in request) {
            utils.forEach(requestHeaders, function setRequestHeader(val, key) {
              if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                delete requestHeaders[key];
              } else {
                request.setRequestHeader(key, val);
              }
            });
          }
          if (!utils.isUndefined(config.withCredentials)) {
            request.withCredentials = !!config.withCredentials;
          }
          if (responseType && responseType !== "json") {
            request.responseType = config.responseType;
          }
          if (typeof config.onDownloadProgress === "function") {
            request.addEventListener("progress", config.onDownloadProgress);
          }
          if (typeof config.onUploadProgress === "function" && request.upload) {
            request.upload.addEventListener("progress", config.onUploadProgress);
          }
          if (config.cancelToken || config.signal) {
            onCanceled = function(cancel) {
              if (!request) {
                return;
              }
              reject(!cancel || cancel && cancel.type ? new CanceledError() : cancel);
              request.abort();
              request = null;
            };
            config.cancelToken && config.cancelToken.subscribe(onCanceled);
            if (config.signal) {
              config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
            }
          }
          if (!requestData) {
            requestData = null;
          }
          var protocol = parseProtocol(fullPath);
          if (protocol && ["http", "https", "file"].indexOf(protocol) === -1) {
            reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
            return;
          }
          request.send(requestData);
        });
      };
    }
  });

  // node_modules/axios/lib/helpers/null.js
  var require_null = __commonJS({
    "node_modules/axios/lib/helpers/null.js"(exports2, module2) {
      module2.exports = null;
    }
  });

  // node_modules/axios/lib/defaults/index.js
  var require_defaults = __commonJS({
    "node_modules/axios/lib/defaults/index.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var normalizeHeaderName = require_normalizeHeaderName();
      var AxiosError = require_AxiosError();
      var transitionalDefaults = require_transitional();
      var toFormData = require_toFormData();
      var DEFAULT_CONTENT_TYPE = {
        "Content-Type": "application/x-www-form-urlencoded"
      };
      function setContentTypeIfUnset(headers, value) {
        if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
          headers["Content-Type"] = value;
        }
      }
      function getDefaultAdapter() {
        var adapter;
        if (typeof XMLHttpRequest !== "undefined") {
          adapter = require_xhr();
        } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
          adapter = require_xhr();
        }
        return adapter;
      }
      function stringifySafely(rawValue, parser, encoder) {
        if (utils.isString(rawValue)) {
          try {
            (parser || JSON.parse)(rawValue);
            return utils.trim(rawValue);
          } catch (e3) {
            if (e3.name !== "SyntaxError") {
              throw e3;
            }
          }
        }
        return (encoder || JSON.stringify)(rawValue);
      }
      var defaults2 = {
        transitional: transitionalDefaults,
        adapter: getDefaultAdapter(),
        transformRequest: [function transformRequest(data, headers) {
          normalizeHeaderName(headers, "Accept");
          normalizeHeaderName(headers, "Content-Type");
          if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
            return data;
          }
          if (utils.isArrayBufferView(data)) {
            return data.buffer;
          }
          if (utils.isURLSearchParams(data)) {
            setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
            return data.toString();
          }
          var isObjectPayload = utils.isObject(data);
          var contentType = headers && headers["Content-Type"];
          var isFileList;
          if ((isFileList = utils.isFileList(data)) || isObjectPayload && contentType === "multipart/form-data") {
            var _FormData = this.env && this.env.FormData;
            return toFormData(isFileList ? { "files[]": data } : data, _FormData && new _FormData());
          } else if (isObjectPayload || contentType === "application/json") {
            setContentTypeIfUnset(headers, "application/json");
            return stringifySafely(data);
          }
          return data;
        }],
        transformResponse: [function transformResponse(data) {
          var transitional = this.transitional || defaults2.transitional;
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
          var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
          if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
            try {
              return JSON.parse(data);
            } catch (e3) {
              if (strictJSONParsing) {
                if (e3.name === "SyntaxError") {
                  throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
                }
                throw e3;
              }
            }
          }
          return data;
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: require_null()
        },
        validateStatus: function validateStatus(status2) {
          return status2 >= 200 && status2 < 300;
        },
        headers: {
          common: {
            "Accept": "application/json, text/plain, */*"
          }
        }
      };
      utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
        defaults2.headers[method] = {};
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        defaults2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
      });
      module2.exports = defaults2;
    }
  });

  // node_modules/axios/lib/core/transformData.js
  var require_transformData = __commonJS({
    "node_modules/axios/lib/core/transformData.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var defaults2 = require_defaults();
      module2.exports = function transformData(data, headers, fns) {
        var context = this || defaults2;
        utils.forEach(fns, function transform(fn2) {
          data = fn2.call(context, data, headers);
        });
        return data;
      };
    }
  });

  // node_modules/axios/lib/cancel/isCancel.js
  var require_isCancel = __commonJS({
    "node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
      "use strict";
      module2.exports = function isCancel(value) {
        return !!(value && value.__CANCEL__);
      };
    }
  });

  // node_modules/axios/lib/core/dispatchRequest.js
  var require_dispatchRequest = __commonJS({
    "node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var transformData = require_transformData();
      var isCancel = require_isCancel();
      var defaults2 = require_defaults();
      var CanceledError = require_CanceledError();
      function throwIfCancellationRequested(config) {
        if (config.cancelToken) {
          config.cancelToken.throwIfRequested();
        }
        if (config.signal && config.signal.aborted) {
          throw new CanceledError();
        }
      }
      module2.exports = function dispatchRequest(config) {
        throwIfCancellationRequested(config);
        config.headers = config.headers || {};
        config.data = transformData.call(
          config,
          config.data,
          config.headers,
          config.transformRequest
        );
        config.headers = utils.merge(
          config.headers.common || {},
          config.headers[config.method] || {},
          config.headers
        );
        utils.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          function cleanHeaderConfig(method) {
            delete config.headers[method];
          }
        );
        var adapter = config.adapter || defaults2.adapter;
        return adapter(config).then(function onAdapterResolution(response) {
          throwIfCancellationRequested(config);
          response.data = transformData.call(
            config,
            response.data,
            response.headers,
            config.transformResponse
          );
          return response;
        }, function onAdapterRejection(reason) {
          if (!isCancel(reason)) {
            throwIfCancellationRequested(config);
            if (reason && reason.response) {
              reason.response.data = transformData.call(
                config,
                reason.response.data,
                reason.response.headers,
                config.transformResponse
              );
            }
          }
          return Promise.reject(reason);
        });
      };
    }
  });

  // node_modules/axios/lib/core/mergeConfig.js
  var require_mergeConfig = __commonJS({
    "node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      module2.exports = function mergeConfig2(config1, config2) {
        config2 = config2 || {};
        var config = {};
        function getMergedValue(target, source) {
          if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
            return utils.merge(target, source);
          } else if (utils.isPlainObject(source)) {
            return utils.merge({}, source);
          } else if (utils.isArray(source)) {
            return source.slice();
          }
          return source;
        }
        function mergeDeepProperties(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function valueFromConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          }
        }
        function defaultToConfig2(prop) {
          if (!utils.isUndefined(config2[prop])) {
            return getMergedValue(void 0, config2[prop]);
          } else if (!utils.isUndefined(config1[prop])) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        function mergeDirectKeys(prop) {
          if (prop in config2) {
            return getMergedValue(config1[prop], config2[prop]);
          } else if (prop in config1) {
            return getMergedValue(void 0, config1[prop]);
          }
        }
        var mergeMap = {
          "url": valueFromConfig2,
          "method": valueFromConfig2,
          "data": valueFromConfig2,
          "baseURL": defaultToConfig2,
          "transformRequest": defaultToConfig2,
          "transformResponse": defaultToConfig2,
          "paramsSerializer": defaultToConfig2,
          "timeout": defaultToConfig2,
          "timeoutMessage": defaultToConfig2,
          "withCredentials": defaultToConfig2,
          "adapter": defaultToConfig2,
          "responseType": defaultToConfig2,
          "xsrfCookieName": defaultToConfig2,
          "xsrfHeaderName": defaultToConfig2,
          "onUploadProgress": defaultToConfig2,
          "onDownloadProgress": defaultToConfig2,
          "decompress": defaultToConfig2,
          "maxContentLength": defaultToConfig2,
          "maxBodyLength": defaultToConfig2,
          "beforeRedirect": defaultToConfig2,
          "transport": defaultToConfig2,
          "httpAgent": defaultToConfig2,
          "httpsAgent": defaultToConfig2,
          "cancelToken": defaultToConfig2,
          "socketPath": defaultToConfig2,
          "responseEncoding": defaultToConfig2,
          "validateStatus": mergeDirectKeys
        };
        utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
          var merge2 = mergeMap[prop] || mergeDeepProperties;
          var configValue = merge2(prop);
          utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
        });
        return config;
      };
    }
  });

  // node_modules/axios/lib/env/data.js
  var require_data = __commonJS({
    "node_modules/axios/lib/env/data.js"(exports2, module2) {
      module2.exports = {
        "version": "0.27.2"
      };
    }
  });

  // node_modules/axios/lib/helpers/validator.js
  var require_validator = __commonJS({
    "node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
      "use strict";
      var VERSION = require_data().version;
      var AxiosError = require_AxiosError();
      var validators = {};
      ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i2) {
        validators[type] = function validator(thing) {
          return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
        };
      });
      var deprecatedWarnings = {};
      validators.transitional = function transitional(validator, version, message) {
        function formatMessage(opt, desc) {
          return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
        }
        return function(value, opt, opts) {
          if (validator === false) {
            throw new AxiosError(
              formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
              AxiosError.ERR_DEPRECATED
            );
          }
          if (version && !deprecatedWarnings[opt]) {
            deprecatedWarnings[opt] = true;
            console.warn(
              formatMessage(
                opt,
                " has been deprecated since v" + version + " and will be removed in the near future"
              )
            );
          }
          return validator ? validator(value, opt, opts) : true;
        };
      };
      function assertOptions(options, schema, allowUnknown) {
        if (typeof options !== "object") {
          throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
        }
        var keys = Object.keys(options);
        var i2 = keys.length;
        while (i2-- > 0) {
          var opt = keys[i2];
          var validator = schema[opt];
          if (validator) {
            var value = options[opt];
            var result = value === void 0 || validator(value, opt, options);
            if (result !== true) {
              throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
            }
            continue;
          }
          if (allowUnknown !== true) {
            throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
          }
        }
      }
      module2.exports = {
        assertOptions,
        validators
      };
    }
  });

  // node_modules/axios/lib/core/Axios.js
  var require_Axios = __commonJS({
    "node_modules/axios/lib/core/Axios.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var buildURL = require_buildURL();
      var InterceptorManager = require_InterceptorManager();
      var dispatchRequest = require_dispatchRequest();
      var mergeConfig2 = require_mergeConfig();
      var buildFullPath = require_buildFullPath();
      var validator = require_validator();
      var validators = validator.validators;
      function Axios(instanceConfig) {
        this.defaults = instanceConfig;
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }
      Axios.prototype.request = function request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig2(this.defaults, config);
        if (config.method) {
          config.method = config.method.toLowerCase();
        } else if (this.defaults.method) {
          config.method = this.defaults.method.toLowerCase();
        } else {
          config.method = "get";
        }
        var transitional = config.transitional;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        var requestInterceptorChain = [];
        var synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        var responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        var promise;
        if (!synchronousRequestInterceptors) {
          var chain = [dispatchRequest, void 0];
          Array.prototype.unshift.apply(chain, requestInterceptorChain);
          chain = chain.concat(responseInterceptorChain);
          promise = Promise.resolve(config);
          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }
          return promise;
        }
        var newConfig = config;
        while (requestInterceptorChain.length) {
          var onFulfilled = requestInterceptorChain.shift();
          var onRejected = requestInterceptorChain.shift();
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected(error);
            break;
          }
        }
        try {
          promise = dispatchRequest(newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        while (responseInterceptorChain.length) {
          promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
        }
        return promise;
      };
      Axios.prototype.getUri = function getUri(config) {
        config = mergeConfig2(this.defaults, config);
        var fullPath = buildFullPath(config.baseURL, config.url);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      };
      utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
        Axios.prototype[method] = function(url, config) {
          return this.request(mergeConfig2(config || {}, {
            method,
            url,
            data: (config || {}).data
          }));
        };
      });
      utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
        function generateHTTPMethod(isForm) {
          return function httpMethod(url, data, config) {
            return this.request(mergeConfig2(config || {}, {
              method,
              headers: isForm ? {
                "Content-Type": "multipart/form-data"
              } : {},
              url,
              data
            }));
          };
        }
        Axios.prototype[method] = generateHTTPMethod();
        Axios.prototype[method + "Form"] = generateHTTPMethod(true);
      });
      module2.exports = Axios;
    }
  });

  // node_modules/axios/lib/cancel/CancelToken.js
  var require_CancelToken = __commonJS({
    "node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
      "use strict";
      var CanceledError = require_CanceledError();
      function CancelToken(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        var resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        var token = this;
        this.promise.then(function(cancel) {
          if (!token._listeners)
            return;
          var i2;
          var l2 = token._listeners.length;
          for (i2 = 0; i2 < l2; i2++) {
            token._listeners[i2](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = function(onfulfilled) {
          var _resolve;
          var promise = new Promise(function(resolve) {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message);
          resolvePromise(token.reason);
        });
      }
      CancelToken.prototype.throwIfRequested = function throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      };
      CancelToken.prototype.subscribe = function subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      };
      CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        var index2 = this._listeners.indexOf(listener);
        if (index2 !== -1) {
          this._listeners.splice(index2, 1);
        }
      };
      CancelToken.source = function source() {
        var cancel;
        var token = new CancelToken(function executor(c2) {
          cancel = c2;
        });
        return {
          token,
          cancel
        };
      };
      module2.exports = CancelToken;
    }
  });

  // node_modules/axios/lib/helpers/spread.js
  var require_spread = __commonJS({
    "node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
      "use strict";
      module2.exports = function spread(callback) {
        return function wrap(arr) {
          return callback.apply(null, arr);
        };
      };
    }
  });

  // node_modules/axios/lib/helpers/isAxiosError.js
  var require_isAxiosError = __commonJS({
    "node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      module2.exports = function isAxiosError(payload) {
        return utils.isObject(payload) && payload.isAxiosError === true;
      };
    }
  });

  // node_modules/axios/lib/axios.js
  var require_axios = __commonJS({
    "node_modules/axios/lib/axios.js"(exports2, module2) {
      "use strict";
      var utils = require_utils();
      var bind = require_bind();
      var Axios = require_Axios();
      var mergeConfig2 = require_mergeConfig();
      var defaults2 = require_defaults();
      function createInstance(defaultConfig) {
        var context = new Axios(defaultConfig);
        var instance = bind(Axios.prototype.request, context);
        utils.extend(instance, Axios.prototype, context);
        utils.extend(instance, context);
        instance.create = function create(instanceConfig) {
          return createInstance(mergeConfig2(defaultConfig, instanceConfig));
        };
        return instance;
      }
      var axios2 = createInstance(defaults2);
      axios2.Axios = Axios;
      axios2.CanceledError = require_CanceledError();
      axios2.CancelToken = require_CancelToken();
      axios2.isCancel = require_isCancel();
      axios2.VERSION = require_data().version;
      axios2.toFormData = require_toFormData();
      axios2.AxiosError = require_AxiosError();
      axios2.Cancel = axios2.CanceledError;
      axios2.all = function all(promises) {
        return Promise.all(promises);
      };
      axios2.spread = require_spread();
      axios2.isAxiosError = require_isAxiosError();
      module2.exports = axios2;
      module2.exports.default = axios2;
    }
  });

  // node_modules/axios/index.js
  var require_axios2 = __commonJS({
    "node_modules/axios/index.js"(exports2, module2) {
      module2.exports = require_axios();
    }
  });

  // node_modules/axios-request-handler/dist/axios-request.js
  var require_axios_request = __commonJS({
    "node_modules/axios-request-handler/dist/axios-request.js"(exports2, module2) {
      (function webpackUniversalModuleDefinition(root2, factory) {
        if (typeof exports2 === "object" && typeof module2 === "object")
          module2.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports2 === "object")
          exports2["axios-request"] = factory();
        else
          root2["axios-request"] = factory();
      })(exports2, function() {
        return function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module3 = installedModules[moduleId] = {
              i: moduleId,
              l: false,
              exports: {}
            };
            modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
            module3.l = true;
            return module3.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports3, name, getter) {
            if (!__webpack_require__.o(exports3, name)) {
              Object.defineProperty(exports3, name, {
                configurable: false,
                enumerable: true,
                get: getter
              });
            }
          };
          __webpack_require__.n = function(module3) {
            var getter = module3 && module3.__esModule ? function getDefault() {
              return module3["default"];
            } : function getModuleExports() {
              return module3;
            };
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "/";
          return __webpack_require__(__webpack_require__.s = 9);
        }([
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
              return typeof obj;
            } : function(obj) {
              return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
            };
            var bind = __webpack_require__(1);
            var isBuffer = __webpack_require__(13);
            var toString = Object.prototype.toString;
            function isArray(val) {
              return toString.call(val) === "[object Array]";
            }
            function isArrayBuffer(val) {
              return toString.call(val) === "[object ArrayBuffer]";
            }
            function isFormData(val) {
              return typeof FormData !== "undefined" && val instanceof FormData;
            }
            function isArrayBufferView(val) {
              var result;
              if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
                result = ArrayBuffer.isView(val);
              } else {
                result = val && val.buffer && val.buffer instanceof ArrayBuffer;
              }
              return result;
            }
            function isString(val) {
              return typeof val === "string";
            }
            function isNumber(val) {
              return typeof val === "number";
            }
            function isUndefined(val) {
              return typeof val === "undefined";
            }
            function isObject2(val) {
              return val !== null && (typeof val === "undefined" ? "undefined" : _typeof2(val)) === "object";
            }
            function isDate2(val) {
              return toString.call(val) === "[object Date]";
            }
            function isFile(val) {
              return toString.call(val) === "[object File]";
            }
            function isBlob(val) {
              return toString.call(val) === "[object Blob]";
            }
            function isFunction(val) {
              return toString.call(val) === "[object Function]";
            }
            function isStream(val) {
              return isObject2(val) && isFunction(val.pipe);
            }
            function isURLSearchParams(val) {
              return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
            }
            function trim(str) {
              return str.replace(/^\s*/, "").replace(/\s*$/, "");
            }
            function isStandardBrowserEnv() {
              if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
                return false;
              }
              return typeof window !== "undefined" && typeof document !== "undefined";
            }
            function forEach(obj, fn2) {
              if (obj === null || typeof obj === "undefined") {
                return;
              }
              if ((typeof obj === "undefined" ? "undefined" : _typeof2(obj)) !== "object") {
                obj = [obj];
              }
              if (isArray(obj)) {
                for (var i2 = 0, l2 = obj.length; i2 < l2; i2++) {
                  fn2.call(null, obj[i2], i2, obj);
                }
              } else {
                for (var key in obj) {
                  if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    fn2.call(null, obj[key], key, obj);
                  }
                }
              }
            }
            function merge2() {
              var result = {};
              function assignValue(val, key) {
                if (_typeof2(result[key]) === "object" && (typeof val === "undefined" ? "undefined" : _typeof2(val)) === "object") {
                  result[key] = merge2(result[key], val);
                } else {
                  result[key] = val;
                }
              }
              for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
                forEach(arguments[i2], assignValue);
              }
              return result;
            }
            function deepMerge() {
              var result = {};
              function assignValue(val, key) {
                if (_typeof2(result[key]) === "object" && (typeof val === "undefined" ? "undefined" : _typeof2(val)) === "object") {
                  result[key] = deepMerge(result[key], val);
                } else if ((typeof val === "undefined" ? "undefined" : _typeof2(val)) === "object") {
                  result[key] = deepMerge({}, val);
                } else {
                  result[key] = val;
                }
              }
              for (var i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
                forEach(arguments[i2], assignValue);
              }
              return result;
            }
            function extend(a2, b3, thisArg) {
              forEach(b3, function assignValue(val, key) {
                if (thisArg && typeof val === "function") {
                  a2[key] = bind(val, thisArg);
                } else {
                  a2[key] = val;
                }
              });
              return a2;
            }
            module3.exports = {
              isArray,
              isArrayBuffer,
              isBuffer,
              isFormData,
              isArrayBufferView,
              isString,
              isNumber,
              isObject: isObject2,
              isUndefined,
              isDate: isDate2,
              isFile,
              isBlob,
              isFunction,
              isStream,
              isURLSearchParams,
              isStandardBrowserEnv,
              forEach,
              merge: merge2,
              deepMerge,
              extend,
              trim
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = function bind(fn2, thisArg) {
              return function wrap() {
                var args = new Array(arguments.length);
                for (var i2 = 0; i2 < args.length; i2++) {
                  args[i2] = arguments[i2];
                }
                return fn2.apply(thisArg, args);
              };
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            function encode(val) {
              return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
            }
            module3.exports = function buildURL(url, params, paramsSerializer) {
              if (!params) {
                return url;
              }
              var serializedParams;
              if (paramsSerializer) {
                serializedParams = paramsSerializer(params);
              } else if (utils.isURLSearchParams(params)) {
                serializedParams = params.toString();
              } else {
                var parts = [];
                utils.forEach(params, function serialize2(val, key) {
                  if (val === null || typeof val === "undefined") {
                    return;
                  }
                  if (utils.isArray(val)) {
                    key = key + "[]";
                  } else {
                    val = [val];
                  }
                  utils.forEach(val, function parseValue(v2) {
                    if (utils.isDate(v2)) {
                      v2 = v2.toISOString();
                    } else if (utils.isObject(v2)) {
                      v2 = JSON.stringify(v2);
                    }
                    parts.push(encode(key) + "=" + encode(v2));
                  });
                });
                serializedParams = parts.join("&");
              }
              if (serializedParams) {
                var hashmarkIndex = url.indexOf("#");
                if (hashmarkIndex !== -1) {
                  url = url.slice(0, hashmarkIndex);
                }
                url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
              }
              return url;
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = function isCancel(value) {
              return !!(value && value.__CANCEL__);
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            (function(process2) {
              var utils = __webpack_require__(0);
              var normalizeHeaderName = __webpack_require__(19);
              var DEFAULT_CONTENT_TYPE = {
                "Content-Type": "application/x-www-form-urlencoded"
              };
              function setContentTypeIfUnset(headers, value) {
                if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
                  headers["Content-Type"] = value;
                }
              }
              function getDefaultAdapter() {
                var adapter;
                if (typeof process2 !== "undefined" && Object.prototype.toString.call(process2) === "[object process]") {
                  adapter = __webpack_require__(5);
                } else if (typeof XMLHttpRequest !== "undefined") {
                  adapter = __webpack_require__(5);
                }
                return adapter;
              }
              var defaults2 = {
                adapter: getDefaultAdapter(),
                transformRequest: [function transformRequest(data, headers) {
                  normalizeHeaderName(headers, "Accept");
                  normalizeHeaderName(headers, "Content-Type");
                  if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
                    return data;
                  }
                  if (utils.isArrayBufferView(data)) {
                    return data.buffer;
                  }
                  if (utils.isURLSearchParams(data)) {
                    setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
                    return data.toString();
                  }
                  if (utils.isObject(data)) {
                    setContentTypeIfUnset(headers, "application/json;charset=utf-8");
                    return JSON.stringify(data);
                  }
                  return data;
                }],
                transformResponse: [function transformResponse(data) {
                  if (typeof data === "string") {
                    try {
                      data = JSON.parse(data);
                    } catch (e3) {
                    }
                  }
                  return data;
                }],
                timeout: 0,
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                maxContentLength: -1,
                validateStatus: function validateStatus(status2) {
                  return status2 >= 200 && status2 < 300;
                }
              };
              defaults2.headers = {
                common: {
                  "Accept": "application/json, text/plain, */*"
                }
              };
              utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
                defaults2.headers[method] = {};
              });
              utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
                defaults2.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
              });
              module3.exports = defaults2;
            }).call(exports3, __webpack_require__(18));
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            var settle = __webpack_require__(20);
            var buildURL = __webpack_require__(2);
            var parseHeaders = __webpack_require__(22);
            var isURLSameOrigin = __webpack_require__(23);
            var createError = __webpack_require__(6);
            module3.exports = function xhrAdapter(config) {
              return new Promise(function dispatchXhrRequest(resolve, reject) {
                var requestData = config.data;
                var requestHeaders = config.headers;
                if (utils.isFormData(requestData)) {
                  delete requestHeaders["Content-Type"];
                }
                var request = new XMLHttpRequest();
                if (config.auth) {
                  var username = config.auth.username || "";
                  var password = config.auth.password || "";
                  requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
                }
                request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);
                request.timeout = config.timeout;
                request.onreadystatechange = function handleLoad() {
                  if (!request || request.readyState !== 4) {
                    return;
                  }
                  if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
                    return;
                  }
                  var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
                  var responseData = !config.responseType || config.responseType === "text" ? request.responseText : request.response;
                  var response = {
                    data: responseData,
                    status: request.status,
                    statusText: request.statusText,
                    headers: responseHeaders,
                    config,
                    request
                  };
                  settle(resolve, reject, response);
                  request = null;
                };
                request.onabort = function handleAbort() {
                  if (!request) {
                    return;
                  }
                  reject(createError("Request aborted", config, "ECONNABORTED", request));
                  request = null;
                };
                request.onerror = function handleError() {
                  reject(createError("Network Error", config, null, request));
                  request = null;
                };
                request.ontimeout = function handleTimeout() {
                  reject(createError("timeout of " + config.timeout + "ms exceeded", config, "ECONNABORTED", request));
                  request = null;
                };
                if (utils.isStandardBrowserEnv()) {
                  var cookies = __webpack_require__(24);
                  var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
                  if (xsrfValue) {
                    requestHeaders[config.xsrfHeaderName] = xsrfValue;
                  }
                }
                if ("setRequestHeader" in request) {
                  utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                    if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
                      delete requestHeaders[key];
                    } else {
                      request.setRequestHeader(key, val);
                    }
                  });
                }
                if (config.withCredentials) {
                  request.withCredentials = true;
                }
                if (config.responseType) {
                  try {
                    request.responseType = config.responseType;
                  } catch (e3) {
                    if (config.responseType !== "json") {
                      throw e3;
                    }
                  }
                }
                if (typeof config.onDownloadProgress === "function") {
                  request.addEventListener("progress", config.onDownloadProgress);
                }
                if (typeof config.onUploadProgress === "function" && request.upload) {
                  request.upload.addEventListener("progress", config.onUploadProgress);
                }
                if (config.cancelToken) {
                  config.cancelToken.promise.then(function onCanceled(cancel) {
                    if (!request) {
                      return;
                    }
                    request.abort();
                    reject(cancel);
                    request = null;
                  });
                }
                if (requestData === void 0) {
                  requestData = null;
                }
                request.send(requestData);
              });
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var enhanceError = __webpack_require__(21);
            module3.exports = function createError(message, config, code, request, response) {
              var error = new Error(message);
              return enhanceError(error, config, code, request, response);
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            module3.exports = function mergeConfig2(config1, config2) {
              config2 = config2 || {};
              var config = {};
              utils.forEach(["url", "method", "params", "data"], function valueFromConfig2(prop) {
                if (typeof config2[prop] !== "undefined") {
                  config[prop] = config2[prop];
                }
              });
              utils.forEach(["headers", "auth", "proxy"], function mergeDeepProperties(prop) {
                if (utils.isObject(config2[prop])) {
                  config[prop] = utils.deepMerge(config1[prop], config2[prop]);
                } else if (typeof config2[prop] !== "undefined") {
                  config[prop] = config2[prop];
                } else if (utils.isObject(config1[prop])) {
                  config[prop] = utils.deepMerge(config1[prop]);
                } else if (typeof config1[prop] !== "undefined") {
                  config[prop] = config1[prop];
                }
              });
              utils.forEach(["baseURL", "transformRequest", "transformResponse", "paramsSerializer", "timeout", "withCredentials", "adapter", "responseType", "xsrfCookieName", "xsrfHeaderName", "onUploadProgress", "onDownloadProgress", "maxContentLength", "validateStatus", "maxRedirects", "httpAgent", "httpsAgent", "cancelToken", "socketPath"], function defaultToConfig2(prop) {
                if (typeof config2[prop] !== "undefined") {
                  config[prop] = config2[prop];
                } else if (typeof config1[prop] !== "undefined") {
                  config[prop] = config1[prop];
                }
              });
              return config;
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            function Cancel(message) {
              this.message = message;
            }
            Cancel.prototype.toString = function toString() {
              return "Cancel" + (this.message ? ": " + this.message : "");
            };
            Cancel.prototype.__CANCEL__ = true;
            module3.exports = Cancel;
          },
          function(module3, exports3, __webpack_require__) {
            module3.exports = __webpack_require__(10);
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports3, "__esModule", {
              value: true
            });
            var cov_15j8tpybze = function() {
              var path = "/home/mike/projects/axios-request/src/axios-request.js", hash4 = "59a64c6be56ac2c7f8f8ad25e520b8b4e5bc6060", global2 = new Function("return this")(), gcv = "__coverage__", coverageData = {
                path: "/home/mike/projects/axios-request/src/axios-request.js",
                statementMap: {
                  "0": {
                    start: {
                      line: 5,
                      column: 8
                    },
                    end: {
                      line: 5,
                      column: 27
                    }
                  },
                  "1": {
                    start: {
                      line: 6,
                      column: 8
                    },
                    end: {
                      line: 6,
                      column: 32
                    }
                  },
                  "2": {
                    start: {
                      line: 7,
                      column: 8
                    },
                    end: {
                      line: 7,
                      column: 26
                    }
                  },
                  "3": {
                    start: {
                      line: 8,
                      column: 8
                    },
                    end: {
                      line: 8,
                      column: 27
                    }
                  },
                  "4": {
                    start: {
                      line: 9,
                      column: 8
                    },
                    end: {
                      line: 9,
                      column: 36
                    }
                  },
                  "5": {
                    start: {
                      line: 10,
                      column: 8
                    },
                    end: {
                      line: 13,
                      column: 10
                    }
                  },
                  "6": {
                    start: {
                      line: 14,
                      column: 8
                    },
                    end: {
                      line: 14,
                      column: 33
                    }
                  },
                  "7": {
                    start: {
                      line: 15,
                      column: 8
                    },
                    end: {
                      line: 15,
                      column: 25
                    }
                  },
                  "8": {
                    start: {
                      line: 18,
                      column: 8
                    },
                    end: {
                      line: 18,
                      column: 59
                    }
                  },
                  "9": {
                    start: {
                      line: 21,
                      column: 8
                    },
                    end: {
                      line: 21,
                      column: 23
                    }
                  },
                  "10": {
                    start: {
                      line: 24,
                      column: 8
                    },
                    end: {
                      line: 24,
                      column: 40
                    }
                  },
                  "11": {
                    start: {
                      line: 27,
                      column: 8
                    },
                    end: {
                      line: 40,
                      column: 9
                    }
                  },
                  "12": {
                    start: {
                      line: 28,
                      column: 27
                    },
                    end: {
                      line: 28,
                      column: 53
                    }
                  },
                  "13": {
                    start: {
                      line: 29,
                      column: 28
                    },
                    end: {
                      line: 29,
                      column: 49
                    }
                  },
                  "14": {
                    start: {
                      line: 31,
                      column: 12
                    },
                    end: {
                      line: 33,
                      column: 13
                    }
                  },
                  "15": {
                    start: {
                      line: 32,
                      column: 16
                    },
                    end: {
                      line: 32,
                      column: 25
                    }
                  },
                  "16": {
                    start: {
                      line: 34,
                      column: 12
                    },
                    end: {
                      line: 36,
                      column: 13
                    }
                  },
                  "17": {
                    start: {
                      line: 35,
                      column: 16
                    },
                    end: {
                      line: 35,
                      column: 38
                    }
                  },
                  "18": {
                    start: {
                      line: 38,
                      column: 12
                    },
                    end: {
                      line: 38,
                      column: 100
                    }
                  },
                  "19": {
                    start: {
                      line: 38,
                      column: 66
                    },
                    end: {
                      line: 38,
                      column: 97
                    }
                  },
                  "20": {
                    start: {
                      line: 39,
                      column: 12
                    },
                    end: {
                      line: 39,
                      column: 102
                    }
                  },
                  "21": {
                    start: {
                      line: 39,
                      column: 61
                    },
                    end: {
                      line: 39,
                      column: 99
                    }
                  },
                  "22": {
                    start: {
                      line: 41,
                      column: 8
                    },
                    end: {
                      line: 41,
                      column: 20
                    }
                  },
                  "23": {
                    start: {
                      line: 44,
                      column: 8
                    },
                    end: {
                      line: 46,
                      column: 9
                    }
                  },
                  "24": {
                    start: {
                      line: 45,
                      column: 12
                    },
                    end: {
                      line: 45,
                      column: 42
                    }
                  },
                  "25": {
                    start: {
                      line: 47,
                      column: 8
                    },
                    end: {
                      line: 47,
                      column: 92
                    }
                  },
                  "26": {
                    start: {
                      line: 47,
                      column: 63
                    },
                    end: {
                      line: 47,
                      column: 90
                    }
                  },
                  "27": {
                    start: {
                      line: 50,
                      column: 8
                    },
                    end: {
                      line: 52,
                      column: 9
                    }
                  },
                  "28": {
                    start: {
                      line: 51,
                      column: 12
                    },
                    end: {
                      line: 51,
                      column: 52
                    }
                  },
                  "29": {
                    start: {
                      line: 53,
                      column: 8
                    },
                    end: {
                      line: 53,
                      column: 112
                    }
                  },
                  "30": {
                    start: {
                      line: 53,
                      column: 73
                    },
                    end: {
                      line: 53,
                      column: 110
                    }
                  },
                  "31": {
                    start: {
                      line: 56,
                      column: 8
                    },
                    end: {
                      line: 58,
                      column: 9
                    }
                  },
                  "32": {
                    start: {
                      line: 57,
                      column: 12
                    },
                    end: {
                      line: 57,
                      column: 43
                    }
                  },
                  "33": {
                    start: {
                      line: 59,
                      column: 8
                    },
                    end: {
                      line: 59,
                      column: 96
                    }
                  },
                  "34": {
                    start: {
                      line: 59,
                      column: 65
                    },
                    end: {
                      line: 59,
                      column: 94
                    }
                  },
                  "35": {
                    start: {
                      line: 62,
                      column: 8
                    },
                    end: {
                      line: 62,
                      column: 37
                    }
                  },
                  "36": {
                    start: {
                      line: 63,
                      column: 8
                    },
                    end: {
                      line: 63,
                      column: 38
                    }
                  },
                  "37": {
                    start: {
                      line: 66,
                      column: 8
                    },
                    end: {
                      line: 66,
                      column: 41
                    }
                  },
                  "38": {
                    start: {
                      line: 67,
                      column: 8
                    },
                    end: {
                      line: 67,
                      column: 24
                    }
                  },
                  "39": {
                    start: {
                      line: 70,
                      column: 8
                    },
                    end: {
                      line: 70,
                      column: 41
                    }
                  },
                  "40": {
                    start: {
                      line: 71,
                      column: 8
                    },
                    end: {
                      line: 71,
                      column: 47
                    }
                  },
                  "41": {
                    start: {
                      line: 72,
                      column: 8
                    },
                    end: {
                      line: 76,
                      column: 9
                    }
                  },
                  "42": {
                    start: {
                      line: 73,
                      column: 12
                    },
                    end: {
                      line: 73,
                      column: 53
                    }
                  },
                  "43": {
                    start: {
                      line: 75,
                      column: 12
                    },
                    end: {
                      line: 75,
                      column: 24
                    }
                  },
                  "44": {
                    start: {
                      line: 78,
                      column: 20
                    },
                    end: {
                      line: 81,
                      column: 5
                    }
                  },
                  "45": {
                    start: {
                      line: 79,
                      column: 30
                    },
                    end: {
                      line: 79,
                      column: 75
                    }
                  },
                  "46": {
                    start: {
                      line: 80,
                      column: 31
                    },
                    end: {
                      line: 80,
                      column: 77
                    }
                  },
                  "47": {
                    start: {
                      line: 82,
                      column: 21
                    },
                    end: {
                      line: 82,
                      column: 53
                    }
                  },
                  "48": {
                    start: {
                      line: 83,
                      column: 22
                    },
                    end: {
                      line: 83,
                      column: 55
                    }
                  },
                  "49": {
                    start: {
                      line: 85,
                      column: 8
                    },
                    end: {
                      line: 100,
                      column: 10
                    }
                  },
                  "50": {
                    start: {
                      line: 86,
                      column: 12
                    },
                    end: {
                      line: 86,
                      column: 50
                    }
                  },
                  "51": {
                    start: {
                      line: 88,
                      column: 12
                    },
                    end: {
                      line: 90,
                      column: 13
                    }
                  },
                  "52": {
                    start: {
                      line: 89,
                      column: 16
                    },
                    end: {
                      line: 89,
                      column: 47
                    }
                  },
                  "53": {
                    start: {
                      line: 91,
                      column: 12
                    },
                    end: {
                      line: 98,
                      column: 13
                    }
                  },
                  "54": {
                    start: {
                      line: 92,
                      column: 32
                    },
                    end: {
                      line: 94,
                      column: 24
                    }
                  },
                  "55": {
                    start: {
                      line: 93,
                      column: 20
                    },
                    end: {
                      line: 93,
                      column: 73
                    }
                  },
                  "56": {
                    start: {
                      line: 95,
                      column: 16
                    },
                    end: {
                      line: 95,
                      column: 49
                    }
                  },
                  "57": {
                    start: {
                      line: 97,
                      column: 16
                    },
                    end: {
                      line: 97,
                      column: 55
                    }
                  },
                  "58": {
                    start: {
                      line: 99,
                      column: 12
                    },
                    end: {
                      line: 99,
                      column: 28
                    }
                  },
                  "59": {
                    start: {
                      line: 106,
                      column: 12
                    },
                    end: {
                      line: 106,
                      column: 52
                    }
                  },
                  "60": {
                    start: {
                      line: 107,
                      column: 8
                    },
                    end: {
                      line: 109,
                      column: 9
                    }
                  },
                  "61": {
                    start: {
                      line: 108,
                      column: 12
                    },
                    end: {
                      line: 108,
                      column: 68
                    }
                  },
                  "62": {
                    start: {
                      line: 110,
                      column: 8
                    },
                    end: {
                      line: 112,
                      column: 9
                    }
                  },
                  "63": {
                    start: {
                      line: 111,
                      column: 12
                    },
                    end: {
                      line: 111,
                      column: 32
                    }
                  },
                  "64": {
                    start: {
                      line: 113,
                      column: 8
                    },
                    end: {
                      line: 113,
                      column: 43
                    }
                  },
                  "65": {
                    start: {
                      line: 114,
                      column: 8
                    },
                    end: {
                      line: 114,
                      column: 36
                    }
                  },
                  "66": {
                    start: {
                      line: 115,
                      column: 8
                    },
                    end: {
                      line: 124,
                      column: 70
                    }
                  },
                  "67": {
                    start: {
                      line: 120,
                      column: 16
                    },
                    end: {
                      line: 120,
                      column: 47
                    }
                  },
                  "68": {
                    start: {
                      line: 123,
                      column: 25
                    },
                    end: {
                      line: 123,
                      column: 66
                    }
                  },
                  "69": {
                    start: {
                      line: 124,
                      column: 26
                    },
                    end: {
                      line: 124,
                      column: 68
                    }
                  }
                },
                fnMap: {
                  "0": {
                    name: "(anonymous_0)",
                    decl: {
                      start: {
                        line: 4,
                        column: 4
                      },
                      end: {
                        line: 4,
                        column: 5
                      }
                    },
                    loc: {
                      start: {
                        line: 4,
                        column: 35
                      },
                      end: {
                        line: 16,
                        column: 5
                      }
                    },
                    line: 4
                  },
                  "1": {
                    name: "(anonymous_1)",
                    decl: {
                      start: {
                        line: 17,
                        column: 17
                      },
                      end: {
                        line: 17,
                        column: 18
                      }
                    },
                    loc: {
                      start: {
                        line: 17,
                        column: 30
                      },
                      end: {
                        line: 19,
                        column: 5
                      }
                    },
                    line: 17
                  },
                  "2": {
                    name: "(anonymous_2)",
                    decl: {
                      start: {
                        line: 20,
                        column: 13
                      },
                      end: {
                        line: 20,
                        column: 14
                      }
                    },
                    loc: {
                      start: {
                        line: 20,
                        column: 22
                      },
                      end: {
                        line: 22,
                        column: 5
                      }
                    },
                    line: 20
                  },
                  "3": {
                    name: "(anonymous_3)",
                    decl: {
                      start: {
                        line: 23,
                        column: 17
                      },
                      end: {
                        line: 23,
                        column: 18
                      }
                    },
                    loc: {
                      start: {
                        line: 23,
                        column: 38
                      },
                      end: {
                        line: 25,
                        column: 5
                      }
                    },
                    line: 23
                  },
                  "4": {
                    name: "(anonymous_4)",
                    decl: {
                      start: {
                        line: 26,
                        column: 13
                      },
                      end: {
                        line: 26,
                        column: 14
                      }
                    },
                    loc: {
                      start: {
                        line: 26,
                        column: 25
                      },
                      end: {
                        line: 42,
                        column: 5
                      }
                    },
                    line: 26
                  },
                  "5": {
                    name: "(anonymous_5)",
                    decl: {
                      start: {
                        line: 38,
                        column: 52
                      },
                      end: {
                        line: 38,
                        column: 53
                      }
                    },
                    loc: {
                      start: {
                        line: 38,
                        column: 66
                      },
                      end: {
                        line: 38,
                        column: 97
                      }
                    },
                    line: 38
                  },
                  "6": {
                    name: "(anonymous_6)",
                    decl: {
                      start: {
                        line: 39,
                        column: 47
                      },
                      end: {
                        line: 39,
                        column: 48
                      }
                    },
                    loc: {
                      start: {
                        line: 39,
                        column: 61
                      },
                      end: {
                        line: 39,
                        column: 99
                      }
                    },
                    line: 39
                  },
                  "7": {
                    name: "(anonymous_7)",
                    decl: {
                      start: {
                        line: 43,
                        column: 16
                      },
                      end: {
                        line: 43,
                        column: 17
                      }
                    },
                    loc: {
                      start: {
                        line: 43,
                        column: 28
                      },
                      end: {
                        line: 48,
                        column: 5
                      }
                    },
                    line: 43
                  },
                  "8": {
                    name: "(anonymous_8)",
                    decl: {
                      start: {
                        line: 47,
                        column: 46
                      },
                      end: {
                        line: 47,
                        column: 47
                      }
                    },
                    loc: {
                      start: {
                        line: 47,
                        column: 63
                      },
                      end: {
                        line: 47,
                        column: 90
                      }
                    },
                    line: 47
                  },
                  "9": {
                    name: "(anonymous_9)",
                    decl: {
                      start: {
                        line: 49,
                        column: 16
                      },
                      end: {
                        line: 49,
                        column: 17
                      }
                    },
                    loc: {
                      start: {
                        line: 49,
                        column: 28
                      },
                      end: {
                        line: 54,
                        column: 5
                      }
                    },
                    line: 49
                  },
                  "10": {
                    name: "(anonymous_10)",
                    decl: {
                      start: {
                        line: 53,
                        column: 56
                      },
                      end: {
                        line: 53,
                        column: 57
                      }
                    },
                    loc: {
                      start: {
                        line: 53,
                        column: 73
                      },
                      end: {
                        line: 53,
                        column: 110
                      }
                    },
                    line: 53
                  },
                  "11": {
                    name: "(anonymous_11)",
                    decl: {
                      start: {
                        line: 55,
                        column: 17
                      },
                      end: {
                        line: 55,
                        column: 18
                      }
                    },
                    loc: {
                      start: {
                        line: 55,
                        column: 29
                      },
                      end: {
                        line: 60,
                        column: 5
                      }
                    },
                    line: 55
                  },
                  "12": {
                    name: "(anonymous_12)",
                    decl: {
                      start: {
                        line: 59,
                        column: 47
                      },
                      end: {
                        line: 59,
                        column: 48
                      }
                    },
                    loc: {
                      start: {
                        line: 59,
                        column: 65
                      },
                      end: {
                        line: 59,
                        column: 94
                      }
                    },
                    line: 59
                  },
                  "13": {
                    name: "(anonymous_13)",
                    decl: {
                      start: {
                        line: 61,
                        column: 26
                      },
                      end: {
                        line: 61,
                        column: 27
                      }
                    },
                    loc: {
                      start: {
                        line: 61,
                        column: 38
                      },
                      end: {
                        line: 64,
                        column: 5
                      }
                    },
                    line: 61
                  },
                  "14": {
                    name: "(anonymous_14)",
                    decl: {
                      start: {
                        line: 65,
                        column: 30
                      },
                      end: {
                        line: 65,
                        column: 31
                      }
                    },
                    loc: {
                      start: {
                        line: 65,
                        column: 52
                      },
                      end: {
                        line: 68,
                        column: 5
                      }
                    },
                    line: 65
                  },
                  "15": {
                    name: "(anonymous_15)",
                    decl: {
                      start: {
                        line: 69,
                        column: 31
                      },
                      end: {
                        line: 69,
                        column: 32
                      }
                    },
                    loc: {
                      start: {
                        line: 69,
                        column: 50
                      },
                      end: {
                        line: 77,
                        column: 5
                      }
                    },
                    line: 69
                  },
                  "16": {
                    name: "(anonymous_16)",
                    decl: {
                      start: {
                        line: 78,
                        column: 11
                      },
                      end: {
                        line: 78,
                        column: 12
                      }
                    },
                    loc: {
                      start: {
                        line: 78,
                        column: 20
                      },
                      end: {
                        line: 81,
                        column: 5
                      }
                    },
                    line: 78
                  },
                  "17": {
                    name: "(anonymous_17)",
                    decl: {
                      start: {
                        line: 79,
                        column: 13
                      },
                      end: {
                        line: 79,
                        column: 14
                      }
                    },
                    loc: {
                      start: {
                        line: 79,
                        column: 30
                      },
                      end: {
                        line: 79,
                        column: 75
                      }
                    },
                    line: 79
                  },
                  "18": {
                    name: "(anonymous_18)",
                    decl: {
                      start: {
                        line: 80,
                        column: 14
                      },
                      end: {
                        line: 80,
                        column: 15
                      }
                    },
                    loc: {
                      start: {
                        line: 80,
                        column: 31
                      },
                      end: {
                        line: 80,
                        column: 77
                      }
                    },
                    line: 80
                  },
                  "19": {
                    name: "(anonymous_19)",
                    decl: {
                      start: {
                        line: 82,
                        column: 10
                      },
                      end: {
                        line: 82,
                        column: 11
                      }
                    },
                    loc: {
                      start: {
                        line: 82,
                        column: 21
                      },
                      end: {
                        line: 82,
                        column: 53
                      }
                    },
                    line: 82
                  },
                  "20": {
                    name: "(anonymous_20)",
                    decl: {
                      start: {
                        line: 83,
                        column: 11
                      },
                      end: {
                        line: 83,
                        column: 12
                      }
                    },
                    loc: {
                      start: {
                        line: 83,
                        column: 22
                      },
                      end: {
                        line: 83,
                        column: 55
                      }
                    },
                    line: 83
                  },
                  "21": {
                    name: "(anonymous_21)",
                    decl: {
                      start: {
                        line: 84,
                        column: 21
                      },
                      end: {
                        line: 84,
                        column: 22
                      }
                    },
                    loc: {
                      start: {
                        line: 85,
                        column: 8
                      },
                      end: {
                        line: 100,
                        column: 10
                      }
                    },
                    line: 85
                  },
                  "22": {
                    name: "(anonymous_22)",
                    decl: {
                      start: {
                        line: 85,
                        column: 57
                      },
                      end: {
                        line: 85,
                        column: 58
                      }
                    },
                    loc: {
                      start: {
                        line: 85,
                        column: 71
                      },
                      end: {
                        line: 100,
                        column: 9
                      }
                    },
                    line: 85
                  },
                  "23": {
                    name: "(anonymous_23)",
                    decl: {
                      start: {
                        line: 92,
                        column: 43
                      },
                      end: {
                        line: 92,
                        column: 44
                      }
                    },
                    loc: {
                      start: {
                        line: 92,
                        column: 49
                      },
                      end: {
                        line: 94,
                        column: 17
                      }
                    },
                    line: 92
                  },
                  "24": {
                    name: "(anonymous_24)",
                    decl: {
                      start: {
                        line: 101,
                        column: 18
                      },
                      end: {
                        line: 101,
                        column: 19
                      }
                    },
                    loc: {
                      start: {
                        line: 101,
                        column: 54
                      },
                      end: {
                        line: 125,
                        column: 5
                      }
                    },
                    line: 101
                  },
                  "25": {
                    name: "(anonymous_25)",
                    decl: {
                      start: {
                        line: 119,
                        column: 47
                      },
                      end: {
                        line: 119,
                        column: 48
                      }
                    },
                    loc: {
                      start: {
                        line: 119,
                        column: 54
                      },
                      end: {
                        line: 121,
                        column: 13
                      }
                    },
                    line: 119
                  },
                  "26": {
                    name: "(anonymous_26)",
                    decl: {
                      start: {
                        line: 123,
                        column: 18
                      },
                      end: {
                        line: 123,
                        column: 19
                      }
                    },
                    loc: {
                      start: {
                        line: 123,
                        column: 25
                      },
                      end: {
                        line: 123,
                        column: 66
                      }
                    },
                    line: 123
                  },
                  "27": {
                    name: "(anonymous_27)",
                    decl: {
                      start: {
                        line: 124,
                        column: 19
                      },
                      end: {
                        line: 124,
                        column: 20
                      }
                    },
                    loc: {
                      start: {
                        line: 124,
                        column: 26
                      },
                      end: {
                        line: 124,
                        column: 68
                      }
                    },
                    line: 124
                  }
                },
                branchMap: {
                  "0": {
                    loc: {
                      start: {
                        line: 4,
                        column: 21
                      },
                      end: {
                        line: 4,
                        column: 33
                      }
                    },
                    type: "default-arg",
                    locations: [{
                      start: {
                        line: 4,
                        column: 31
                      },
                      end: {
                        line: 4,
                        column: 33
                      }
                    }],
                    line: 4
                  },
                  "1": {
                    loc: {
                      start: {
                        line: 27,
                        column: 8
                      },
                      end: {
                        line: 40,
                        column: 9
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 27,
                        column: 8
                      },
                      end: {
                        line: 40,
                        column: 9
                      }
                    }, {
                      start: {
                        line: 27,
                        column: 8
                      },
                      end: {
                        line: 40,
                        column: 9
                      }
                    }],
                    line: 27
                  },
                  "2": {
                    loc: {
                      start: {
                        line: 31,
                        column: 12
                      },
                      end: {
                        line: 33,
                        column: 13
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 31,
                        column: 12
                      },
                      end: {
                        line: 33,
                        column: 13
                      }
                    }, {
                      start: {
                        line: 31,
                        column: 12
                      },
                      end: {
                        line: 33,
                        column: 13
                      }
                    }],
                    line: 31
                  },
                  "3": {
                    loc: {
                      start: {
                        line: 34,
                        column: 12
                      },
                      end: {
                        line: 36,
                        column: 13
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 34,
                        column: 12
                      },
                      end: {
                        line: 36,
                        column: 13
                      }
                    }, {
                      start: {
                        line: 34,
                        column: 12
                      },
                      end: {
                        line: 36,
                        column: 13
                      }
                    }],
                    line: 34
                  },
                  "4": {
                    loc: {
                      start: {
                        line: 44,
                        column: 8
                      },
                      end: {
                        line: 46,
                        column: 9
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 44,
                        column: 8
                      },
                      end: {
                        line: 46,
                        column: 9
                      }
                    }, {
                      start: {
                        line: 44,
                        column: 8
                      },
                      end: {
                        line: 46,
                        column: 9
                      }
                    }],
                    line: 44
                  },
                  "5": {
                    loc: {
                      start: {
                        line: 50,
                        column: 8
                      },
                      end: {
                        line: 52,
                        column: 9
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 50,
                        column: 8
                      },
                      end: {
                        line: 52,
                        column: 9
                      }
                    }, {
                      start: {
                        line: 50,
                        column: 8
                      },
                      end: {
                        line: 52,
                        column: 9
                      }
                    }],
                    line: 50
                  },
                  "6": {
                    loc: {
                      start: {
                        line: 56,
                        column: 8
                      },
                      end: {
                        line: 58,
                        column: 9
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 56,
                        column: 8
                      },
                      end: {
                        line: 58,
                        column: 9
                      }
                    }, {
                      start: {
                        line: 56,
                        column: 8
                      },
                      end: {
                        line: 58,
                        column: 9
                      }
                    }],
                    line: 56
                  },
                  "7": {
                    loc: {
                      start: {
                        line: 72,
                        column: 8
                      },
                      end: {
                        line: 76,
                        column: 9
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 72,
                        column: 8
                      },
                      end: {
                        line: 76,
                        column: 9
                      }
                    }, {
                      start: {
                        line: 72,
                        column: 8
                      },
                      end: {
                        line: 76,
                        column: 9
                      }
                    }],
                    line: 72
                  },
                  "8": {
                    loc: {
                      start: {
                        line: 88,
                        column: 12
                      },
                      end: {
                        line: 90,
                        column: 13
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 88,
                        column: 12
                      },
                      end: {
                        line: 90,
                        column: 13
                      }
                    }, {
                      start: {
                        line: 88,
                        column: 12
                      },
                      end: {
                        line: 90,
                        column: 13
                      }
                    }],
                    line: 88
                  },
                  "9": {
                    loc: {
                      start: {
                        line: 91,
                        column: 12
                      },
                      end: {
                        line: 98,
                        column: 13
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 91,
                        column: 12
                      },
                      end: {
                        line: 98,
                        column: 13
                      }
                    }, {
                      start: {
                        line: 91,
                        column: 12
                      },
                      end: {
                        line: 98,
                        column: 13
                      }
                    }],
                    line: 91
                  },
                  "10": {
                    loc: {
                      start: {
                        line: 91,
                        column: 16
                      },
                      end: {
                        line: 91,
                        column: 49
                      }
                    },
                    type: "binary-expr",
                    locations: [{
                      start: {
                        line: 91,
                        column: 16
                      },
                      end: {
                        line: 91,
                        column: 20
                      }
                    }, {
                      start: {
                        line: 91,
                        column: 24
                      },
                      end: {
                        line: 91,
                        column: 49
                      }
                    }],
                    line: 91
                  },
                  "11": {
                    loc: {
                      start: {
                        line: 101,
                        column: 27
                      },
                      end: {
                        line: 101,
                        column: 39
                      }
                    },
                    type: "default-arg",
                    locations: [{
                      start: {
                        line: 101,
                        column: 37
                      },
                      end: {
                        line: 101,
                        column: 39
                      }
                    }],
                    line: 101
                  },
                  "12": {
                    loc: {
                      start: {
                        line: 107,
                        column: 8
                      },
                      end: {
                        line: 109,
                        column: 9
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 107,
                        column: 8
                      },
                      end: {
                        line: 109,
                        column: 9
                      }
                    }, {
                      start: {
                        line: 107,
                        column: 8
                      },
                      end: {
                        line: 109,
                        column: 9
                      }
                    }],
                    line: 107
                  },
                  "13": {
                    loc: {
                      start: {
                        line: 107,
                        column: 12
                      },
                      end: {
                        line: 107,
                        column: 59
                      }
                    },
                    type: "binary-expr",
                    locations: [{
                      start: {
                        line: 107,
                        column: 12
                      },
                      end: {
                        line: 107,
                        column: 20
                      }
                    }, {
                      start: {
                        line: 107,
                        column: 24
                      },
                      end: {
                        line: 107,
                        column: 33
                      }
                    }, {
                      start: {
                        line: 107,
                        column: 37
                      },
                      end: {
                        line: 107,
                        column: 59
                      }
                    }],
                    line: 107
                  },
                  "14": {
                    loc: {
                      start: {
                        line: 110,
                        column: 8
                      },
                      end: {
                        line: 112,
                        column: 9
                      }
                    },
                    type: "if",
                    locations: [{
                      start: {
                        line: 110,
                        column: 8
                      },
                      end: {
                        line: 112,
                        column: 9
                      }
                    }, {
                      start: {
                        line: 110,
                        column: 8
                      },
                      end: {
                        line: 112,
                        column: 9
                      }
                    }],
                    line: 110
                  }
                },
                s: {
                  "0": 0,
                  "1": 0,
                  "2": 0,
                  "3": 0,
                  "4": 0,
                  "5": 0,
                  "6": 0,
                  "7": 0,
                  "8": 0,
                  "9": 0,
                  "10": 0,
                  "11": 0,
                  "12": 0,
                  "13": 0,
                  "14": 0,
                  "15": 0,
                  "16": 0,
                  "17": 0,
                  "18": 0,
                  "19": 0,
                  "20": 0,
                  "21": 0,
                  "22": 0,
                  "23": 0,
                  "24": 0,
                  "25": 0,
                  "26": 0,
                  "27": 0,
                  "28": 0,
                  "29": 0,
                  "30": 0,
                  "31": 0,
                  "32": 0,
                  "33": 0,
                  "34": 0,
                  "35": 0,
                  "36": 0,
                  "37": 0,
                  "38": 0,
                  "39": 0,
                  "40": 0,
                  "41": 0,
                  "42": 0,
                  "43": 0,
                  "44": 0,
                  "45": 0,
                  "46": 0,
                  "47": 0,
                  "48": 0,
                  "49": 0,
                  "50": 0,
                  "51": 0,
                  "52": 0,
                  "53": 0,
                  "54": 0,
                  "55": 0,
                  "56": 0,
                  "57": 0,
                  "58": 0,
                  "59": 0,
                  "60": 0,
                  "61": 0,
                  "62": 0,
                  "63": 0,
                  "64": 0,
                  "65": 0,
                  "66": 0,
                  "67": 0,
                  "68": 0,
                  "69": 0
                },
                f: {
                  "0": 0,
                  "1": 0,
                  "2": 0,
                  "3": 0,
                  "4": 0,
                  "5": 0,
                  "6": 0,
                  "7": 0,
                  "8": 0,
                  "9": 0,
                  "10": 0,
                  "11": 0,
                  "12": 0,
                  "13": 0,
                  "14": 0,
                  "15": 0,
                  "16": 0,
                  "17": 0,
                  "18": 0,
                  "19": 0,
                  "20": 0,
                  "21": 0,
                  "22": 0,
                  "23": 0,
                  "24": 0,
                  "25": 0,
                  "26": 0,
                  "27": 0
                },
                b: {
                  "0": [0],
                  "1": [0, 0],
                  "2": [0, 0],
                  "3": [0, 0],
                  "4": [0, 0],
                  "5": [0, 0],
                  "6": [0, 0],
                  "7": [0, 0],
                  "8": [0, 0],
                  "9": [0, 0],
                  "10": [0, 0],
                  "11": [0],
                  "12": [0, 0],
                  "13": [0, 0, 0],
                  "14": [0, 0]
                },
                _coverageSchema: "332fd63041d2c1bcb487cc26dd0d5f7d97098a6c"
              }, coverage = global2[gcv] || (global2[gcv] = {});
              if (coverage[path] && coverage[path].hash === hash4) {
                return coverage[path];
              }
              coverageData.hash = hash4;
              return coverage[path] = coverageData;
            }();
            var _extends3 = Object.assign || function(target) {
              for (var i2 = 1; i2 < arguments.length; i2++) {
                var source = arguments[i2];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _axios = __webpack_require__(11);
            var _axios2 = _interopRequireDefault(_axios);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _objectWithoutProperties2(obj, keys) {
              var target = {};
              for (var i2 in obj) {
                if (keys.indexOf(i2) >= 0)
                  continue;
                if (!Object.prototype.hasOwnProperty.call(obj, i2))
                  continue;
                target[i2] = obj[i2];
              }
              return target;
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Request2 = function Request3(url) {
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (cov_15j8tpybze.b[0][0]++, {});
              _classCallCheck(this, Request3);
              _initialiseProps.call(this);
              cov_15j8tpybze.f[0]++;
              cov_15j8tpybze.s[0]++;
              this.timeouts = {};
              cov_15j8tpybze.s[1]++;
              this.cancelMethods = {};
              cov_15j8tpybze.s[2]++;
              this.pending = {};
              cov_15j8tpybze.s[3]++;
              this.updating = {};
              cov_15j8tpybze.s[4]++;
              this.pollingInProgress = {};
              cov_15j8tpybze.s[5]++;
              this.options = {
                lockable: false,
                cancelable: true
              };
              cov_15j8tpybze.s[6]++;
              this.setOptions(options);
              cov_15j8tpybze.s[7]++;
              this.setUrl(url);
            };
            var _initialiseProps = function _initialiseProps2() {
              var _this = this;
              this.setOptions = function(options) {
                cov_15j8tpybze.f[1]++;
                cov_15j8tpybze.s[8]++;
                _this.option = Object.assign(_this.options, options);
              };
              this.setUrl = function(url) {
                cov_15j8tpybze.f[2]++;
                cov_15j8tpybze.s[9]++;
                _this.url = url;
              };
              this.setTimeout = function(timeout, method) {
                cov_15j8tpybze.f[3]++;
                cov_15j8tpybze.s[10]++;
                _this.timeouts[method] = timeout;
              };
              this.cancel = function(method) {
                cov_15j8tpybze.f[4]++;
                cov_15j8tpybze.s[11]++;
                if (method) {
                  cov_15j8tpybze.b[1][0]++;
                  var cancel = (cov_15j8tpybze.s[12]++, _this.cancelMethods[method]);
                  var timeout = (cov_15j8tpybze.s[13]++, _this.timeouts[method]);
                  cov_15j8tpybze.s[14]++;
                  if (typeof cancel === "function") {
                    cov_15j8tpybze.b[2][0]++;
                    cov_15j8tpybze.s[15]++;
                    cancel();
                  } else {
                    cov_15j8tpybze.b[2][1]++;
                  }
                  cov_15j8tpybze.s[16]++;
                  if (timeout) {
                    cov_15j8tpybze.b[3][0]++;
                    cov_15j8tpybze.s[17]++;
                    clearTimeout(timeout);
                  } else {
                    cov_15j8tpybze.b[3][1]++;
                  }
                } else {
                  cov_15j8tpybze.b[1][1]++;
                  cov_15j8tpybze.s[18]++;
                  Object.keys(_this.cancelMethods).forEach(function(reqMethod) {
                    cov_15j8tpybze.f[5]++;
                    cov_15j8tpybze.s[19]++;
                    return _this.cancelMethods[reqMethod]();
                  });
                  cov_15j8tpybze.s[20]++;
                  Object.keys(_this.timeouts).forEach(function(reqMethod) {
                    cov_15j8tpybze.f[6]++;
                    cov_15j8tpybze.s[21]++;
                    return clearTimeout(_this.timeouts[reqMethod]);
                  });
                }
                cov_15j8tpybze.s[22]++;
                return _this;
              };
              this.isPending = function(method) {
                cov_15j8tpybze.f[7]++;
                cov_15j8tpybze.s[23]++;
                if (method) {
                  cov_15j8tpybze.b[4][0]++;
                  cov_15j8tpybze.s[24]++;
                  return !!_this.pending[method];
                } else {
                  cov_15j8tpybze.b[4][1]++;
                }
                cov_15j8tpybze.s[25]++;
                return Object.keys(_this.pending).some(function(pendingMethod) {
                  cov_15j8tpybze.f[8]++;
                  cov_15j8tpybze.s[26]++;
                  return _this.pending[pendingMethod];
                });
              };
              this.isPolling = function(method) {
                cov_15j8tpybze.f[9]++;
                cov_15j8tpybze.s[27]++;
                if (method) {
                  cov_15j8tpybze.b[5][0]++;
                  cov_15j8tpybze.s[28]++;
                  return !!_this.pollingInProgress[method];
                } else {
                  cov_15j8tpybze.b[5][1]++;
                }
                cov_15j8tpybze.s[29]++;
                return Object.keys(_this.pollingInProgress).some(function(pollingMethod) {
                  cov_15j8tpybze.f[10]++;
                  cov_15j8tpybze.s[30]++;
                  return _this.pollingInProgress[pollingMethod];
                });
              };
              this.isUpdating = function(method) {
                cov_15j8tpybze.f[11]++;
                cov_15j8tpybze.s[31]++;
                if (method) {
                  cov_15j8tpybze.b[6][0]++;
                  cov_15j8tpybze.s[32]++;
                  return !!_this.updating[method];
                } else {
                  cov_15j8tpybze.b[6][1]++;
                }
                cov_15j8tpybze.s[33]++;
                return Object.keys(_this.updating).some(function(updatingMethod) {
                  cov_15j8tpybze.f[12]++;
                  cov_15j8tpybze.s[34]++;
                  return _this.updating[updatingMethod];
                });
              };
              this.setOffPendingStatus = function(method) {
                cov_15j8tpybze.f[13]++;
                cov_15j8tpybze.s[35]++;
                _this.pending[method] = false;
                cov_15j8tpybze.s[36]++;
                _this.updating[method] = false;
              };
              this.setOffPendingStatusThen = function(response, method) {
                cov_15j8tpybze.f[14]++;
                cov_15j8tpybze.s[37]++;
                _this.setOffPendingStatus(method);
                cov_15j8tpybze.s[38]++;
                return response;
              };
              this.setOffPendingStatusCatch = function(error, method) {
                cov_15j8tpybze.f[15]++;
                cov_15j8tpybze.s[39]++;
                _this.setOffPendingStatus(method);
                cov_15j8tpybze.s[40]++;
                _this.pollingInProgress[method] = false;
                cov_15j8tpybze.s[41]++;
                if (_this.options.errorHandler) {
                  cov_15j8tpybze.b[7][0]++;
                  cov_15j8tpybze.s[42]++;
                  _this.options.errorHandler(error, method);
                } else {
                  cov_15j8tpybze.b[7][1]++;
                  cov_15j8tpybze.s[43]++;
                  throw error;
                }
              };
              this.poll = function(time) {
                cov_15j8tpybze.f[16]++;
                cov_15j8tpybze.s[44]++;
                return {
                  get: function get2(cl, options) {
                    cov_15j8tpybze.f[17]++;
                    cov_15j8tpybze.s[45]++;
                    return _this.pollingRequest(cl, options, time, "get");
                  },
                  post: function post(cl, options) {
                    cov_15j8tpybze.f[18]++;
                    cov_15j8tpybze.s[46]++;
                    return _this.pollingRequest(cl, options, time, "post");
                  }
                };
              };
              this.get = function(options) {
                cov_15j8tpybze.f[19]++;
                cov_15j8tpybze.s[47]++;
                return _this.sendRequest("get", options);
              };
              this.post = function(options) {
                cov_15j8tpybze.f[20]++;
                cov_15j8tpybze.s[48]++;
                return _this.sendRequest("post", options);
              };
              this.pollingRequest = function(cl, options, time, method, updating) {
                cov_15j8tpybze.f[21]++;
                cov_15j8tpybze.s[49]++;
                return _this.sendRequest(method, options, updating).then(function(response) {
                  cov_15j8tpybze.f[22]++;
                  cov_15j8tpybze.s[50]++;
                  _this.pollingInProgress[method] = true;
                  var continuePolling = void 0;
                  cov_15j8tpybze.s[51]++;
                  if (cl) {
                    cov_15j8tpybze.b[8][0]++;
                    cov_15j8tpybze.s[52]++;
                    continuePolling = cl(response);
                  } else {
                    cov_15j8tpybze.b[8][1]++;
                  }
                  cov_15j8tpybze.s[53]++;
                  if ((cov_15j8tpybze.b[10][0]++, time) && (cov_15j8tpybze.b[10][1]++, continuePolling !== false)) {
                    cov_15j8tpybze.b[9][0]++;
                    var timeOut = (cov_15j8tpybze.s[54]++, setTimeout(function() {
                      cov_15j8tpybze.f[23]++;
                      cov_15j8tpybze.s[55]++;
                      _this.pollingRequest(cl, options, time, method, true);
                    }, time));
                    cov_15j8tpybze.s[56]++;
                    _this.setTimeout(timeOut, method);
                  } else {
                    cov_15j8tpybze.b[9][1]++;
                    cov_15j8tpybze.s[57]++;
                    _this.pollingInProgress[method] = false;
                  }
                  cov_15j8tpybze.s[58]++;
                  return response;
                });
              };
              this.sendRequest = function(method) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (cov_15j8tpybze.b[11][0]++, {});
                var updating = arguments[2];
                cov_15j8tpybze.f[24]++;
                var _ref = (cov_15j8tpybze.s[59]++, Object.assign({}, _this.options, options)), lockable = _ref.lockable, cancelable = _ref.cancelable, axiosOption = _objectWithoutProperties2(_ref, ["lockable", "cancelable"]);
                cov_15j8tpybze.s[60]++;
                if ((cov_15j8tpybze.b[13][0]++, lockable) && (cov_15j8tpybze.b[13][1]++, !updating) && (cov_15j8tpybze.b[13][2]++, _this.isPending(method))) {
                  cov_15j8tpybze.b[12][0]++;
                  cov_15j8tpybze.s[61]++;
                  return Promise.reject(new Error("Request in progress"));
                } else {
                  cov_15j8tpybze.b[12][1]++;
                }
                cov_15j8tpybze.s[62]++;
                if (cancelable) {
                  cov_15j8tpybze.b[14][0]++;
                  cov_15j8tpybze.s[63]++;
                  _this.cancel(method);
                } else {
                  cov_15j8tpybze.b[14][1]++;
                }
                cov_15j8tpybze.s[64]++;
                _this.updating[method] = !!updating;
                cov_15j8tpybze.s[65]++;
                _this.pending[method] = true;
                cov_15j8tpybze.s[66]++;
                return (0, _axios2.default)(_extends3({}, axiosOption, {
                  method,
                  url: _this.url,
                  cancelToken: new _axios2.default.CancelToken(function(c2) {
                    cov_15j8tpybze.f[25]++;
                    cov_15j8tpybze.s[67]++;
                    _this.cancelMethods[method] = c2;
                  })
                })).then(function(res) {
                  cov_15j8tpybze.f[26]++;
                  cov_15j8tpybze.s[68]++;
                  return _this.setOffPendingStatusThen(res, method);
                }).catch(function(err) {
                  cov_15j8tpybze.f[27]++;
                  cov_15j8tpybze.s[69]++;
                  return _this.setOffPendingStatusCatch(err, method);
                });
              };
            };
            exports3.default = Request2;
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = __webpack_require__(12);
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            var bind = __webpack_require__(1);
            var Axios = __webpack_require__(14);
            var mergeConfig2 = __webpack_require__(7);
            var defaults2 = __webpack_require__(4);
            function createInstance(defaultConfig) {
              var context = new Axios(defaultConfig);
              var instance = bind(Axios.prototype.request, context);
              utils.extend(instance, Axios.prototype, context);
              utils.extend(instance, context);
              return instance;
            }
            var axios2 = createInstance(defaults2);
            axios2.Axios = Axios;
            axios2.create = function create(instanceConfig) {
              return createInstance(mergeConfig2(axios2.defaults, instanceConfig));
            };
            axios2.Cancel = __webpack_require__(8);
            axios2.CancelToken = __webpack_require__(27);
            axios2.isCancel = __webpack_require__(3);
            axios2.all = function all(promises) {
              return Promise.all(promises);
            };
            axios2.spread = __webpack_require__(28);
            module3.exports = axios2;
            module3.exports.default = axios2;
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = function isBuffer(obj) {
              return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            var buildURL = __webpack_require__(2);
            var InterceptorManager = __webpack_require__(15);
            var dispatchRequest = __webpack_require__(16);
            var mergeConfig2 = __webpack_require__(7);
            function Axios(instanceConfig) {
              this.defaults = instanceConfig;
              this.interceptors = {
                request: new InterceptorManager(),
                response: new InterceptorManager()
              };
            }
            Axios.prototype.request = function request(config) {
              if (typeof config === "string") {
                config = arguments[1] || {};
                config.url = arguments[0];
              } else {
                config = config || {};
              }
              config = mergeConfig2(this.defaults, config);
              config.method = config.method ? config.method.toLowerCase() : "get";
              var chain = [dispatchRequest, void 0];
              var promise = Promise.resolve(config);
              this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
                chain.unshift(interceptor.fulfilled, interceptor.rejected);
              });
              this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
                chain.push(interceptor.fulfilled, interceptor.rejected);
              });
              while (chain.length) {
                promise = promise.then(chain.shift(), chain.shift());
              }
              return promise;
            };
            Axios.prototype.getUri = function getUri(config) {
              config = mergeConfig2(this.defaults, config);
              return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
            };
            utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
              Axios.prototype[method] = function(url, config) {
                return this.request(utils.merge(config || {}, {
                  method,
                  url
                }));
              };
            });
            utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
              Axios.prototype[method] = function(url, data, config) {
                return this.request(utils.merge(config || {}, {
                  method,
                  url,
                  data
                }));
              };
            });
            module3.exports = Axios;
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            function InterceptorManager() {
              this.handlers = [];
            }
            InterceptorManager.prototype.use = function use(fulfilled, rejected) {
              this.handlers.push({
                fulfilled,
                rejected
              });
              return this.handlers.length - 1;
            };
            InterceptorManager.prototype.eject = function eject(id) {
              if (this.handlers[id]) {
                this.handlers[id] = null;
              }
            };
            InterceptorManager.prototype.forEach = function forEach(fn2) {
              utils.forEach(this.handlers, function forEachHandler(h2) {
                if (h2 !== null) {
                  fn2(h2);
                }
              });
            };
            module3.exports = InterceptorManager;
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            var transformData = __webpack_require__(17);
            var isCancel = __webpack_require__(3);
            var defaults2 = __webpack_require__(4);
            var isAbsoluteURL = __webpack_require__(25);
            var combineURLs = __webpack_require__(26);
            function throwIfCancellationRequested(config) {
              if (config.cancelToken) {
                config.cancelToken.throwIfRequested();
              }
            }
            module3.exports = function dispatchRequest(config) {
              throwIfCancellationRequested(config);
              if (config.baseURL && !isAbsoluteURL(config.url)) {
                config.url = combineURLs(config.baseURL, config.url);
              }
              config.headers = config.headers || {};
              config.data = transformData(config.data, config.headers, config.transformRequest);
              config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});
              utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
                delete config.headers[method];
              });
              var adapter = config.adapter || defaults2.adapter;
              return adapter(config).then(function onAdapterResolution(response) {
                throwIfCancellationRequested(config);
                response.data = transformData(response.data, response.headers, config.transformResponse);
                return response;
              }, function onAdapterRejection(reason) {
                if (!isCancel(reason)) {
                  throwIfCancellationRequested(config);
                  if (reason && reason.response) {
                    reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
                  }
                }
                return Promise.reject(reason);
              });
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            module3.exports = function transformData(data, headers, fns) {
              utils.forEach(fns, function transform(fn2) {
                data = fn2(data, headers);
              });
              return data;
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var process2 = module3.exports = {};
            var cachedSetTimeout;
            var cachedClearTimeout;
            function defaultSetTimout() {
              throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
              throw new Error("clearTimeout has not been defined");
            }
            (function() {
              try {
                if (typeof setTimeout === "function") {
                  cachedSetTimeout = setTimeout;
                } else {
                  cachedSetTimeout = defaultSetTimout;
                }
              } catch (e3) {
                cachedSetTimeout = defaultSetTimout;
              }
              try {
                if (typeof clearTimeout === "function") {
                  cachedClearTimeout = clearTimeout;
                } else {
                  cachedClearTimeout = defaultClearTimeout;
                }
              } catch (e3) {
                cachedClearTimeout = defaultClearTimeout;
              }
            })();
            function runTimeout(fun) {
              if (cachedSetTimeout === setTimeout) {
                return setTimeout(fun, 0);
              }
              if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
                cachedSetTimeout = setTimeout;
                return setTimeout(fun, 0);
              }
              try {
                return cachedSetTimeout(fun, 0);
              } catch (e3) {
                try {
                  return cachedSetTimeout.call(null, fun, 0);
                } catch (e4) {
                  return cachedSetTimeout.call(this, fun, 0);
                }
              }
            }
            function runClearTimeout(marker) {
              if (cachedClearTimeout === clearTimeout) {
                return clearTimeout(marker);
              }
              if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
                cachedClearTimeout = clearTimeout;
                return clearTimeout(marker);
              }
              try {
                return cachedClearTimeout(marker);
              } catch (e3) {
                try {
                  return cachedClearTimeout.call(null, marker);
                } catch (e4) {
                  return cachedClearTimeout.call(this, marker);
                }
              }
            }
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
              if (!draining || !currentQueue) {
                return;
              }
              draining = false;
              if (currentQueue.length) {
                queue = currentQueue.concat(queue);
              } else {
                queueIndex = -1;
              }
              if (queue.length) {
                drainQueue();
              }
            }
            function drainQueue() {
              if (draining) {
                return;
              }
              var timeout = runTimeout(cleanUpNextTick);
              draining = true;
              var len = queue.length;
              while (len) {
                currentQueue = queue;
                queue = [];
                while (++queueIndex < len) {
                  if (currentQueue) {
                    currentQueue[queueIndex].run();
                  }
                }
                queueIndex = -1;
                len = queue.length;
              }
              currentQueue = null;
              draining = false;
              runClearTimeout(timeout);
            }
            process2.nextTick = function(fun) {
              var args = new Array(arguments.length - 1);
              if (arguments.length > 1) {
                for (var i2 = 1; i2 < arguments.length; i2++) {
                  args[i2 - 1] = arguments[i2];
                }
              }
              queue.push(new Item(fun, args));
              if (queue.length === 1 && !draining) {
                runTimeout(drainQueue);
              }
            };
            function Item(fun, array) {
              this.fun = fun;
              this.array = array;
            }
            Item.prototype.run = function() {
              this.fun.apply(null, this.array);
            };
            process2.title = "browser";
            process2.browser = true;
            process2.env = {};
            process2.argv = [];
            process2.version = "";
            process2.versions = {};
            function noop3() {
            }
            process2.on = noop3;
            process2.addListener = noop3;
            process2.once = noop3;
            process2.off = noop3;
            process2.removeListener = noop3;
            process2.removeAllListeners = noop3;
            process2.emit = noop3;
            process2.prependListener = noop3;
            process2.prependOnceListener = noop3;
            process2.listeners = function(name) {
              return [];
            };
            process2.binding = function(name) {
              throw new Error("process.binding is not supported");
            };
            process2.cwd = function() {
              return "/";
            };
            process2.chdir = function(dir) {
              throw new Error("process.chdir is not supported");
            };
            process2.umask = function() {
              return 0;
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            module3.exports = function normalizeHeaderName(headers, normalizedName) {
              utils.forEach(headers, function processHeader(value, name) {
                if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
                  headers[normalizedName] = value;
                  delete headers[name];
                }
              });
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var createError = __webpack_require__(6);
            module3.exports = function settle(resolve, reject, response) {
              var validateStatus = response.config.validateStatus;
              if (!validateStatus || validateStatus(response.status)) {
                resolve(response);
              } else {
                reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
              }
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = function enhanceError(error, config, code, request, response) {
              error.config = config;
              if (code) {
                error.code = code;
              }
              error.request = request;
              error.response = response;
              error.isAxiosError = true;
              error.toJSON = function() {
                return {
                  message: this.message,
                  name: this.name,
                  description: this.description,
                  number: this.number,
                  fileName: this.fileName,
                  lineNumber: this.lineNumber,
                  columnNumber: this.columnNumber,
                  stack: this.stack,
                  config: this.config,
                  code: this.code
                };
              };
              return error;
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            var ignoreDuplicateOf = ["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"];
            module3.exports = function parseHeaders(headers) {
              var parsed = {};
              var key;
              var val;
              var i2;
              if (!headers) {
                return parsed;
              }
              utils.forEach(headers.split("\n"), function parser(line) {
                i2 = line.indexOf(":");
                key = utils.trim(line.substr(0, i2)).toLowerCase();
                val = utils.trim(line.substr(i2 + 1));
                if (key) {
                  if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                    return;
                  }
                  if (key === "set-cookie") {
                    parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
                  } else {
                    parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
                  }
                }
              });
              return parsed;
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            module3.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
              var msie = /(msie|trident)/i.test(navigator.userAgent);
              var urlParsingNode = document.createElement("a");
              var originURL;
              function resolveURL(url) {
                var href = url;
                if (msie) {
                  urlParsingNode.setAttribute("href", href);
                  href = urlParsingNode.href;
                }
                urlParsingNode.setAttribute("href", href);
                return {
                  href: urlParsingNode.href,
                  protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                  host: urlParsingNode.host,
                  search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                  hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                  hostname: urlParsingNode.hostname,
                  port: urlParsingNode.port,
                  pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
                };
              }
              originURL = resolveURL(window.location.href);
              return function isURLSameOrigin(requestURL) {
                var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
                return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
              };
            }() : function nonStandardBrowserEnv() {
              return function isURLSameOrigin() {
                return true;
              };
            }();
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var utils = __webpack_require__(0);
            module3.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
              return {
                write: function write(name, value, expires, path, domain, secure) {
                  var cookie = [];
                  cookie.push(name + "=" + encodeURIComponent(value));
                  if (utils.isNumber(expires)) {
                    cookie.push("expires=" + new Date(expires).toGMTString());
                  }
                  if (utils.isString(path)) {
                    cookie.push("path=" + path);
                  }
                  if (utils.isString(domain)) {
                    cookie.push("domain=" + domain);
                  }
                  if (secure === true) {
                    cookie.push("secure");
                  }
                  document.cookie = cookie.join("; ");
                },
                read: function read(name) {
                  var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
                  return match ? decodeURIComponent(match[3]) : null;
                },
                remove: function remove(name) {
                  this.write(name, "", Date.now() - 864e5);
                }
              };
            }() : function nonStandardBrowserEnv() {
              return {
                write: function write() {
                },
                read: function read() {
                  return null;
                },
                remove: function remove() {
                }
              };
            }();
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = function isAbsoluteURL(url) {
              return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = function combineURLs(baseURL, relativeURL) {
              return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
            };
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            var Cancel = __webpack_require__(8);
            function CancelToken(executor) {
              if (typeof executor !== "function") {
                throw new TypeError("executor must be a function.");
              }
              var resolvePromise;
              this.promise = new Promise(function promiseExecutor(resolve) {
                resolvePromise = resolve;
              });
              var token = this;
              executor(function cancel(message) {
                if (token.reason) {
                  return;
                }
                token.reason = new Cancel(message);
                resolvePromise(token.reason);
              });
            }
            CancelToken.prototype.throwIfRequested = function throwIfRequested() {
              if (this.reason) {
                throw this.reason;
              }
            };
            CancelToken.source = function source() {
              var cancel;
              var token = new CancelToken(function executor(c2) {
                cancel = c2;
              });
              return {
                token,
                cancel
              };
            };
            module3.exports = CancelToken;
          },
          function(module3, exports3, __webpack_require__) {
            "use strict";
            module3.exports = function spread(callback) {
              return function wrap(arr) {
                return callback.apply(null, arr);
              };
            };
          }
        ]);
      });
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports2) {
      "use strict";
      var m2 = require_react_dom();
      if (false) {
        exports2.createRoot = m2.createRoot;
        exports2.hydrateRoot = m2.hydrateRoot;
      } else {
        i2 = m2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports2.createRoot = function(c2, o2) {
          i2.usingClientEntryPoint = true;
          try {
            return m2.createRoot(c2, o2);
          } finally {
            i2.usingClientEntryPoint = false;
          }
        };
        exports2.hydrateRoot = function(c2, h2, o2) {
          i2.usingClientEntryPoint = true;
          try {
            return m2.hydrateRoot(c2, h2, o2);
          } finally {
            i2.usingClientEntryPoint = false;
          }
        };
      }
      var i2;
    }
  });

  // src/dev.tsx
  var import_react142 = __toESM(require_react());

  // src/index.tsx
  var import_react141 = __toESM(require_react());

  // src/components/ChangeDiscovery/OrderedCollection.tsx
  var import_react140 = __toESM(require_react());

  // src/context/ordered-collection-context.tsx
  var import_react = __toESM(require_react());
  var defaultState = {
    prev: "",
    pages: [],
    cart: []
  };
  var OrderedCollectionStateContext = import_react.default.createContext(defaultState);
  var OrderedCollectionDispatchContext = import_react.default.createContext(defaultState);
  function orderedCollectionReducer(state, action) {
    switch (action.type) {
      case "resetCart": {
        return __spreadProps(__spreadValues({}, state), {
          cart: []
        });
      }
      case "updatePrev": {
        return __spreadProps(__spreadValues({}, state), {
          prev: action.id
        });
      }
      case "updatePages": {
        return __spreadProps(__spreadValues({}, state), {
          pages: !state.pages.includes(action.id) ? [...state.pages, action.id] : state.pages
        });
      }
      case "updateCart": {
        return __spreadProps(__spreadValues({}, state), {
          cart: !state.cart.includes(action.id) ? [...state.cart, action.id] : state.cart
        });
      }
      default: {
        throw new Error(`Unhandled action type: ${action.type}`);
      }
    }
  }
  var OrderedCollectionProvider = ({
    initialState: initialState3 = defaultState,
    children
  }) => {
    const [state, dispatch] = import_react.default.useReducer(orderedCollectionReducer, initialState3);
    return /* @__PURE__ */ import_react.default.createElement(OrderedCollectionStateContext.Provider, {
      value: state
    }, /* @__PURE__ */ import_react.default.createElement(OrderedCollectionDispatchContext.Provider, {
      value: dispatch
    }, children));
  };
  function useOrderedCollectionState() {
    const context = import_react.default.useContext(OrderedCollectionStateContext);
    if (context === void 0) {
      throw new Error(
        "useOrderedCollectionState must be used within OrderedCollectionProvider"
      );
    }
    return context;
  }
  function useOrderedCollectionDispatch() {
    const context = import_react.default.useContext(OrderedCollectionDispatchContext);
    if (context === void 0) {
      throw new Error(
        "useOrderedCollectionDispatch must be used within OrderedCollectionProvider"
      );
    }
    return context;
  }

  // src/components/ChangeDiscovery/PrevPageObserver.tsx
  var import_react4 = __toESM(require_react());

  // node_modules/react-intersection-observer/react-intersection-observer.modern.mjs
  var React2 = __toESM(require_react(), 1);
  var observerMap = /* @__PURE__ */ new Map();
  var RootIds = /* @__PURE__ */ new WeakMap();
  var rootId = 0;
  var unsupportedValue = void 0;
  function getRootId(root2) {
    if (!root2)
      return "0";
    if (RootIds.has(root2))
      return RootIds.get(root2);
    rootId += 1;
    RootIds.set(root2, rootId.toString());
    return RootIds.get(root2);
  }
  function optionsToId(options) {
    return Object.keys(options).sort().filter((key) => options[key] !== void 0).map((key) => {
      return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
    }).toString();
  }
  function createObserver(options) {
    let id = optionsToId(options);
    let instance = observerMap.get(id);
    if (!instance) {
      const elements = /* @__PURE__ */ new Map();
      let thresholds;
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          var _elements$get;
          const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
          if (options.trackVisibility && typeof entry.isVisible === "undefined") {
            entry.isVisible = inView;
          }
          (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach((callback) => {
            callback(inView, entry);
          });
        });
      }, options);
      thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
      instance = {
        id,
        observer,
        elements
      };
      observerMap.set(id, instance);
    }
    return instance;
  }
  function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
    if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
      const bounds = element.getBoundingClientRect();
      callback(fallbackInView, {
        isIntersecting: fallbackInView,
        target: element,
        intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
        time: 0,
        boundingClientRect: bounds,
        intersectionRect: bounds,
        rootBounds: bounds
      });
      return () => {
      };
    }
    const {
      id,
      observer,
      elements
    } = createObserver(options);
    let callbacks = elements.get(element) || [];
    if (!elements.has(element)) {
      elements.set(element, callbacks);
    }
    callbacks.push(callback);
    observer.observe(element);
    return function unobserve() {
      callbacks.splice(callbacks.indexOf(callback), 1);
      if (callbacks.length === 0) {
        elements.delete(element);
        observer.unobserve(element);
      }
      if (elements.size === 0) {
        observer.disconnect();
        observerMap.delete(id);
      }
    };
  }
  function useInView({
    threshold,
    delay,
    trackVisibility,
    rootMargin,
    root: root2,
    triggerOnce,
    skip,
    initialInView,
    fallbackInView,
    onChange
  } = {}) {
    var _state$entry;
    const [ref, setRef2] = React2.useState(null);
    const callback = React2.useRef();
    const [state, setState] = React2.useState({
      inView: !!initialInView,
      entry: void 0
    });
    callback.current = onChange;
    React2.useEffect(
      () => {
        if (skip || !ref)
          return;
        let unobserve = observe(ref, (inView, entry) => {
          setState({
            inView,
            entry
          });
          if (callback.current)
            callback.current(inView, entry);
          if (entry.isIntersecting && triggerOnce && unobserve) {
            unobserve();
            unobserve = void 0;
          }
        }, {
          root: root2,
          rootMargin,
          threshold,
          trackVisibility,
          delay
        }, fallbackInView);
        return () => {
          if (unobserve) {
            unobserve();
          }
        };
      },
      [
        Array.isArray(threshold) ? threshold.toString() : threshold,
        ref,
        root2,
        rootMargin,
        triggerOnce,
        skip,
        trackVisibility,
        fallbackInView,
        delay
      ]
    );
    const entryTarget = (_state$entry = state.entry) == null ? void 0 : _state$entry.target;
    React2.useEffect(() => {
      if (!ref && entryTarget && !triggerOnce && !skip) {
        setState({
          inView: !!initialInView,
          entry: void 0
        });
      }
    }, [ref, entryTarget, triggerOnce, skip, initialInView]);
    const result = [setRef2, state.inView, state.entry];
    result.ref = result[0];
    result.inView = result[1];
    result.entry = result[2];
    return result;
  }

  // node_modules/@stitches/react/dist/index.mjs
  var import_react2 = __toESM(require_react(), 1);
  var e = "colors";
  var t = "sizes";
  var r = "space";
  var n = { gap: r, gridGap: r, columnGap: r, gridColumnGap: r, rowGap: r, gridRowGap: r, inset: r, insetBlock: r, insetBlockEnd: r, insetBlockStart: r, insetInline: r, insetInlineEnd: r, insetInlineStart: r, margin: r, marginTop: r, marginRight: r, marginBottom: r, marginLeft: r, marginBlock: r, marginBlockEnd: r, marginBlockStart: r, marginInline: r, marginInlineEnd: r, marginInlineStart: r, padding: r, paddingTop: r, paddingRight: r, paddingBottom: r, paddingLeft: r, paddingBlock: r, paddingBlockEnd: r, paddingBlockStart: r, paddingInline: r, paddingInlineEnd: r, paddingInlineStart: r, top: r, right: r, bottom: r, left: r, scrollMargin: r, scrollMarginTop: r, scrollMarginRight: r, scrollMarginBottom: r, scrollMarginLeft: r, scrollMarginX: r, scrollMarginY: r, scrollMarginBlock: r, scrollMarginBlockEnd: r, scrollMarginBlockStart: r, scrollMarginInline: r, scrollMarginInlineEnd: r, scrollMarginInlineStart: r, scrollPadding: r, scrollPaddingTop: r, scrollPaddingRight: r, scrollPaddingBottom: r, scrollPaddingLeft: r, scrollPaddingX: r, scrollPaddingY: r, scrollPaddingBlock: r, scrollPaddingBlockEnd: r, scrollPaddingBlockStart: r, scrollPaddingInline: r, scrollPaddingInlineEnd: r, scrollPaddingInlineStart: r, fontSize: "fontSizes", background: e, backgroundColor: e, backgroundImage: e, borderImage: e, border: e, borderBlock: e, borderBlockEnd: e, borderBlockStart: e, borderBottom: e, borderBottomColor: e, borderColor: e, borderInline: e, borderInlineEnd: e, borderInlineStart: e, borderLeft: e, borderLeftColor: e, borderRight: e, borderRightColor: e, borderTop: e, borderTopColor: e, caretColor: e, color: e, columnRuleColor: e, fill: e, outline: e, outlineColor: e, stroke: e, textDecorationColor: e, fontFamily: "fonts", fontWeight: "fontWeights", lineHeight: "lineHeights", letterSpacing: "letterSpacings", blockSize: t, minBlockSize: t, maxBlockSize: t, inlineSize: t, minInlineSize: t, maxInlineSize: t, width: t, minWidth: t, maxWidth: t, height: t, minHeight: t, maxHeight: t, flexBasis: t, gridTemplateColumns: t, gridTemplateRows: t, borderWidth: "borderWidths", borderTopWidth: "borderWidths", borderRightWidth: "borderWidths", borderBottomWidth: "borderWidths", borderLeftWidth: "borderWidths", borderStyle: "borderStyles", borderTopStyle: "borderStyles", borderRightStyle: "borderStyles", borderBottomStyle: "borderStyles", borderLeftStyle: "borderStyles", borderRadius: "radii", borderTopLeftRadius: "radii", borderTopRightRadius: "radii", borderBottomRightRadius: "radii", borderBottomLeftRadius: "radii", boxShadow: "shadows", textShadow: "shadows", transition: "transitions", zIndex: "zIndices" };
  var i = (e3, t2) => "function" == typeof t2 ? { "()": Function.prototype.toString.call(t2) } : t2;
  var o = () => {
    const e3 = /* @__PURE__ */ Object.create(null);
    return (t2, r2, ...n2) => {
      const o2 = ((e4) => JSON.stringify(e4, i))(t2);
      return o2 in e3 ? e3[o2] : e3[o2] = r2(t2, ...n2);
    };
  };
  var l = Symbol.for("sxs.internal");
  var s = (e3, t2) => Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2));
  var a = (e3) => {
    for (const t2 in e3)
      return true;
    return false;
  };
  var { hasOwnProperty: c } = Object.prototype;
  var d = (e3) => e3.includes("-") ? e3 : e3.replace(/[A-Z]/g, (e4) => "-" + e4.toLowerCase());
  var g = /\s+(?![^()]*\))/;
  var p = (e3) => (t2) => e3(..."string" == typeof t2 ? String(t2).split(g) : [t2]);
  var u = { appearance: (e3) => ({ WebkitAppearance: e3, appearance: e3 }), backfaceVisibility: (e3) => ({ WebkitBackfaceVisibility: e3, backfaceVisibility: e3 }), backdropFilter: (e3) => ({ WebkitBackdropFilter: e3, backdropFilter: e3 }), backgroundClip: (e3) => ({ WebkitBackgroundClip: e3, backgroundClip: e3 }), boxDecorationBreak: (e3) => ({ WebkitBoxDecorationBreak: e3, boxDecorationBreak: e3 }), clipPath: (e3) => ({ WebkitClipPath: e3, clipPath: e3 }), content: (e3) => ({ content: e3.includes('"') || e3.includes("'") || /^([A-Za-z]+\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e3) ? e3 : `"${e3}"` }), hyphens: (e3) => ({ WebkitHyphens: e3, hyphens: e3 }), maskImage: (e3) => ({ WebkitMaskImage: e3, maskImage: e3 }), maskSize: (e3) => ({ WebkitMaskSize: e3, maskSize: e3 }), tabSize: (e3) => ({ MozTabSize: e3, tabSize: e3 }), textSizeAdjust: (e3) => ({ WebkitTextSizeAdjust: e3, textSizeAdjust: e3 }), userSelect: (e3) => ({ WebkitUserSelect: e3, userSelect: e3 }), marginBlock: p((e3, t2) => ({ marginBlockStart: e3, marginBlockEnd: t2 || e3 })), marginInline: p((e3, t2) => ({ marginInlineStart: e3, marginInlineEnd: t2 || e3 })), maxSize: p((e3, t2) => ({ maxBlockSize: e3, maxInlineSize: t2 || e3 })), minSize: p((e3, t2) => ({ minBlockSize: e3, minInlineSize: t2 || e3 })), paddingBlock: p((e3, t2) => ({ paddingBlockStart: e3, paddingBlockEnd: t2 || e3 })), paddingInline: p((e3, t2) => ({ paddingInlineStart: e3, paddingInlineEnd: t2 || e3 })) };
  var h = /([\d.]+)([^]*)/;
  var f = (e3, t2) => e3.length ? e3.reduce((e4, r2) => (e4.push(...t2.map((e5) => e5.includes("&") ? e5.replace(/&/g, /[ +>|~]/.test(r2) && /&.*&/.test(e5) ? `:is(${r2})` : r2) : r2 + " " + e5)), e4), []) : t2;
  var m = (e3, t2) => e3 in b && "string" == typeof t2 ? t2.replace(/^((?:[^]*[^\w-])?)(fit-content|stretch)((?:[^\w-][^]*)?)$/, (t3, r2, n2, i2) => r2 + ("stretch" === n2 ? `-moz-available${i2};${d(e3)}:${r2}-webkit-fill-available` : `-moz-fit-content${i2};${d(e3)}:${r2}fit-content`) + i2) : String(t2);
  var b = { blockSize: 1, height: 1, inlineSize: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, width: 1 };
  var S = (e3) => e3 ? e3 + "-" : "";
  var k = (e3, t2, r2) => e3.replace(/([+-])?((?:\d+(?:\.\d*)?|\.\d+)(?:[Ee][+-]?\d+)?)?(\$|--)([$\w-]+)/g, (e4, n2, i2, o2, l2) => "$" == o2 == !!i2 ? e4 : (n2 || "--" == o2 ? "calc(" : "") + "var(--" + ("$" === o2 ? S(t2) + (l2.includes("$") ? "" : S(r2)) + l2.replace(/\$/g, "-") : l2) + ")" + (n2 || "--" == o2 ? "*" + (n2 || "") + (i2 || "1") + ")" : ""));
  var y = /\s*,\s*(?![^()]*\))/;
  var B = Object.prototype.toString;
  var $2 = (e3, t2, r2, n2, i2) => {
    let o2, l2, s2;
    const a2 = (e4, t3, r3) => {
      let c2, g2;
      const p2 = (e5) => {
        for (c2 in e5) {
          const R3 = 64 === c2.charCodeAt(0), z3 = R3 && Array.isArray(e5[c2]) ? e5[c2] : [e5[c2]];
          for (g2 of z3) {
            const e6 = /[A-Z]/.test($3 = c2) ? $3 : $3.replace(/-[^]/g, (e7) => e7[1].toUpperCase()), z4 = "object" == typeof g2 && g2 && g2.toString === B && (!n2.utils[e6] || !t3.length);
            if (e6 in n2.utils && !z4) {
              const t4 = n2.utils[e6];
              if (t4 !== l2) {
                l2 = t4, p2(t4(g2)), l2 = null;
                continue;
              }
            } else if (e6 in u) {
              const t4 = u[e6];
              if (t4 !== s2) {
                s2 = t4, p2(t4(g2)), s2 = null;
                continue;
              }
            }
            if (R3 && (b3 = c2.slice(1) in n2.media ? "@media " + n2.media[c2.slice(1)] : c2, c2 = b3.replace(/\(\s*([\w-]+)\s*(=|<|<=|>|>=)\s*([\w-]+)\s*(?:(<|<=|>|>=)\s*([\w-]+)\s*)?\)/g, (e7, t4, r4, n3, i3, o3) => {
              const l3 = h.test(t4), s3 = 0.0625 * (l3 ? -1 : 1), [a3, c3] = l3 ? [n3, t4] : [t4, n3];
              return "(" + ("=" === r4[0] ? "" : ">" === r4[0] === l3 ? "max-" : "min-") + a3 + ":" + ("=" !== r4[0] && 1 === r4.length ? c3.replace(h, (e8, t5, n4) => Number(t5) + s3 * (">" === r4 ? 1 : -1) + n4) : c3) + (i3 ? ") and (" + (">" === i3[0] ? "min-" : "max-") + a3 + ":" + (1 === i3.length ? o3.replace(h, (e8, t5, r5) => Number(t5) + s3 * (">" === i3 ? -1 : 1) + r5) : o3) : "") + ")";
            })), z4) {
              const e7 = R3 ? r3.concat(c2) : [...r3], n3 = R3 ? [...t3] : f(t3, c2.split(y));
              void 0 !== o2 && i2(x(...o2)), o2 = void 0, a2(g2, n3, e7);
            } else
              void 0 === o2 && (o2 = [[], t3, r3]), c2 = R3 || 36 !== c2.charCodeAt(0) ? c2 : `--${S(n2.prefix)}${c2.slice(1).replace(/\$/g, "-")}`, g2 = z4 ? g2 : "number" == typeof g2 ? g2 && e6 in I ? String(g2) + "px" : String(g2) : k(m(e6, null == g2 ? "" : g2), n2.prefix, n2.themeMap[e6]), o2[0].push(`${R3 ? `${c2} ` : `${d(c2)}:`}${g2}`);
          }
        }
        var b3, $3;
      };
      p2(e4), void 0 !== o2 && i2(x(...o2)), o2 = void 0;
    };
    a2(e3, t2, r2);
  };
  var x = (e3, t2, r2) => `${r2.map((e4) => `${e4}{`).join("")}${t2.length ? `${t2.join(",")}{` : ""}${e3.join(";")}${t2.length ? "}" : ""}${Array(r2.length ? r2.length + 1 : 0).join("}")}`;
  var I = { animationDelay: 1, animationDuration: 1, backgroundSize: 1, blockSize: 1, border: 1, borderBlock: 1, borderBlockEnd: 1, borderBlockEndWidth: 1, borderBlockStart: 1, borderBlockStartWidth: 1, borderBlockWidth: 1, borderBottom: 1, borderBottomLeftRadius: 1, borderBottomRightRadius: 1, borderBottomWidth: 1, borderEndEndRadius: 1, borderEndStartRadius: 1, borderInlineEnd: 1, borderInlineEndWidth: 1, borderInlineStart: 1, borderInlineStartWidth: 1, borderInlineWidth: 1, borderLeft: 1, borderLeftWidth: 1, borderRadius: 1, borderRight: 1, borderRightWidth: 1, borderSpacing: 1, borderStartEndRadius: 1, borderStartStartRadius: 1, borderTop: 1, borderTopLeftRadius: 1, borderTopRightRadius: 1, borderTopWidth: 1, borderWidth: 1, bottom: 1, columnGap: 1, columnRule: 1, columnRuleWidth: 1, columnWidth: 1, containIntrinsicSize: 1, flexBasis: 1, fontSize: 1, gap: 1, gridAutoColumns: 1, gridAutoRows: 1, gridTemplateColumns: 1, gridTemplateRows: 1, height: 1, inlineSize: 1, inset: 1, insetBlock: 1, insetBlockEnd: 1, insetBlockStart: 1, insetInline: 1, insetInlineEnd: 1, insetInlineStart: 1, left: 1, letterSpacing: 1, margin: 1, marginBlock: 1, marginBlockEnd: 1, marginBlockStart: 1, marginBottom: 1, marginInline: 1, marginInlineEnd: 1, marginInlineStart: 1, marginLeft: 1, marginRight: 1, marginTop: 1, maxBlockSize: 1, maxHeight: 1, maxInlineSize: 1, maxWidth: 1, minBlockSize: 1, minHeight: 1, minInlineSize: 1, minWidth: 1, offsetDistance: 1, offsetRotate: 1, outline: 1, outlineOffset: 1, outlineWidth: 1, overflowClipMargin: 1, padding: 1, paddingBlock: 1, paddingBlockEnd: 1, paddingBlockStart: 1, paddingBottom: 1, paddingInline: 1, paddingInlineEnd: 1, paddingInlineStart: 1, paddingLeft: 1, paddingRight: 1, paddingTop: 1, perspective: 1, right: 1, rowGap: 1, scrollMargin: 1, scrollMarginBlock: 1, scrollMarginBlockEnd: 1, scrollMarginBlockStart: 1, scrollMarginBottom: 1, scrollMarginInline: 1, scrollMarginInlineEnd: 1, scrollMarginInlineStart: 1, scrollMarginLeft: 1, scrollMarginRight: 1, scrollMarginTop: 1, scrollPadding: 1, scrollPaddingBlock: 1, scrollPaddingBlockEnd: 1, scrollPaddingBlockStart: 1, scrollPaddingBottom: 1, scrollPaddingInline: 1, scrollPaddingInlineEnd: 1, scrollPaddingInlineStart: 1, scrollPaddingLeft: 1, scrollPaddingRight: 1, scrollPaddingTop: 1, shapeMargin: 1, textDecoration: 1, textDecorationThickness: 1, textIndent: 1, textUnderlineOffset: 1, top: 1, transitionDelay: 1, transitionDuration: 1, verticalAlign: 1, width: 1, wordSpacing: 1 };
  var R = (e3) => String.fromCharCode(e3 + (e3 > 25 ? 39 : 97));
  var z = (e3) => ((e4) => {
    let t2, r2 = "";
    for (t2 = Math.abs(e4); t2 > 52; t2 = t2 / 52 | 0)
      r2 = R(t2 % 52) + r2;
    return R(t2 % 52) + r2;
  })(((e4, t2) => {
    let r2 = t2.length;
    for (; r2; )
      e4 = 33 * e4 ^ t2.charCodeAt(--r2);
    return e4;
  })(5381, JSON.stringify(e3)) >>> 0);
  var W = ["themed", "global", "styled", "onevar", "resonevar", "allvar", "inline"];
  var j = (e3) => {
    if (e3.href && !e3.href.startsWith(location.origin))
      return false;
    try {
      return !!e3.cssRules;
    } catch (e4) {
      return false;
    }
  };
  var E = (e3) => {
    let t2;
    const r2 = () => {
      const { cssRules: e4 } = t2.sheet;
      return [].map.call(e4, (r3, n3) => {
        const { cssText: i2 } = r3;
        let o2 = "";
        if (i2.startsWith("--sxs"))
          return "";
        if (e4[n3 - 1] && (o2 = e4[n3 - 1].cssText).startsWith("--sxs")) {
          if (!r3.cssRules.length)
            return "";
          for (const e5 in t2.rules)
            if (t2.rules[e5].group === r3)
              return `--sxs{--sxs:${[...t2.rules[e5].cache].join(" ")}}${i2}`;
          return r3.cssRules.length ? `${o2}${i2}` : "";
        }
        return i2;
      }).join("");
    }, n2 = () => {
      if (t2) {
        const { rules: e4, sheet: r3 } = t2;
        if (!r3.deleteRule) {
          for (; 3 === Object(Object(r3.cssRules)[0]).type; )
            r3.cssRules.splice(0, 1);
          r3.cssRules = [];
        }
        for (const t3 in e4)
          delete e4[t3];
      }
      const i2 = Object(e3).styleSheets || [];
      for (const e4 of i2)
        if (j(e4)) {
          for (let i3 = 0, o3 = e4.cssRules; o3[i3]; ++i3) {
            const l3 = Object(o3[i3]);
            if (1 !== l3.type)
              continue;
            const s2 = Object(o3[i3 + 1]);
            if (4 !== s2.type)
              continue;
            ++i3;
            const { cssText: a2 } = l3;
            if (!a2.startsWith("--sxs"))
              continue;
            const c2 = a2.slice(14, -3).trim().split(/\s+/), d3 = W[c2[0]];
            d3 && (t2 || (t2 = { sheet: e4, reset: n2, rules: {}, toString: r2 }), t2.rules[d3] = { group: s2, index: i3, cache: new Set(c2) });
          }
          if (t2)
            break;
        }
      if (!t2) {
        const i3 = (e4, t3) => ({ type: t3, cssRules: [], insertRule(e5, t4) {
          this.cssRules.splice(t4, 0, i3(e5, { import: 3, undefined: 1 }[(e5.toLowerCase().match(/^@([a-z]+)/) || [])[1]] || 4));
        }, get cssText() {
          return "@media{}" === e4 ? `@media{${[].map.call(this.cssRules, (e5) => e5.cssText).join("")}}` : e4;
        } });
        t2 = { sheet: e3 ? (e3.head || e3).appendChild(document.createElement("style")).sheet : i3("", "text/css"), rules: {}, reset: n2, toString: r2 };
      }
      const { sheet: o2, rules: l2 } = t2;
      for (let e4 = W.length - 1; e4 >= 0; --e4) {
        const t3 = W[e4];
        if (!l2[t3]) {
          const r3 = W[e4 + 1], n3 = l2[r3] ? l2[r3].index : o2.cssRules.length;
          o2.insertRule("@media{}", n3), o2.insertRule(`--sxs{--sxs:${e4}}`, n3), l2[t3] = { group: o2.cssRules[n3 + 1], index: n3, cache: /* @__PURE__ */ new Set([e4]) };
        }
        v(l2[t3]);
      }
    };
    return n2(), t2;
  };
  var v = (e3) => {
    const t2 = e3.group;
    let r2 = t2.cssRules.length;
    e3.apply = (e4) => {
      try {
        t2.insertRule(e4, r2), ++r2;
      } catch (e5) {
      }
    };
  };
  var T = Symbol();
  var w = o();
  var M = (e3, t2) => w(e3, () => (...r2) => {
    let n2 = { type: null, composers: /* @__PURE__ */ new Set() };
    for (const t3 of r2)
      if (null != t3)
        if (t3[l]) {
          null == n2.type && (n2.type = t3[l].type);
          for (const e4 of t3[l].composers)
            n2.composers.add(e4);
        } else
          t3.constructor !== Object || t3.$$typeof ? null == n2.type && (n2.type = t3) : n2.composers.add(C(t3, e3));
    return null == n2.type && (n2.type = "span"), n2.composers.size || n2.composers.add(["PJLV", {}, [], [], {}, []]), P(e3, n2, t2);
  });
  var C = ({ variants: e3, compoundVariants: t2, defaultVariants: r2, ...n2 }, i2) => {
    const o2 = `${S(i2.prefix)}c-${z(n2)}`, l2 = [], s2 = [], d3 = /* @__PURE__ */ Object.create(null), g2 = [];
    for (const e4 in r2)
      d3[e4] = String(r2[e4]);
    if ("object" == typeof e3 && e3)
      for (const t3 in e3) {
        p2 = d3, u2 = t3, c.call(p2, u2) || (d3[t3] = "undefined");
        const r3 = e3[t3];
        for (const e4 in r3) {
          const n3 = { [t3]: String(e4) };
          "undefined" === String(e4) && g2.push(t3);
          const i3 = r3[e4], o3 = [n3, i3, !a(i3)];
          l2.push(o3);
        }
      }
    var p2, u2;
    if ("object" == typeof t2 && t2)
      for (const e4 of t2) {
        let { css: t3, ...r3 } = e4;
        t3 = "object" == typeof t3 && t3 || {};
        for (const e5 in r3)
          r3[e5] = String(r3[e5]);
        const n3 = [r3, t3, !a(t3)];
        s2.push(n3);
      }
    return [o2, n2, l2, s2, d3, g2];
  };
  var P = (e3, t2, r2) => {
    const [n2, i2, o2, a2] = L(t2.composers), c2 = "function" == typeof t2.type || t2.type.$$typeof ? ((e4) => {
      function t3() {
        for (let r3 = 0; r3 < t3[T].length; r3++) {
          const [n3, i3] = t3[T][r3];
          e4.rules[n3].apply(i3);
        }
        return t3[T] = [], null;
      }
      return t3[T] = [], t3.rules = {}, W.forEach((e5) => t3.rules[e5] = { apply: (r3) => t3[T].push([e5, r3]) }), t3;
    })(r2) : null, d3 = (c2 || r2).rules, g2 = `.${n2}${i2.length > 1 ? `:where(.${i2.slice(1).join(".")})` : ""}`, p2 = (l2) => {
      l2 = "object" == typeof l2 && l2 || A;
      const { css: s2, ...p3 } = l2, u2 = {};
      for (const e4 in o2)
        if (delete p3[e4], e4 in l2) {
          let t3 = l2[e4];
          "object" == typeof t3 && t3 ? u2[e4] = { "@initial": o2[e4], ...t3 } : (t3 = String(t3), u2[e4] = "undefined" !== t3 || a2.has(e4) ? t3 : o2[e4]);
        } else
          u2[e4] = o2[e4];
      const h2 = /* @__PURE__ */ new Set([...i2]);
      for (const [n3, i3, o3, l3] of t2.composers) {
        r2.rules.styled.cache.has(n3) || (r2.rules.styled.cache.add(n3), $2(i3, [`.${n3}`], [], e3, (e4) => {
          d3.styled.apply(e4);
        }));
        const t3 = O(o3, u2, e3.media), s3 = O(l3, u2, e3.media, true);
        for (const i4 of t3)
          if (void 0 !== i4)
            for (const [t4, o4, l4] of i4) {
              const i5 = `${n3}-${z(o4)}-${t4}`;
              h2.add(i5);
              const s4 = (l4 ? r2.rules.resonevar : r2.rules.onevar).cache, a3 = l4 ? d3.resonevar : d3.onevar;
              s4.has(i5) || (s4.add(i5), $2(o4, [`.${i5}`], [], e3, (e4) => {
                a3.apply(e4);
              }));
            }
        for (const t4 of s3)
          if (void 0 !== t4)
            for (const [i4, o4] of t4) {
              const t5 = `${n3}-${z(o4)}-${i4}`;
              h2.add(t5), r2.rules.allvar.cache.has(t5) || (r2.rules.allvar.cache.add(t5), $2(o4, [`.${t5}`], [], e3, (e4) => {
                d3.allvar.apply(e4);
              }));
            }
      }
      if ("object" == typeof s2 && s2) {
        const t3 = `${n2}-i${z(s2)}-css`;
        h2.add(t3), r2.rules.inline.cache.has(t3) || (r2.rules.inline.cache.add(t3), $2(s2, [`.${t3}`], [], e3, (e4) => {
          d3.inline.apply(e4);
        }));
      }
      for (const e4 of String(l2.className || "").trim().split(/\s+/))
        e4 && h2.add(e4);
      const f2 = p3.className = [...h2].join(" ");
      return { type: t2.type, className: f2, selector: g2, props: p3, toString: () => f2, deferredInjector: c2 };
    };
    return s(p2, { className: n2, selector: g2, [l]: t2, toString: () => (r2.rules.styled.cache.has(n2) || p2(), n2) });
  };
  var L = (e3) => {
    let t2 = "";
    const r2 = [], n2 = {}, i2 = [];
    for (const [o2, , , , l2, s2] of e3) {
      "" === t2 && (t2 = o2), r2.push(o2), i2.push(...s2);
      for (const e4 in l2) {
        const t3 = l2[e4];
        (void 0 === n2[e4] || "undefined" !== t3 || s2.includes(t3)) && (n2[e4] = t3);
      }
    }
    return [t2, r2, n2, new Set(i2)];
  };
  var O = (e3, t2, r2, n2) => {
    const i2 = [];
    e:
      for (let [o2, l2, s2] of e3) {
        if (s2)
          continue;
        let e4, a2 = 0, c2 = false;
        for (e4 in o2) {
          const n3 = o2[e4];
          let i3 = t2[e4];
          if (i3 !== n3) {
            if ("object" != typeof i3 || !i3)
              continue e;
            {
              let e5, t3, o3 = 0;
              for (const l3 in i3) {
                if (n3 === String(i3[l3])) {
                  if ("@initial" !== l3) {
                    const e6 = l3.slice(1);
                    (t3 = t3 || []).push(e6 in r2 ? r2[e6] : l3.replace(/^@media ?/, "")), c2 = true;
                  }
                  a2 += o3, e5 = true;
                }
                ++o3;
              }
              if (t3 && t3.length && (l2 = { ["@media " + t3.join(", ")]: l2 }), !e5)
                continue e;
            }
          }
        }
        (i2[a2] = i2[a2] || []).push([n2 ? "cv" : `${e4}-${o2[e4]}`, l2, c2]);
      }
    return i2;
  };
  var A = {};
  var N = o();
  var D = (e3, t2) => N(e3, () => (...r2) => {
    const n2 = () => {
      for (let n3 of r2) {
        n3 = "object" == typeof n3 && n3 || {};
        let r3 = z(n3);
        if (!t2.rules.global.cache.has(r3)) {
          if (t2.rules.global.cache.add(r3), "@import" in n3) {
            let e4 = [].indexOf.call(t2.sheet.cssRules, t2.rules.themed.group) - 1;
            for (let r4 of [].concat(n3["@import"]))
              r4 = r4.includes('"') || r4.includes("'") ? r4 : `"${r4}"`, t2.sheet.insertRule(`@import ${r4};`, e4++);
            delete n3["@import"];
          }
          $2(n3, [], [], e3, (e4) => {
            t2.rules.global.apply(e4);
          });
        }
      }
      return "";
    };
    return s(n2, { toString: n2 });
  });
  var H = o();
  var V = (e3, t2) => H(e3, () => (r2) => {
    const n2 = `${S(e3.prefix)}k-${z(r2)}`, i2 = () => {
      if (!t2.rules.global.cache.has(n2)) {
        t2.rules.global.cache.add(n2);
        const i3 = [];
        $2(r2, [], [], e3, (e4) => i3.push(e4));
        const o2 = `@keyframes ${n2}{${i3.join("")}}`;
        t2.rules.global.apply(o2);
      }
      return n2;
    };
    return s(i2, { get name() {
      return i2();
    }, toString: i2 });
  });
  var G = class {
    constructor(e3, t2, r2, n2) {
      this.token = null == e3 ? "" : String(e3), this.value = null == t2 ? "" : String(t2), this.scale = null == r2 ? "" : String(r2), this.prefix = null == n2 ? "" : String(n2);
    }
    get computedValue() {
      return "var(" + this.variable + ")";
    }
    get variable() {
      return "--" + S(this.prefix) + S(this.scale) + this.token;
    }
    toString() {
      return this.computedValue;
    }
  };
  var F = o();
  var J = (e3, t2) => F(e3, () => (r2, n2) => {
    n2 = "object" == typeof r2 && r2 || Object(n2);
    const i2 = `.${r2 = (r2 = "string" == typeof r2 ? r2 : "") || `${S(e3.prefix)}t-${z(n2)}`}`, o2 = {}, l2 = [];
    for (const t3 in n2) {
      o2[t3] = {};
      for (const r3 in n2[t3]) {
        const i3 = `--${S(e3.prefix)}${t3}-${r3}`, s3 = k(String(n2[t3][r3]), e3.prefix, t3);
        o2[t3][r3] = new G(r3, s3, t3, e3.prefix), l2.push(`${i3}:${s3}`);
      }
    }
    const s2 = () => {
      if (l2.length && !t2.rules.themed.cache.has(r2)) {
        t2.rules.themed.cache.add(r2);
        const i3 = `${n2 === e3.theme ? ":root," : ""}.${r2}{${l2.join(";")}}`;
        t2.rules.themed.apply(i3);
      }
      return r2;
    };
    return { ...o2, get className() {
      return s2();
    }, selector: i2, toString: s2 };
  });
  var U = o();
  var X;
  var Y = o();
  var q = (e3) => {
    const t2 = ((e4) => {
      let t3 = false;
      const r2 = U(e4, (e5) => {
        t3 = true;
        const r3 = "prefix" in (e5 = "object" == typeof e5 && e5 || {}) ? String(e5.prefix) : "", i2 = "object" == typeof e5.media && e5.media || {}, o2 = "object" == typeof e5.root ? e5.root || null : globalThis.document || null, l2 = "object" == typeof e5.theme && e5.theme || {}, s2 = { prefix: r3, media: i2, theme: l2, themeMap: "object" == typeof e5.themeMap && e5.themeMap || { ...n }, utils: "object" == typeof e5.utils && e5.utils || {} }, a2 = E(o2), c2 = { css: M(s2, a2), globalCss: D(s2, a2), keyframes: V(s2, a2), createTheme: J(s2, a2), reset() {
          a2.reset(), c2.theme.toString();
        }, theme: {}, sheet: a2, config: s2, prefix: r3, getCssText: a2.toString, toString: a2.toString };
        return String(c2.theme = c2.createTheme(l2)), c2;
      });
      return t3 || r2.reset(), r2;
    })(e3);
    return t2.styled = (({ config: e4, sheet: t3 }) => Y(e4, () => {
      const r2 = M(e4, t3);
      return (...e5) => {
        const t4 = r2(...e5), n2 = t4[l].type, i2 = import_react2.default.forwardRef((e6, r3) => {
          const i3 = e6 && e6.as || n2, { props: o2, deferredInjector: l2 } = t4(e6);
          return delete o2.as, o2.ref = r3, l2 ? import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement(i3, o2), import_react2.default.createElement(l2, null)) : import_react2.default.createElement(i3, o2);
        });
        return i2.className = t4.className, i2.displayName = `Styled.${n2.displayName || n2.name || n2}`, i2.selector = t4.selector, i2.toString = () => t4.selector, i2[l] = t4[l], i2;
      };
    }))(t2), t2;
  };
  var K = () => X || (X = q());
  var Q = (...e3) => K().createTheme(...e3);
  var re = (...e3) => K().styled(...e3);

  // src/stitches.ts
  var theme = {
    fonts: {
      sans: "'Inter', Arial, sans-serif",
      display: "'Lora', 'Inter', Arial, sans-serif"
    },
    transitions: {
      all: "all 250ms cubic-bezier(0.16, 1, 0.3, 1)",
      load: "all 1.25s cubic-bezier(0.16, 1, 0.3, 1)"
    }
  };
  var { styled, css, keyframes, createTheme } = q({
    theme
  });

  // src/components/UI/Button/Button.styled.ts
  var ButtonStyled = styled("button", {
    display: "flex",
    alignContent: "center",
    alignItems: "center",
    border: "none",
    background: "linear-gradient(135deg, #5746afdd, #5746af);",
    fontFamily: "$sans",
    padding: "0.5rem 1rem",
    margin: "0 0 0 1rem",
    fontSize: "1rem",
    textDecoration: "none",
    cursor: "pointer",
    color: "#fff",
    borderRadius: "3px",
    textAlign: "center",
    justifyContent: "center",
    transition: "$all",
    "&:hover, &:active": {
      background: "linear-gradient(135deg, #392c72dd, #392c72);"
    },
    svg: {
      marginLeft: "0.5em",
      opacity: "0.7"
    }
  });

  // src/components/ChangeDiscovery/PrevPageObserver.tsx
  var PrevPageObserver = ({ id }) => {
    const dispatch = useOrderedCollectionDispatch();
    const { ref, entry } = useInView({ delay: 100, rootMargin: "800px" });
    (0, import_react4.useEffect)(() => {
      if (entry == null ? void 0 : entry.isIntersecting)
        handlePrev();
    }, [entry]);
    const handlePrev = () => dispatch({
      type: "updatePages",
      id
    });
    return /* @__PURE__ */ import_react4.default.createElement(ButtonStyled, {
      "data-id": id,
      onClick: handlePrev,
      ref,
      css: { margin: 0 }
    }, "Load More");
  };
  var PrevPageObserver_default = PrevPageObserver;

  // src/components/ChangeDiscovery/OrderedCollectionPage.tsx
  var import_react137 = __toESM(require_react());

  // src/components/UI/SVG/SVG.styled.tsx
  var SVGStyled = styled("svg", {
    height: "1rem"
  });

  // src/components/UI/Workspace/Panel/Panel.styled.ts
  var PanelActions = styled("div", {
    display: "flex"
  });
  var PanelBody = styled("div", {
    display: "flex",
    justifyContent: "space-between"
  });
  var PanelContent = styled("div", {
    display: "flex",
    justifyContent: "flex-end",
    flexDirection: "column",
    fontSize: "1rem",
    minWidth: "0",
    "a, a:visited": {
      width: "100%",
      color: "#000a",
      textDecoration: "none",
      transition: "$all",
      whiteSpace: "nowrap",
      overflow: "hidden",
      textOverflow: "ellipsis",
      "&:hover, &:active": {
        color: "#5746af"
      }
    }
  });
  var PanelHeader = styled("header", {
    fontSize: "1rem",
    display: "flex",
    alignItems: "flex-end",
    alignContent: "flex-end",
    [`> ${SVGStyled}`]: {
      display: "flex",
      position: "relative",
      margin: "0 0.25rem 0 0",
      top: "-0.05rem",
      opacity: "0.5"
    }
  });
  var PanelHeaderTime = styled("span", {
    display: "flex",
    color: "#000a",
    fontSize: "0.8333rem",
    margin: "0 0 0 0.5rem"
  });
  var PanelStyled = styled("article", {
    backgroundColor: "white",
    margin: "0 0 1rem",
    padding: "1rem",
    borderRadius: "3px",
    boxShadow: "5px 5px 11px #0001",
    transition: "$all",
    cursor: "move",
    borderLeft: "none",
    "&[data-cart=true]": {
      borderLeft: "1rem solid #5746af",
      cursor: "auto"
    },
    "&:hover": {
      boxShadow: "8px 8px 19px #0002"
    }
  });

  // src/components/UI/SVG/Paths.tsx
  var import_react5 = __toESM(require_react());
  var ArrowForward = () => {
    return /* @__PURE__ */ import_react5.default.createElement("path", {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: "48",
      d: "M268 112l144 144-144 144M392 256H100"
    });
  };
  var Close = () => {
    return /* @__PURE__ */ import_react5.default.createElement("path", {
      d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
    });
  };

  // src/components/UI/Badge/Badge.tsx
  var import_react6 = __toESM(require_react());

  // src/components/UI/Badge/Badge.styled.ts
  var BadgeStyled = styled("span", {
    display: "flex",
    fontWeight: "700",
    margin: "0 0.25rem 0 0"
  });

  // src/components/UI/Badge/Badge.tsx
  var Badge = ({ children }) => {
    return /* @__PURE__ */ import_react6.default.createElement(BadgeStyled, null, children);
  };
  var Badge_default = Badge;

  // src/components/UI/Button/Button.tsx
  var import_react7 = __toESM(require_react());
  var Button = ({
    as = "button",
    children,
    href,
    onClick
  }) => {
    return /* @__PURE__ */ import_react7.default.createElement(ButtonStyled, {
      as,
      href,
      target: href && "_blank",
      onClick
    }, children);
  };
  var Button_default = Button;

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // node_modules/@radix-ui/react-dialog/dist/index.module.js
  var import_react22 = __toESM(require_react());

  // node_modules/@radix-ui/primitive/dist/index.module.js
  function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-compose-refs/dist/index.module.js
  var import_react8 = __toESM(require_react());
  function $6ed0406888f73fc4$var$setRef(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
    return (0, import_react8.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
  }

  // node_modules/@radix-ui/react-context/dist/index.module.js
  var import_react9 = __toESM(require_react());
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const Context = /* @__PURE__ */ (0, import_react9.createContext)(defaultContext);
    function Provider(props) {
      const { children, ...context } = props;
      const value = (0, import_react9.useMemo)(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ (0, import_react9.createElement)(Context.Provider, {
        value
      }, children);
    }
    function useContext2(consumerName) {
      const context = (0, import_react9.useContext)(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext2
    ];
  }
  function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react9.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react9.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react9.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react9.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react9.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react9.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react9.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-id/dist/index.module.js
  var $2AODx$react = __toESM(require_react());

  // node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js
  var import_react10 = __toESM(require_react());
  var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react10.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-id/dist/index.module.js
  var $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
  var $1746a345f3d73bb7$var$count = 0;
  function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
    const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (!deterministicId)
        setId(
          (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
        );
    }, [
      deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : "");
  }

  // node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
  var import_react12 = __toESM(require_react());

  // node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js
  var import_react11 = __toESM(require_react());
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
    const callbackRef = (0, import_react11.useRef)(callback);
    (0, import_react11.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react11.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
  function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
    const setValue = (0, import_react12.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react12.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react12.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
    (0, import_react12.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
  var import_react16 = __toESM(require_react());

  // node_modules/@radix-ui/react-primitive/dist/index.module.js
  var import_react14 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());

  // node_modules/@radix-ui/react-slot/dist/index.module.js
  var import_react13 = __toESM(require_react());
  var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react13.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react13.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react13.Children.count(newElement) > 1)
            return import_react13.Children.only(null);
          return /* @__PURE__ */ (0, import_react13.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react13.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react13.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react13.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react13.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react13.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react13.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react13.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
        ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
      });
    return import_react13.Children.count(children) > 1 ? import_react13.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react13.createElement)(import_react13.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable(child) {
    return /* @__PURE__ */ (0, import_react13.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
  }
  function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler)
        overrideProps[propName] = (...args) => {
          childPropValue === null || childPropValue === void 0 || childPropValue(...args);
          slotPropValue === null || slotPropValue === void 0 || slotPropValue(...args);
        };
      else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-primitive/dist/index.module.js
  var $8927f6f2acc4f386$var$NODES = [
    "a",
    "button",
    "div",
    "h2",
    "h3",
    "img",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react14.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
      (0, import_react14.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react14.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});
  function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
    if (target)
      (0, import_react_dom.flushSync)(
        () => target.dispatchEvent(event)
      );
  }

  // node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
  var import_react15 = __toESM(require_react());
  function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp) {
    const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
    (0, import_react15.useEffect)(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape")
          onEscapeKeyDown(event);
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [
      onEscapeKeyDown
    ]);
  }

  // node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
  var $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
  var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var $5cb92bef7577960e$var$originalBodyPointerEvents;
  var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react16.createContext)({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react16.forwardRef)((props, forwardedRef) => {
    const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
    const context = (0, import_react16.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
    const [node1, setNode] = (0, import_react16.useState)(null);
    const [, force] = (0, import_react16.useState)({});
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setNode(node)
    );
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [
      ...context.layersWithOutsidePointerEventsDisabled
    ].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node1 ? layers.indexOf(node1) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    });
    const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (isFocusInBranch)
        return;
      onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    });
    $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    });
    (0, import_react16.useEffect)(() => {
      if (!node1)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          $5cb92bef7577960e$var$originalBodyPointerEvents = document.body.style.pointerEvents;
          document.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node1);
      }
      context.layers.add(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
          document.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
      };
    }, [
      node1,
      disableOutsidePointerEvents,
      context
    ]);
    (0, import_react16.useEffect)(() => {
      return () => {
        if (!node1)
          return;
        context.layers.delete(node1);
        context.layersWithOutsidePointerEventsDisabled.delete(node1);
        $5cb92bef7577960e$var$dispatchUpdate();
      };
    }, [
      node1,
      context
    ]);
    (0, import_react16.useEffect)(() => {
      const handleUpdate = () => force({});
      document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_react16.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
      ref: composedRefs,
      style: {
        pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
        ...props.style
      },
      onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
      onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
      onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
    }));
  });
  function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside) {
    const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
    const isPointerInsideReactTreeRef = (0, import_react16.useRef)(false);
    const handleClickRef = (0, import_react16.useRef)(() => {
    });
    (0, import_react16.useEffect)(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent = function() {
            $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
              discrete: true
            });
          };
          const eventDetail = {
            originalEvent: event
          };
          if (event.pointerType === "touch") {
            document.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
            document.addEventListener("click", handleClickRef.current, {
              once: true
            });
          } else
            handleAndDispatchPointerDownOutsideEvent();
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        document.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        document.removeEventListener("pointerdown", handlePointerDown);
        document.removeEventListener("click", handleClickRef.current);
      };
    }, [
      handlePointerDownOutside
    ]);
    return {
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside) {
    const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
    const isFocusInsideReactTreeRef = (0, import_react16.useRef)(false);
    (0, import_react16.useEffect)(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = {
            originalEvent: event
          };
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      document.addEventListener("focusin", handleFocus);
      return () => document.removeEventListener("focusin", handleFocus);
    }, [
      handleFocusOutside
    ]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function $5cb92bef7577960e$var$dispatchUpdate() {
    const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, {
      bubbles: false,
      cancelable: true,
      detail
    });
    if (handler)
      target.addEventListener(name, handler, {
        once: true
      });
    if (discrete)
      $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
    else
      target.dispatchEvent(event);
  }

  // node_modules/@radix-ui/react-focus-scope/dist/index.module.js
  var import_react17 = __toESM(require_react());
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
  };
  var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react17.forwardRef)((props, forwardedRef) => {
    const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
    const [container1, setContainer] = (0, import_react17.useState)(null);
    const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
    const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
    const lastFocusedElementRef = (0, import_react17.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setContainer(node)
    );
    const focusScope = (0, import_react17.useRef)({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    (0, import_react17.useEffect)(() => {
      if (trapped) {
        let handleFocusIn = function(event) {
          if (focusScope.paused || !container1)
            return;
          const target = event.target;
          if (container1.contains(target))
            lastFocusedElementRef.current = target;
          else
            $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
              select: true
            });
        }, handleFocusOut = function(event) {
          if (focusScope.paused || !container1)
            return;
          if (!container1.contains(event.relatedTarget))
            $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
              select: true
            });
        };
        document.addEventListener("focusin", handleFocusIn);
        document.addEventListener("focusout", handleFocusOut);
        return () => {
          document.removeEventListener("focusin", handleFocusIn);
          document.removeEventListener("focusout", handleFocusOut);
        };
      }
    }, [
      trapped,
      container1,
      focusScope.paused
    ]);
    (0, import_react17.useEffect)(() => {
      if (container1) {
        $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container1.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
              select: true
            });
            if (document.activeElement === previouslyFocusedElement)
              $d3863c46a17e8a28$var$focus(container1);
          }
        }
        return () => {
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
            container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container1.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented)
              $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
                select: true
              });
            container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [
      container1,
      onMountAutoFocus,
      onUnmountAutoFocus,
      focusScope
    ]);
    const handleKeyDown = (0, import_react17.useCallback)((event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus(first, {
                select: true
              });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus(last, {
                select: true
              });
          }
        }
      }
    }, [
      loop,
      trapped,
      focusScope.paused
    ]);
    return /* @__PURE__ */ (0, import_react17.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      tabIndex: -1
    }, scopeProps, {
      ref: composedRefs,
      onKeyDown: handleKeyDown
    }));
  });
  function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      $d3863c46a17e8a28$var$focus(candidate, {
        select
      });
      if (document.activeElement !== previouslyFocusedElement)
        return;
    }
  }
  function $d3863c46a17e8a28$var$getTabbableEdges(container2) {
    const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container2);
    const first = $d3863c46a17e8a28$var$findVisible(candidates, container2);
    const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container2);
    return [
      first,
      last
    ];
  }
  function $d3863c46a17e8a28$var$getTabbableCandidates(container2) {
    const nodes = [];
    const walker = document.createTreeWalker(container2, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  }
  function $d3863c46a17e8a28$var$findVisible(elements, container2) {
    for (const element of elements) {
      if (!$d3863c46a17e8a28$var$isHidden(element, {
        upTo: container2
      }))
        return element;
    }
  }
  function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden")
      return true;
    while (node) {
      if (upTo !== void 0 && node === upTo)
        return false;
      if (getComputedStyle(node).display === "none")
        return true;
      node = node.parentElement;
    }
    return false;
  }
  function $d3863c46a17e8a28$var$isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({
        preventScroll: true
      });
      if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
        element.select();
    }
  }
  var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
  function $d3863c46a17e8a28$var$createFocusScopesStack() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope)
          activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
        stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        var _stack$;
        stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);
        (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
      }
    };
  }
  function $d3863c46a17e8a28$var$arrayRemove(array, item) {
    const updatedArray = [
      ...array
    ];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1)
      updatedArray.splice(index2, 1);
    return updatedArray;
  }
  function $d3863c46a17e8a28$var$removeLinks(items) {
    return items.filter(
      (item) => item.tagName !== "A"
    );
  }

  // node_modules/@radix-ui/react-portal/dist/index.module.js
  var import_react18 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());
  var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react18.forwardRef)((props, forwardedRef) => {
    var _globalThis$document;
    const { container: container2 = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body, ...portalProps } = props;
    return container2 ? /* @__PURE__ */ import_react_dom2.default.createPortal(/* @__PURE__ */ (0, import_react18.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
      ref: forwardedRef
    })), container2) : null;
  });

  // node_modules/@radix-ui/react-presence/dist/index.module.js
  var import_react19 = __toESM(require_react());
  var import_react_dom3 = __toESM(require_react_dom());
  function $fe963b355347cc68$export$3e6543de14f8614f(initialState3, machine) {
    return (0, import_react19.useReducer)((state, event) => {
      const nextState = machine[state][event];
      return nextState !== null && nextState !== void 0 ? nextState : state;
    }, initialState3);
  }
  var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
    const { present, children } = props;
    const presence = $921a889cee6df7e8$var$usePresence(present);
    const child = typeof children === "function" ? children({
      present: presence.isPresent
    }) : import_react19.Children.only(children);
    const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react19.cloneElement)(child, {
      ref
    }) : null;
  };
  $921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
  function $921a889cee6df7e8$var$usePresence(present) {
    const [node1, setNode] = (0, import_react19.useState)();
    const stylesRef = (0, import_react19.useRef)({});
    const prevPresentRef = (0, import_react19.useRef)(present);
    const prevAnimationNameRef = (0, import_react19.useRef)("none");
    const initialState3 = present ? "mounted" : "unmounted";
    const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState3, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    (0, import_react19.useEffect)(() => {
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [
      state
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      const styles = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
        if (present)
          send("MOUNT");
        else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
          send("UNMOUNT");
        else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating)
            send("ANIMATION_OUT");
          else
            send("UNMOUNT");
        }
        prevPresentRef.current = present;
      }
    }, [
      present,
      send
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (node1) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node1 && isCurrentAnimation)
            (0, import_react_dom3.flushSync)(
              () => send("ANIMATION_END")
            );
        };
        const handleAnimationStart = (event) => {
          if (event.target === node1)
            prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        };
        node1.addEventListener("animationstart", handleAnimationStart);
        node1.addEventListener("animationcancel", handleAnimationEnd);
        node1.addEventListener("animationend", handleAnimationEnd);
        return () => {
          node1.removeEventListener("animationstart", handleAnimationStart);
          node1.removeEventListener("animationcancel", handleAnimationEnd);
          node1.removeEventListener("animationend", handleAnimationEnd);
        };
      } else
        send("ANIMATION_END");
    }, [
      node1,
      send
    ]);
    return {
      isPresent: [
        "mounted",
        "unmountSuspended"
      ].includes(state),
      ref: (0, import_react19.useCallback)((node) => {
        if (node)
          stylesRef.current = getComputedStyle(node);
        setNode(node);
      }, [])
    };
  }
  function $921a889cee6df7e8$var$getAnimationName(styles) {
    return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
  }

  // node_modules/@radix-ui/react-focus-guards/dist/index.module.js
  var import_react20 = __toESM(require_react());
  var $3db38b7d1fb3fe6a$var$count = 0;
  function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
    (0, import_react20.useEffect)(() => {
      var _edgeGuards$, _edgeGuards$2;
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
      document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
      $3db38b7d1fb3fe6a$var$count++;
      return () => {
        if ($3db38b7d1fb3fe6a$var$count === 1)
          document.querySelectorAll("[data-radix-focus-guard]").forEach(
            (node) => node.remove()
          );
        $3db38b7d1fb3fe6a$var$count--;
      };
    }, []);
  }
  function $3db38b7d1fb3fe6a$var$createFocusGuard() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
    return element;
  }

  // node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn
  } = import_tslib.default;

  // node_modules/react-remove-scroll/dist/es2015/Combination.js
  var React12 = __toESM(require_react());

  // node_modules/react-remove-scroll/dist/es2015/UI.js
  var React8 = __toESM(require_react());

  // node_modules/react-remove-scroll-bar/dist/es2015/constants.js
  var zeroRightClassName = "right-scroll-bar-position";
  var fullWidthClassName = "width-before-scroll-bar";
  var noScrollbarsClassName = "with-scroll-bars-hidden";
  var removedBarSizeVariable = "--removed-body-scroll-bar-size";

  // node_modules/use-callback-ref/dist/es2015/assignRef.js
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }

  // node_modules/use-callback-ref/dist/es2015/useRef.js
  var import_react21 = __toESM(require_react());
  function useCallbackRef(initialValue, callback) {
    var ref = (0, import_react21.useState)(function() {
      return {
        value: initialValue,
        callback,
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last = ref.value;
            if (last !== value) {
              ref.value = value;
              ref.callback(value, last);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }

  // node_modules/use-callback-ref/dist/es2015/useMergeRef.js
  function useMergeRefs(refs, defaultValue) {
    return useCallbackRef(defaultValue || null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
  }

  // node_modules/use-sidecar/dist/es2015/medium.js
  function ItoI(a2) {
    return a2;
  }
  function innerCreateMedium(defaults2, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults2;
      },
      useMedium: function(data) {
        var item = middleware(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x2) {
            return x2 !== item;
          });
        };
      },
      assignSyncMedium: function(cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function(x2) {
            return cb(x2);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x2) {
            pendingQueue.push(x2);
            cycle();
          },
          filter: function(filter) {
            pendingQueue = pendingQueue.filter(filter);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createSidecarMedium(options) {
    if (options === void 0) {
      options = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options);
    return medium;
  }

  // node_modules/use-sidecar/dist/es2015/exports.js
  var React7 = __toESM(require_react());
  var SideCar = function(_a) {
    var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
    if (!sideCar) {
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error("Sidecar medium not found");
    }
    return React7.createElement(Target, __assign({}, rest));
  };
  SideCar.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
  }

  // node_modules/react-remove-scroll/dist/es2015/medium.js
  var effectCar = createSidecarMedium();

  // node_modules/react-remove-scroll/dist/es2015/UI.js
  var nothing = function() {
    return;
  };
  var RemoveScroll = React8.forwardRef(function(props, parentRef) {
    var ref = React8.useRef(null);
    var _a = React8.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return React8.createElement(
      React8.Fragment,
      null,
      enabled && React8.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
      forwardProps ? React8.cloneElement(React8.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React8.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };

  // node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var React11 = __toESM(require_react());

  // node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var React10 = __toESM(require_react());

  // node_modules/react-style-singleton/dist/es2015/hook.js
  var React9 = __toESM(require_react());

  // node_modules/get-nonce/dist/es2015/index.js
  var currentNonce;
  var getNonce = function() {
    if (currentNonce) {
      return currentNonce;
    }
    if (typeof __webpack_nonce__ !== "undefined") {
      return __webpack_nonce__;
    }
    return void 0;
  };

  // node_modules/react-style-singleton/dist/es2015/singleton.js
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    return tag;
  }
  function injectStyles(tag, css2) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css2;
    } else {
      tag.appendChild(document.createTextNode(css2));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function(style) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function() {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };

  // node_modules/react-style-singleton/dist/es2015/hook.js
  var styleHookSingleton = function() {
    var sheet = stylesheetSingleton();
    return function(styles, isDynamic) {
      React9.useEffect(function() {
        sheet.add(styles);
        return function() {
          sheet.remove();
        };
      }, [styles && isDynamic]);
    };
  };

  // node_modules/react-style-singleton/dist/es2015/component.js
  var styleSingleton = function() {
    var useStyle = styleHookSingleton();
    var Sheet = function(_a) {
      var styles = _a.styles, dynamic = _a.dynamic;
      useStyle(styles, dynamic);
      return null;
    };
    return Sheet;
  };

  // node_modules/react-remove-scroll-bar/dist/es2015/utils.js
  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };
  var parse = function(x2) {
    return parseInt(x2 || "", 10) || 0;
  };
  var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    if (true) {
      if (cs.overflowY === "hidden") {
        console.error("react-remove-scroll-bar: cannot calculate scrollbar size because it is removed (overflow:hidden on body");
      }
    }
    var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
    var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
    var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse(left), parse(top), parse(right)];
  };
  var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    if (typeof window === "undefined") {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };

  // node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var Style = styleSingleton();
  var getStyles = function(_a, allowRelative, gapMode, important) {
    var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
      gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
  };
  var RemoveScrollBar = function(props) {
    var noRelative = props.noRelative, noImportant = props.noImportant, _a = props.gapMode, gapMode = _a === void 0 ? "margin" : _a;
    var gap = React10.useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return React10.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
  };

  // node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var options;
  var nonPassive = passiveSupported ? { passive: false } : false;

  // node_modules/react-remove-scroll/dist/es2015/handleScroll.js
  var elementCouldBeVScrolled = function(node) {
    var styles = window.getComputedStyle(node);
    return styles.overflowY !== "hidden" && !(styles.overflowY === styles.overflowX && styles.overflowY === "visible");
  };
  var elementCouldBeHScrolled = function(node) {
    var styles = window.getComputedStyle(node);
    return styles.overflowX !== "hidden" && !(styles.overflowY === styles.overflowX && styles.overflowX === "visible");
  };
  var locationCouldBeScrolled = function(axis, node) {
    var current = node;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables(axis, current), s2 = _a[1], d3 = _a[2];
        if (s2 > d3) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== document.body);
    return false;
  };
  var getVScrollVariables = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled = function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
  };
  var getScrollVariables = function(axis, node) {
    return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
  };
  var getDirectionFactor = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      target = target.parentNode;
    } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
    if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };

  // node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var getTouchXY = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare = function(x2, y2) {
    return x2[0] === y2[0] && x2[1] === y2[1];
  };
  var generateStyle = function(id) {
    return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = React11.useRef([]);
    var touchStartRef = React11.useRef([0, 0]);
    var activeAxis = React11.useRef();
    var id = React11.useState(idCounter++)[0];
    var Style2 = React11.useState(function() {
      return styleSingleton();
    })[0];
    var lastProps = React11.useRef(props);
    React11.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    React11.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React11.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React11.useCallback(function(_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
        return e3.name === event.type && e3.target === event.target && deltaCompare(e3.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        event.preventDefault();
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          event.preventDefault();
        }
      }
    }, []);
    var shouldCancel = React11.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
          return e3 !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = React11.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = React11.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React11.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React11.useEffect(function() {
      lockStack.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive);
      document.addEventListener("touchmove", shouldPrevent, nonPassive);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive);
      return function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return React11.createElement(
      React11.Fragment,
      null,
      inert ? React11.createElement(Style2, { styles: generateStyle(id) }) : null,
      removeScrollBar ? React11.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
    );
  }

  // node_modules/react-remove-scroll/dist/es2015/sidecar.js
  var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

  // node_modules/react-remove-scroll/dist/es2015/Combination.js
  var ReactRemoveScroll = React12.forwardRef(function(props, ref) {
    return React12.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var Combination_default = ReactRemoveScroll;

  // node_modules/aria-hidden/dist/es2015/index.js
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = Array.isArray(originalTarget) ? originalTarget : [originalTarget];
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node) {
        if (elementsToKeep.has(node)) {
          deep(node);
        } else {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node) {
        var counterValue = counterMap.get(node) - 1;
        var markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node)) {
            node.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node);
        }
        if (!markerValue) {
          node.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };

  // node_modules/@radix-ui/react-dialog/dist/index.module.js
  var $5d3850c4d0b4e6c7$var$DIALOG_NAME = "Dialog";
  var [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);
  var [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);
  var $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {
    const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
    const triggerRef = (0, import_react22.useRef)(null);
    const contentRef = (0, import_react22.useRef)(null);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react22.createElement)($5d3850c4d0b4e6c7$var$DialogProvider, {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
      titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
      descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: (0, import_react22.useCallback)(
        () => setOpen(
          (prevOpen) => !prevOpen
        ),
        [
          setOpen
        ]
      ),
      modal
    }, children);
  };
  var $5d3850c4d0b4e6c7$var$TRIGGER_NAME = "DialogTrigger";
  var $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88 = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": context.open,
      "aria-controls": context.contentId,
      "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, triggerProps, {
      ref: composedTriggerRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
    }));
  });
  var $5d3850c4d0b4e6c7$var$PORTAL_NAME = "DialogPortal";
  var [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
    forceMount: void 0
  });
  var $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {
    const { __scopeDialog, forceMount, children, container: container2 } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_react22.createElement)($5d3850c4d0b4e6c7$var$PortalProvider, {
      scope: __scopeDialog,
      forceMount
    }, import_react22.Children.map(
      children,
      (child) => /* @__PURE__ */ (0, import_react22.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, /* @__PURE__ */ (0, import_react22.createElement)($f1701beae083dbae$export$602eac185826482c, {
        asChild: true,
        container: container2
      }, child))
    ));
  };
  var $5d3850c4d0b4e6c7$var$OVERLAY_NAME = "DialogOverlay";
  var $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ (0, import_react22.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ (0, import_react22.createElement)($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends({}, overlayProps, {
      ref: forwardedRef
    }))) : null;
  });
  var $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_react22.createElement)(Combination_default, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      allowPinchZoom: true,
      shards: [
        context.contentRef
      ]
    }, /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, overlayProps, {
      ref: forwardedRef,
      style: {
        pointerEvents: "auto",
        ...overlayProps.style
      }
    })));
  });
  var $5d3850c4d0b4e6c7$var$CONTENT_NAME = "DialogContent";
  var $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    return /* @__PURE__ */ (0, import_react22.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, context.modal ? /* @__PURE__ */ (0, import_react22.createElement)($5d3850c4d0b4e6c7$var$DialogContentModal, _extends({}, contentProps, {
      ref: forwardedRef
    })) : /* @__PURE__ */ (0, import_react22.createElement)($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends({}, contentProps, {
      ref: forwardedRef
    })));
  });
  var $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const contentRef = (0, import_react22.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);
    (0, import_react22.useEffect)(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_react22.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
      ref: composedRefs,
      trapFocus: context.open,
      disableOutsidePointerEvents: true,
      onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
        var _context$triggerRef$c;
        event.preventDefault();
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      }),
      onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
        const originalEvent = event.detail.originalEvent;
        const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
        const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
        if (isRightClick)
          event.preventDefault();
      }),
      onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onFocusOutside,
        (event) => event.preventDefault()
      )
    }));
  });
  var $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = (0, import_react22.useRef)(false);
    return /* @__PURE__ */ (0, import_react22.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      onCloseAutoFocus: (event) => {
        var _props$onCloseAutoFoc;
        (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
        if (!event.defaultPrevented) {
          var _context$triggerRef$c2;
          if (!hasInteractedOutsideRef.current)
            (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
          event.preventDefault();
        }
        hasInteractedOutsideRef.current = false;
      },
      onInteractOutside: (event) => {
        var _props$onInteractOuts, _context$triggerRef$c3;
        (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
        if (!event.defaultPrevented)
          hasInteractedOutsideRef.current = true;
        const target = event.target;
        const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
        if (targetIsTrigger)
          event.preventDefault();
      }
    }));
  });
  var $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);
    const contentRef = (0, import_react22.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
    return /* @__PURE__ */ (0, import_react22.createElement)(import_react22.Fragment, null, /* @__PURE__ */ (0, import_react22.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus
    }, /* @__PURE__ */ (0, import_react22.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends({
      role: "dialog",
      id: context.contentId,
      "aria-describedby": context.descriptionId,
      "aria-labelledby": context.titleId,
      "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, contentProps, {
      ref: composedRefs,
      onDismiss: () => context.onOpenChange(false)
    }))), false);
  });
  var $5d3850c4d0b4e6c7$var$TITLE_NAME = "DialogTitle";
  var $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.h2, _extends({
      id: context.titleId
    }, titleProps, {
      ref: forwardedRef
    }));
  });
  var $5d3850c4d0b4e6c7$var$CLOSE_NAME = "DialogClose";
  var $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ (0, import_react22.forwardRef)((props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_react22.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
      type: "button"
    }, closeProps, {
      ref: forwardedRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onClick,
        () => context.onOpenChange(false)
      )
    }));
  });
  function $5d3850c4d0b4e6c7$var$getState(open) {
    return open ? "open" : "closed";
  }
  var $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = "DialogTitleWarning";
  var [$5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext] = $c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {
    contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,
    titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,
    docsSlug: "dialog"
  });
  var $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;
  var $5d3850c4d0b4e6c7$export$41fb9f06171c75f4 = $5d3850c4d0b4e6c7$export$2e1e1122cf0cba88;
  var $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;
  var $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;
  var $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;
  var $5d3850c4d0b4e6c7$export$f99233281efd08a0 = $5d3850c4d0b4e6c7$export$16f7638e4a34b909;
  var $5d3850c4d0b4e6c7$export$f39c2d165cd861fe = $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac;

  // src/components/UI/Modal/Modal.tsx
  var import_react25 = __toESM(require_react());

  // src/components/UI/Modal/Modal.styled.ts
  var ModalContent = re($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, {
    position: "fixed",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    width: "90vw",
    maxWidth: "90vw",
    maxHeight: "90vh",
    backgroundColor: "#1a1d1e",
    overflow: "hidden",
    borderRadius: "3px",
    filter: "drop-shadow(8px 8px 19px #0006)"
  });
  var ModalContentHeader = re("div", {
    display: "flex",
    justifyContent: "space-between",
    padding: "0 1rem",
    fontSize: "0.8333rem",
    alignContent: "center",
    h2: {
      fontFamily: "$sans",
      fontWeight: "400",
      fontSize: "inherit",
      color: "#fff"
    },
    [`> ${ButtonStyled}`]: {
      fontSize: "inherit",
      background: "transparent",
      color: "#fff",
      fill: "#fff",
      stroke: "#fff",
      padding: "0",
      "&:hover, &:active": {
        background: "transparent"
      }
    }
  });
  var ModalContentInner = re("div", {
    backgroundColor: "#fff",
    minHeight: "500px"
  });
  var ModalClose = re($5d3850c4d0b4e6c7$export$f39c2d165cd861fe, {});
  var ModalOverlay = re($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, {
    position: "fixed",
    backgroundColor: "#000c",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%"
  });

  // src/components/UI/SVG/SVG.tsx
  var import_react24 = __toESM(require_react());
  var SVG = ({ children }) => {
    return /* @__PURE__ */ import_react24.default.createElement(SVGStyled, {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 512 512"
    }, /* @__PURE__ */ import_react24.default.createElement("title", null, "Arrow Forward"), children);
  };
  var SVG_default = SVG;

  // src/components/UI/Modal/Modal.tsx
  var Modal = ({ buttonText, children, title }) => {
    return /* @__PURE__ */ import_react25.default.createElement($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, null, /* @__PURE__ */ import_react25.default.createElement($5d3850c4d0b4e6c7$export$41fb9f06171c75f4, {
      asChild: true
    }, /* @__PURE__ */ import_react25.default.createElement(ButtonStyled, null, buttonText)), /* @__PURE__ */ import_react25.default.createElement($5d3850c4d0b4e6c7$export$602eac185826482c, null, /* @__PURE__ */ import_react25.default.createElement(ModalOverlay, null), /* @__PURE__ */ import_react25.default.createElement(ModalContent, null, /* @__PURE__ */ import_react25.default.createElement(ModalContentHeader, null, title && /* @__PURE__ */ import_react25.default.createElement($5d3850c4d0b4e6c7$export$f99233281efd08a0, null, title), /* @__PURE__ */ import_react25.default.createElement(ModalClose, {
      asChild: true
    }, /* @__PURE__ */ import_react25.default.createElement(ButtonStyled, null, "Close", /* @__PURE__ */ import_react25.default.createElement(SVG_default, null, /* @__PURE__ */ import_react25.default.createElement(Close, null))))), /* @__PURE__ */ import_react25.default.createElement(ModalContentInner, null, children))));
  };
  var Modal_default = Modal;

  // src/components/UI/Workspace/Panel/Panel.tsx
  var import_react43 = __toESM(require_react());

  // node_modules/react-dnd/dist/core/DndContext.js
  var import_react26 = __toESM(require_react(), 1);
  var DndContext = (0, import_react26.createContext)({
    dragDropManager: void 0
  });

  // node_modules/react-dnd/dist/core/DndProvider.js
  var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // node_modules/@babel/runtime/helpers/esm/objectSpread2.js
  function ownKeys(e3, r2) {
    var t2 = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e3);
      r2 && (o2 = o2.filter(function(r3) {
        return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
      })), t2.push.apply(t2, o2);
    }
    return t2;
  }
  function _objectSpread2(e3) {
    for (var r2 = 1; r2 < arguments.length; r2++) {
      var t2 = null != arguments[r2] ? arguments[r2] : {};
      r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
        _defineProperty(e3, r3, t2[r3]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
        Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
      });
    }
    return e3;
  }

  // node_modules/redux/es/redux.js
  var $$observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();
  var randomString = function randomString2() {
    return Math.random().toString(36).substring(7).split("").join(".");
  };
  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };
  function isPlainObject(obj) {
    if (typeof obj !== "object" || obj === null)
      return false;
    var proto = obj;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(obj) === proto;
  }
  function miniKindOf(val) {
    if (val === void 0)
      return "undefined";
    if (val === null)
      return "null";
    var type = typeof val;
    switch (type) {
      case "boolean":
      case "string":
      case "number":
      case "symbol":
      case "function": {
        return type;
      }
    }
    if (Array.isArray(val))
      return "array";
    if (isDate(val))
      return "date";
    if (isError(val))
      return "error";
    var constructorName = ctorName(val);
    switch (constructorName) {
      case "Symbol":
      case "Promise":
      case "WeakMap":
      case "WeakSet":
      case "Map":
      case "Set":
        return constructorName;
    }
    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
  }
  function ctorName(val) {
    return typeof val.constructor === "function" ? val.constructor.name : null;
  }
  function isError(val) {
    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
  }
  function isDate(val) {
    if (val instanceof Date)
      return true;
    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
  }
  function kindOf(val) {
    var typeOfVal = typeof val;
    if (true) {
      typeOfVal = miniKindOf(val);
    }
    return typeOfVal;
  }
  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;
    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
      throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
    }
    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
      enhancer = preloadedState;
      preloadedState = void 0;
    }
    if (typeof enhancer !== "undefined") {
      if (typeof enhancer !== "function") {
        throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
      }
      return enhancer(createStore)(reducer, preloadedState);
    }
    if (typeof reducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
    }
    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    function getState() {
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
      }
      return currentState;
    }
    function subscribe(listener) {
      if (typeof listener !== "function") {
        throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }
        if (isDispatching) {
          throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        }
        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index2 = nextListeners.indexOf(listener);
        nextListeners.splice(index2, 1);
        currentListeners = null;
      };
    }
    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
      }
      if (typeof action.type === "undefined") {
        throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
      }
      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }
      var listeners = currentListeners = nextListeners;
      for (var i2 = 0; i2 < listeners.length; i2++) {
        var listener = listeners[i2];
        listener();
      }
      return action;
    }
    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== "function") {
        throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
      }
      currentReducer = nextReducer;
      dispatch({
        type: ActionTypes.REPLACE
      });
    }
    function observable() {
      var _ref;
      var outerSubscribe = subscribe;
      return _ref = {
        subscribe: function subscribe2(observer) {
          if (typeof observer !== "object" || observer === null) {
            throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
          }
          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }
          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe
          };
        }
      }, _ref[$$observable] = function() {
        return this;
      }, _ref;
    }
    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch,
      subscribe,
      getState,
      replaceReducer
    }, _ref2[$$observable] = observable, _ref2;
  }
  function warning(message) {
    if (typeof console !== "undefined" && typeof console.error === "function") {
      console.error(message);
    }
    try {
      throw new Error(message);
    } catch (e3) {
    }
  }
  function getUnexpectedStateShapeWarningMessage(inputState, reducers2, action, unexpectedKeyCache) {
    var reducerKeys = Object.keys(reducers2);
    var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
    if (reducerKeys.length === 0) {
      return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
    }
    if (!isPlainObject(inputState)) {
      return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
    }
    var unexpectedKeys = Object.keys(inputState).filter(function(key) {
      return !reducers2.hasOwnProperty(key) && !unexpectedKeyCache[key];
    });
    unexpectedKeys.forEach(function(key) {
      unexpectedKeyCache[key] = true;
    });
    if (action && action.type === ActionTypes.REPLACE)
      return;
    if (unexpectedKeys.length > 0) {
      return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
    }
  }
  function assertReducerShape(reducers2) {
    Object.keys(reducers2).forEach(function(key) {
      var reducer = reducers2[key];
      var initialState3 = reducer(void 0, {
        type: ActionTypes.INIT
      });
      if (typeof initialState3 === "undefined") {
        throw new Error(false ? formatProdErrorMessage(12) : 'The slice reducer for key "' + key + `" returned undefined during initialization. If the state passed to the reducer is undefined, you must explicitly return the initial state. The initial state may not be undefined. If you don't want to set a value for this reducer, you can use null instead of undefined.`);
      }
      if (typeof reducer(void 0, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === "undefined") {
        throw new Error(false ? formatProdErrorMessage(13) : 'The slice reducer for key "' + key + '" returned undefined when probed with a random type. ' + ("Don't try to handle '" + ActionTypes.INIT + `' or other actions in "redux/*" `) + "namespace. They are considered private. Instead, you must return the current state for any unknown actions, unless it is undefined, in which case you must return the initial state, regardless of the action type. The initial state may not be undefined, but can be null.");
      }
    });
  }
  function combineReducers(reducers2) {
    var reducerKeys = Object.keys(reducers2);
    var finalReducers = {};
    for (var i2 = 0; i2 < reducerKeys.length; i2++) {
      var key = reducerKeys[i2];
      if (true) {
        if (typeof reducers2[key] === "undefined") {
          warning('No reducer provided for key "' + key + '"');
        }
      }
      if (typeof reducers2[key] === "function") {
        finalReducers[key] = reducers2[key];
      }
    }
    var finalReducerKeys = Object.keys(finalReducers);
    var unexpectedKeyCache;
    if (true) {
      unexpectedKeyCache = {};
    }
    var shapeAssertionError;
    try {
      assertReducerShape(finalReducers);
    } catch (e3) {
      shapeAssertionError = e3;
    }
    return function combination(state, action) {
      if (state === void 0) {
        state = {};
      }
      if (shapeAssertionError) {
        throw shapeAssertionError;
      }
      if (true) {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);
        if (warningMessage) {
          warning(warningMessage);
        }
      }
      var hasChanged = false;
      var nextState = {};
      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);
        if (typeof nextStateForKey === "undefined") {
          var actionType = action && action.type;
          throw new Error(false ? formatProdErrorMessage(14) : "When called with an action of type " + (actionType ? '"' + String(actionType) + '"' : "(unknown type)") + ', the slice reducer for key "' + _key + '" returned undefined. To ignore an action, you must explicitly return the previous state. If you want this reducer to hold no value, you can return null instead of undefined.');
        }
        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }
      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }
  function compose() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }
    if (funcs.length === 0) {
      return function(arg) {
        return arg;
      };
    }
    if (funcs.length === 1) {
      return funcs[0];
    }
    return funcs.reduce(function(a2, b3) {
      return function() {
        return a2(b3.apply(void 0, arguments));
      };
    });
  }
  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }
    return function(createStore3) {
      return function() {
        var store = createStore3.apply(void 0, arguments);
        var _dispatch = function dispatch() {
          throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
        };
        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch() {
            return _dispatch.apply(void 0, arguments);
          }
        };
        var chain = middlewares.map(function(middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose.apply(void 0, chain)(store.dispatch);
        return _objectSpread2(_objectSpread2({}, store), {}, {
          dispatch: _dispatch
        });
      };
    };
  }
  function isCrushed() {
  }
  if (typeof isCrushed.name === "string" && isCrushed.name !== "isCrushed") {
    warning('You are currently using minified code outside of NODE_ENV === "production". This means that you are running a slower development build of Redux. You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) to ensure you have the correct code for your production build.');
  }

  // node_modules/@react-dnd/invariant/dist/index.js
  function invariant(condition, format, ...args) {
    if (isProduction()) {
      if (format === void 0) {
        throw new Error("invariant requires an error message argument");
      }
    }
    if (!condition) {
      let error;
      if (format === void 0) {
        error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      } else {
        let argIndex = 0;
        error = new Error(format.replace(/%s/g, function() {
          return args[argIndex++];
        }));
        error.name = "Invariant Violation";
      }
      error.framesToPop = 1;
      throw error;
    }
  }
  function isProduction() {
    return typeof process !== "undefined" && false;
  }

  // node_modules/dnd-core/dist/utils/js_utils.js
  function get(obj, path, defaultValue) {
    return path.split(".").reduce(
      (a2, c2) => a2 && a2[c2] ? a2[c2] : defaultValue || null,
      obj
    );
  }
  function without(items, item) {
    return items.filter(
      (i2) => i2 !== item
    );
  }
  function isObject(input) {
    return typeof input === "object";
  }
  function xor(itemsA, itemsB) {
    const map = /* @__PURE__ */ new Map();
    const insertItem = (item) => {
      map.set(item, map.has(item) ? map.get(item) + 1 : 1);
    };
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    map.forEach((count, key) => {
      if (count === 1) {
        result.push(key);
      }
    });
    return result;
  }
  function intersection(itemsA, itemsB) {
    return itemsA.filter(
      (t2) => itemsB.indexOf(t2) > -1
    );
  }

  // node_modules/dnd-core/dist/actions/dragDrop/types.js
  var INIT_COORDS = "dnd-core/INIT_COORDS";
  var BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
  var PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
  var HOVER = "dnd-core/HOVER";
  var DROP = "dnd-core/DROP";
  var END_DRAG = "dnd-core/END_DRAG";

  // node_modules/dnd-core/dist/actions/dragDrop/local/setClientOffset.js
  function setClientOffset(clientOffset, sourceClientOffset) {
    return {
      type: INIT_COORDS,
      payload: {
        sourceClientOffset: sourceClientOffset || null,
        clientOffset: clientOffset || null
      }
    };
  }

  // node_modules/dnd-core/dist/actions/dragDrop/beginDrag.js
  var ResetCoordinatesAction = {
    type: INIT_COORDS,
    payload: {
      clientOffset: null,
      sourceClientOffset: null
    }
  };
  function createBeginDrag(manager) {
    return function beginDrag(sourceIds = [], options = {
      publishSource: true
    }) {
      const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;
      const monitor = manager.getMonitor();
      const registry = manager.getRegistry();
      manager.dispatch(setClientOffset(clientOffset));
      verifyInvariants(sourceIds, monitor, registry);
      const sourceId = getDraggableSource(sourceIds, monitor);
      if (sourceId == null) {
        manager.dispatch(ResetCoordinatesAction);
        return;
      }
      let sourceClientOffset = null;
      if (clientOffset) {
        if (!getSourceClientOffset2) {
          throw new Error("getSourceClientOffset must be defined");
        }
        verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
        sourceClientOffset = getSourceClientOffset2(sourceId);
      }
      manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
      const source = registry.getSource(sourceId);
      const item = source.beginDrag(monitor, sourceId);
      if (item == null) {
        return void 0;
      }
      verifyItemIsObject(item);
      registry.pinSource(sourceId);
      const itemType = registry.getSourceType(sourceId);
      return {
        type: BEGIN_DRAG,
        payload: {
          itemType,
          item,
          sourceId,
          clientOffset: clientOffset || null,
          sourceClientOffset: sourceClientOffset || null,
          isSourcePublic: !!publishSource
        }
      };
    };
  }
  function verifyInvariants(sourceIds, monitor, registry) {
    invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
    sourceIds.forEach(function(sourceId) {
      invariant(registry.getSource(sourceId), "Expected sourceIds to be registered.");
    });
  }
  function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
    invariant(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
  }
  function verifyItemIsObject(item) {
    invariant(isObject(item), "Item must be an object.");
  }
  function getDraggableSource(sourceIds, monitor) {
    let sourceId = null;
    for (let i2 = sourceIds.length - 1; i2 >= 0; i2--) {
      if (monitor.canDragSource(sourceIds[i2])) {
        sourceId = sourceIds[i2];
        break;
      }
    }
    return sourceId;
  }

  // node_modules/dnd-core/dist/actions/dragDrop/drop.js
  function _defineProperty2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys3 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys3.forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    }
    return target;
  }
  function createDrop(manager) {
    return function drop(options = {}) {
      const monitor = manager.getMonitor();
      const registry = manager.getRegistry();
      verifyInvariants2(monitor);
      const targetIds = getDroppableTargets(monitor);
      targetIds.forEach((targetId, index2) => {
        const dropResult = determineDropResult(targetId, index2, registry, monitor);
        const action = {
          type: DROP,
          payload: {
            dropResult: _objectSpread({}, options, dropResult)
          }
        };
        manager.dispatch(action);
      });
    };
  }
  function verifyInvariants2(monitor) {
    invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
    invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
  }
  function determineDropResult(targetId, index2, registry, monitor) {
    const target = registry.getTarget(targetId);
    let dropResult = target ? target.drop(monitor, targetId) : void 0;
    verifyDropResultType(dropResult);
    if (typeof dropResult === "undefined") {
      dropResult = index2 === 0 ? {} : monitor.getDropResult();
    }
    return dropResult;
  }
  function verifyDropResultType(dropResult) {
    invariant(typeof dropResult === "undefined" || isObject(dropResult), "Drop result must either be an object or undefined.");
  }
  function getDroppableTargets(monitor) {
    const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
    targetIds.reverse();
    return targetIds;
  }

  // node_modules/dnd-core/dist/actions/dragDrop/endDrag.js
  function createEndDrag(manager) {
    return function endDrag() {
      const monitor = manager.getMonitor();
      const registry = manager.getRegistry();
      verifyIsDragging(monitor);
      const sourceId = monitor.getSourceId();
      if (sourceId != null) {
        const source = registry.getSource(sourceId, true);
        source.endDrag(monitor, sourceId);
        registry.unpinSource();
      }
      return {
        type: END_DRAG
      };
    };
  }
  function verifyIsDragging(monitor) {
    invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
  }

  // node_modules/dnd-core/dist/utils/matchesType.js
  function matchesType(targetType, draggedItemType) {
    if (draggedItemType === null) {
      return targetType === null;
    }
    return Array.isArray(targetType) ? targetType.some(
      (t2) => t2 === draggedItemType
    ) : targetType === draggedItemType;
  }

  // node_modules/dnd-core/dist/actions/dragDrop/hover.js
  function createHover(manager) {
    return function hover(targetIdsArg, { clientOffset } = {}) {
      verifyTargetIdsIsArray(targetIdsArg);
      const targetIds = targetIdsArg.slice(0);
      const monitor = manager.getMonitor();
      const registry = manager.getRegistry();
      const draggedItemType = monitor.getItemType();
      removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
      checkInvariants(targetIds, monitor, registry);
      hoverAllTargets(targetIds, monitor, registry);
      return {
        type: HOVER,
        payload: {
          targetIds,
          clientOffset: clientOffset || null
        }
      };
    };
  }
  function verifyTargetIdsIsArray(targetIdsArg) {
    invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
  }
  function checkInvariants(targetIds, monitor, registry) {
    invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
    invariant(!monitor.didDrop(), "Cannot call hover after drop.");
    for (let i2 = 0; i2 < targetIds.length; i2++) {
      const targetId = targetIds[i2];
      invariant(targetIds.lastIndexOf(targetId) === i2, "Expected targetIds to be unique in the passed array.");
      const target = registry.getTarget(targetId);
      invariant(target, "Expected targetIds to be registered.");
    }
  }
  function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
    for (let i2 = targetIds.length - 1; i2 >= 0; i2--) {
      const targetId = targetIds[i2];
      const targetType = registry.getTargetType(targetId);
      if (!matchesType(targetType, draggedItemType)) {
        targetIds.splice(i2, 1);
      }
    }
  }
  function hoverAllTargets(targetIds, monitor, registry) {
    targetIds.forEach(function(targetId) {
      const target = registry.getTarget(targetId);
      target.hover(monitor, targetId);
    });
  }

  // node_modules/dnd-core/dist/actions/dragDrop/publishDragSource.js
  function createPublishDragSource(manager) {
    return function publishDragSource() {
      const monitor = manager.getMonitor();
      if (monitor.isDragging()) {
        return {
          type: PUBLISH_DRAG_SOURCE
        };
      }
      return;
    };
  }

  // node_modules/dnd-core/dist/actions/dragDrop/index.js
  function createDragDropActions(manager) {
    return {
      beginDrag: createBeginDrag(manager),
      publishDragSource: createPublishDragSource(manager),
      hover: createHover(manager),
      drop: createDrop(manager),
      endDrag: createEndDrag(manager)
    };
  }

  // node_modules/dnd-core/dist/classes/DragDropManagerImpl.js
  var DragDropManagerImpl = class {
    receiveBackend(backend) {
      this.backend = backend;
    }
    getMonitor() {
      return this.monitor;
    }
    getBackend() {
      return this.backend;
    }
    getRegistry() {
      return this.monitor.registry;
    }
    getActions() {
      const manager = this;
      const { dispatch } = this.store;
      function bindActionCreator(actionCreator) {
        return (...args) => {
          const action = actionCreator.apply(manager, args);
          if (typeof action !== "undefined") {
            dispatch(action);
          }
        };
      }
      const actions = createDragDropActions(this);
      return Object.keys(actions).reduce((boundActions, key) => {
        const action = actions[key];
        boundActions[key] = bindActionCreator(action);
        return boundActions;
      }, {});
    }
    dispatch(action) {
      this.store.dispatch(action);
    }
    constructor(store, monitor) {
      this.isSetUp = false;
      this.handleRefCountChange = () => {
        const shouldSetUp = this.store.getState().refCount > 0;
        if (this.backend) {
          if (shouldSetUp && !this.isSetUp) {
            this.backend.setup();
            this.isSetUp = true;
          } else if (!shouldSetUp && this.isSetUp) {
            this.backend.teardown();
            this.isSetUp = false;
          }
        }
      };
      this.store = store;
      this.monitor = monitor;
      store.subscribe(this.handleRefCountChange);
    }
  };

  // node_modules/dnd-core/dist/utils/coords.js
  function add(a2, b3) {
    return {
      x: a2.x + b3.x,
      y: a2.y + b3.y
    };
  }
  function subtract(a2, b3) {
    return {
      x: a2.x - b3.x,
      y: a2.y - b3.y
    };
  }
  function getSourceClientOffset(state) {
    const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;
    if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
      return null;
    }
    return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
  }
  function getDifferenceFromInitialOffset(state) {
    const { clientOffset, initialClientOffset } = state;
    if (!clientOffset || !initialClientOffset) {
      return null;
    }
    return subtract(clientOffset, initialClientOffset);
  }

  // node_modules/dnd-core/dist/utils/dirtiness.js
  var NONE = [];
  var ALL = [];
  NONE.__IS_NONE__ = true;
  ALL.__IS_ALL__ = true;
  function areDirty(dirtyIds, handlerIds) {
    if (dirtyIds === NONE) {
      return false;
    }
    if (dirtyIds === ALL || typeof handlerIds === "undefined") {
      return true;
    }
    const commonIds = intersection(handlerIds, dirtyIds);
    return commonIds.length > 0;
  }

  // node_modules/dnd-core/dist/classes/DragDropMonitorImpl.js
  var DragDropMonitorImpl = class {
    subscribeToStateChange(listener, options = {}) {
      const { handlerIds } = options;
      invariant(typeof listener === "function", "listener must be a function.");
      invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
      let prevStateId = this.store.getState().stateId;
      const handleChange = () => {
        const state = this.store.getState();
        const currentStateId = state.stateId;
        try {
          const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
          if (!canSkipListener) {
            listener();
          }
        } finally {
          prevStateId = currentStateId;
        }
      };
      return this.store.subscribe(handleChange);
    }
    subscribeToOffsetChange(listener) {
      invariant(typeof listener === "function", "listener must be a function.");
      let previousState = this.store.getState().dragOffset;
      const handleChange = () => {
        const nextState = this.store.getState().dragOffset;
        if (nextState === previousState) {
          return;
        }
        previousState = nextState;
        listener();
      };
      return this.store.subscribe(handleChange);
    }
    canDragSource(sourceId) {
      if (!sourceId) {
        return false;
      }
      const source = this.registry.getSource(sourceId);
      invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
      if (this.isDragging()) {
        return false;
      }
      return source.canDrag(this, sourceId);
    }
    canDropOnTarget(targetId) {
      if (!targetId) {
        return false;
      }
      const target = this.registry.getTarget(targetId);
      invariant(target, `Expected to find a valid target. targetId=${targetId}`);
      if (!this.isDragging() || this.didDrop()) {
        return false;
      }
      const targetType = this.registry.getTargetType(targetId);
      const draggedItemType = this.getItemType();
      return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
    }
    isDragging() {
      return Boolean(this.getItemType());
    }
    isDraggingSource(sourceId) {
      if (!sourceId) {
        return false;
      }
      const source = this.registry.getSource(sourceId, true);
      invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
      if (!this.isDragging() || !this.isSourcePublic()) {
        return false;
      }
      const sourceType = this.registry.getSourceType(sourceId);
      const draggedItemType = this.getItemType();
      if (sourceType !== draggedItemType) {
        return false;
      }
      return source.isDragging(this, sourceId);
    }
    isOverTarget(targetId, options = {
      shallow: false
    }) {
      if (!targetId) {
        return false;
      }
      const { shallow } = options;
      if (!this.isDragging()) {
        return false;
      }
      const targetType = this.registry.getTargetType(targetId);
      const draggedItemType = this.getItemType();
      if (draggedItemType && !matchesType(targetType, draggedItemType)) {
        return false;
      }
      const targetIds = this.getTargetIds();
      if (!targetIds.length) {
        return false;
      }
      const index2 = targetIds.indexOf(targetId);
      if (shallow) {
        return index2 === targetIds.length - 1;
      } else {
        return index2 > -1;
      }
    }
    getItemType() {
      return this.store.getState().dragOperation.itemType;
    }
    getItem() {
      return this.store.getState().dragOperation.item;
    }
    getSourceId() {
      return this.store.getState().dragOperation.sourceId;
    }
    getTargetIds() {
      return this.store.getState().dragOperation.targetIds;
    }
    getDropResult() {
      return this.store.getState().dragOperation.dropResult;
    }
    didDrop() {
      return this.store.getState().dragOperation.didDrop;
    }
    isSourcePublic() {
      return Boolean(this.store.getState().dragOperation.isSourcePublic);
    }
    getInitialClientOffset() {
      return this.store.getState().dragOffset.initialClientOffset;
    }
    getInitialSourceClientOffset() {
      return this.store.getState().dragOffset.initialSourceClientOffset;
    }
    getClientOffset() {
      return this.store.getState().dragOffset.clientOffset;
    }
    getSourceClientOffset() {
      return getSourceClientOffset(this.store.getState().dragOffset);
    }
    getDifferenceFromInitialOffset() {
      return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
    }
    constructor(store, registry) {
      this.store = store;
      this.registry = registry;
    }
  };

  // node_modules/@react-dnd/asap/dist/makeRequestCall.js
  var scope = typeof global !== "undefined" ? global : self;
  var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
  function makeRequestCallFromTimer(callback) {
    return function requestCall() {
      const timeoutHandle = setTimeout(handleTimer, 0);
      const intervalHandle = setInterval(handleTimer, 50);
      function handleTimer() {
        clearTimeout(timeoutHandle);
        clearInterval(intervalHandle);
        callback();
      }
    };
  }
  function makeRequestCallFromMutationObserver(callback) {
    let toggle = 1;
    const observer = new BrowserMutationObserver(callback);
    const node = document.createTextNode("");
    observer.observe(node, {
      characterData: true
    });
    return function requestCall() {
      toggle = -toggle;
      node.data = toggle;
    };
  }
  var makeRequestCall = typeof BrowserMutationObserver === "function" ? makeRequestCallFromMutationObserver : makeRequestCallFromTimer;

  // node_modules/@react-dnd/asap/dist/AsapQueue.js
  var AsapQueue = class {
    enqueueTask(task) {
      const { queue: q3, requestFlush } = this;
      if (!q3.length) {
        requestFlush();
        this.flushing = true;
      }
      q3[q3.length] = task;
    }
    constructor() {
      this.queue = [];
      this.pendingErrors = [];
      this.flushing = false;
      this.index = 0;
      this.capacity = 1024;
      this.flush = () => {
        const { queue: q3 } = this;
        while (this.index < q3.length) {
          const currentIndex = this.index;
          this.index++;
          q3[currentIndex].call();
          if (this.index > this.capacity) {
            for (let scan = 0, newLength = q3.length - this.index; scan < newLength; scan++) {
              q3[scan] = q3[scan + this.index];
            }
            q3.length -= this.index;
            this.index = 0;
          }
        }
        q3.length = 0;
        this.index = 0;
        this.flushing = false;
      };
      this.registerPendingError = (err) => {
        this.pendingErrors.push(err);
        this.requestErrorThrow();
      };
      this.requestFlush = makeRequestCall(this.flush);
      this.requestErrorThrow = makeRequestCallFromTimer(() => {
        if (this.pendingErrors.length) {
          throw this.pendingErrors.shift();
        }
      });
    }
  };

  // node_modules/@react-dnd/asap/dist/RawTask.js
  var RawTask = class {
    call() {
      try {
        this.task && this.task();
      } catch (error) {
        this.onError(error);
      } finally {
        this.task = null;
        this.release(this);
      }
    }
    constructor(onError, release) {
      this.onError = onError;
      this.release = release;
      this.task = null;
    }
  };

  // node_modules/@react-dnd/asap/dist/TaskFactory.js
  var TaskFactory = class {
    create(task) {
      const tasks = this.freeTasks;
      const t1 = tasks.length ? tasks.pop() : new RawTask(
        this.onError,
        (t2) => tasks[tasks.length] = t2
      );
      t1.task = task;
      return t1;
    }
    constructor(onError) {
      this.onError = onError;
      this.freeTasks = [];
    }
  };

  // node_modules/@react-dnd/asap/dist/asap.js
  var asapQueue = new AsapQueue();
  var taskFactory = new TaskFactory(asapQueue.registerPendingError);
  function asap(task) {
    asapQueue.enqueueTask(taskFactory.create(task));
  }

  // node_modules/dnd-core/dist/actions/registry.js
  var ADD_SOURCE = "dnd-core/ADD_SOURCE";
  var ADD_TARGET = "dnd-core/ADD_TARGET";
  var REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
  var REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
  function addSource(sourceId) {
    return {
      type: ADD_SOURCE,
      payload: {
        sourceId
      }
    };
  }
  function addTarget(targetId) {
    return {
      type: ADD_TARGET,
      payload: {
        targetId
      }
    };
  }
  function removeSource(sourceId) {
    return {
      type: REMOVE_SOURCE,
      payload: {
        sourceId
      }
    };
  }
  function removeTarget(targetId) {
    return {
      type: REMOVE_TARGET,
      payload: {
        targetId
      }
    };
  }

  // node_modules/dnd-core/dist/contracts.js
  function validateSourceContract(source) {
    invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
    invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
    invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
  }
  function validateTargetContract(target) {
    invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
    invariant(typeof target.hover === "function", "Expected hover to be a function.");
    invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
  }
  function validateType(type, allowArray) {
    if (allowArray && Array.isArray(type)) {
      type.forEach(
        (t2) => validateType(t2, false)
      );
      return;
    }
    invariant(typeof type === "string" || typeof type === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
  }

  // node_modules/dnd-core/dist/interfaces.js
  var HandlerRole;
  (function(HandlerRole2) {
    HandlerRole2["SOURCE"] = "SOURCE";
    HandlerRole2["TARGET"] = "TARGET";
  })(HandlerRole || (HandlerRole = {}));

  // node_modules/dnd-core/dist/utils/getNextUniqueId.js
  var nextUniqueId = 0;
  function getNextUniqueId() {
    return nextUniqueId++;
  }

  // node_modules/dnd-core/dist/classes/HandlerRegistryImpl.js
  function getNextHandlerId(role) {
    const id = getNextUniqueId().toString();
    switch (role) {
      case HandlerRole.SOURCE:
        return `S${id}`;
      case HandlerRole.TARGET:
        return `T${id}`;
      default:
        throw new Error(`Unknown Handler Role: ${role}`);
    }
  }
  function parseRoleFromHandlerId(handlerId) {
    switch (handlerId[0]) {
      case "S":
        return HandlerRole.SOURCE;
      case "T":
        return HandlerRole.TARGET;
      default:
        throw new Error(`Cannot parse handler ID: ${handlerId}`);
    }
  }
  function mapContainsValue(map, searchValue) {
    const entries = map.entries();
    let isDone = false;
    do {
      const { done, value: [, value] } = entries.next();
      if (value === searchValue) {
        return true;
      }
      isDone = !!done;
    } while (!isDone);
    return false;
  }
  var HandlerRegistryImpl = class {
    addSource(type, source) {
      validateType(type);
      validateSourceContract(source);
      const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
      this.store.dispatch(addSource(sourceId));
      return sourceId;
    }
    addTarget(type, target) {
      validateType(type, true);
      validateTargetContract(target);
      const targetId = this.addHandler(HandlerRole.TARGET, type, target);
      this.store.dispatch(addTarget(targetId));
      return targetId;
    }
    containsHandler(handler) {
      return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
    }
    getSource(sourceId, includePinned = false) {
      invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
      const isPinned = includePinned && sourceId === this.pinnedSourceId;
      const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
      return source;
    }
    getTarget(targetId) {
      invariant(this.isTargetId(targetId), "Expected a valid target ID.");
      return this.dropTargets.get(targetId);
    }
    getSourceType(sourceId) {
      invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
      return this.types.get(sourceId);
    }
    getTargetType(targetId) {
      invariant(this.isTargetId(targetId), "Expected a valid target ID.");
      return this.types.get(targetId);
    }
    isSourceId(handlerId) {
      const role = parseRoleFromHandlerId(handlerId);
      return role === HandlerRole.SOURCE;
    }
    isTargetId(handlerId) {
      const role = parseRoleFromHandlerId(handlerId);
      return role === HandlerRole.TARGET;
    }
    removeSource(sourceId) {
      invariant(this.getSource(sourceId), "Expected an existing source.");
      this.store.dispatch(removeSource(sourceId));
      asap(() => {
        this.dragSources.delete(sourceId);
        this.types.delete(sourceId);
      });
    }
    removeTarget(targetId) {
      invariant(this.getTarget(targetId), "Expected an existing target.");
      this.store.dispatch(removeTarget(targetId));
      this.dropTargets.delete(targetId);
      this.types.delete(targetId);
    }
    pinSource(sourceId) {
      const source = this.getSource(sourceId);
      invariant(source, "Expected an existing source.");
      this.pinnedSourceId = sourceId;
      this.pinnedSource = source;
    }
    unpinSource() {
      invariant(this.pinnedSource, "No source is pinned at the time.");
      this.pinnedSourceId = null;
      this.pinnedSource = null;
    }
    addHandler(role, type, handler) {
      const id = getNextHandlerId(role);
      this.types.set(id, type);
      if (role === HandlerRole.SOURCE) {
        this.dragSources.set(id, handler);
      } else if (role === HandlerRole.TARGET) {
        this.dropTargets.set(id, handler);
      }
      return id;
    }
    constructor(store) {
      this.types = /* @__PURE__ */ new Map();
      this.dragSources = /* @__PURE__ */ new Map();
      this.dropTargets = /* @__PURE__ */ new Map();
      this.pinnedSourceId = null;
      this.pinnedSource = null;
      this.store = store;
    }
  };

  // node_modules/dnd-core/dist/utils/equality.js
  var strictEquality = (a2, b3) => a2 === b3;
  function areCoordsEqual(offsetA, offsetB) {
    if (!offsetA && !offsetB) {
      return true;
    } else if (!offsetA || !offsetB) {
      return false;
    } else {
      return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
    }
  }
  function areArraysEqual(a2, b3, isEqual2 = strictEquality) {
    if (a2.length !== b3.length) {
      return false;
    }
    for (let i2 = 0; i2 < a2.length; ++i2) {
      if (!isEqual2(a2[i2], b3[i2])) {
        return false;
      }
    }
    return true;
  }

  // node_modules/dnd-core/dist/reducers/dirtyHandlerIds.js
  function reduce(_state = NONE, action) {
    switch (action.type) {
      case HOVER:
        break;
      case ADD_SOURCE:
      case ADD_TARGET:
      case REMOVE_TARGET:
      case REMOVE_SOURCE:
        return NONE;
      case BEGIN_DRAG:
      case PUBLISH_DRAG_SOURCE:
      case END_DRAG:
      case DROP:
      default:
        return ALL;
    }
    const { targetIds = [], prevTargetIds = [] } = action.payload;
    const result = xor(targetIds, prevTargetIds);
    const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
    if (!didChange) {
      return NONE;
    }
    const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
    const innermostTargetId = targetIds[targetIds.length - 1];
    if (prevInnermostTargetId !== innermostTargetId) {
      if (prevInnermostTargetId) {
        result.push(prevInnermostTargetId);
      }
      if (innermostTargetId) {
        result.push(innermostTargetId);
      }
    }
    return result;
  }

  // node_modules/dnd-core/dist/reducers/dragOffset.js
  function _defineProperty3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectSpread3(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys3 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys3.forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    }
    return target;
  }
  var initialState = {
    initialSourceClientOffset: null,
    initialClientOffset: null,
    clientOffset: null
  };
  function reduce2(state = initialState, action) {
    const { payload } = action;
    switch (action.type) {
      case INIT_COORDS:
      case BEGIN_DRAG:
        return {
          initialSourceClientOffset: payload.sourceClientOffset,
          initialClientOffset: payload.clientOffset,
          clientOffset: payload.clientOffset
        };
      case HOVER:
        if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
          return state;
        }
        return _objectSpread3({}, state, {
          clientOffset: payload.clientOffset
        });
      case END_DRAG:
      case DROP:
        return initialState;
      default:
        return state;
    }
  }

  // node_modules/dnd-core/dist/reducers/dragOperation.js
  function _defineProperty4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectSpread4(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys3 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys3.forEach(function(key) {
        _defineProperty4(target, key, source[key]);
      });
    }
    return target;
  }
  var initialState2 = {
    itemType: null,
    item: null,
    sourceId: null,
    targetIds: [],
    dropResult: null,
    didDrop: false,
    isSourcePublic: null
  };
  function reduce3(state = initialState2, action) {
    const { payload } = action;
    switch (action.type) {
      case BEGIN_DRAG:
        return _objectSpread4({}, state, {
          itemType: payload.itemType,
          item: payload.item,
          sourceId: payload.sourceId,
          isSourcePublic: payload.isSourcePublic,
          dropResult: null,
          didDrop: false
        });
      case PUBLISH_DRAG_SOURCE:
        return _objectSpread4({}, state, {
          isSourcePublic: true
        });
      case HOVER:
        return _objectSpread4({}, state, {
          targetIds: payload.targetIds
        });
      case REMOVE_TARGET:
        if (state.targetIds.indexOf(payload.targetId) === -1) {
          return state;
        }
        return _objectSpread4({}, state, {
          targetIds: without(state.targetIds, payload.targetId)
        });
      case DROP:
        return _objectSpread4({}, state, {
          dropResult: payload.dropResult,
          didDrop: true,
          targetIds: []
        });
      case END_DRAG:
        return _objectSpread4({}, state, {
          itemType: null,
          item: null,
          sourceId: null,
          dropResult: null,
          didDrop: false,
          isSourcePublic: null,
          targetIds: []
        });
      default:
        return state;
    }
  }

  // node_modules/dnd-core/dist/reducers/refCount.js
  function reduce4(state = 0, action) {
    switch (action.type) {
      case ADD_SOURCE:
      case ADD_TARGET:
        return state + 1;
      case REMOVE_SOURCE:
      case REMOVE_TARGET:
        return state - 1;
      default:
        return state;
    }
  }

  // node_modules/dnd-core/dist/reducers/stateId.js
  function reduce5(state = 0) {
    return state + 1;
  }

  // node_modules/dnd-core/dist/reducers/index.js
  function _defineProperty5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectSpread5(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys3 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys3.forEach(function(key) {
        _defineProperty5(target, key, source[key]);
      });
    }
    return target;
  }
  function reduce6(state = {}, action) {
    return {
      dirtyHandlerIds: reduce(state.dirtyHandlerIds, {
        type: action.type,
        payload: _objectSpread5({}, action.payload, {
          prevTargetIds: get(state, "dragOperation.targetIds", [])
        })
      }),
      dragOffset: reduce2(state.dragOffset, action),
      refCount: reduce4(state.refCount, action),
      dragOperation: reduce3(state.dragOperation, action),
      stateId: reduce5(state.stateId)
    };
  }

  // node_modules/dnd-core/dist/createDragDropManager.js
  function createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {
    const store = makeStoreInstance(debugMode);
    const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
    const manager = new DragDropManagerImpl(store, monitor);
    const backend = backendFactory(manager, globalContext, backendOptions);
    manager.receiveBackend(backend);
    return manager;
  }
  function makeStoreInstance(debugMode) {
    const reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
    return createStore(reduce6, debugMode && reduxDevTools && reduxDevTools({
      name: "dnd-core",
      instanceId: "dnd-core"
    }));
  }

  // node_modules/react-dnd/dist/core/DndProvider.js
  var import_react27 = __toESM(require_react(), 1);
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i2;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
        key = sourceSymbolKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i2;
    for (i2 = 0; i2 < sourceKeys.length; i2++) {
      key = sourceKeys[i2];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  var refCount = 0;
  var INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
  var DndProvider = /* @__PURE__ */ (0, import_react27.memo)(function DndProvider2(_param) {
    var { children } = _param, props = _objectWithoutProperties(_param, [
      "children"
    ]);
    const [manager, isGlobalInstance] = getDndContextValue(props);
    (0, import_react27.useEffect)(() => {
      if (isGlobalInstance) {
        const context = getGlobalContext();
        ++refCount;
        return () => {
          if (--refCount === 0) {
            context[INSTANCE_SYM] = null;
          }
        };
      }
      return;
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(DndContext.Provider, {
      value: manager,
      children
    });
  });
  function getDndContextValue(props) {
    if ("manager" in props) {
      const manager2 = {
        dragDropManager: props.manager
      };
      return [
        manager2,
        false
      ];
    }
    const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
    const isGlobalInstance = !props.context;
    return [
      manager,
      isGlobalInstance
    ];
  }
  function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
    const ctx = context;
    if (!ctx[INSTANCE_SYM]) {
      ctx[INSTANCE_SYM] = {
        dragDropManager: createDragDropManager(backend, context, options, debugMode)
      };
    }
    return ctx[INSTANCE_SYM];
  }
  function getGlobalContext() {
    return typeof global !== "undefined" ? global : window;
  }

  // node_modules/react-dnd/dist/hooks/useCollector.js
  var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);
  var import_react29 = __toESM(require_react(), 1);

  // node_modules/react-dnd/dist/hooks/useIsomorphicLayoutEffect.js
  var import_react28 = __toESM(require_react(), 1);
  var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react28.useLayoutEffect : import_react28.useEffect;

  // node_modules/react-dnd/dist/hooks/useCollector.js
  function useCollector(monitor, collect, onUpdate) {
    const [collected, setCollected] = (0, import_react29.useState)(
      () => collect(monitor)
    );
    const updateCollected = (0, import_react29.useCallback)(() => {
      const nextValue = collect(monitor);
      if (!(0, import_fast_deep_equal.default)(collected, nextValue)) {
        setCollected(nextValue);
        if (onUpdate) {
          onUpdate();
        }
      }
    }, [
      collected,
      monitor,
      onUpdate
    ]);
    useIsomorphicLayoutEffect(updateCollected);
    return [
      collected,
      updateCollected
    ];
  }

  // node_modules/react-dnd/dist/hooks/useMonitorOutput.js
  function useMonitorOutput(monitor, collect, onCollect) {
    const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
    useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
      const handlerId = monitor.getHandlerId();
      if (handlerId == null) {
        return;
      }
      return monitor.subscribeToStateChange(updateCollected, {
        handlerIds: [
          handlerId
        ]
      });
    }, [
      monitor,
      updateCollected
    ]);
    return collected;
  }

  // node_modules/react-dnd/dist/hooks/useCollectedProps.js
  function useCollectedProps(collector, monitor, connector) {
    return useMonitorOutput(
      monitor,
      collector || (() => ({})),
      () => connector.reconnect()
    );
  }

  // node_modules/react-dnd/dist/hooks/useOptionalFactory.js
  var import_react30 = __toESM(require_react(), 1);
  function useOptionalFactory(arg, deps) {
    const memoDeps = [
      ...deps || []
    ];
    if (deps == null && typeof arg !== "function") {
      memoDeps.push(arg);
    }
    return (0, import_react30.useMemo)(() => {
      return typeof arg === "function" ? arg() : arg;
    }, memoDeps);
  }

  // node_modules/react-dnd/dist/hooks/useDrag/connectors.js
  var import_react31 = __toESM(require_react(), 1);
  function useConnectDragSource(connector) {
    return (0, import_react31.useMemo)(
      () => connector.hooks.dragSource(),
      [
        connector
      ]
    );
  }
  function useConnectDragPreview(connector) {
    return (0, import_react31.useMemo)(
      () => connector.hooks.dragPreview(),
      [
        connector
      ]
    );
  }

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js
  var import_react34 = __toESM(require_react(), 1);

  // node_modules/react-dnd/dist/internals/DragSourceMonitorImpl.js
  var isCallingCanDrag = false;
  var isCallingIsDragging = false;
  var DragSourceMonitorImpl = class {
    receiveHandlerId(sourceId) {
      this.sourceId = sourceId;
    }
    getHandlerId() {
      return this.sourceId;
    }
    canDrag() {
      invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
      try {
        isCallingCanDrag = true;
        return this.internalMonitor.canDragSource(this.sourceId);
      } finally {
        isCallingCanDrag = false;
      }
    }
    isDragging() {
      if (!this.sourceId) {
        return false;
      }
      invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
      try {
        isCallingIsDragging = true;
        return this.internalMonitor.isDraggingSource(this.sourceId);
      } finally {
        isCallingIsDragging = false;
      }
    }
    subscribeToStateChange(listener, options) {
      return this.internalMonitor.subscribeToStateChange(listener, options);
    }
    isDraggingSource(sourceId) {
      return this.internalMonitor.isDraggingSource(sourceId);
    }
    isOverTarget(targetId, options) {
      return this.internalMonitor.isOverTarget(targetId, options);
    }
    getTargetIds() {
      return this.internalMonitor.getTargetIds();
    }
    isSourcePublic() {
      return this.internalMonitor.isSourcePublic();
    }
    getSourceId() {
      return this.internalMonitor.getSourceId();
    }
    subscribeToOffsetChange(listener) {
      return this.internalMonitor.subscribeToOffsetChange(listener);
    }
    canDragSource(sourceId) {
      return this.internalMonitor.canDragSource(sourceId);
    }
    canDropOnTarget(targetId) {
      return this.internalMonitor.canDropOnTarget(targetId);
    }
    getItemType() {
      return this.internalMonitor.getItemType();
    }
    getItem() {
      return this.internalMonitor.getItem();
    }
    getDropResult() {
      return this.internalMonitor.getDropResult();
    }
    didDrop() {
      return this.internalMonitor.didDrop();
    }
    getInitialClientOffset() {
      return this.internalMonitor.getInitialClientOffset();
    }
    getInitialSourceClientOffset() {
      return this.internalMonitor.getInitialSourceClientOffset();
    }
    getSourceClientOffset() {
      return this.internalMonitor.getSourceClientOffset();
    }
    getClientOffset() {
      return this.internalMonitor.getClientOffset();
    }
    getDifferenceFromInitialOffset() {
      return this.internalMonitor.getDifferenceFromInitialOffset();
    }
    constructor(manager) {
      this.sourceId = null;
      this.internalMonitor = manager.getMonitor();
    }
  };

  // node_modules/react-dnd/dist/internals/DropTargetMonitorImpl.js
  var isCallingCanDrop = false;
  var DropTargetMonitorImpl = class {
    receiveHandlerId(targetId) {
      this.targetId = targetId;
    }
    getHandlerId() {
      return this.targetId;
    }
    subscribeToStateChange(listener, options) {
      return this.internalMonitor.subscribeToStateChange(listener, options);
    }
    canDrop() {
      if (!this.targetId) {
        return false;
      }
      invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
      try {
        isCallingCanDrop = true;
        return this.internalMonitor.canDropOnTarget(this.targetId);
      } finally {
        isCallingCanDrop = false;
      }
    }
    isOver(options) {
      if (!this.targetId) {
        return false;
      }
      return this.internalMonitor.isOverTarget(this.targetId, options);
    }
    getItemType() {
      return this.internalMonitor.getItemType();
    }
    getItem() {
      return this.internalMonitor.getItem();
    }
    getDropResult() {
      return this.internalMonitor.getDropResult();
    }
    didDrop() {
      return this.internalMonitor.didDrop();
    }
    getInitialClientOffset() {
      return this.internalMonitor.getInitialClientOffset();
    }
    getInitialSourceClientOffset() {
      return this.internalMonitor.getInitialSourceClientOffset();
    }
    getSourceClientOffset() {
      return this.internalMonitor.getSourceClientOffset();
    }
    getClientOffset() {
      return this.internalMonitor.getClientOffset();
    }
    getDifferenceFromInitialOffset() {
      return this.internalMonitor.getDifferenceFromInitialOffset();
    }
    constructor(manager) {
      this.targetId = null;
      this.internalMonitor = manager.getMonitor();
    }
  };

  // node_modules/react-dnd/dist/internals/registration.js
  function registerTarget(type, target, manager) {
    const registry = manager.getRegistry();
    const targetId = registry.addTarget(type, target);
    return [
      targetId,
      () => registry.removeTarget(targetId)
    ];
  }
  function registerSource(type, source, manager) {
    const registry = manager.getRegistry();
    const sourceId = registry.addSource(type, source);
    return [
      sourceId,
      () => registry.removeSource(sourceId)
    ];
  }

  // node_modules/@react-dnd/shallowequal/dist/index.js
  function shallowEqual(objA, objB, compare, compareContext) {
    let compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;
    if (compareResult !== void 0) {
      return !!compareResult;
    }
    if (objA === objB) {
      return true;
    }
    if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
      return false;
    }
    const keysA = Object.keys(objA);
    const keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
    for (let idx = 0; idx < keysA.length; idx++) {
      const key = keysA[idx];
      if (!bHasOwnProperty(key)) {
        return false;
      }
      const valueA = objA[key];
      const valueB = objB[key];
      compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
      if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
        return false;
      }
    }
    return true;
  }

  // node_modules/react-dnd/dist/internals/isRef.js
  function isRef(obj) {
    return obj !== null && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "current");
  }

  // node_modules/react-dnd/dist/internals/wrapConnectorHooks.js
  var import_react32 = __toESM(require_react(), 1);
  function throwIfCompositeComponentElement(element) {
    if (typeof element.type === "string") {
      return;
    }
    const displayName = element.type.displayName || element.type.name || "the component";
    throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);
  }
  function wrapHookToRecognizeElement(hook) {
    return (elementOrNode = null, options = null) => {
      if (!(0, import_react32.isValidElement)(elementOrNode)) {
        const node = elementOrNode;
        hook(node, options);
        return node;
      }
      const element = elementOrNode;
      throwIfCompositeComponentElement(element);
      const ref = options ? (node) => hook(node, options) : hook;
      return cloneWithRef(element, ref);
    };
  }
  function wrapConnectorHooks(hooks) {
    const wrappedHooks = {};
    Object.keys(hooks).forEach((key) => {
      const hook = hooks[key];
      if (key.endsWith("Ref")) {
        wrappedHooks[key] = hooks[key];
      } else {
        const wrappedHook = wrapHookToRecognizeElement(hook);
        wrappedHooks[key] = () => wrappedHook;
      }
    });
    return wrappedHooks;
  }
  function setRef(ref, node) {
    if (typeof ref === "function") {
      ref(node);
    } else {
      ref.current = node;
    }
  }
  function cloneWithRef(element, newRef) {
    const previousRef = element.ref;
    invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
    if (!previousRef) {
      return (0, import_react32.cloneElement)(element, {
        ref: newRef
      });
    } else {
      return (0, import_react32.cloneElement)(element, {
        ref: (node) => {
          setRef(previousRef, node);
          setRef(newRef, node);
        }
      });
    }
  }

  // node_modules/react-dnd/dist/internals/SourceConnector.js
  var SourceConnector = class {
    receiveHandlerId(newHandlerId) {
      if (this.handlerId === newHandlerId) {
        return;
      }
      this.handlerId = newHandlerId;
      this.reconnect();
    }
    get connectTarget() {
      return this.dragSource;
    }
    get dragSourceOptions() {
      return this.dragSourceOptionsInternal;
    }
    set dragSourceOptions(options) {
      this.dragSourceOptionsInternal = options;
    }
    get dragPreviewOptions() {
      return this.dragPreviewOptionsInternal;
    }
    set dragPreviewOptions(options) {
      this.dragPreviewOptionsInternal = options;
    }
    reconnect() {
      const didChange = this.reconnectDragSource();
      this.reconnectDragPreview(didChange);
    }
    reconnectDragSource() {
      const dragSource = this.dragSource;
      const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
      if (didChange) {
        this.disconnectDragSource();
      }
      if (!this.handlerId) {
        return didChange;
      }
      if (!dragSource) {
        this.lastConnectedDragSource = dragSource;
        return didChange;
      }
      if (didChange) {
        this.lastConnectedHandlerId = this.handlerId;
        this.lastConnectedDragSource = dragSource;
        this.lastConnectedDragSourceOptions = this.dragSourceOptions;
        this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
      }
      return didChange;
    }
    reconnectDragPreview(forceDidChange = false) {
      const dragPreview = this.dragPreview;
      const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
      if (didChange) {
        this.disconnectDragPreview();
      }
      if (!this.handlerId) {
        return;
      }
      if (!dragPreview) {
        this.lastConnectedDragPreview = dragPreview;
        return;
      }
      if (didChange) {
        this.lastConnectedHandlerId = this.handlerId;
        this.lastConnectedDragPreview = dragPreview;
        this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
        this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
      }
    }
    didHandlerIdChange() {
      return this.lastConnectedHandlerId !== this.handlerId;
    }
    didConnectedDragSourceChange() {
      return this.lastConnectedDragSource !== this.dragSource;
    }
    didConnectedDragPreviewChange() {
      return this.lastConnectedDragPreview !== this.dragPreview;
    }
    didDragSourceOptionsChange() {
      return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
    }
    didDragPreviewOptionsChange() {
      return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
    }
    disconnectDragSource() {
      if (this.dragSourceUnsubscribe) {
        this.dragSourceUnsubscribe();
        this.dragSourceUnsubscribe = void 0;
      }
    }
    disconnectDragPreview() {
      if (this.dragPreviewUnsubscribe) {
        this.dragPreviewUnsubscribe();
        this.dragPreviewUnsubscribe = void 0;
        this.dragPreviewNode = null;
        this.dragPreviewRef = null;
      }
    }
    get dragSource() {
      return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
    }
    get dragPreview() {
      return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
    }
    clearDragSource() {
      this.dragSourceNode = null;
      this.dragSourceRef = null;
    }
    clearDragPreview() {
      this.dragPreviewNode = null;
      this.dragPreviewRef = null;
    }
    constructor(backend) {
      this.hooks = wrapConnectorHooks({
        dragSource: (node, options) => {
          this.clearDragSource();
          this.dragSourceOptions = options || null;
          if (isRef(node)) {
            this.dragSourceRef = node;
          } else {
            this.dragSourceNode = node;
          }
          this.reconnectDragSource();
        },
        dragPreview: (node, options) => {
          this.clearDragPreview();
          this.dragPreviewOptions = options || null;
          if (isRef(node)) {
            this.dragPreviewRef = node;
          } else {
            this.dragPreviewNode = node;
          }
          this.reconnectDragPreview();
        }
      });
      this.handlerId = null;
      this.dragSourceRef = null;
      this.dragSourceOptionsInternal = null;
      this.dragPreviewRef = null;
      this.dragPreviewOptionsInternal = null;
      this.lastConnectedHandlerId = null;
      this.lastConnectedDragSource = null;
      this.lastConnectedDragSourceOptions = null;
      this.lastConnectedDragPreview = null;
      this.lastConnectedDragPreviewOptions = null;
      this.backend = backend;
    }
  };

  // node_modules/react-dnd/dist/internals/TargetConnector.js
  var TargetConnector = class {
    get connectTarget() {
      return this.dropTarget;
    }
    reconnect() {
      const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
      if (didChange) {
        this.disconnectDropTarget();
      }
      const dropTarget = this.dropTarget;
      if (!this.handlerId) {
        return;
      }
      if (!dropTarget) {
        this.lastConnectedDropTarget = dropTarget;
        return;
      }
      if (didChange) {
        this.lastConnectedHandlerId = this.handlerId;
        this.lastConnectedDropTarget = dropTarget;
        this.lastConnectedDropTargetOptions = this.dropTargetOptions;
        this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
      }
    }
    receiveHandlerId(newHandlerId) {
      if (newHandlerId === this.handlerId) {
        return;
      }
      this.handlerId = newHandlerId;
      this.reconnect();
    }
    get dropTargetOptions() {
      return this.dropTargetOptionsInternal;
    }
    set dropTargetOptions(options) {
      this.dropTargetOptionsInternal = options;
    }
    didHandlerIdChange() {
      return this.lastConnectedHandlerId !== this.handlerId;
    }
    didDropTargetChange() {
      return this.lastConnectedDropTarget !== this.dropTarget;
    }
    didOptionsChange() {
      return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
    }
    disconnectDropTarget() {
      if (this.unsubscribeDropTarget) {
        this.unsubscribeDropTarget();
        this.unsubscribeDropTarget = void 0;
      }
    }
    get dropTarget() {
      return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
    }
    clearDropTarget() {
      this.dropTargetRef = null;
      this.dropTargetNode = null;
    }
    constructor(backend) {
      this.hooks = wrapConnectorHooks({
        dropTarget: (node, options) => {
          this.clearDropTarget();
          this.dropTargetOptions = options;
          if (isRef(node)) {
            this.dropTargetRef = node;
          } else {
            this.dropTargetNode = node;
          }
          this.reconnect();
        }
      });
      this.handlerId = null;
      this.dropTargetRef = null;
      this.dropTargetOptionsInternal = null;
      this.lastConnectedHandlerId = null;
      this.lastConnectedDropTarget = null;
      this.lastConnectedDropTargetOptions = null;
      this.backend = backend;
    }
  };

  // node_modules/react-dnd/dist/hooks/useDragDropManager.js
  var import_react33 = __toESM(require_react(), 1);
  function useDragDropManager() {
    const { dragDropManager } = (0, import_react33.useContext)(DndContext);
    invariant(dragDropManager != null, "Expected drag drop context");
    return dragDropManager;
  }

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSourceConnector.js
  function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
    const manager = useDragDropManager();
    const connector = (0, import_react34.useMemo)(
      () => new SourceConnector(manager.getBackend()),
      [
        manager
      ]
    );
    useIsomorphicLayoutEffect(() => {
      connector.dragSourceOptions = dragSourceOptions || null;
      connector.reconnect();
      return () => connector.disconnectDragSource();
    }, [
      connector,
      dragSourceOptions
    ]);
    useIsomorphicLayoutEffect(() => {
      connector.dragPreviewOptions = dragPreviewOptions || null;
      connector.reconnect();
      return () => connector.disconnectDragPreview();
    }, [
      connector,
      dragPreviewOptions
    ]);
    return connector;
  }

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSourceMonitor.js
  var import_react35 = __toESM(require_react(), 1);
  function useDragSourceMonitor() {
    const manager = useDragDropManager();
    return (0, import_react35.useMemo)(
      () => new DragSourceMonitorImpl(manager),
      [
        manager
      ]
    );
  }

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js
  var import_react36 = __toESM(require_react(), 1);

  // node_modules/react-dnd/dist/hooks/useDrag/DragSourceImpl.js
  var DragSourceImpl = class {
    beginDrag() {
      const spec = this.spec;
      const monitor = this.monitor;
      let result = null;
      if (typeof spec.item === "object") {
        result = spec.item;
      } else if (typeof spec.item === "function") {
        result = spec.item(monitor);
      } else {
        result = {};
      }
      return result !== null && result !== void 0 ? result : null;
    }
    canDrag() {
      const spec = this.spec;
      const monitor = this.monitor;
      if (typeof spec.canDrag === "boolean") {
        return spec.canDrag;
      } else if (typeof spec.canDrag === "function") {
        return spec.canDrag(monitor);
      } else {
        return true;
      }
    }
    isDragging(globalMonitor, target) {
      const spec = this.spec;
      const monitor = this.monitor;
      const { isDragging } = spec;
      return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
    }
    endDrag() {
      const spec = this.spec;
      const monitor = this.monitor;
      const connector = this.connector;
      const { end } = spec;
      if (end) {
        end(monitor.getItem(), monitor);
      }
      connector.reconnect();
    }
    constructor(spec, monitor, connector) {
      this.spec = spec;
      this.monitor = monitor;
      this.connector = connector;
    }
  };

  // node_modules/react-dnd/dist/hooks/useDrag/useDragSource.js
  function useDragSource(spec, monitor, connector) {
    const handler = (0, import_react36.useMemo)(
      () => new DragSourceImpl(spec, monitor, connector),
      [
        monitor,
        connector
      ]
    );
    (0, import_react36.useEffect)(() => {
      handler.spec = spec;
    }, [
      spec
    ]);
    return handler;
  }

  // node_modules/react-dnd/dist/hooks/useDrag/useDragType.js
  var import_react37 = __toESM(require_react(), 1);
  function useDragType(spec) {
    return (0, import_react37.useMemo)(() => {
      const result = spec.type;
      invariant(result != null, "spec.type must be defined");
      return result;
    }, [
      spec
    ]);
  }

  // node_modules/react-dnd/dist/hooks/useDrag/useRegisteredDragSource.js
  function useRegisteredDragSource(spec, monitor, connector) {
    const manager = useDragDropManager();
    const handler = useDragSource(spec, monitor, connector);
    const itemType = useDragType(spec);
    useIsomorphicLayoutEffect(function registerDragSource() {
      if (itemType != null) {
        const [handlerId, unregister] = registerSource(itemType, handler, manager);
        monitor.receiveHandlerId(handlerId);
        connector.receiveHandlerId(handlerId);
        return unregister;
      }
      return;
    }, [
      manager,
      monitor,
      connector,
      handler,
      itemType
    ]);
  }

  // node_modules/react-dnd/dist/hooks/useDrag/useDrag.js
  function useDrag(specArg, deps) {
    const spec = useOptionalFactory(specArg, deps);
    invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
    const monitor = useDragSourceMonitor();
    const connector = useDragSourceConnector(spec.options, spec.previewOptions);
    useRegisteredDragSource(spec, monitor, connector);
    return [
      useCollectedProps(spec.collect, monitor, connector),
      useConnectDragSource(connector),
      useConnectDragPreview(connector)
    ];
  }

  // node_modules/react-dnd/dist/hooks/useDrop/connectors.js
  var import_react38 = __toESM(require_react(), 1);
  function useConnectDropTarget(connector) {
    return (0, import_react38.useMemo)(
      () => connector.hooks.dropTarget(),
      [
        connector
      ]
    );
  }

  // node_modules/react-dnd/dist/hooks/useDrop/useDropTargetConnector.js
  var import_react39 = __toESM(require_react(), 1);
  function useDropTargetConnector(options) {
    const manager = useDragDropManager();
    const connector = (0, import_react39.useMemo)(
      () => new TargetConnector(manager.getBackend()),
      [
        manager
      ]
    );
    useIsomorphicLayoutEffect(() => {
      connector.dropTargetOptions = options || null;
      connector.reconnect();
      return () => connector.disconnectDropTarget();
    }, [
      options
    ]);
    return connector;
  }

  // node_modules/react-dnd/dist/hooks/useDrop/useDropTargetMonitor.js
  var import_react40 = __toESM(require_react(), 1);
  function useDropTargetMonitor() {
    const manager = useDragDropManager();
    return (0, import_react40.useMemo)(
      () => new DropTargetMonitorImpl(manager),
      [
        manager
      ]
    );
  }

  // node_modules/react-dnd/dist/hooks/useDrop/useAccept.js
  var import_react41 = __toESM(require_react(), 1);
  function useAccept(spec) {
    const { accept } = spec;
    return (0, import_react41.useMemo)(() => {
      invariant(spec.accept != null, "accept must be defined");
      return Array.isArray(accept) ? accept : [
        accept
      ];
    }, [
      accept
    ]);
  }

  // node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js
  var import_react42 = __toESM(require_react(), 1);

  // node_modules/react-dnd/dist/hooks/useDrop/DropTargetImpl.js
  var DropTargetImpl = class {
    canDrop() {
      const spec = this.spec;
      const monitor = this.monitor;
      return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
    }
    hover() {
      const spec = this.spec;
      const monitor = this.monitor;
      if (spec.hover) {
        spec.hover(monitor.getItem(), monitor);
      }
    }
    drop() {
      const spec = this.spec;
      const monitor = this.monitor;
      if (spec.drop) {
        return spec.drop(monitor.getItem(), monitor);
      }
      return;
    }
    constructor(spec, monitor) {
      this.spec = spec;
      this.monitor = monitor;
    }
  };

  // node_modules/react-dnd/dist/hooks/useDrop/useDropTarget.js
  function useDropTarget(spec, monitor) {
    const dropTarget = (0, import_react42.useMemo)(
      () => new DropTargetImpl(spec, monitor),
      [
        monitor
      ]
    );
    (0, import_react42.useEffect)(() => {
      dropTarget.spec = spec;
    }, [
      spec
    ]);
    return dropTarget;
  }

  // node_modules/react-dnd/dist/hooks/useDrop/useRegisteredDropTarget.js
  function useRegisteredDropTarget(spec, monitor, connector) {
    const manager = useDragDropManager();
    const dropTarget = useDropTarget(spec, monitor);
    const accept = useAccept(spec);
    useIsomorphicLayoutEffect(function registerDropTarget() {
      const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
      monitor.receiveHandlerId(handlerId);
      connector.receiveHandlerId(handlerId);
      return unregister;
    }, [
      manager,
      monitor,
      dropTarget,
      connector,
      accept.map(
        (a2) => a2.toString()
      ).join("|")
    ]);
  }

  // node_modules/react-dnd/dist/hooks/useDrop/useDrop.js
  function useDrop(specArg, deps) {
    const spec = useOptionalFactory(specArg, deps);
    const monitor = useDropTargetMonitor();
    const connector = useDropTargetConnector(spec.options);
    useRegisteredDropTarget(spec, monitor, connector);
    return [
      useCollectedProps(spec.collect, monitor, connector),
      useConnectDropTarget(connector)
    ];
  }

  // src/components/UI/Workspace/Panel/Panel.tsx
  var Panel = ({ children, id }) => {
    const { cart } = useOrderedCollectionState();
    const dispatch = useOrderedCollectionDispatch();
    const [{ isDragging }, drag] = useDrag(() => ({
      type: "resource",
      item: { id },
      end: (item, monitor) => {
        const dropResult = monitor.getDropResult();
        if (item && dropResult)
          dispatch({
            type: "updateCart",
            id: item.id
          });
      },
      collect: (monitor) => ({
        isDragging: monitor.isDragging(),
        handlerId: monitor.getHandlerId()
      })
    }));
    const opacity = isDragging ? 0.382 : 1;
    return /* @__PURE__ */ import_react43.default.createElement(PanelStyled, {
      ref: drag,
      style: { opacity },
      "data-cart": cart.includes(id)
    }, children);
  };
  var Panel_default = Panel;

  // src/components/ChangeDiscovery/OrderedItem.tsx
  var import_react136 = __toESM(require_react());

  // node_modules/@samvera/clover-iiif/dist/viewer/index.mjs
  var import_react134 = __toESM(require_react(), 1);

  // node_modules/@iiif/parser/dist/bundle/esm/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var EMPTY = [];
  Object.freeze(EMPTY);
  var emptyAnnotationPage = {
    id: "https://iiif-parser/annotation-page",
    type: "AnnotationPage",
    behavior: EMPTY,
    motivation: null,
    label: null,
    thumbnail: EMPTY,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    provider: EMPTY,
    items: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    rendering: EMPTY,
    service: EMPTY
  };
  var emptyCanvas = {
    id: "https://iiif-parser/empty-canvas",
    type: "Canvas",
    label: null,
    behavior: EMPTY,
    motivation: null,
    thumbnail: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    navDate: null,
    provider: EMPTY,
    items: EMPTY,
    annotations: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    partOf: EMPTY,
    rendering: EMPTY,
    service: EMPTY,
    duration: 0,
    height: 0,
    width: 0
  };
  var emptyCollection = {
    id: "https://iiif-parser/empty-collection",
    type: "Collection",
    label: null,
    viewingDirection: "left-to-right",
    behavior: EMPTY,
    motivation: null,
    thumbnail: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    navDate: null,
    provider: EMPTY,
    items: EMPTY,
    annotations: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    partOf: EMPTY,
    rendering: EMPTY,
    service: EMPTY,
    services: EMPTY
  };
  var emptyManifest = {
    id: "https://iiif-parser/empty-manifest",
    type: "Manifest",
    annotations: EMPTY,
    behavior: EMPTY,
    homepage: EMPTY,
    items: EMPTY,
    label: null,
    logo: EMPTY,
    metadata: EMPTY,
    motivation: null,
    navDate: null,
    provider: EMPTY,
    partOf: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    rendering: EMPTY,
    requiredStatement: null,
    rights: null,
    seeAlso: EMPTY,
    service: EMPTY,
    services: EMPTY,
    start: null,
    structures: EMPTY,
    summary: null,
    thumbnail: EMPTY,
    viewingDirection: "left-to-right"
  };
  var emptyRange = {
    id: "https://iiif-parser/empty-canvas",
    type: "Range",
    label: null,
    behavior: EMPTY,
    motivation: null,
    thumbnail: EMPTY,
    posterCanvas: null,
    accompanyingCanvas: null,
    placeholderCanvas: null,
    summary: null,
    requiredStatement: null,
    metadata: EMPTY,
    rights: null,
    navDate: null,
    provider: EMPTY,
    items: EMPTY,
    annotations: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY,
    logo: EMPTY,
    partOf: EMPTY,
    rendering: EMPTY,
    service: EMPTY,
    start: null,
    supplementary: null,
    viewingDirection: "left-to-right"
  };
  var emptyAgent = {
    id: "https://iiif-parser/empty-agent",
    type: "Agent",
    label: {},
    logo: EMPTY,
    seeAlso: EMPTY,
    homepage: EMPTY
  };
  function ensureArray$1(maybeArray) {
    if (Array.isArray(maybeArray)) {
      return maybeArray;
    }
    return [maybeArray];
  }
  var types$1 = [
    "Collection",
    "Manifest",
    "Canvas",
    "AnnotationPage",
    "AnnotationCollection",
    "Annotation",
    "ContentResource",
    "Range",
    "Service",
    "Selector",
    "Agent"
  ];
  function identifyResource$1(resource) {
    if (typeof resource === "undefined" || resource === null) {
      throw new Error("Null or undefined is not a valid entity.");
    }
    if (Array.isArray(resource)) {
      throw new Error("Array is not a valid entity");
    }
    if (typeof resource !== "object") {
      throw new Error(`${typeof resource} is not a valid entity`);
    }
    if (typeof resource.type === "string") {
      const hasType = types$1.indexOf(resource.type);
      if (hasType !== -1) {
        return types$1[hasType];
      }
    }
    if (resource.profile) {
      return "Service";
    }
    throw new Error("Resource type is not known");
  }
  var Traverse$1 = class {
    constructor(traversals, options = {}) {
      __publicField(this, "traversals");
      __publicField(this, "options");
      this.traversals = {
        collection: [],
        manifest: [],
        canvas: [],
        annotationCollection: [],
        annotationPage: [],
        annotation: [],
        contentResource: [],
        choice: [],
        range: [],
        service: [],
        agent: [],
        ...traversals
      };
      this.options = {
        allowUndefinedReturn: false,
        ...options
      };
    }
    static all(traversal) {
      return new Traverse$1({
        collection: [traversal],
        manifest: [traversal],
        canvas: [traversal],
        annotationCollection: [traversal],
        annotationPage: [traversal],
        annotation: [traversal],
        contentResource: [traversal],
        choice: [traversal],
        range: [traversal],
        service: [traversal]
      });
    }
    traverseDescriptive(resource) {
      if (resource.thumbnail) {
        resource.thumbnail = resource.thumbnail.map(
          (thumbnail) => this.traverseType(thumbnail, this.traversals.contentResource)
        );
      }
      if (resource.provider) {
        resource.provider = resource.provider.map((agent) => this.traverseAgent(agent));
      }
      return resource;
    }
    traverseLinking(resource) {
      if (resource.seeAlso) {
        resource.seeAlso = resource.seeAlso.map((content) => this.traverseType(content, this.traversals.contentResource));
      }
      if (resource.service) {
        resource.service = ensureArray$1(resource.service).map(
          (service) => this.traverseType(service, this.traversals.service)
        );
      }
      if (resource.services) {
        resource.services = resource.services.map((service) => this.traverseType(service, this.traversals.service));
      }
      if (resource.logo) {
        resource.logo = resource.logo.map((content) => this.traverseType(content, this.traversals.contentResource));
      }
      if (resource.homepage) {
        resource.homepage = resource.homepage.map(
          (homepage) => this.traverseType(homepage, this.traversals.contentResource)
        );
      }
      if (resource.partOf) {
        resource.partOf = resource.partOf.map((partOf) => {
          if (typeof partOf === "string" || !partOf.type) {
            return this.traverseType(partOf, this.traversals.contentResource);
          }
          if (partOf.type === "Canvas") {
            return this.traverseType(partOf, this.traversals.canvas);
          }
          if (partOf.type === "AnnotationCollection") {
            return this.traverseType(partOf, this.traversals.annotationCollection);
          }
          if (partOf.type === "Collection") {
            return this.traverseType(partOf, this.traversals.collection);
          }
          return this.traverseType(partOf, this.traversals.contentResource);
        });
      }
      if (resource.start) {
        resource.start = resource.start ? this.traverseType(resource.start, this.traversals.canvas) : null;
      }
      if (resource.rendering) {
        resource.rendering = resource.rendering.map(
          (content) => this.traverseType(content, this.traversals.contentResource)
        );
      }
      if (resource.supplementary) {
        resource.supplementary = resource.supplementary.map(
          (content) => this.traverseType(content, this.traversals.contentResource)
        );
      }
      return resource;
    }
    traverseCollectionItems(collection) {
      if (collection.items) {
        collection.items.map((collectionOrManifest) => {
          if (collectionOrManifest.type === "Collection") {
            return this.traverseCollection(collectionOrManifest);
          }
          return this.traverseManifest(collectionOrManifest);
        });
      }
      return collection;
    }
    traverseCollection(collection) {
      return this.traverseType(
        this.traverseDescriptive(
          this.traverseInlineAnnotationPages(
            this.traverseLinking(this.traversePosterCanvas(this.traverseCollectionItems(collection)))
          )
        ),
        this.traversals.collection
      );
    }
    traverseManifestItems(manifest) {
      if (manifest.items) {
        manifest.items = manifest.items.map((canvas) => this.traverseCanvas(canvas));
      }
      return manifest;
    }
    traverseManifestStructures(manifest) {
      if (manifest.structures) {
        manifest.structures = manifest.structures.map((range) => this.traverseRange(range));
      }
      return manifest;
    }
    traverseManifest(manifest) {
      return this.traverseType(
        this.traverseInlineAnnotationPages(
          this.traverseManifestStructures(
            this.traversePosterCanvas(
              this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(manifest)))
            )
          )
        ),
        this.traversals.manifest
      );
    }
    traverseCanvasItems(canvas) {
      canvas.items = (canvas.items || []).map((annotationPage) => {
        return this.traverseAnnotationPage(annotationPage);
      });
      return canvas;
    }
    traverseInlineAnnotationPages(resource) {
      if (typeof resource === "string" || !resource) {
        return resource;
      }
      if (resource.annotations) {
        resource.annotations = resource.annotations.map((annotationPage) => {
          return this.traverseAnnotationPage(annotationPage);
        });
      }
      return resource;
    }
    traverseCanvas(canvas) {
      return this.traverseType(
        this.traverseInlineAnnotationPages(
          this.traversePosterCanvas(this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(canvas))))
        ),
        this.traversals.canvas
      );
    }
    traverseAnnotationPageItems(annotationPage) {
      if (annotationPage.items) {
        annotationPage.items = annotationPage.items.map((annotation) => {
          return this.traverseAnnotation(annotation);
        });
      }
      return annotationPage;
    }
    traverseAnnotationPage(annotationPageJson) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationPageItems(annotationPageJson))),
        this.traversals.annotationPage
      );
    }
    traverseAnnotationBody(annotation) {
      if (Array.isArray(annotation.body)) {
        annotation.body = annotation.body.map((annotationBody) => {
          return this.traverseContentResource(annotationBody);
        });
      } else if (annotation.body) {
        annotation.body = this.traverseContentResource(annotation.body);
      }
      return annotation;
    }
    traversePosterCanvas(json) {
      if (json.posterCanvas) {
        json.posterCanvas = this.traverseCanvas(json.posterCanvas);
      }
      if (json.placeholderCanvas) {
        json.placeholderCanvas = this.traverseCanvas(json.placeholderCanvas);
      }
      if (json.accompanyingCanvas) {
        json.accompanyingCanvas = this.traverseCanvas(json.accompanyingCanvas);
      }
      return json;
    }
    traverseAnnotation(annotationJson) {
      return this.traverseType(
        this.traverseLinking(this.traverseAnnotationBody(annotationJson)),
        this.traversals.annotation
      );
    }
    traverseContentResourceLinking(contentResourceJson) {
      if (typeof contentResourceJson === "string" || !contentResourceJson) {
        return contentResourceJson;
      }
      if (contentResourceJson && contentResourceJson.service) {
        contentResourceJson.service = ensureArray$1(
          contentResourceJson.service || []
        ).map((service) => this.traverseType(service, this.traversals.service));
      }
      return contentResourceJson;
    }
    traverseContentResource(contentResourceJson) {
      if (contentResourceJson.type === "Choice") {
        contentResourceJson.items = contentResourceJson.items.map((choiceItem) => {
          return this.traverseContentResource(choiceItem);
        });
      }
      return this.traverseType(
        this.traverseInlineAnnotationPages(this.traverseContentResourceLinking(contentResourceJson)),
        this.traversals.contentResource
      );
    }
    traverseRangeRanges(range) {
      if (range.items) {
        range.items = range.items.map((rangeOrManifest) => {
          if (typeof rangeOrManifest === "string") {
            return this.traverseCanvas({ id: rangeOrManifest, type: "Canvas" });
          }
          if (rangeOrManifest.type === "Manifest") {
            return this.traverseManifest(rangeOrManifest);
          }
          return this.traverseRange(rangeOrManifest);
        });
      }
      return range;
    }
    traverseRange(range) {
      return this.traverseType(
        this.traversePosterCanvas(this.traverseDescriptive(this.traverseLinking(this.traverseRangeRanges(range)))),
        this.traversals.range
      );
    }
    traverseAgent(agent) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(agent)),
        this.traversals.agent
      );
    }
    traverseType(object, traversals) {
      return traversals.reduce((acc, traversal) => {
        const returnValue = traversal(acc);
        if (typeof returnValue === "undefined" && !this.options.allowUndefinedReturn) {
          return acc;
        }
        return returnValue;
      }, object);
    }
    traverseService(service) {
      return this.traverseType(service, this.traversals.service);
    }
    traverseUnknown(resource) {
      const type = identifyResource$1(resource);
      switch (type) {
        case "Collection":
          return this.traverseCollection(resource);
        case "Manifest":
          return this.traverseManifest(resource);
        case "Canvas":
          return this.traverseCanvas(resource);
        case "AnnotationPage":
          return this.traverseAnnotationPage(resource);
        case "Annotation":
          return this.traverseAnnotation(resource);
        case "ContentResource":
          return this.traverseContentResource(resource);
        case "Range":
          return this.traverseRange(resource);
        case "Service":
          return this.traverseService(resource);
        case "Agent":
          return this.traverseAgent(resource);
        default:
          throw new Error(`Unknown or unsupported resource type of ${type}`);
      }
    }
  };
  var types = [
    "sc:Collection",
    "sc:Manifest",
    "sc:Canvas",
    "sc:AnnotationList",
    "oa:Annotation",
    "sc:Range",
    "sc:Layer",
    "sc:Sequence",
    "oa:Choice",
    "Service",
    "ContentResource"
  ];
  function identifyResource(resource) {
    if (typeof resource === "undefined" || resource === null) {
      throw new Error("Null or undefined is not a valid entity.");
    }
    if (Array.isArray(resource)) {
      throw new Error("Array is not a valid entity");
    }
    if (typeof resource !== "object") {
      throw new Error(`${typeof resource} is not a valid entity`);
    }
    if (typeof resource["@type"] === "string") {
      const hasType = types.indexOf(resource["@type"]);
      if (hasType !== -1) {
        return types[hasType];
      }
    }
    if (resource.profile) {
      return "Service";
    }
    if (resource.format) {
      return "ContentResource";
    }
    if (resource["@type"]) {
      return "ContentResource";
    }
    throw new Error("Resource type is not known");
  }
  var Traverse = class {
    constructor(traversals, options = {}) {
      __publicField(this, "traversals");
      __publicField(this, "options");
      this.traversals = {
        collection: [],
        manifest: [],
        canvas: [],
        annotationList: [],
        sequence: [],
        annotation: [],
        contentResource: [],
        choice: [],
        range: [],
        service: [],
        layer: [],
        ...traversals
      };
      this.options = {
        convertPropsToArray: true,
        mergeMemberProperties: true,
        allowUndefinedReturn: false,
        ...options
      };
    }
    static all(traversal) {
      return new Traverse({
        collection: [traversal],
        manifest: [traversal],
        canvas: [traversal],
        annotationList: [traversal],
        sequence: [traversal],
        annotation: [traversal],
        contentResource: [traversal],
        choice: [traversal],
        range: [traversal],
        service: [traversal],
        layer: [traversal]
      });
    }
    traverseCollection(collection) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseCollectionItems(collection))),
        this.traversals.collection
      );
    }
    traverseCollectionItems(collection) {
      if (this.options.mergeMemberProperties) {
        const members = [
          ...(collection.manifests || []).map((manifest) => {
            if (typeof manifest === "string") {
              return { "@id": manifest, "@type": "sc:Manifest" };
            }
            return manifest;
          }),
          ...(collection.collections || []).map((subCollection) => {
            if (typeof subCollection === "string") {
              return { "@id": subCollection, "@type": "sc:Collection" };
            }
            return subCollection;
          }),
          ...collection.members || []
        ];
        delete collection.collections;
        delete collection.manifests;
        collection.members = members;
      }
      if (collection.manifests) {
        collection.manifests = collection.manifests.map(
          (manifest) => this.traverseManifest(
            typeof manifest === "string" ? { "@id": manifest, "@type": "sc:Manifest" } : manifest
          )
        );
      }
      if (collection.collections) {
        collection.collections = collection.collections.map(
          (subCollection) => this.traverseCollection(
            typeof subCollection === "string" ? { "@id": subCollection, "@type": "sc:Collection" } : subCollection
          )
        );
      }
      if (collection.members) {
        collection.members = collection.members.map((member) => {
          if (typeof member === "string") {
            return member;
          }
          return this.traverseUnknown(member);
        });
      }
      return collection;
    }
    traverseManifest(manifest) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(manifest))),
        this.traversals.manifest
      );
    }
    traverseManifestItems(manifest) {
      if (manifest.sequences) {
        manifest.sequences = manifest.sequences.map((sequence) => this.traverseSequence(sequence));
      }
      if (manifest.structures) {
        manifest.structures = manifest.structures.map((structure) => this.traverseRange(structure));
      }
      return manifest;
    }
    traverseSequence(sequence) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseSequenceItems(sequence))),
        this.traversals.sequence
      );
    }
    traverseSequenceItems(sequence) {
      if (sequence.canvases) {
        sequence.canvases = sequence.canvases.map((canvas) => this.traverseCanvas(canvas));
      }
      return sequence;
    }
    traverseCanvas(canvas) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(canvas))),
        this.traversals.canvas
      );
    }
    traverseCanvasItems(canvas) {
      if (canvas.images) {
        canvas.images = canvas.images.map((image) => this.traverseAnnotation(image));
      }
      if (canvas.otherContent) {
        canvas.otherContent = canvas.otherContent.map((annotationList) => this.traverseAnnotationList(annotationList));
      }
      return canvas;
    }
    traverseRange(range) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseRangeItems(range))),
        this.traversals.range
      );
    }
    traverseRangeItems(range) {
      if (this.options.mergeMemberProperties) {
        const members = [
          ...(range.ranges || []).map((innerRange) => {
            if (typeof innerRange === "string") {
              return { "@id": innerRange, "@type": "sc:Range" };
            }
            return innerRange;
          }),
          ...(range.canvases || []).map((canvas) => {
            if (typeof canvas === "string") {
              return { "@id": canvas, "@type": "sc:Canvas" };
            }
            return canvas;
          }),
          ...range.members || []
        ];
        delete range.ranges;
        delete range.canvases;
        range.members = members.length ? members.map((member) => this.traverseUnknown(member)) : void 0;
      }
      return range;
    }
    traverseAnnotationList(annotationList) {
      const list = typeof annotationList === "string" ? { "@id": annotationList, "@type": "sc:AnnotationList" } : annotationList;
      return this.traverseType(
        this.traverseDescriptive(this.traverseAnnotationListItems(list)),
        this.traversals.annotationList
      );
    }
    traverseAnnotationListItems(annotationList) {
      if (annotationList.resources) {
        annotationList.resources = annotationList.resources.map((annotation) => this.traverseAnnotation(annotation));
      }
      return annotationList;
    }
    traverseAnnotation(annotation) {
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationItems(annotation))),
        this.traversals.annotation
      );
    }
    traverseAnnotationItems(annotation) {
      if (annotation.resource) {
        if (Array.isArray(annotation.resource)) {
          annotation.resource = annotation.resource.map(
            (res) => this.traverseContentResource(res)
          );
        } else {
          annotation.resource = this.traverseContentResource(annotation.resource);
        }
      }
      if (annotation.on)
        ;
      return annotation;
    }
    traverseLayer(layer) {
      return this.traverseType(this.traverseLinking(this.traverseLayerItems(layer)), this.traversals.layer);
    }
    traverseLayerItems(layer) {
      if (layer.otherContent) {
        layer.otherContent = layer.otherContent.map((annotationList) => this.traverseAnnotationList(annotationList));
      }
      return layer;
    }
    traverseChoice(choice) {
      return this.traverseType(this.traverseChoiceItems(choice), this.traversals.choice);
    }
    traverseChoiceItems(choice) {
      if (choice.default && choice.default !== "rdf:nil") {
        choice.default = this.traverseContentResource(choice.default);
      }
      if (choice.item && choice.item !== "rdf:nil") {
        choice.item = choice.item.map((item) => this.traverseContentResource(item));
      }
      return choice;
    }
    traverseService(service) {
      return this.traverseType(this.traverseLinking(service), this.traversals.service);
    }
    traverseContentResource(contentResource) {
      if (contentResource["@type"] === "oa:Choice") {
        return this.traverseChoice(contentResource);
      }
      return this.traverseType(
        this.traverseDescriptive(this.traverseLinking(contentResource)),
        this.traversals.contentResource
      );
    }
    traverseUnknown(item) {
      if (!item["@type"] || typeof item === "string") {
        return item;
      }
      switch (identifyResource(item)) {
        case "sc:Collection":
          return this.traverseCollection(item);
        case "sc:Manifest":
          return this.traverseManifest(item);
        case "sc:Canvas":
          return this.traverseCanvas(item);
        case "sc:Sequence":
          return this.traverseSequence(item);
        case "sc:Range":
          return this.traverseRange(item);
        case "oa:Annotation":
          return this.traverseAnnotation(item);
        case "sc:AnnotationList":
          return this.traverseAnnotationList(item);
        case "sc:Layer":
          return this.traverseLayer(item);
        case "Service":
          return this.traverseService(item);
        case "oa:Choice":
          return this.traverseChoice(item);
        case "ContentResource":
          return this.traverseContentResource(item);
      }
      if (item.profile) {
        return this.traverseService(item);
      }
      return item;
    }
    traverseImageResource(contentResource) {
      const wasArray = Array.isArray(contentResource);
      const resourceList = Array.isArray(contentResource) ? contentResource : [contentResource];
      const newResourceList = [];
      for (const singleResource of resourceList) {
        if (typeof singleResource === "string") {
          newResourceList.push(
            this.traverseContentResource({
              "@id": singleResource,
              "@type": "dctypes:Image"
            })
          );
        } else {
          newResourceList.push(this.traverseContentResource(singleResource));
        }
      }
      if (!wasArray && !this.options.convertPropsToArray) {
        return newResourceList[0];
      }
      return newResourceList;
    }
    traverseDescriptive(resource) {
      if (resource.thumbnail) {
        resource.thumbnail = this.traverseImageResource(resource.thumbnail);
      }
      if (resource.logo) {
        resource.logo = this.traverseImageResource(resource.logo);
      }
      return resource;
    }
    traverseOneOrMoreServices(allServices) {
      const wasArray = Array.isArray(allServices);
      const services = Array.isArray(allServices) ? allServices : [allServices];
      const newServices = [];
      for (const service of services) {
        newServices.push(this.traverseService(service));
      }
      if (!wasArray && !this.options.convertPropsToArray) {
        return newServices[0];
      }
      return newServices;
    }
    traverseLinking(resource) {
      if (resource.related) {
        resource.related = this.traverseOneOrManyType(resource.related, this.traversals.contentResource);
      }
      if (resource.rendering) {
        resource.rendering = this.traverseOneOrManyType(resource.rendering, this.traversals.contentResource);
      }
      if (resource.service) {
        resource.service = this.traverseOneOrMoreServices(resource.service);
      }
      if (resource.seeAlso) {
        resource.seeAlso = this.traverseOneOrManyType(resource.seeAlso, this.traversals.contentResource);
      }
      if (resource.within) {
        if (typeof resource.within === "string")
          ;
        else {
          resource.within = this.traverseOneOrManyType(
            resource.within,
            this.traversals.contentResource
          );
        }
      }
      if (resource.startCanvas) {
        if (typeof resource.startCanvas === "string") {
          resource.startCanvas = this.traverseType(
            { "@id": resource.startCanvas, "@type": "sc:Canvas" },
            this.traversals.canvas
          );
        } else if (resource.startCanvas) {
          this.traverseType(resource.startCanvas, this.traversals.canvas);
        }
      }
      if (resource.contentLayer) {
        if (typeof resource.contentLayer === "string") {
          resource.contentLayer = this.traverseLayer({
            "@id": resource.contentLayer,
            "@type": "sc:Layer"
          });
        } else {
          resource.contentLayer = this.traverseLayer(resource.contentLayer);
        }
      }
      return resource;
    }
    traverseOneOrManyType(object, traversals) {
      if (!Array.isArray(object)) {
        if (this.options.convertPropsToArray) {
          object = [object];
        } else {
          return this.traverseType(object, traversals);
        }
      }
      return object.map((singleObj) => this.traverseType(singleObj, traversals));
    }
    traverseType(object, traversals) {
      return traversals.reduce((acc, traversal) => {
        const returnValue = traversal(acc);
        if (typeof returnValue === "undefined" && !this.options.allowUndefinedReturn) {
          return acc;
        }
        return returnValue;
      }, object);
    }
  };
  var STANFORD_IIIF_IMAGE_COMPLIANCE_0 = "http://library.stanford.edu/iiif/image-api/compliance.html#level0";
  var STANFORD_IIIF_IMAGE_COMPLIANCE_1 = "http://library.stanford.edu/iiif/image-api/compliance.html#level1";
  var STANFORD_IIIF_IMAGE_COMPLIANCE_2 = "http://library.stanford.edu/iiif/image-api/compliance.html#level2";
  var STANFORD_IIIF_IMAGE_CONFORMANCE_0 = "http://library.stanford.edu/iiif/image-api/conformance.html#level0";
  var STANFORD_IIIF_IMAGE_CONFORMANCE_1 = "http://library.stanford.edu/iiif/image-api/conformance.html#level1";
  var STANFORD_IIIF_IMAGE_CONFORMANCE_2 = "http://library.stanford.edu/iiif/image-api/conformance.html#level2";
  var STANFORD_IIIF_1_IMAGE_COMPLIANCE_0 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0";
  var STANFORD_IIIF_1_IMAGE_COMPLIANCE_1 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1";
  var STANFORD_IIIF_1_IMAGE_COMPLIANCE_2 = "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2";
  var STANFORD_IIIF_1_IMAGE_CONFORMANCE_0 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0";
  var STANFORD_IIIF_1_IMAGE_CONFORMANCE_1 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1";
  var STANFORD_IIIF_1_IMAGE_CONFORMANCE_2 = "http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2";
  var IIIF_1_IMAGE_LEVEL_0 = "http://iiif.io/api/image/1/level0.json";
  var IIIF_1_IMAGE_LEVEL_0_PROFILE = "http://iiif.io/api/image/1/profiles/level0.json";
  var IIIF_1_IMAGE_LEVEL_1 = "http://iiif.io/api/image/1/level1.json";
  var IIIF_1_IMAGE_LEVEL_1_PROFILE = "http://iiif.io/api/image/1/profiles/level1.json";
  var IIIF_1_IMAGE_LEVEL_2 = "http://iiif.io/api/image/1/level2.json";
  var IIIF_1_IMAGE_LEVEL_2_PROFILE = "http://iiif.io/api/image/1/profiles/level2.json";
  var IIIF_2_IMAGE_LEVEL_0 = "http://iiif.io/api/image/2/level0.json";
  var IIIF_2_IMAGE_LEVEL_0_PROFILE = "http://iiif.io/api/image/2/profiles/level0.json";
  var IIIF_2_IMAGE_LEVEL_1 = "http://iiif.io/api/image/2/level1.json";
  var IIIF_2_IMAGE_LEVEL_1_PROFILE = "http://iiif.io/api/image/2/profiles/level1.json";
  var IIIF_2_IMAGE_LEVEL_2 = "http://iiif.io/api/image/2/level2.json";
  var IIIF_2_IMAGE_LEVEL_2_PROFILE = "http://iiif.io/api/image/2/profiles/level2.json";
  var IIIF_3_IMAGE_LEVEL_0 = "level0";
  var IIIF_3_IMAGE_LEVEL_1 = "level1";
  var IIIF_3_IMAGE_LEVEL_2 = "level2";
  var IIIF_2_IMAGE_LEVEL_0_NO_JSON = "http://iiif.io/api/image/2/level0";
  var IIIF_2_IMAGE_LEVEL_1_NO_JSON = "http://iiif.io/api/image/2/level1";
  var IIIF_2_IMAGE_LEVEL_2_NO_JSON = "http://iiif.io/api/image/2/level2";
  var level1Support = [
    IIIF_2_IMAGE_LEVEL_1_NO_JSON,
    IIIF_2_IMAGE_LEVEL_2_NO_JSON,
    STANFORD_IIIF_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_IMAGE_CONFORMANCE_2,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,
    IIIF_1_IMAGE_LEVEL_1,
    IIIF_1_IMAGE_LEVEL_1_PROFILE,
    IIIF_1_IMAGE_LEVEL_2,
    IIIF_1_IMAGE_LEVEL_2_PROFILE,
    IIIF_2_IMAGE_LEVEL_1,
    IIIF_2_IMAGE_LEVEL_1_PROFILE,
    IIIF_2_IMAGE_LEVEL_2,
    IIIF_2_IMAGE_LEVEL_2_PROFILE,
    IIIF_3_IMAGE_LEVEL_1,
    IIIF_3_IMAGE_LEVEL_2
  ];
  var imageServiceProfiles = [
    IIIF_2_IMAGE_LEVEL_0_NO_JSON,
    IIIF_2_IMAGE_LEVEL_1_NO_JSON,
    IIIF_2_IMAGE_LEVEL_2_NO_JSON,
    STANFORD_IIIF_IMAGE_COMPLIANCE_0,
    STANFORD_IIIF_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_IMAGE_CONFORMANCE_0,
    STANFORD_IIIF_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_IMAGE_CONFORMANCE_2,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_0,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_1,
    STANFORD_IIIF_1_IMAGE_COMPLIANCE_2,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_0,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_1,
    STANFORD_IIIF_1_IMAGE_CONFORMANCE_2,
    IIIF_1_IMAGE_LEVEL_0,
    IIIF_1_IMAGE_LEVEL_0_PROFILE,
    IIIF_1_IMAGE_LEVEL_1,
    IIIF_1_IMAGE_LEVEL_1_PROFILE,
    IIIF_1_IMAGE_LEVEL_2,
    IIIF_1_IMAGE_LEVEL_2_PROFILE,
    IIIF_2_IMAGE_LEVEL_0,
    IIIF_2_IMAGE_LEVEL_0_PROFILE,
    IIIF_2_IMAGE_LEVEL_1,
    IIIF_2_IMAGE_LEVEL_1_PROFILE,
    IIIF_2_IMAGE_LEVEL_2,
    IIIF_2_IMAGE_LEVEL_2_PROFILE,
    IIIF_3_IMAGE_LEVEL_0,
    IIIF_3_IMAGE_LEVEL_1,
    IIIF_3_IMAGE_LEVEL_2
  ];
  var configuration = {
    attributionLabel: "Attribution",
    lang: "none",
    providerId: "http://example.org/provider",
    providerName: "Unknown"
  };
  function convertLanguageMapping(inputLangProperty, defaultLang = "none") {
    if (!inputLangProperty) {
      return {};
    }
    const arrayOfValues = Array.isArray(inputLangProperty) ? inputLangProperty : [inputLangProperty];
    const languageMap = {};
    for (const language of arrayOfValues) {
      if (typeof language === "string") {
        languageMap[defaultLang] = languageMap[defaultLang] ? languageMap[defaultLang] : [];
        languageMap[defaultLang].push(language || "");
        continue;
      }
      if (!language["@language"]) {
        languageMap[defaultLang] = languageMap[defaultLang] ? languageMap[defaultLang] : [];
        languageMap[defaultLang].push(language["@value"] || "");
        continue;
      }
      const lang = language["@language"];
      languageMap[lang] = languageMap[lang] ? languageMap[lang] : [];
      languageMap[lang].push(language["@value"] || "");
    }
    return languageMap;
  }
  function getProfile(profile) {
    if (Array.isArray(profile)) {
      return getProfile(profile.find((s2) => typeof s2 === "string"));
    }
    if (imageServiceProfiles.indexOf(profile) !== -1) {
      return "level2";
    }
    if (level1Support.indexOf(profile) !== -1) {
      return "level1";
    }
    if (typeof profile !== "string") {
      return void 0;
    }
    return profile;
  }
  function getTypeFromContext(inputContexts) {
    const contexts = Array.isArray(inputContexts) ? inputContexts : [inputContexts];
    for (const context of contexts) {
      switch (context) {
        case "http://iiif.io/api/image/2/context.json":
        case "http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2":
          return "ImageService2";
        case "http://iiif.io/api/image/1/context.json":
        case "http://library.stanford.edu/iiif/image-api/1.1/context.json":
          return "ImageService1";
        case "http://iiif.io/api/annex/openannotation/context.json":
          return "ImageApiSelector";
      }
    }
    return void 0;
  }
  function getTypeFromProfile(inputProfile) {
    switch (inputProfile) {
      case "http://iiif.io/api/image/2/level0.json":
      case "http://iiif.io/api/image/2/level1.json":
      case "http://iiif.io/api/image/2/level2.json":
        return "ImageService2";
      case "http://iiif.io/api/auth/1/kiosk":
      case "http://iiif.io/api/auth/1/login":
      case "http://iiif.io/api/auth/1/clickthrough":
      case "http://iiif.io/api/auth/1/external":
      case "http://iiif.io/api/auth/0/kiosk":
      case "http://iiif.io/api/auth/0/login":
      case "http://iiif.io/api/auth/0/clickthrough":
      case "http://iiif.io/api/auth/0/external":
        return "AuthCookieService1";
      case "http://iiif.io/api/auth/1/token":
      case "http://iiif.io/api/auth/0/token":
        return "AuthTokenService1";
      case "http://iiif.io/api/auth/1/logout":
      case "http://iiif.io/api/auth/0/logout":
        return "AuthLogoutService1";
      case "http://iiif.io/api/search/1/search":
      case "http://iiif.io/api/search/0/search":
        return "SearchService1";
      case "http://iiif.io/api/search/1/autocomplete":
      case "http://iiif.io/api/search/0/autocomplete":
        return "AutoCompleteService1";
    }
    return void 0;
  }
  function removePrefix(str) {
    for (const prefix of ["sc", "oa", "dcterms", "dctypes", "iiif"]) {
      if (str.startsWith(`${prefix}:`)) {
        return str.slice(prefix.length + 1);
      }
    }
    return str;
  }
  var knownTypes = ["Collection", "Manifest", "Annotation", "AnnotationPage", "Range", "Service"];
  function getNewType(resource) {
    const id = resource["@id"] || resource.id;
    let oldType = resource["@type"] || resource.type;
    const profile = resource.profile || void 0;
    const context = resource["@context"] || void 0;
    if (profile) {
      const possibleType = getTypeFromProfile(profile);
      if (possibleType) {
        return possibleType;
      }
    }
    if (context) {
      const possibleType = getTypeFromContext(context);
      if (possibleType) {
        return possibleType;
      }
    }
    if (oldType) {
      if (Array.isArray(oldType)) {
        if (oldType.indexOf("oa:CssStylesheet") !== -1) {
          return "CssStylesheet";
        }
        if (oldType.indexOf("cnt:ContentAsText") !== -1) {
          return "TextualBody";
        }
        oldType = oldType[0];
      }
      for (const prefix of ["sc", "oa", "dcterms", "dctypes", "iiif"]) {
        if (oldType.startsWith(`${prefix}:`)) {
          oldType = oldType.slice(prefix.length + 1);
          break;
        }
      }
      switch (oldType) {
        case "Layer":
          return "AnnotationCollection";
        case "AnnotationList":
          return "AnnotationPage";
        case "cnt:ContentAsText":
          return "TextualBody";
      }
    }
    if (oldType && knownTypes.indexOf(oldType) !== -1) {
      return oldType;
    }
    if (resource.format) {
      if (resource.format.startsWith("image/")) {
        return "Image";
      }
      if (resource.format.startsWith("text/")) {
        return "Text";
      }
      if (resource.format === "application/pdf") {
        return "Text";
      }
      if (resource.format.startsWith("application/")) {
        return "Dataset";
      }
    }
    if (id && (id.endsWith(".jpg") || id.endsWith(".png") || id.endsWith(".jpeg"))) {
      return "Image";
    }
    if (!oldType) {
      return "unknown";
    }
    return oldType;
  }
  var licenseRegex = /http(s)?:\/\/(creativecommons.org|rightsstatements.org)[^"'\\<\n]+/gm;
  function extractLicense(license) {
    const matches = license.match(licenseRegex);
    if (matches) {
      return matches[0];
    }
    return license;
  }
  function fixLicense(license, licenseLabel = "Rights/License", lang = "none") {
    let rights = null;
    const metadata = [];
    const licenseList = Array.isArray(license) ? license : [license];
    for (const rawLicense of licenseList) {
      const singleLicense = rawLicense ? extractLicense(rawLicense) : void 0;
      if (singleLicense && (singleLicense.indexOf("creativecommons.org") !== -1 || singleLicense.indexOf("rightsstatements.org") !== -1)) {
        if (singleLicense.startsWith("https://")) {
          rights = `http://${singleLicense.slice(8)}`;
        } else {
          rights = singleLicense;
        }
        continue;
      }
      if (singleLicense) {
        metadata.push({
          label: { [lang]: [licenseLabel] },
          value: { [lang]: [singleLicense] }
        });
      }
    }
    return [rights, metadata];
  }
  var removeContexts = [
    "http://iiif.io/api/presentation/2/context.json",
    "http://iiif.io/api/image/2/context.json",
    "http://iiif.io/api/image/1/context.json",
    "http://library.stanford.edu/iiif/image-api/1.1/context.json",
    "http://iiif.io/api/search/1/context.json",
    "http://iiif.io/api/search/0/context.json",
    "http://iiif.io/api/auth/1/context.json",
    "http://iiif.io/api/auth/0/context.json",
    "http://iiif.io/api/annex/openannotation/context.json"
  ];
  function fixContext(inputContext) {
    if (inputContext) {
      const contexts = Array.isArray(inputContext) ? inputContext : [inputContext];
      const newContexts = [];
      for (const context of contexts) {
        if (context === "http://iiif.io/api/presentation/2/context.json") {
          newContexts.push("http://iiif.io/api/presentation/3/context.json");
        }
        if (removeContexts.indexOf(context) !== -1) {
          continue;
        }
        newContexts.push(context);
      }
      if (contexts.length) {
        return newContexts.length === 1 ? newContexts[0] : newContexts;
      }
    }
    return void 0;
  }
  function convertMetadata(metadata) {
    if (!metadata) {
      return [];
    }
    return metadata.map((item) => {
      return {
        label: convertLanguageMapping(item.label),
        value: convertLanguageMapping(item.value)
      };
    });
  }
  function removeUndefinedProperties(obj) {
    for (const prop in obj) {
      if (typeof obj[prop] === "undefined" || obj[prop] === null) {
        delete obj[prop];
      }
    }
    return obj;
  }
  var mintedIdCounter = 0;
  function mintNewIdFromResource(resource, subresource) {
    const origId = encodeURI(resource.id || resource["@id"] || "").trim();
    if (origId && subresource) {
      return `${origId}/${subresource}`;
    }
    if (origId) {
      return origId;
    }
    mintedIdCounter++;
    return `http://example.org/${resource["@type"]}${subresource ? `/${subresource}` : ""}/${mintedIdCounter}`;
  }
  function technicalProperties$2(resource) {
    const allBehaviours = [...resource.behavior || []];
    if (resource.viewingHint) {
      allBehaviours.push(resource.viewingHint);
    }
    let motivation;
    if (Array.isArray(resource.motivation)) {
      motivation = resource.motivation.map(removePrefix);
    } else if (resource.motivation) {
      motivation = removePrefix(resource.motivation);
    }
    return {
      "@context": resource["@context"] ? fixContext(resource["@context"]) : void 0,
      id: (resource["@id"] || mintNewIdFromResource(resource)).trim(),
      type: getNewType(resource),
      behavior: allBehaviours.length ? allBehaviours : void 0,
      height: resource.height ? resource.height : void 0,
      width: resource.width ? resource.width : void 0,
      motivation,
      viewingDirection: resource.viewingDirection,
      profile: resource.profile,
      format: resource.format ? resource.format : void 0,
      duration: void 0,
      timeMode: void 0
    };
  }
  function descriptiveProperties$2(resource) {
    const [rights, extraMetadata] = fixLicense(resource.license);
    const allMetadata = [...resource.metadata ? convertMetadata(resource.metadata) : [], ...extraMetadata];
    return {
      rights,
      metadata: allMetadata.length ? allMetadata : void 0,
      label: resource.label ? convertLanguageMapping(resource.label) : void 0,
      requiredStatement: resource.attribution ? {
        label: convertLanguageMapping(configuration.attributionLabel),
        value: convertLanguageMapping(resource.attribution)
      } : void 0,
      navDate: resource.navDate,
      summary: resource.description ? convertLanguageMapping(resource.description) : void 0,
      thumbnail: resource.thumbnail
    };
  }
  function parseWithin(resource) {
    if (!resource.within) {
      return void 0;
    }
    const withinProperties = Array.isArray(resource.within) ? resource.within : [resource.within];
    const returnPartOf = [];
    for (const within of withinProperties) {
      if (typeof within === "string") {
        if (within) {
          switch (resource["@type"]) {
            case "sc:Manifest":
              returnPartOf.push({ id: within, type: "Collection" });
              break;
          }
        }
      } else if (within["@id"]) {
        returnPartOf.push({
          id: within["@id"],
          type: getNewType(within)
        });
      } else
        ;
    }
    return returnPartOf.length ? returnPartOf : void 0;
  }
  function linkingProperties$2(resource) {
    const related = resource.related ? Array.isArray(resource.related) ? resource.related : [resource.related] : [];
    const layer = resource.contentLayer;
    return {
      provider: resource.logo || related.length ? [
        {
          id: configuration.providerId,
          type: "Agent",
          homepage: related.length ? [related[0]] : void 0,
          logo: resource.logo ? Array.isArray(resource.logo) ? resource.logo : [resource.logo] : void 0,
          label: convertLanguageMapping(configuration.providerName)
        }
      ] : void 0,
      partOf: parseWithin(resource),
      rendering: resource.rendering,
      seeAlso: resource.seeAlso,
      start: resource.startCanvas,
      service: resource.service ? ensureArray$1(resource.service) : void 0,
      supplementary: layer ? [layer] : void 0
    };
  }
  function embeddedContentProperties(resource) {
    return {
      chars: resource.chars,
      format: resource.format ? resource.format : void 0,
      language: resource.language
    };
  }
  function upgradeCollection(collection) {
    return removeUndefinedProperties({
      ...technicalProperties$2(collection),
      ...descriptiveProperties$2(collection),
      ...linkingProperties$2(collection),
      items: collection.members
    });
  }
  function upgradeManifest(manifest) {
    const allCanvases = [];
    const behavior = [];
    for (const sequence of manifest.sequences || []) {
      if (sequence.canvases.length) {
        allCanvases.push(...sequence.canvases);
      }
      if (sequence.behavior) {
        behavior.push(...sequence.behavior);
      }
    }
    const technical = technicalProperties$2(manifest);
    if (behavior.length) {
      if (technical.behavior) {
        technical.behavior.push(...behavior);
      } else {
        technical.behavior = behavior;
      }
    }
    return removeUndefinedProperties({
      ...technical,
      ...descriptiveProperties$2(manifest),
      ...linkingProperties$2(manifest),
      items: allCanvases,
      structures: manifest.structures
    });
  }
  function upgradeCanvas(canvas) {
    return removeUndefinedProperties({
      ...technicalProperties$2(canvas),
      ...descriptiveProperties$2(canvas),
      ...linkingProperties$2(canvas),
      annotations: canvas.otherContent && canvas.otherContent.length ? canvas.otherContent : void 0,
      items: canvas.images && canvas.images.length ? [
        {
          id: mintNewIdFromResource(canvas, "annotation-page"),
          type: "AnnotationPage",
          items: canvas.images
        }
      ] : void 0
    });
  }
  function upgradeAnnotationList(annotationPage) {
    return removeUndefinedProperties({
      ...technicalProperties$2(annotationPage),
      ...descriptiveProperties$2(annotationPage),
      ...linkingProperties$2(annotationPage),
      items: annotationPage.resources && annotationPage.resources.length ? annotationPage.resources : void 0
    });
  }
  function upgradeSequence(sequence) {
    if (!sequence.canvases || sequence.canvases.length === 0) {
      return {
        canvases: [],
        behavior: []
      };
    }
    return {
      canvases: sequence.canvases,
      behavior: sequence.viewingHint ? [sequence.viewingHint] : []
    };
  }
  function upgradeAnnotation(annotation) {
    function upgradeTarget(target) {
      if (Array.isArray(target)) {
        if (target.length > 1) {
          return { type: "List", items: target.map(upgradeTarget) };
        }
        target = target[0];
      }
      if (typeof target === "string") {
        return encodeURI(target).trim();
      } else if ("@type" in target) {
        let source;
        if (typeof target.full === "string") {
          source = target.full;
        } else if (target.full["@type"] === "dctypes:Image") {
          source = { id: target.full["@id"], type: "Image" };
        } else if (target.full["@type"] === "sc:Canvas") {
          source = { id: target.full["@id"], type: "Canvas" };
        } else {
          throw new Error(`Unsupported source type on annotation: ${target.full["@type"]}`);
        }
        return {
          type: "SpecificResource",
          source,
          selector: upgradeSelector(target.selector)
        };
      } else {
        return encodeURI(target["@id"]).trim();
      }
    }
    return removeUndefinedProperties({
      ...technicalProperties$2(annotation),
      ...descriptiveProperties$2(annotation),
      ...linkingProperties$2(annotation),
      target: upgradeTarget(annotation.on),
      body: Array.isArray(annotation.resource) ? annotation.resource.map(upgradeContentResource) : upgradeContentResource(annotation.resource)
    });
  }
  function upgradeContentResource(inputContentResource) {
    const contentResource = inputContentResource;
    return removeUndefinedProperties({
      ...technicalProperties$2(contentResource),
      ...descriptiveProperties$2(contentResource),
      ...linkingProperties$2(contentResource),
      ...embeddedContentProperties(contentResource)
    });
  }
  function upgradeChoice(choice) {
    const items = [];
    if (choice.default && choice.default !== "rdf:nil") {
      items.push(choice.default);
    }
    if (choice.item && choice.item !== "rdf:nil") {
      items.push(...choice.item);
    }
    return {
      ...technicalProperties$2(choice),
      ...descriptiveProperties$2(choice),
      items
    };
  }
  function upgradeRange(range) {
    return removeUndefinedProperties({
      ...technicalProperties$2(range),
      ...descriptiveProperties$2(range),
      ...linkingProperties$2(range),
      items: range.members
    });
  }
  function upgradeService(service) {
    const { "@id": id, "@type": type, "@context": context, profile, ...additionalProps } = service;
    const newService = {};
    if (id) {
      newService["@id"] = id;
    }
    newService["@type"] = getNewType(service);
    if (newService["@type"] === "unknown") {
      if (context && context.length) {
        newService["@context"] = context;
      }
      newService["@type"] = "Service";
    }
    if (profile) {
      newService.profile = getProfile(profile);
    }
    return removeUndefinedProperties({
      ...newService,
      ...additionalProps
    });
  }
  function upgradeLayer(layer) {
    return removeUndefinedProperties({
      ...technicalProperties$2(layer),
      ...descriptiveProperties$2(layer),
      ...linkingProperties$2(layer)
    });
  }
  var presentation2to3 = new Traverse({
    collection: [upgradeCollection],
    manifest: [upgradeManifest],
    canvas: [upgradeCanvas],
    annotationList: [upgradeAnnotationList],
    sequence: [upgradeSequence],
    annotation: [upgradeAnnotation],
    contentResource: [upgradeContentResource],
    choice: [upgradeChoice],
    range: [upgradeRange],
    service: [upgradeService],
    layer: [upgradeLayer]
  });
  function convertPresentation2(entity) {
    if (entity && entity["@context"] && (entity["@context"] === "http://iiif.io/api/presentation/2/context.json" || entity["@context"].indexOf("http://iiif.io/api/presentation/2/context.json") !== -1 || entity["@context"] === "http://www.shared-canvas.org/ns/context.json") || entity["@context"] === "http://iiif.io/api/image/2/context.json") {
      return presentation2to3.traverseUnknown(entity);
    }
    return entity;
  }
  function upgradeSelector(selector) {
    const isSvgSelector = (Array.isArray(selector["@type"]) && selector["@type"].includes("oa:SvgSelector") || selector["@type"] == "oa:SvgSelector") && ("chars" in selector || "value" in selector);
    if (isSvgSelector) {
      return {
        type: "SvgSelector",
        value: "chars" in selector ? selector.chars : selector.value
      };
    }
    if (selector["@type"] === "oa:FragmentSelector") {
      return {
        type: "FragmentSelector",
        value: selector.value
      };
    }
    if (selector["@type"] === "oa:Choice") {
      return [
        upgradeSelector(selector.default),
        ...(Array.isArray(selector.item) ? selector.item : [selector.item]).map(
          upgradeSelector
        )
      ];
    }
    if (selector["@type"] == "iiif:ImageApiSelector") {
      return {
        type: "ImageApiSelector",
        region: "region" in selector ? selector.region : void 0,
        rotation: "rotation" in selector ? selector.rotation : void 0
      };
    }
    throw new Error(`Unsupported selector type: ${selector["@type"]}`);
  }
  function getDefaultEntities() {
    return {
      Collection: {},
      Manifest: {},
      Canvas: {},
      AnnotationPage: {},
      AnnotationCollection: {},
      Annotation: {},
      ContentResource: {},
      Range: {},
      Service: {},
      Selector: {},
      Agent: {}
    };
  }
  function getResource(entityOrString, type) {
    if (typeof entityOrString === "string") {
      return { id: entityOrString, type };
    }
    if (!entityOrString.id) {
      throw new Error(`Invalid resource does not have an ID (${type})`);
    }
    return entityOrString;
  }
  function mapToEntities(entities) {
    return (type, defaultStringType) => {
      const storeType = entities[type] ? entities[type] : {};
      return (r2) => {
        const resource = getResource(r2, defaultStringType || type);
        if (resource && resource.id && type) {
          storeType[resource.id] = storeType[resource.id] ? mergeEntities(storeType[resource.id], resource) : Object.assign({}, resource);
          return {
            id: resource.id,
            type: type === "ContentResource" ? type : resource.type
          };
        }
        return resource;
      };
    };
  }
  function merge(existing, incoming) {
    if (!incoming) {
      return existing;
    }
    if (Array.isArray(existing)) {
      if (!Array.isArray(incoming)) {
        throw new Error("Cannot merge array with non-array");
      }
      const merged = [...existing];
      for (const item of incoming) {
        if (item === null || item === void 0) {
          continue;
        }
        if (Array.isArray(item)) {
          merged.push(item);
        } else if (typeof item === "object" && item.id && item.type) {
          const existingIdx = merged.findIndex((e3) => e3.id === item.id && e3.type === item.type);
          if (existingIdx >= 0) {
            merged[existingIdx] = merge(merged[existingIdx], item);
          }
        } else if (existing.indexOf(item) === -1) {
          merged.push(item);
        }
      }
      return merged;
    } else if (typeof existing === "object") {
      if (Array.isArray(incoming) || typeof incoming !== "object") {
        throw new Error("Cannot merge object with non-object");
      }
      const merged = { ...existing };
      for (const [key, val] of Object.entries(incoming)) {
        const currentVal = merged[key];
        if (currentVal === EMPTY || !currentVal) {
          merged[key] = val;
        } else {
          merged[key] = merge(currentVal, val);
        }
      }
      return merged;
    } else if (existing) {
      return existing;
    }
    return incoming;
  }
  function mergeEntities(existing, incoming) {
    if (typeof existing === "string") {
      return existing;
    }
    if (incoming.id !== existing.id || incoming.type !== existing.type) {
      throw new Error("Can only merge entities with identical identifiers and type!");
    }
    return merge({ ...existing }, incoming);
  }
  function recordTypeInMapping(mapping) {
    return (type, defaultStringType) => {
      return (r2) => {
        const { id, type: foundType } = getResource(r2, defaultStringType || type);
        if (typeof id === "undefined") {
          throw new Error("Found invalid entity without an ID.");
        }
        if (type === "ContentResource") {
          mapping[id] = type;
        } else {
          mapping[id] = foundType;
        }
        return r2;
      };
    };
  }
  function hash(object) {
    const text = JSON.stringify(object);
    let numHash = 5381, index2 = text.length;
    while (index2) {
      numHash = numHash * 33 ^ text.charCodeAt(--index2);
    }
    const num = numHash >>> 0;
    const hexString = num.toString(16);
    if (hexString.length % 2) {
      return "0" + hexString;
    }
    return hexString;
  }
  function addMissingIdToContentResource(type) {
    return (resource) => {
      if (typeof resource === "string") {
        return { id: resource, type };
      }
      if (!resource.id) {
        return { id: `vault://${hash(resource)}`, type, ...resource };
      }
      if (!resource.type) {
        return { type, ...resource };
      }
      return resource;
    };
  }
  function ensureDefaultFields(defaultResource) {
    return (resource) => {
      return {
        ...defaultResource,
        ...resource
      };
    };
  }
  function ensureArray(maybeArray) {
    if (Array.isArray(maybeArray)) {
      return maybeArray;
    }
    return [maybeArray];
  }
  function ensureArrayOnAnnotation(annotation) {
    if (annotation.body) {
      annotation.body = ensureArray(annotation.body);
    }
    if (annotation.seeAlso) {
      annotation.seeAlso = ensureArray(annotation.seeAlso);
    }
    if (annotation.body) {
      annotation.body = ensureArray(annotation.body);
    }
    if (annotation.audience) {
      annotation.audience = ensureArray(annotation.audience);
    }
    if (annotation.accessibility) {
      annotation.accessibility = ensureArray(annotation.accessibility);
    }
    if (annotation.motivation) {
      annotation.motivation = ensureArray(annotation.motivation);
    }
    return annotation;
  }
  function normalize(unknownEntity) {
    const entity = convertPresentation2(unknownEntity);
    const entities = getDefaultEntities();
    const mapping = {};
    const addToEntities = mapToEntities(entities);
    const addToMapping = recordTypeInMapping(mapping);
    const traversal = new Traverse$1({
      collection: [
        ensureDefaultFields(emptyCollection),
        addToMapping("Collection"),
        addToEntities("Collection")
      ],
      manifest: [
        ensureDefaultFields(emptyManifest),
        addToMapping("Manifest"),
        addToEntities("Manifest")
      ],
      canvas: [
        ensureDefaultFields(emptyCanvas),
        addToMapping("Canvas"),
        addToEntities("Canvas")
      ],
      annotationPage: [
        addMissingIdToContentResource("AnnotationPage"),
        ensureDefaultFields(emptyAnnotationPage),
        addToMapping("AnnotationPage"),
        addToEntities("AnnotationPage")
      ],
      annotation: [
        addMissingIdToContentResource("Annotation"),
        ensureArrayOnAnnotation,
        addToMapping("Annotation"),
        addToEntities("Annotation")
      ],
      contentResource: [
        addMissingIdToContentResource("ContentResource"),
        addToMapping("ContentResource"),
        addToEntities("ContentResource")
      ],
      range: [
        ensureDefaultFields(emptyRange),
        addToMapping("Range", "Canvas"),
        addToEntities("Range", "Canvas")
      ],
      agent: [
        ensureDefaultFields(emptyAgent),
        addToMapping("Agent"),
        addToEntities("Agent")
      ]
    });
    const resource = traversal.traverseUnknown(entity);
    return { entities, resource, mapping };
  }
  var UNSET = "__$UNSET$__";
  var UNWRAP = "__$UNWRAP$__";
  function resolveIfExists(state, url) {
    const request = state.requests[url];
    const resourceType = state.mapping[url];
    if (!resourceType || request && request.resourceUri && !state.entities[resourceType][request.resourceUri]) {
      return void 0;
    }
    return state.entities[resourceType][request ? request.resourceUri : url];
  }
  function serializedFieldsToObject(fields) {
    const object = {};
    for (const [key, value] of fields) {
      if (key === UNWRAP && value !== UNSET) {
        return value;
      }
      if (value !== UNSET && typeof value !== "undefined" && value !== null) {
        object[key] = value;
      }
    }
    return object;
  }
  function serialize(state, subject, config) {
    if (!subject.type || !subject.id) {
      throw new Error("Unknown entity");
    }
    if (!config[subject.type]) {
      throw new Error(`Serializer not found for ${subject.type}`);
    }
    function flatten(sub) {
      const generator = config[sub.type];
      if (!generator) {
        return UNSET;
      }
      const resource = resolveIfExists(state, sub.id) || (sub.id && sub.type ? sub : null);
      if (!resource) {
        return UNSET;
      }
      const iterator = generator(resource, state, { isTopLevel: subject.id === sub.id });
      let current = iterator.next();
      while (!current.done) {
        const requestToHydrate = current.value;
        let next = UNSET;
        if (requestToHydrate) {
          if (Array.isArray(requestToHydrate)) {
            const nextList = [];
            for (const req of requestToHydrate) {
              nextList.push(flatten(req));
            }
            next = nextList;
          } else {
            next = flatten(requestToHydrate);
          }
        }
        current = iterator.next(next);
      }
      if (current.value === UNSET) {
        return UNSET;
      }
      return serializedFieldsToObject(current.value);
    }
    return flatten(subject);
  }
  function languageString2to3(value) {
    if (!value) {
      return void 0;
    }
    const languages = Object.keys(value);
    if (languages.length === 0) {
      return void 0;
    }
    if (languages.length === 1) {
      const language = languages[0];
      if (!language) {
        return "";
      }
      const singleValue = (value[language] || []).join("");
      if (language === "@none" || language === "none" || language === "en") {
        return singleValue;
      }
      return {
        "@language": language,
        "@value": singleValue
      };
    }
    return languages.map((language) => {
      return {
        "@language": language,
        "@value": (value[language] || []).join("")
      };
    });
  }
  function parseCanvasTarget(target) {
    if (Array.isArray(target)) {
      return target.map((t2) => parseCanvasTarget(t2));
    }
    if (typeof target === "string") {
      return target;
    }
    if (target.type && target.type === "Canvas") {
      return target.id;
    }
    return target;
  }
  function unNestArray(oneOrArray, onlyOne = false) {
    if (!oneOrArray) {
      return void 0;
    }
    if (oneOrArray.length > 1 && !onlyOne) {
      return oneOrArray;
    }
    return oneOrArray[0] || void 0;
  }
  function convertService(service) {
    if (!service) {
      return void 0;
    }
    if (typeof service === "string") {
      return {
        "@id": service
      };
    }
    if ("@id" in service) {
      const newService = { ...service };
      delete newService["@type"];
      return newService;
    }
    return {
      "@context": "http://iiif.io/api/image/2/context.json",
      "@id": service.id,
      profile: `http://iiif.io/api/image/2/profiles/${service.profile}.json`
    };
  }
  function technicalProperties$1(props, type) {
    return [
      ["@id", props.id],
      ["@type", type],
      ["format", props.format],
      ["height", props.height],
      ["width", props.width],
      ["viewingDirection", props.viewingDirection !== "left-to-right" ? props.viewingDirection : void 0]
    ];
  }
  function* descriptiveProperties$1(prop) {
    const provider = prop.provider ? yield prop.provider[0] : void 0;
    return [
      ["label", languageString2to3(prop.label)],
      [
        "metadata",
        prop.metadata && prop.metadata.length ? prop.metadata.map((item) => ({
          label: languageString2to3(item.label) || "",
          value: languageString2to3(item.value) || ""
        })) : void 0
      ],
      ["description", languageString2to3(prop.summary)],
      ["thumbnail", unNestArray(yield prop.thumbnail)],
      ["navDate", prop.navDate],
      ["logo", provider ? unNestArray(provider.logo) : void 0],
      ["homepage", provider ? provider.homepage : void 0],
      ["attribution", prop.requiredStatement ? languageString2to3(prop.requiredStatement.value) : void 0]
    ];
  }
  function* linkingProperties$1(prop) {
    return [
      ["seeAlso", unNestArray(yield prop.seeAlso)],
      ["service", unNestArray((prop.service || []).map(convertService))],
      ["rendering", unNestArray(yield prop.rendering)],
      ["startCanvas", prop.start ? prop.start.id : void 0]
    ];
  }
  var serializeConfigPresentation2 = {
    Manifest: function* (entity) {
      return [
        ...technicalProperties$1(entity, "sc:Manifest"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        [
          "sequences",
          [
            {
              "@id": `${entity.id}/sequence0`,
              "@type": "sc:Sequence",
              canvases: yield entity.items
            }
          ]
        ],
        ["structures", yield entity.structures]
      ];
    },
    Canvas: function* (entity) {
      const paintingPage = yield entity.items;
      const resources = paintingPage[0];
      return [
        ...technicalProperties$1(entity, "sc:Canvas"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        ["images", resources ? [resources.resources] : void 0],
        [
          "annotations",
          entity.annotations && entity.annotations.length ? unNestArray(yield entity.annotations) : void 0
        ]
      ];
    },
    AnnotationPage: function* (entity) {
      return [
        ...technicalProperties$1(entity, "sc:AnnotationList"),
        ...yield* descriptiveProperties$1(entity),
        ["resources", entity.items && entity.items.length ? unNestArray(yield entity.items) : void 0]
      ];
    },
    Annotation: function* (entity) {
      return [
        ["@id", entity.id],
        ["@type", "oa:Annotation"],
        ["motivation", "sc:painting"],
        ["on", parseCanvasTarget(entity.target)],
        ["resource", unNestArray(yield entity.body, true)]
      ];
    },
    ContentResource: function* (entity) {
      switch (entity.type) {
        case "Image":
          return [
            ...technicalProperties$1(entity, "dctypes:Image"),
            ...yield* descriptiveProperties$1(entity),
            ...yield* linkingProperties$1(entity)
          ];
        case "Text":
        case "Dataset":
        default:
          return [...technicalProperties$1(entity, void 0), ...yield* descriptiveProperties$1(entity)];
      }
    },
    AnnotationCollection: function* (entity) {
      return [
        ["@id", entity.id],
        ["@type", "sc:Layer"],
        ["label", languageString2to3(entity.label)]
      ];
    },
    Collection: function* (entity) {
      return [
        ...technicalProperties$1(entity, "sc:Collection"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        ["members", yield* entity.items]
      ];
    },
    Range: function* (entity) {
      const members = [];
      const canvases = [];
      if (entity.items) {
        for (const item of entity.items) {
          const canvas = yield item;
          members.push({
            "@id": item.id,
            "@type": item.type,
            label: canvas ? canvas.label : void 0,
            within: entity.id
          });
          if (item.type === "Canvas") {
            canvases.push(item.id);
          }
        }
      }
      return [
        ...technicalProperties$1(entity, "sc:Range"),
        ...yield* descriptiveProperties$1(entity),
        ...yield* linkingProperties$1(entity),
        ["canvases", canvases.length === members.length ? canvases : void 0],
        ["members", canvases.length !== members.length ? members : void 0]
      ];
    }
  };
  function technicalProperties(entity) {
    var _a;
    return [
      ["id", !((_a = entity.id) == null ? void 0 : _a.startsWith("vault://")) ? entity.id : void 0],
      ["type", entity.type],
      ["format", entity.format],
      ["profile", entity.profile],
      ["height", entity.height],
      ["width", entity.width],
      ["duration", entity.duration || void 0],
      ["viewingDirection", entity.viewingDirection !== "left-to-right" ? entity.viewingDirection : void 0],
      ["behavior", entity.behavior && entity.behavior.length ? entity.behavior : void 0],
      ["timeMode", entity.timeMode],
      ["motivation", Array.isArray(entity.motivation) ? entity.motivation[0] : entity.motivation]
    ];
  }
  function filterEmpty(item) {
    if (!item || item.length === 0) {
      return void 0;
    }
    return item;
  }
  function service2compat(service) {
    if (service && service.type && service.type === "ImageService2") {
      const { id, type, profile: _profile, ..._service } = service;
      const profile = typeof _profile === "string" ? _profile : Array.isArray(_profile) ? _profile.find((p2) => typeof p2 === "string") : "";
      return {
        "@id": id,
        "@type": type,
        profile: profile ? profile.startsWith("http") ? profile : `http://iiif.io/api/image/2/${profile}.json` : "http://iiif.io/api/image/2/level0.json",
        ..._service
      };
    }
    return service;
  }
  function filterService2Compat(services) {
    if (!services || services.length === 0) {
      return void 0;
    }
    return services.map(service2compat);
  }
  function* descriptiveProperties(entity) {
    return [
      ["label", entity.label],
      ["metadata", filterEmpty(entity.metadata)],
      ["summary", entity.summary],
      ["requiredStatement", entity.requiredStatement],
      ["rights", entity.rights],
      ["navDate", entity.navDate],
      ["language", entity.language],
      ["thumbnail", filterEmpty(yield entity.thumbnail)],
      ["placeholderCanvas", yield entity.placeholderCanvas],
      ["accompanyingCanvas", yield entity.accompanyingCanvas],
      ["provider", filterEmpty(yield entity.provider)]
    ];
  }
  function* linkingProperties(entity) {
    return [
      ["seeAlso", filterEmpty(yield entity.seeAlso)],
      ["service", filterService2Compat(entity.service)],
      ["services", filterService2Compat(entity.services)],
      ["rendering", filterEmpty(yield entity.rendering)],
      ["supplementary", filterEmpty(yield entity.supplementary)],
      ["homepage", filterEmpty(yield entity.homepage)],
      ["logo", filterEmpty(yield entity.logo)],
      ["partOf", filterEmpty(yield entity.partOf)],
      ["start", entity.start]
    ];
  }
  var serializeConfigPresentation3 = {
    Manifest: function* (entity, state, { isTopLevel }) {
      if (!isTopLevel) {
        return [
          ...technicalProperties(entity),
          ...yield* descriptiveProperties(entity)
        ];
      }
      return [
        ["@context", "http://iiif.io/api/presentation/3/context.json"],
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["items", yield entity.items],
        ["structures", filterEmpty(yield entity.structures)],
        ["annotations", filterEmpty(yield entity.annotations)]
      ];
    },
    Canvas: function* (entity) {
      return [
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["items", yield entity.items],
        ["annotations", filterEmpty(yield entity.annotations)]
      ];
    },
    Agent: function* (entity) {
      return [
        ["id", entity.id],
        ["type", "Agent"],
        ["label", entity.label],
        ...yield* linkingProperties(entity)
      ];
    },
    AnnotationPage: function* (entity) {
      const entries = Object.entries(entity).map(([key, item]) => {
        return [key, Array.isArray(item) ? filterEmpty(item) : item];
      }).filter(([key, value]) => {
        return key !== "items";
      });
      return [
        ...entries,
        ...yield* linkingProperties(entity),
        ["items", yield entity.items]
      ];
    },
    Service: function* (entity) {
      return [[UNWRAP, service2compat(entity)]];
    },
    Annotation: function* (entity) {
      const entries = Object.entries(entity).map(([key, item]) => {
        if (key === "motivation") {
          return [key, Array.isArray(item) ? item[0] : item];
        }
        return [key, Array.isArray(item) ? filterEmpty(item) : item];
      }).filter(([key]) => {
        return key !== "body";
      });
      const resolvedBody = yield entity.body;
      return [...entries, ["body", resolvedBody.length === 1 ? resolvedBody[0] : resolvedBody]];
    },
    ContentResource: function* (entity) {
      return [
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["annotations", filterEmpty(yield entity.annotations)],
        ["items", filterEmpty(yield entity.items)]
      ];
    },
    AnnotationCollection: function* (entity) {
      return [
        ["id", entity.id],
        ["type", "AnnotationCollection"],
        ["label", entity.label]
      ];
    },
    Collection: function* (entity, state, { isTopLevel }) {
      if (isTopLevel) {
        return [
          ["@context", "http://iiif.io/api/presentation/3/context.json"],
          ...technicalProperties(entity),
          ...yield* descriptiveProperties(entity),
          ...yield* linkingProperties(entity),
          ["items", filterEmpty(yield entity.items)]
        ];
      }
      return [...technicalProperties(entity), ...yield* descriptiveProperties(entity)];
    },
    Range: function* (entity) {
      const rangeItems = [];
      for (const item of entity.items) {
        if (item.type === "Range") {
          rangeItems.push(yield item);
        } else {
          rangeItems.push(item);
        }
      }
      return [
        ...technicalProperties(entity),
        ...yield* descriptiveProperties(entity),
        ...yield* linkingProperties(entity),
        ["items", rangeItems],
        ["annotations", filterEmpty(yield entity.annotations)]
      ];
    }
  };

  // node_modules/@iiif/vault/dist/esm/index.mjs
  var import_typesafe_actions = __toESM(require_typesafe_actions_umd_production(), 1);
  var IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
  var MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
  var REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
  var ADD_REFERENCE = "@iiif/ADD_REFERENCE";
  var REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
  var importEntities = (0, import_typesafe_actions.createAction)(IMPORT_ENTITIES)();
  var modifyEntityField = (0, import_typesafe_actions.createAction)(MODIFY_ENTITY_FIELD)();
  var reorderEntityField = (0, import_typesafe_actions.createAction)(REORDER_ENTITY_FIELD)();
  var addReference = (0, import_typesafe_actions.createAction)(ADD_REFERENCE)();
  var removeReference = (0, import_typesafe_actions.createAction)(REMOVE_REFERENCE)();
  var entityActions = { importEntities, modifyEntityField, reorderEntityField, addReference, removeReference };
  var ADD_MAPPING = "@iiif/ADD_MAPPING";
  var ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
  var addMapping = (0, import_typesafe_actions.createAction)(ADD_MAPPING)();
  var addMappings = (0, import_typesafe_actions.createAction)(ADD_MAPPINGS)();
  var SET_META_VALUE = "@iiif/SET_META_VALUE";
  var SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
  var UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
  var setMetaValue = (0, import_typesafe_actions.createAction)(SET_META_VALUE)();
  var setMetaValueDynamic = (0, import_typesafe_actions.createAction)(SET_META_VALUE_DYNAMIC)();
  var unsetMetaValue = (0, import_typesafe_actions.createAction)(UNSET_META_VALUE)();
  var metaActions = {
    setMetaValue,
    setMetaValueDynamic,
    unsetMetaValue
  };
  var RESOURCE_ERROR = "RESOURCE_ERROR";
  var RESOURCE_LOADING = "RESOURCE_LOADING";
  var RESOURCE_READY = "RESOURCE_READY";
  var REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
  var REQUEST_ERROR = "@iiif/REQUEST_ERROR";
  var REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
  var REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
  var REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
  var requestResource = (0, import_typesafe_actions.createAction)(REQUEST_RESOURCE)();
  var requestError = (0, import_typesafe_actions.createAction)(REQUEST_ERROR)();
  var requestMismatch = (0, import_typesafe_actions.createAction)(REQUEST_MISMATCH)();
  var requestComplete = (0, import_typesafe_actions.createAction)(REQUEST_COMPLETE)();
  (0, import_typesafe_actions.createAction)(REQUEST_OFFLINE_RESOURCE)();
  var BATCH_ACTIONS = "@iiif/BATCH";
  var BATCH_IMPORT = "@iiif/BATCH_IMPORT";
  var batchActions = (0, import_typesafe_actions.createAction)(BATCH_ACTIONS)();
  (0, import_typesafe_actions.createAction)(BATCH_IMPORT)();
  var actionListFromResource = (id, response) => {
    const { entities, resource, mapping } = normalize(response);
    if (resource.id === void 0) {
      return [requestError({ id, message: "ID is not defined in resource." })];
    }
    const actions = [importEntities({ entities }), addMappings({ mapping })];
    if (resource.id !== id) {
      actions.push(addMapping({ id, type: resource.type }));
      actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
    }
    actions.push(requestComplete({ id }));
    return actions;
  };
  var safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === "number" && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
      return newInputs === lastInputs;
    }
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (let i2 = 0; i2 < newInputs.length; i2++) {
      if (!isEqual(newInputs[i2], lastInputs[i2])) {
        return false;
      }
    }
    return true;
  }
  function resolveIfExists2(state, url) {
    const request = state.iiif.requests[url];
    const resourceType = state.iiif.mapping[url];
    if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
      return void 0;
    }
    return state.iiif.entities[resourceType][request.resourceUri];
  }
  function createFetchHelper(store, fetcher, { waitTimeout = 30 } = {}) {
    return async (url, options) => {
      const state = store.getState();
      const request = state.iiif.requests[url];
      if (request) {
        switch (request.loadingState) {
          case RESOURCE_ERROR:
            break;
          case RESOURCE_LOADING: {
            let cleanupSubscription;
            let didContinue = false;
            try {
              const resolvedEntity = await Promise.race([
                new Promise((resolve, reject) => {
                  if (didContinue) {
                    return;
                  }
                  cleanupSubscription = store.subscribe(() => {
                    const latestState = store.getState();
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                      reject();
                      return;
                    }
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                      const maybeResolvedEntity = resolveIfExists2(latestState, url);
                      if (maybeResolvedEntity) {
                        resolve(maybeResolvedEntity);
                      } else {
                        reject();
                      }
                    }
                  });
                }),
                new Promise((resolve, reject) => setTimeout(() => {
                  didContinue = true;
                  reject();
                }, waitTimeout * 60))
              ]);
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              if (resolvedEntity) {
                return resolvedEntity;
              }
            } catch (e3) {
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              break;
            }
            break;
          }
          case RESOURCE_READY: {
            const resolvedEntity = resolveIfExists2(state, url);
            if (resolvedEntity) {
              return resolvedEntity;
            }
            break;
          }
        }
      }
      store.dispatch(requestResource({ id: url }));
      try {
        const resource = await fetcher(url, options);
        if (!resource.id && !resource["@id"]) {
          if (resource["@type"]) {
            resource["@id"] = url;
            resource.id = url;
          } else {
            resource.id = url;
          }
        }
        const toDispatch = actionListFromResource(url, resource);
        store.dispatch(batchActions({ actions: toDispatch }));
        return resolveIfExists2(store.getState(), url);
      } catch (err) {
        store.dispatch(requestError({ id: url, message: err.toString() }));
        throw err;
      }
    };
  }
  function getDefaultEntities2() {
    return {
      Collection: {},
      Manifest: {},
      Canvas: {},
      AnnotationPage: {},
      AnnotationCollection: {},
      Annotation: {},
      ContentResource: {},
      Range: {},
      Service: {},
      Selector: {},
      Agent: {}
    };
  }
  var mappingReducer = (state = {}, action) => {
    switch (action.type) {
      case ADD_MAPPING:
        return {
          ...state,
          [action.payload.id]: action.payload.type
        };
      case ADD_MAPPINGS:
        return {
          ...state,
          ...action.payload.mapping
        };
      default:
        return state;
    }
  };
  function isReferenceList(state, id, type, key) {
    return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
  }
  function quickMerge(a2, b3) {
    const newResource = {};
    const added = [];
    for (const [key, value] of Object.entries(a2 || {})) {
      added.push(key);
      const bValue = (b3 || {})[key];
      if (!bValue || bValue.length === 0) {
        newResource[key] = value;
        continue;
      }
      newResource[key] = bValue;
    }
    for (const [key, value] of Object.entries(b3 || {})) {
      if (added.indexOf(key) !== -1) {
        continue;
      }
      newResource[key] = value;
    }
    return newResource;
  }
  var entitiesReducer = (state = getDefaultEntities2(), action) => {
    switch (action.type) {
      case MODIFY_ENTITY_FIELD: {
        if (!state[action.payload.type] || !state[action.payload.type][action.payload.id]) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        if (typeof entity === "string") {
          return state;
        }
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: action.payload.value
            }
          }
        };
      }
      case REORDER_ENTITY_FIELD: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        if (typeof entity === "string") {
          return state;
        }
        const result = Array.from(entity[action.payload.key]);
        const [removed] = result.splice(action.payload.startIndex, 1);
        result.splice(action.payload.endIndex, 0, removed);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      case IMPORT_ENTITIES: {
        const keys = Object.keys(action.payload.entities);
        const toReturn = { ...state };
        for (const key of keys) {
          const entities = action.payload.entities[key];
          const newEntities = { ...state[key] || {} };
          let changed = false;
          const ids = Object.keys(entities || {}) || [];
          if (entities && ids) {
            for (const id of ids) {
              changed = true;
              newEntities[id] = state[key][id] ? quickMerge(state[key][id], entities[id]) : entities[id];
            }
            if (changed) {
              toReturn[key] = newEntities;
            }
          }
        }
        return toReturn;
      }
      case ADD_REFERENCE: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        const result = Array.from(entity[action.payload.key]);
        result.splice(action.payload.index || result.length + 1, 0, action.payload.reference);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      case REMOVE_REFERENCE: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        const result = Array.from(entity[action.payload.key]);
        const indexToRemove = action.payload.index || result.findIndex((e3) => e3 && e3.id === action.payload.reference.id);
        if (indexToRemove === -1) {
          return state;
        }
        if (result[indexToRemove]?.id !== action.payload.reference.id) {
          return state;
        }
        result.splice(indexToRemove, 1);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      default:
        return state;
    }
  };
  var requestReducer = (state = {}, action) => {
    switch (action.type) {
      case REQUEST_RESOURCE:
      case REQUEST_OFFLINE_RESOURCE:
        return {
          ...state,
          [action.payload.id]: {
            requestUri: action.payload.id,
            loadingState: RESOURCE_LOADING,
            uriMismatch: false,
            resourceUri: action.payload.id
          }
        };
      case REQUEST_MISMATCH:
        return {
          ...state,
          [action.payload.requestId]: {
            ...state[action.payload.requestId] || {},
            uriMismatch: true,
            resourceUri: action.payload.actualId
          },
          [action.payload.actualId]: {
            requestUri: action.payload.requestId,
            loadingState: state[action.payload.requestId].loadingState,
            uriMismatch: true,
            resourceUri: action.payload.actualId
          }
        };
      case REQUEST_ERROR:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_ERROR,
            error: action.payload.message
          }
        };
      case REQUEST_COMPLETE:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_READY,
            error: void 0
          }
        };
    }
    return state;
  };
  var metaReducer = (state = {}, action) => {
    const { id, updateValue, value, meta, key } = action && action.payload || {};
    switch (action.type) {
      case SET_META_VALUE: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: value
            }
          }
        };
      }
      case SET_META_VALUE_DYNAMIC: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
            }
          }
        };
      }
      case UNSET_META_VALUE: {
        if (state[id] && state[id][meta] && state[id][meta][key]) {
          return {
            ...state,
            [id]: {
              ...state[id] || {},
              [meta]: {
                ...state[id] ? state[id][meta] || {} : {},
                [key]: void 0
              }
            }
          };
        }
        return state;
      }
      default:
        return state;
    }
  };
  function createBatchReducer(rootReducer) {
    return (state, action) => {
      if (action && action.type === BATCH_ACTIONS) {
        return action.payload.actions.reduce(rootReducer, state);
      }
      if (action && action.type === BATCH_IMPORT) {
        return action.payload.state;
      }
      return rootReducer(state, action);
    };
  }
  var reducers = combineReducers({
    mapping: mappingReducer,
    entities: entitiesReducer,
    requests: requestReducer,
    meta: metaReducer
  });
  var composeEnhancers = typeof window !== "undefined" ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose : compose;
  function createStore2(options = {}) {
    const {
      enableDevtools = true,
      iiifStoreName = "iiif",
      defaultState: defaultState2 = {},
      extraMiddleware = [],
      customReducers = {}
    } = options;
    const rootReducer = combineReducers({ [iiifStoreName]: reducers, ...customReducers });
    const store = createStore(createBatchReducer(rootReducer), defaultState2, enableDevtools ? composeEnhancers(applyMiddleware(...extraMiddleware)) : compose(applyMiddleware(...extraMiddleware)));
    return store;
  }
  function mitt(n2) {
    return { all: n2 = n2 || /* @__PURE__ */ new Map(), on: function(t2, e3) {
      var i2 = n2.get(t2);
      i2 ? i2.push(e3) : n2.set(t2, [e3]);
    }, off: function(t2, e3) {
      var i2 = n2.get(t2);
      i2 && (e3 ? i2.splice(i2.indexOf(e3) >>> 0, 1) : n2.set(t2, []));
    }, emit: function(t2, e3) {
      var i2 = n2.get(t2);
      i2 && i2.slice().map(function(n3) {
        n3(e3);
      }), (i2 = n2.get("*")) && i2.slice().map(function(n3) {
        n3(t2, e3);
      });
    } };
  }
  var Vault = class {
    options;
    store;
    emitter;
    isBatching = false;
    batchQueue = [];
    remoteFetcher;
    staticFetcher;
    constructor(options, store) {
      this.options = Object.assign({
        reducers: {},
        middleware: [],
        defaultState: {},
        customFetcher: this.defaultFetcher,
        enableDevtools: true
      }, options || {});
      this.store = store || createStore2({
        customReducers: this.options.reducers,
        extraMiddleware: [...this.options.middleware, this.middleware],
        defaultState: this.options.defaultState,
        enableDevtools: this.options.enableDevtools
      });
      this.emitter = mitt();
      this.remoteFetcher = createFetchHelper(this.store, this.options.customFetcher);
      this.staticFetcher = createFetchHelper(this.store, (id, json) => json);
    }
    defaultFetcher = (url) => {
      return fetch(url).then((r2) => r2.json());
    };
    batch(cb) {
      this.isBatching = true;
      try {
        cb(this);
        this.store.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e3) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e3;
      }
      this.batchQueue = [];
      this.isBatching = false;
    }
    async asyncBatch(cb) {
      this.isBatching = true;
      try {
        await cb(this);
        this.store.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e3) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e3;
      }
      this.batchQueue = [];
      this.isBatching = false;
    }
    modifyEntityField(entity, key, value) {
      this.dispatch(entityActions.modifyEntityField({
        id: entity.id,
        type: entity.type,
        key,
        value
      }));
    }
    dispatch(action) {
      if (!this.isBatching) {
        this.store.dispatch(action);
      } else {
        this.batchQueue.push(action);
      }
    }
    middleware = (store) => (next) => (action) => {
      if (action.type === BATCH_ACTIONS) {
        for (const realAction of action.payload.actions) {
          this.emitter.emit(realAction.type, { realAction, state: store.getState() });
        }
        const state2 = next(action);
        for (const realAction of action.payload.actions) {
          this.emitter.emit(`after:${action.type}`, { action, state: state2 });
        }
        return state2;
      }
      this.emitter.emit(action.type, { action, state: store.getState() });
      const state = next(action);
      this.emitter.emit(`after:${action.type}`, { action, state });
      return state;
    };
    serialize(entity, config) {
      return serialize(this.getState().iiif, entity, config);
    }
    toPresentation2(entity) {
      return this.serialize(entity, serializeConfigPresentation2);
    }
    toPresentation3(entity) {
      return this.serialize(entity, serializeConfigPresentation3);
    }
    hydrate(reference, type) {
      return this.get(reference, type, { skipSelfReturn: false });
    }
    get(reference, type, options = {}) {
      if (typeof type !== "string") {
        options = type || {};
        type = void 0;
      }
      const { skipSelfReturn = true } = options || {};
      if (Array.isArray(reference)) {
        return reference.map((i2) => this.get(i2, options));
      }
      const state = this.getState();
      if (typeof reference === "string") {
        const _type2 = type ? type : state.iiif.mapping[reference];
        if (!_type2) {
          if (skipSelfReturn) {
            return null;
          }
          return { id: reference, type: "unknown" };
        }
        reference = { id: reference, type: _type2 };
      }
      const _type = type ? type : reference.type;
      const _id = reference.id;
      const entities = state.iiif.entities[_type];
      if (!entities) {
        const request = state.iiif.requests[_id];
        if (request && request.resourceUri !== _id) {
          return this.get(request.resourceUri, options);
        }
        if (skipSelfReturn) {
          return null;
        }
        return reference;
      }
      return entities[reference.id] || (skipSelfReturn ? null : reference);
    }
    select(selector) {
      return selector(this.getState());
    }
    getStore() {
      return this.store;
    }
    getState() {
      return this.store.getState();
    }
    loadManifest(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json);
    }
    loadCollection(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json);
    }
    load(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      if (json) {
        return this.staticFetcher(_id, json);
      }
      return this.remoteFetcher(_id);
    }
    areInputsEqual(newInputs, lastInputs) {
      return areInputsEqual(newInputs, lastInputs);
    }
    subscribe(selector, subscription, skipInitial) {
      if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
        skipInitial = subscription;
        subscription = selector;
        selector = (a2) => a2;
      }
      let lastState = skipInitial ? null : selector(this.store.getState());
      if (!skipInitial) {
        subscription(lastState, this);
      }
      return this.store.subscribe(() => {
        const state = this.store.getState();
        const selectedState = selector(state);
        if (lastState !== selectedState && !areInputsEqual(lastState, selectedState)) {
          subscription(selectedState, this);
        }
        lastState = selectedState;
      });
    }
    async ensureLoaded(_id) {
      const id = typeof _id === "string" ? _id : _id.id;
      if (!this.requestStatus(id)) {
        await this.load(id);
      }
    }
    requestStatus(id) {
      return this.select((state) => {
        return state.iiif.requests[id];
      });
    }
    getResourceMeta(resource, metaKey) {
      const resourceMeta = this.getState().iiif.meta[resource];
      if (!resourceMeta) {
        return void 0;
      }
      if (!metaKey) {
        return resourceMeta;
      }
      return resourceMeta[metaKey];
    }
    setMetaValue([id, meta, key], newValueOrUpdate) {
      this.dispatch(typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
        id,
        meta,
        key,
        updateValue: newValueOrUpdate
      }) : metaActions.setMetaValue({
        id,
        meta,
        key,
        value: newValueOrUpdate
      }));
    }
  };

  // node_modules/@radix-ui/react-collapsible/dist/index.mjs
  var import_react52 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/primitive/dist/index.mjs
  function $e42e1063c40fb3ef$export$b9ecd428b558ff102(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react44 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c12(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react44.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react44.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react44.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react44.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react44.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react44.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes2(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes2(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react44.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var import_react46 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react45 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a2(callback) {
    const callbackRef = (0, import_react45.useRef)(callback);
    (0, import_react45.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react45.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  function $71cd76cc60e0454e$export$6f32135080cb4c32({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState2({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a2(onChange);
    const setValue = (0, import_react46.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState2({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react46.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react46.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a2(onChange);
    (0, import_react46.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var import_react47 = __toESM(require_react(), 1);
  var $9f79659886946c16$export$e5c5a5f917a5871c2 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react47.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react48 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef2(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af2(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef2(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d052(...refs) {
    return (0, import_react48.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af2(...refs), refs);
  }

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react50 = __toESM(require_react(), 1);
  var import_react_dom4 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react49 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac13602 = /* @__PURE__ */ (0, import_react49.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react49.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable2);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react49.Children.count(newElement) > 1)
            return import_react49.Children.only(null);
          return /* @__PURE__ */ (0, import_react49.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react49.createElement)($5e63c961fc1ce211$var$SlotClone2, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react49.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react49.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react49.createElement)($5e63c961fc1ce211$var$SlotClone2, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13602.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone2 = /* @__PURE__ */ (0, import_react49.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react49.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react49.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps2(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af2(forwardedRef, children.ref) : children.ref
      });
    return import_react49.Children.count(children) > 1 ? import_react49.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone2.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d452 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react49.createElement)(import_react49.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable2(child) {
    return /* @__PURE__ */ (0, import_react49.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d452;
  }
  function $5e63c961fc1ce211$var$mergeProps2(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES2 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0342 = $8927f6f2acc4f386$var$NODES2.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react50.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac13602 : node;
      (0, import_react50.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react50.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-presence/dist/index.mjs
  var import_react51 = __toESM(require_react(), 1);
  var import_react_dom5 = __toESM(require_react_dom(), 1);
  function $fe963b355347cc68$export$3e6543de14f8614f2(initialState3, machine) {
    return (0, import_react51.useReducer)((state, event) => {
      const nextState = machine[state][event];
      return nextState !== null && nextState !== void 0 ? nextState : state;
    }, initialState3);
  }
  var $921a889cee6df7e8$export$99c2b779aa4e8b8b2 = (props) => {
    const { present, children } = props;
    const presence = $921a889cee6df7e8$var$usePresence2(present);
    const child = typeof children === "function" ? children({
      present: presence.isPresent
    }) : import_react51.Children.only(children);
    const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d052(presence.ref, child.ref);
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react51.cloneElement)(child, {
      ref
    }) : null;
  };
  $921a889cee6df7e8$export$99c2b779aa4e8b8b2.displayName = "Presence";
  function $921a889cee6df7e8$var$usePresence2(present) {
    const [node1, setNode] = (0, import_react51.useState)();
    const stylesRef = (0, import_react51.useRef)({});
    const prevPresentRef = (0, import_react51.useRef)(present);
    const prevAnimationNameRef = (0, import_react51.useRef)("none");
    const initialState3 = present ? "mounted" : "unmounted";
    const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f2(initialState3, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    (0, import_react51.useEffect)(() => {
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName2(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [
      state
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c2(() => {
      const styles = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName2(styles);
        if (present)
          send("MOUNT");
        else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
          send("UNMOUNT");
        else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating)
            send("ANIMATION_OUT");
          else
            send("UNMOUNT");
        }
        prevPresentRef.current = present;
      }
    }, [
      present,
      send
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c2(() => {
      if (node1) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = $921a889cee6df7e8$var$getAnimationName2(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node1 && isCurrentAnimation)
            (0, import_react_dom5.flushSync)(
              () => send("ANIMATION_END")
            );
        };
        const handleAnimationStart = (event) => {
          if (event.target === node1)
            prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName2(stylesRef.current);
        };
        node1.addEventListener("animationstart", handleAnimationStart);
        node1.addEventListener("animationcancel", handleAnimationEnd);
        node1.addEventListener("animationend", handleAnimationEnd);
        return () => {
          node1.removeEventListener("animationstart", handleAnimationStart);
          node1.removeEventListener("animationcancel", handleAnimationEnd);
          node1.removeEventListener("animationend", handleAnimationEnd);
        };
      } else
        send("ANIMATION_END");
    }, [
      node1,
      send
    ]);
    return {
      isPresent: [
        "mounted",
        "unmountSuspended"
      ].includes(state),
      ref: (0, import_react51.useCallback)((node) => {
        if (node)
          stylesRef.current = getComputedStyle(node);
        setNode(node);
      }, [])
    };
  }
  function $921a889cee6df7e8$var$getAnimationName2(styles) {
    return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
  }

  // node_modules/@radix-ui/react-collapsible/node_modules/@radix-ui/react-id/dist/index.mjs
  var $2AODx$react2 = __toESM(require_react(), 1);
  var $1746a345f3d73bb7$var$useReactId2 = $2AODx$react2["useId".toString()] || (() => void 0);
  var $1746a345f3d73bb7$var$count2 = 0;
  function $1746a345f3d73bb7$export$f680877a34711e372(deterministicId) {
    const [id, setId] = $2AODx$react2.useState($1746a345f3d73bb7$var$useReactId2());
    $9f79659886946c16$export$e5c5a5f917a5871c2(() => {
      if (!deterministicId)
        setId(
          (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count2++)
        );
    }, [
      deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : "");
  }

  // node_modules/@radix-ui/react-collapsible/dist/index.mjs
  var $409067139f391064$var$COLLAPSIBLE_NAME = "Collapsible";
  var [$409067139f391064$var$createCollapsibleContext, $409067139f391064$export$952b32dcbe73087a] = $c512c27ab02ef895$export$50c7b4e9d9f19c12($409067139f391064$var$COLLAPSIBLE_NAME);
  var [$409067139f391064$var$CollapsibleProvider, $409067139f391064$var$useCollapsibleContext] = $409067139f391064$var$createCollapsibleContext($409067139f391064$var$COLLAPSIBLE_NAME);
  var $409067139f391064$export$6eb0f7ddcda6131f = /* @__PURE__ */ (0, import_react52.forwardRef)((props, forwardedRef) => {
    const { __scopeCollapsible, open: openProp, defaultOpen, disabled, onOpenChange, ...collapsibleProps } = props;
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c32({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react52.createElement)($409067139f391064$var$CollapsibleProvider, {
      scope: __scopeCollapsible,
      disabled,
      contentId: $1746a345f3d73bb7$export$f680877a34711e372(),
      open,
      onOpenToggle: (0, import_react52.useCallback)(
        () => setOpen(
          (prevOpen) => !prevOpen
        ),
        [
          setOpen
        ]
      )
    }, /* @__PURE__ */ (0, import_react52.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0342.div, _extends({
      "data-state": $409067139f391064$var$getState(open),
      "data-disabled": disabled ? "" : void 0
    }, collapsibleProps, {
      ref: forwardedRef
    })));
  });
  var $409067139f391064$var$TRIGGER_NAME = "CollapsibleTrigger";
  var $409067139f391064$export$c135dce7b15bbbdc = /* @__PURE__ */ (0, import_react52.forwardRef)((props, forwardedRef) => {
    const { __scopeCollapsible, ...triggerProps } = props;
    const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$TRIGGER_NAME, __scopeCollapsible);
    return /* @__PURE__ */ (0, import_react52.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0342.button, _extends({
      type: "button",
      "aria-controls": context.contentId,
      "aria-expanded": context.open || false,
      "data-state": $409067139f391064$var$getState(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      disabled: context.disabled
    }, triggerProps, {
      ref: forwardedRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff102(props.onClick, context.onOpenToggle)
    }));
  });
  var $409067139f391064$var$CONTENT_NAME = "CollapsibleContent";
  var $409067139f391064$export$aadde00976f34151 = /* @__PURE__ */ (0, import_react52.forwardRef)((props, forwardedRef) => {
    const { forceMount, ...contentProps } = props;
    const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, props.__scopeCollapsible);
    return /* @__PURE__ */ (0, import_react52.createElement)(
      $921a889cee6df7e8$export$99c2b779aa4e8b8b2,
      {
        present: forceMount || context.open
      },
      ({ present }) => /* @__PURE__ */ (0, import_react52.createElement)($409067139f391064$var$CollapsibleContentImpl, _extends({}, contentProps, {
        ref: forwardedRef,
        present
      }))
    );
  });
  var $409067139f391064$var$CollapsibleContentImpl = /* @__PURE__ */ (0, import_react52.forwardRef)((props, forwardedRef) => {
    const { __scopeCollapsible, present, children, ...contentProps } = props;
    const context = $409067139f391064$var$useCollapsibleContext($409067139f391064$var$CONTENT_NAME, __scopeCollapsible);
    const [isPresent, setIsPresent] = (0, import_react52.useState)(present);
    const ref = (0, import_react52.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d052(forwardedRef, ref);
    const heightRef = (0, import_react52.useRef)(0);
    const height = heightRef.current;
    const widthRef = (0, import_react52.useRef)(0);
    const width = widthRef.current;
    const isOpen = context.open || isPresent;
    const isMountAnimationPreventedRef = (0, import_react52.useRef)(isOpen);
    const originalStylesRef = (0, import_react52.useRef)();
    (0, import_react52.useEffect)(() => {
      const rAF = requestAnimationFrame(
        () => isMountAnimationPreventedRef.current = false
      );
      return () => cancelAnimationFrame(rAF);
    }, []);
    $9f79659886946c16$export$e5c5a5f917a5871c2(() => {
      const node = ref.current;
      if (node) {
        originalStylesRef.current = originalStylesRef.current || {
          transitionDuration: node.style.transitionDuration,
          animationName: node.style.animationName
        };
        node.style.transitionDuration = "0s";
        node.style.animationName = "none";
        const rect = node.getBoundingClientRect();
        heightRef.current = rect.height;
        widthRef.current = rect.width;
        if (!isMountAnimationPreventedRef.current) {
          node.style.transitionDuration = originalStylesRef.current.transitionDuration;
          node.style.animationName = originalStylesRef.current.animationName;
        }
        setIsPresent(present);
      }
    }, [
      context.open,
      present
    ]);
    return /* @__PURE__ */ (0, import_react52.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0342.div, _extends({
      "data-state": $409067139f391064$var$getState(context.open),
      "data-disabled": context.disabled ? "" : void 0,
      id: context.contentId,
      hidden: !isOpen
    }, contentProps, {
      ref: composedRefs,
      style: {
        [`--radix-collapsible-content-height`]: height ? `${height}px` : void 0,
        [`--radix-collapsible-content-width`]: width ? `${width}px` : void 0,
        ...props.style
      }
    }), isOpen && children);
  });
  function $409067139f391064$var$getState(open) {
    return open ? "open" : "closed";
  }
  var $409067139f391064$export$be92b6f5f03c0fe9 = $409067139f391064$export$6eb0f7ddcda6131f;
  var $409067139f391064$export$41fb9f06171c75f4 = $409067139f391064$export$c135dce7b15bbbdc;
  var $409067139f391064$export$7c6e2c02157bb7d2 = $409067139f391064$export$aadde00976f34151;

  // node_modules/react-error-boundary/dist/react-error-boundary.cjs.mjs
  var import_react_error_boundary_cjs = __toESM(require_react_error_boundary_cjs(), 1);

  // node_modules/@radix-ui/react-tabs/dist/index.mjs
  var import_react74 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/primitive/dist/index.mjs
  function $e42e1063c40fb3ef$export$b9ecd428b558ff103(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react53 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c13(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react53.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react53.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react53.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react53.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react53.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react53.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes3(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes3(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react53.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-roving-focus/dist/index.mjs
  var import_react66 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/primitive/dist/index.mjs
  function $e42e1063c40fb3ef$export$b9ecd428b558ff104(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-collection/dist/index.mjs
  var import_react57 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react54 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c14(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react54.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react54.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react54.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react54.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react54.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react54.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes4(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes4(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react54.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react55 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef3(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af3(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef3(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d053(...refs) {
    return (0, import_react55.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af3(...refs), refs);
  }

  // node_modules/@radix-ui/react-collection/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react56 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac13603 = /* @__PURE__ */ (0, import_react56.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react56.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable3);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react56.Children.count(newElement) > 1)
            return import_react56.Children.only(null);
          return /* @__PURE__ */ (0, import_react56.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react56.createElement)($5e63c961fc1ce211$var$SlotClone3, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react56.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react56.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react56.createElement)($5e63c961fc1ce211$var$SlotClone3, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13603.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone3 = /* @__PURE__ */ (0, import_react56.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react56.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react56.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps3(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af3(forwardedRef, children.ref) : children.ref
      });
    return import_react56.Children.count(children) > 1 ? import_react56.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone3.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d453 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react56.createElement)(import_react56.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable3(child) {
    return /* @__PURE__ */ (0, import_react56.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d453;
  }
  function $5e63c961fc1ce211$var$mergeProps3(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-collection/dist/index.mjs
  function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
    const PROVIDER_NAME = name + "CollectionProvider";
    const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c14(PROVIDER_NAME);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
      collectionRef: {
        current: null
      },
      itemMap: /* @__PURE__ */ new Map()
    });
    const CollectionProvider = (props) => {
      const { scope: scope2, children } = props;
      const ref = import_react57.default.useRef(null);
      const itemMap = import_react57.default.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ import_react57.default.createElement(CollectionProviderImpl, {
        scope: scope2,
        itemMap,
        collectionRef: ref
      }, children);
    };
    /* @__PURE__ */ Object.assign(CollectionProvider, {
      displayName: PROVIDER_NAME
    });
    const COLLECTION_SLOT_NAME = name + "CollectionSlot";
    const CollectionSlot = /* @__PURE__ */ import_react57.default.forwardRef((props, forwardedRef) => {
      const { scope: scope2, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope2);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d053(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ import_react57.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac13603, {
        ref: composedRefs
      }, children);
    });
    /* @__PURE__ */ Object.assign(CollectionSlot, {
      displayName: COLLECTION_SLOT_NAME
    });
    const ITEM_SLOT_NAME = name + "CollectionItemSlot";
    const ITEM_DATA_ATTR = "data-radix-collection-item";
    const CollectionItemSlot = /* @__PURE__ */ import_react57.default.forwardRef((props, forwardedRef) => {
      const { scope: scope2, children, ...itemData } = props;
      const ref = import_react57.default.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d053(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope2);
      import_react57.default.useEffect(() => {
        context.itemMap.set(ref, {
          ref,
          ...itemData
        });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ import_react57.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac13603, {
        [ITEM_DATA_ATTR]: "",
        ref: composedRefs
      }, children);
    });
    /* @__PURE__ */ Object.assign(CollectionItemSlot, {
      displayName: ITEM_SLOT_NAME
    });
    function useCollection(scope2) {
      const context = useCollectionContext(name + "CollectionConsumer", scope2);
      const getItems = import_react57.default.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode)
          return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort(
          (a2, b3) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b3.ref.current)
        );
        return orderedItems;
      }, [
        context.collectionRef,
        context.itemMap
      ]);
      return getItems;
    }
    return [
      {
        Provider: CollectionProvider,
        Slot: CollectionSlot,
        ItemSlot: CollectionItemSlot
      },
      useCollection,
      createCollectionScope
    ];
  }

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react58 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef4(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af4(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef4(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d054(...refs) {
    return (0, import_react58.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af4(...refs), refs);
  }

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react59 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c15(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react59.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react59.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react59.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react59.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react59.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react59.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes5(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes5(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react59.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-id/dist/index.mjs
  var $2AODx$react3 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var import_react60 = __toESM(require_react(), 1);
  var $9f79659886946c16$export$e5c5a5f917a5871c3 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react60.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-id/dist/index.mjs
  var $1746a345f3d73bb7$var$useReactId3 = $2AODx$react3["useId".toString()] || (() => void 0);
  var $1746a345f3d73bb7$var$count3 = 0;
  function $1746a345f3d73bb7$export$f680877a34711e373(deterministicId) {
    const [id, setId] = $2AODx$react3.useState($1746a345f3d73bb7$var$useReactId3());
    $9f79659886946c16$export$e5c5a5f917a5871c3(() => {
      if (!deterministicId)
        setId(
          (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count3++)
        );
    }, [
      deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : "");
  }

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react62 = __toESM(require_react(), 1);
  var import_react_dom6 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react61 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac13604 = /* @__PURE__ */ (0, import_react61.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react61.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable4);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react61.Children.count(newElement) > 1)
            return import_react61.Children.only(null);
          return /* @__PURE__ */ (0, import_react61.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react61.createElement)($5e63c961fc1ce211$var$SlotClone4, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react61.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react61.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react61.createElement)($5e63c961fc1ce211$var$SlotClone4, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13604.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone4 = /* @__PURE__ */ (0, import_react61.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react61.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react61.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps4(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af4(forwardedRef, children.ref) : children.ref
      });
    return import_react61.Children.count(children) > 1 ? import_react61.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone4.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d454 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react61.createElement)(import_react61.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable4(child) {
    return /* @__PURE__ */ (0, import_react61.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d454;
  }
  function $5e63c961fc1ce211$var$mergeProps4(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES3 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0343 = $8927f6f2acc4f386$var$NODES3.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react62.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac13604 : node;
      (0, import_react62.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react62.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react63 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a3(callback) {
    const callbackRef = (0, import_react63.useRef)(callback);
    (0, import_react63.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react63.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-roving-focus/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var import_react64 = __toESM(require_react(), 1);
  function $71cd76cc60e0454e$export$6f32135080cb4c33({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState3({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a3(onChange);
    const setValue = (0, import_react64.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState3({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react64.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react64.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a3(onChange);
    (0, import_react64.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-direction/dist/index.mjs
  var import_react65 = __toESM(require_react(), 1);
  var $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react65.createContext)(void 0);
  function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
    const globalDir = (0, import_react65.useContext)($f631663db3294ace$var$DirectionContext);
    return localDir || globalDir || "ltr";
  }

  // node_modules/@radix-ui/react-roving-focus/dist/index.mjs
  var $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
  var $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
  };
  var $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
  var [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
  var [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c15($d7bdfb9eb0fdf311$var$GROUP_NAME, [
    $d7bdfb9eb0fdf311$var$createCollectionScope
  ]);
  var [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
  var $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    return /* @__PURE__ */ (0, import_react66.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {
      scope: props.__scopeRovingFocusGroup
    }, /* @__PURE__ */ (0, import_react66.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {
      scope: props.__scopeRovingFocusGroup
    }, /* @__PURE__ */ (0, import_react66.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
      ref: forwardedRef
    }))));
  });
  var $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
    const ref = (0, import_react66.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d054(forwardedRef, ref);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c33({
      prop: currentTabStopIdProp,
      defaultProp: defaultCurrentTabStopId,
      onChange: onCurrentTabStopIdChange
    });
    const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react66.useState)(false);
    const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a3(onEntryFocus);
    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
    const isClickFocusRef = (0, import_react66.useRef)(false);
    const [focusableItemsCount, setFocusableItemsCount] = (0, import_react66.useState)(0);
    (0, import_react66.useEffect)(() => {
      const node = ref.current;
      if (node) {
        node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
        return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      }
    }, [
      handleEntryFocus
    ]);
    return /* @__PURE__ */ (0, import_react66.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: (0, import_react66.useCallback)(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [
          setCurrentTabStopId
        ]
      ),
      onItemShiftTab: (0, import_react66.useCallback)(
        () => setIsTabbingBackOut(true),
        []
      ),
      onFocusableItemAdd: (0, import_react66.useCallback)(
        () => setFocusableItemsCount(
          (prevCount) => prevCount + 1
        ),
        []
      ),
      onFocusableItemRemove: (0, import_react66.useCallback)(
        () => setFocusableItemsCount(
          (prevCount) => prevCount - 1
        ),
        []
      )
    }, /* @__PURE__ */ (0, import_react66.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0343.div, _extends({
      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
      "data-orientation": orientation
    }, groupProps, {
      ref: composedRefs,
      style: {
        outline: "none",
        ...props.style
      },
      onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff104(props.onMouseDown, () => {
        isClickFocusRef.current = true;
      }),
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff104(props.onFocus, (event) => {
        const isKeyboardFocus = !isClickFocusRef.current;
        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
          const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
          event.currentTarget.dispatchEvent(entryFocusEvent);
          if (!entryFocusEvent.defaultPrevented) {
            const items = getItems().filter(
              (item) => item.focusable
            );
            const activeItem = items.find(
              (item) => item.active
            );
            const currentItem = items.find(
              (item) => item.id === currentTabStopId
            );
            const candidateItems = [
              activeItem,
              currentItem,
              ...items
            ].filter(Boolean);
            const candidateNodes = candidateItems.map(
              (item) => item.ref.current
            );
            $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
          }
        }
        isClickFocusRef.current = false;
      }),
      onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff104(
        props.onBlur,
        () => setIsTabbingBackOut(false)
      )
    })));
  });
  var $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
  var $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
    const autoId = $1746a345f3d73bb7$export$f680877a34711e373();
    const id = tabStopId || autoId;
    const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    (0, import_react66.useEffect)(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [
      focusable,
      onFocusableItemAdd,
      onFocusableItemRemove
    ]);
    return /* @__PURE__ */ (0, import_react66.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
      scope: __scopeRovingFocusGroup,
      id,
      focusable,
      active
    }, /* @__PURE__ */ (0, import_react66.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0343.span, _extends({
      tabIndex: isCurrentTabStop ? 0 : -1,
      "data-orientation": context.orientation
    }, itemProps, {
      ref: forwardedRef,
      onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff104(props.onMouseDown, (event) => {
        if (!focusable)
          event.preventDefault();
        else
          context.onItemFocus(id);
      }),
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff104(
        props.onFocus,
        () => context.onItemFocus(id)
      ),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff104(props.onKeyDown, (event) => {
        if (event.key === "Tab" && event.shiftKey) {
          context.onItemShiftTab();
          return;
        }
        if (event.target !== event.currentTarget)
          return;
        const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
        if (focusIntent !== void 0) {
          event.preventDefault();
          const items = getItems().filter(
            (item) => item.focusable
          );
          let candidateNodes = items.map(
            (item) => item.ref.current
          );
          if (focusIntent === "last")
            candidateNodes.reverse();
          else if (focusIntent === "prev" || focusIntent === "next") {
            if (focusIntent === "prev")
              candidateNodes.reverse();
            const currentIndex = candidateNodes.indexOf(event.currentTarget);
            candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
          }
          setTimeout(
            () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
          );
        }
      })
    })));
  });
  var $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
    if (dir !== "rtl")
      return key;
    return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
  }
  function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
    const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
    if (orientation === "vertical" && [
      "ArrowLeft",
      "ArrowRight"
    ].includes(key))
      return void 0;
    if (orientation === "horizontal" && [
      "ArrowUp",
      "ArrowDown"
    ].includes(key))
      return void 0;
    return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
  }
  function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
        return;
      candidate.focus();
      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
        return;
    }
  }
  function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
    return array.map(
      (_, index2) => array[(startIndex + index2) % array.length]
    );
  }
  var $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
  var $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-presence/dist/index.mjs
  var import_react69 = __toESM(require_react(), 1);
  var import_react_dom7 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react67 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef5(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af5(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef5(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d055(...refs) {
    return (0, import_react67.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af5(...refs), refs);
  }

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var import_react68 = __toESM(require_react(), 1);
  var $9f79659886946c16$export$e5c5a5f917a5871c4 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react68.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-presence/dist/index.mjs
  function $fe963b355347cc68$export$3e6543de14f8614f3(initialState3, machine) {
    return (0, import_react69.useReducer)((state, event) => {
      const nextState = machine[state][event];
      return nextState !== null && nextState !== void 0 ? nextState : state;
    }, initialState3);
  }
  var $921a889cee6df7e8$export$99c2b779aa4e8b8b3 = (props) => {
    const { present, children } = props;
    const presence = $921a889cee6df7e8$var$usePresence3(present);
    const child = typeof children === "function" ? children({
      present: presence.isPresent
    }) : import_react69.Children.only(children);
    const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d055(presence.ref, child.ref);
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react69.cloneElement)(child, {
      ref
    }) : null;
  };
  $921a889cee6df7e8$export$99c2b779aa4e8b8b3.displayName = "Presence";
  function $921a889cee6df7e8$var$usePresence3(present) {
    const [node1, setNode] = (0, import_react69.useState)();
    const stylesRef = (0, import_react69.useRef)({});
    const prevPresentRef = (0, import_react69.useRef)(present);
    const prevAnimationNameRef = (0, import_react69.useRef)("none");
    const initialState3 = present ? "mounted" : "unmounted";
    const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f3(initialState3, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    (0, import_react69.useEffect)(() => {
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName3(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [
      state
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c4(() => {
      const styles = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName3(styles);
        if (present)
          send("MOUNT");
        else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
          send("UNMOUNT");
        else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating)
            send("ANIMATION_OUT");
          else
            send("UNMOUNT");
        }
        prevPresentRef.current = present;
      }
    }, [
      present,
      send
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c4(() => {
      if (node1) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = $921a889cee6df7e8$var$getAnimationName3(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node1 && isCurrentAnimation)
            (0, import_react_dom7.flushSync)(
              () => send("ANIMATION_END")
            );
        };
        const handleAnimationStart = (event) => {
          if (event.target === node1)
            prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName3(stylesRef.current);
        };
        node1.addEventListener("animationstart", handleAnimationStart);
        node1.addEventListener("animationcancel", handleAnimationEnd);
        node1.addEventListener("animationend", handleAnimationEnd);
        return () => {
          node1.removeEventListener("animationstart", handleAnimationStart);
          node1.removeEventListener("animationcancel", handleAnimationEnd);
          node1.removeEventListener("animationend", handleAnimationEnd);
        };
      } else
        send("ANIMATION_END");
    }, [
      node1,
      send
    ]);
    return {
      isPresent: [
        "mounted",
        "unmountSuspended"
      ].includes(state),
      ref: (0, import_react69.useCallback)((node) => {
        if (node)
          stylesRef.current = getComputedStyle(node);
        setNode(node);
      }, [])
    };
  }
  function $921a889cee6df7e8$var$getAnimationName3(styles) {
    return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
  }

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react71 = __toESM(require_react(), 1);
  var import_react_dom8 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react70 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac13605 = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react70.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable5);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react70.Children.count(newElement) > 1)
            return import_react70.Children.only(null);
          return /* @__PURE__ */ (0, import_react70.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react70.createElement)($5e63c961fc1ce211$var$SlotClone5, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react70.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react70.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react70.createElement)($5e63c961fc1ce211$var$SlotClone5, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13605.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone5 = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react70.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react70.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps5(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af5(forwardedRef, children.ref) : children.ref
      });
    return import_react70.Children.count(children) > 1 ? import_react70.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone5.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d455 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react70.createElement)(import_react70.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable5(child) {
    return /* @__PURE__ */ (0, import_react70.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d455;
  }
  function $5e63c961fc1ce211$var$mergeProps5(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES4 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0344 = $8927f6f2acc4f386$var$NODES4.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react71.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac13605 : node;
      (0, import_react71.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react71.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var import_react73 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react72 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a4(callback) {
    const callbackRef = (0, import_react72.useRef)(callback);
    (0, import_react72.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react72.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  function $71cd76cc60e0454e$export$6f32135080cb4c34({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState4({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a4(onChange);
    const setValue = (0, import_react73.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState4({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react73.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react73.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a4(onChange);
    (0, import_react73.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-tabs/node_modules/@radix-ui/react-id/dist/index.mjs
  var $2AODx$react4 = __toESM(require_react(), 1);
  var $1746a345f3d73bb7$var$useReactId4 = $2AODx$react4["useId".toString()] || (() => void 0);
  var $1746a345f3d73bb7$var$count4 = 0;
  function $1746a345f3d73bb7$export$f680877a34711e374(deterministicId) {
    const [id, setId] = $2AODx$react4.useState($1746a345f3d73bb7$var$useReactId4());
    $9f79659886946c16$export$e5c5a5f917a5871c4(() => {
      if (!deterministicId)
        setId(
          (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count4++)
        );
    }, [
      deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : "");
  }

  // node_modules/@radix-ui/react-tabs/dist/index.mjs
  var $69cb30bb0017df05$var$TABS_NAME = "Tabs";
  var [$69cb30bb0017df05$var$createTabsContext, $69cb30bb0017df05$export$355f5bd209d7b13a] = $c512c27ab02ef895$export$50c7b4e9d9f19c13($69cb30bb0017df05$var$TABS_NAME, [
    $d7bdfb9eb0fdf311$export$c7109489551a4f4
  ]);
  var $69cb30bb0017df05$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
  var [$69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext] = $69cb30bb0017df05$var$createTabsContext($69cb30bb0017df05$var$TABS_NAME);
  var $69cb30bb0017df05$export$b2539bed5023c21c = /* @__PURE__ */ (0, import_react74.forwardRef)((props, forwardedRef) => {
    const { __scopeTabs, value: valueProp, onValueChange, defaultValue, orientation = "horizontal", dir, activationMode = "automatic", ...tabsProps } = props;
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c34({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue
    });
    return /* @__PURE__ */ (0, import_react74.createElement)($69cb30bb0017df05$var$TabsProvider, {
      scope: __scopeTabs,
      baseId: $1746a345f3d73bb7$export$f680877a34711e374(),
      value,
      onValueChange: setValue,
      orientation,
      dir: direction,
      activationMode
    }, /* @__PURE__ */ (0, import_react74.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0344.div, _extends({
      dir: direction,
      "data-orientation": orientation
    }, tabsProps, {
      ref: forwardedRef
    })));
  });
  var $69cb30bb0017df05$var$TAB_LIST_NAME = "TabsList";
  var $69cb30bb0017df05$export$9712d22edc0d78c1 = /* @__PURE__ */ (0, import_react74.forwardRef)((props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ (0, import_react74.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
      asChild: true
    }, rovingFocusGroupScope, {
      orientation: context.orientation,
      dir: context.dir,
      loop
    }), /* @__PURE__ */ (0, import_react74.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0344.div, _extends({
      role: "tablist",
      "aria-orientation": context.orientation
    }, listProps, {
      ref: forwardedRef
    })));
  });
  var $69cb30bb0017df05$var$TRIGGER_NAME = "TabsTrigger";
  var $69cb30bb0017df05$export$8114b9fdfdf9f3ba = /* @__PURE__ */ (0, import_react74.forwardRef)((props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TRIGGER_NAME, __scopeTabs);
    const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
    const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
    const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ (0, import_react74.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
      asChild: true
    }, rovingFocusGroupScope, {
      focusable: !disabled,
      active: isSelected
    }), /* @__PURE__ */ (0, import_react74.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0344.button, _extends({
      type: "button",
      role: "tab",
      "aria-selected": isSelected,
      "aria-controls": contentId,
      "data-state": isSelected ? "active" : "inactive",
      "data-disabled": disabled ? "" : void 0,
      disabled,
      id: triggerId
    }, triggerProps, {
      ref: forwardedRef,
      onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff103(props.onMouseDown, (event) => {
        if (!disabled && event.button === 0 && event.ctrlKey === false)
          context.onValueChange(value);
        else
          event.preventDefault();
      }),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff103(props.onKeyDown, (event) => {
        if ([
          " ",
          "Enter"
        ].includes(event.key))
          context.onValueChange(value);
      }),
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff103(props.onFocus, () => {
        const isAutomaticActivation = context.activationMode !== "manual";
        if (!isSelected && !disabled && isAutomaticActivation)
          context.onValueChange(value);
      })
    })));
  });
  var $69cb30bb0017df05$var$CONTENT_NAME = "TabsContent";
  var $69cb30bb0017df05$export$bd905d70e8fd2ebb = /* @__PURE__ */ (0, import_react74.forwardRef)((props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$CONTENT_NAME, __scopeTabs);
    const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
    const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = (0, import_react74.useRef)(isSelected);
    (0, import_react74.useEffect)(() => {
      const rAF = requestAnimationFrame(
        () => isMountAnimationPreventedRef.current = false
      );
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ (0, import_react74.createElement)(
      $921a889cee6df7e8$export$99c2b779aa4e8b8b3,
      {
        present: forceMount || isSelected
      },
      ({ present }) => /* @__PURE__ */ (0, import_react74.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0344.div, _extends({
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0
      }, contentProps, {
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        }
      }), present && children)
    );
  });
  function $69cb30bb0017df05$var$makeTriggerId(baseId, value) {
    return `${baseId}-trigger-${value}`;
  }
  function $69cb30bb0017df05$var$makeContentId(baseId, value) {
    return `${baseId}-content-${value}`;
  }
  var $69cb30bb0017df05$export$be92b6f5f03c0fe9 = $69cb30bb0017df05$export$b2539bed5023c21c;
  var $69cb30bb0017df05$export$54c2e3dc7acea9f5 = $69cb30bb0017df05$export$9712d22edc0d78c1;
  var $69cb30bb0017df05$export$41fb9f06171c75f4 = $69cb30bb0017df05$export$8114b9fdfdf9f3ba;
  var $69cb30bb0017df05$export$7c6e2c02157bb7d2 = $69cb30bb0017df05$export$bd905d70e8fd2ebb;

  // node_modules/@samvera/clover-iiif/dist/viewer/index.mjs
  var import_sanitize_html = __toESM(require_sanitize_html(), 1);

  // node_modules/hls.js/dist/hls.mjs
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var urlToolkit = { exports: {} };
  (function(module2, exports2) {
    (function(root2) {
      var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
      var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
      var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
      var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
      var URLToolkit = {
        buildAbsoluteURL: function(baseURL, relativeURL, opts) {
          opts = opts || {};
          baseURL = baseURL.trim();
          relativeURL = relativeURL.trim();
          if (!relativeURL) {
            if (!opts.alwaysNormalize) {
              return baseURL;
            }
            var basePartsForNormalise = URLToolkit.parseURL(baseURL);
            if (!basePartsForNormalise) {
              throw new Error("Error trying to parse base URL.");
            }
            basePartsForNormalise.path = URLToolkit.normalizePath(
              basePartsForNormalise.path
            );
            return URLToolkit.buildURLFromParts(basePartsForNormalise);
          }
          var relativeParts = URLToolkit.parseURL(relativeURL);
          if (!relativeParts) {
            throw new Error("Error trying to parse relative URL.");
          }
          if (relativeParts.scheme) {
            if (!opts.alwaysNormalize) {
              return relativeURL;
            }
            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
            return URLToolkit.buildURLFromParts(relativeParts);
          }
          var baseParts = URLToolkit.parseURL(baseURL);
          if (!baseParts) {
            throw new Error("Error trying to parse base URL.");
          }
          if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
            baseParts.netLoc = pathParts[1];
            baseParts.path = pathParts[2];
          }
          if (baseParts.netLoc && !baseParts.path) {
            baseParts.path = "/";
          }
          var builtParts = {
            scheme: baseParts.scheme,
            netLoc: relativeParts.netLoc,
            path: null,
            params: relativeParts.params,
            query: relativeParts.query,
            fragment: relativeParts.fragment
          };
          if (!relativeParts.netLoc) {
            builtParts.netLoc = baseParts.netLoc;
            if (relativeParts.path[0] !== "/") {
              if (!relativeParts.path) {
                builtParts.path = baseParts.path;
                if (!relativeParts.params) {
                  builtParts.params = baseParts.params;
                  if (!relativeParts.query) {
                    builtParts.query = baseParts.query;
                  }
                }
              } else {
                var baseURLPath = baseParts.path;
                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                builtParts.path = URLToolkit.normalizePath(newPath);
              }
            }
          }
          if (builtParts.path === null) {
            builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
          }
          return URLToolkit.buildURLFromParts(builtParts);
        },
        parseURL: function(url) {
          var parts = URL_REGEX.exec(url);
          if (!parts) {
            return null;
          }
          return {
            scheme: parts[1] || "",
            netLoc: parts[2] || "",
            path: parts[3] || "",
            params: parts[4] || "",
            query: parts[5] || "",
            fragment: parts[6] || ""
          };
        },
        normalizePath: function(path) {
          path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
          while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
          }
          return path.split("").reverse().join("");
        },
        buildURLFromParts: function(parts) {
          return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
        }
      };
      module2.exports = URLToolkit;
    })();
  })(urlToolkit);
  var urlToolkitExports = urlToolkit.exports;
  function ownKeys2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread22(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = null != arguments[i2] ? arguments[i2] : {};
      i2 % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty6(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty6(obj, key, value) {
    key = _toPropertyKey2(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _extends2() {
    _extends2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        var source = arguments[i2];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _toPrimitive2(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey2(arg) {
    var key = _toPrimitive2(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  var isFiniteNumber = Number.isFinite || function(value) {
    return typeof value === "number" && isFinite(value);
  };
  var Events = /* @__PURE__ */ function(Events2) {
    Events2["MEDIA_ATTACHING"] = "hlsMediaAttaching";
    Events2["MEDIA_ATTACHED"] = "hlsMediaAttached";
    Events2["MEDIA_DETACHING"] = "hlsMediaDetaching";
    Events2["MEDIA_DETACHED"] = "hlsMediaDetached";
    Events2["BUFFER_RESET"] = "hlsBufferReset";
    Events2["BUFFER_CODECS"] = "hlsBufferCodecs";
    Events2["BUFFER_CREATED"] = "hlsBufferCreated";
    Events2["BUFFER_APPENDING"] = "hlsBufferAppending";
    Events2["BUFFER_APPENDED"] = "hlsBufferAppended";
    Events2["BUFFER_EOS"] = "hlsBufferEos";
    Events2["BUFFER_FLUSHING"] = "hlsBufferFlushing";
    Events2["BUFFER_FLUSHED"] = "hlsBufferFlushed";
    Events2["MANIFEST_LOADING"] = "hlsManifestLoading";
    Events2["MANIFEST_LOADED"] = "hlsManifestLoaded";
    Events2["MANIFEST_PARSED"] = "hlsManifestParsed";
    Events2["LEVEL_SWITCHING"] = "hlsLevelSwitching";
    Events2["LEVEL_SWITCHED"] = "hlsLevelSwitched";
    Events2["LEVEL_LOADING"] = "hlsLevelLoading";
    Events2["LEVEL_LOADED"] = "hlsLevelLoaded";
    Events2["LEVEL_UPDATED"] = "hlsLevelUpdated";
    Events2["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
    Events2["LEVELS_UPDATED"] = "hlsLevelsUpdated";
    Events2["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
    Events2["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
    Events2["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
    Events2["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
    Events2["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
    Events2["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
    Events2["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
    Events2["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
    Events2["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
    Events2["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
    Events2["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
    Events2["CUES_PARSED"] = "hlsCuesParsed";
    Events2["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
    Events2["INIT_PTS_FOUND"] = "hlsInitPtsFound";
    Events2["FRAG_LOADING"] = "hlsFragLoading";
    Events2["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
    Events2["FRAG_LOADED"] = "hlsFragLoaded";
    Events2["FRAG_DECRYPTED"] = "hlsFragDecrypted";
    Events2["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
    Events2["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
    Events2["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
    Events2["FRAG_PARSED"] = "hlsFragParsed";
    Events2["FRAG_BUFFERED"] = "hlsFragBuffered";
    Events2["FRAG_CHANGED"] = "hlsFragChanged";
    Events2["FPS_DROP"] = "hlsFpsDrop";
    Events2["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
    Events2["ERROR"] = "hlsError";
    Events2["DESTROYING"] = "hlsDestroying";
    Events2["KEY_LOADING"] = "hlsKeyLoading";
    Events2["KEY_LOADED"] = "hlsKeyLoaded";
    Events2["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
    Events2["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
    return Events2;
  }({});
  var ErrorTypes = /* @__PURE__ */ function(ErrorTypes2) {
    ErrorTypes2["NETWORK_ERROR"] = "networkError";
    ErrorTypes2["MEDIA_ERROR"] = "mediaError";
    ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
    ErrorTypes2["MUX_ERROR"] = "muxError";
    ErrorTypes2["OTHER_ERROR"] = "otherError";
    return ErrorTypes2;
  }({});
  var ErrorDetails = /* @__PURE__ */ function(ErrorDetails2) {
    ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
    ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
    ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
    ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
    ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
    ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
    ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
    ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
    ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
    ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
    ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
    ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
    ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
    ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
    ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
    ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
    ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
    ErrorDetails2["LEVEL_PARSING_ERROR"] = "levelParsingError";
    ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
    ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
    ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
    ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
    ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
    ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
    ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
    ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
    ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
    ErrorDetails2["FRAG_GAP"] = "fragGap";
    ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
    ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
    ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
    ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
    ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
    ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
    ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
    ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
    ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
    ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
    ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
    ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
    ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
    ErrorDetails2["UNKNOWN"] = "unknown";
    return ErrorDetails2;
  }({});
  var noop = function noop2() {
  };
  var fakeLogger = {
    trace: noop,
    debug: noop,
    log: noop,
    warn: noop,
    info: noop,
    error: noop
  };
  var exportedLogger = fakeLogger;
  function consolePrintFn(type) {
    const func = self.console[type];
    if (func) {
      return func.bind(self.console, `[${type}] >`);
    }
    return noop;
  }
  function exportLoggerFunctions(debugConfig, ...functions) {
    functions.forEach(function(type) {
      exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
    });
  }
  function enableLogs(debugConfig, id) {
    if (self.console && debugConfig === true || typeof debugConfig === "object") {
      exportLoggerFunctions(
        debugConfig,
        "debug",
        "log",
        "info",
        "warn",
        "error"
      );
      try {
        exportedLogger.log(`Debug logs enabled for "${id}" in hls.js version ${"1.4.12"}`);
      } catch (e3) {
        exportedLogger = fakeLogger;
      }
    } else {
      exportedLogger = fakeLogger;
    }
  }
  var logger = exportedLogger;
  var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
  var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;
  var AttrList = class {
    constructor(attrs) {
      if (typeof attrs === "string") {
        attrs = AttrList.parseAttrList(attrs);
      }
      for (const attr in attrs) {
        if (attrs.hasOwnProperty(attr)) {
          if (attr.substring(0, 2) === "X-") {
            this.clientAttrs = this.clientAttrs || [];
            this.clientAttrs.push(attr);
          }
          this[attr] = attrs[attr];
        }
      }
    }
    decimalInteger(attrName) {
      const intValue = parseInt(this[attrName], 10);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
    hexadecimalInteger(attrName) {
      if (this[attrName]) {
        let stringValue = (this[attrName] || "0x").slice(2);
        stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
        const value = new Uint8Array(stringValue.length / 2);
        for (let i2 = 0; i2 < stringValue.length / 2; i2++) {
          value[i2] = parseInt(stringValue.slice(i2 * 2, i2 * 2 + 2), 16);
        }
        return value;
      } else {
        return null;
      }
    }
    hexadecimalIntegerAsNumber(attrName) {
      const intValue = parseInt(this[attrName], 16);
      if (intValue > Number.MAX_SAFE_INTEGER) {
        return Infinity;
      }
      return intValue;
    }
    decimalFloatingPoint(attrName) {
      return parseFloat(this[attrName]);
    }
    optionalFloat(attrName, defaultValue) {
      const value = this[attrName];
      return value ? parseFloat(value) : defaultValue;
    }
    enumeratedString(attrName) {
      return this[attrName];
    }
    bool(attrName) {
      return this[attrName] === "YES";
    }
    decimalResolution(attrName) {
      const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
      if (res === null) {
        return void 0;
      }
      return {
        width: parseInt(res[1], 10),
        height: parseInt(res[2], 10)
      };
    }
    static parseAttrList(input) {
      let match;
      const attrs = {};
      const quote = '"';
      ATTR_LIST_REGEX.lastIndex = 0;
      while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
        let value = match[2];
        if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
          value = value.slice(1, -1);
        }
        const name = match[1].trim();
        attrs[name] = value;
      }
      return attrs;
    }
  };
  function isDateRangeCueAttribute(attrName) {
    return attrName !== "ID" && attrName !== "CLASS" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
  }
  function isSCTE35Attribute(attrName) {
    return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN";
  }
  var DateRange = class {
    constructor(dateRangeAttr, dateRangeWithSameId) {
      this.attr = void 0;
      this._startDate = void 0;
      this._endDate = void 0;
      this._badValueForSameId = void 0;
      if (dateRangeWithSameId) {
        const previousAttr = dateRangeWithSameId.attr;
        for (const key in previousAttr) {
          if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
            logger.warn(`DATERANGE tag attribute: "${key}" does not match for tags with ID: "${dateRangeAttr.ID}"`);
            this._badValueForSameId = key;
            break;
          }
        }
        dateRangeAttr = _extends2(new AttrList({}), previousAttr, dateRangeAttr);
      }
      this.attr = dateRangeAttr;
      this._startDate = new Date(dateRangeAttr["START-DATE"]);
      if ("END-DATE" in this.attr) {
        const endDate = new Date(this.attr["END-DATE"]);
        if (isFiniteNumber(endDate.getTime())) {
          this._endDate = endDate;
        }
      }
    }
    get id() {
      return this.attr.ID;
    }
    get class() {
      return this.attr.CLASS;
    }
    get startDate() {
      return this._startDate;
    }
    get endDate() {
      if (this._endDate) {
        return this._endDate;
      }
      const duration = this.duration;
      if (duration !== null) {
        return new Date(this._startDate.getTime() + duration * 1e3);
      }
      return null;
    }
    get duration() {
      if ("DURATION" in this.attr) {
        const duration = this.attr.decimalFloatingPoint("DURATION");
        if (isFiniteNumber(duration)) {
          return duration;
        }
      } else if (this._endDate) {
        return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;
      }
      return null;
    }
    get plannedDuration() {
      if ("PLANNED-DURATION" in this.attr) {
        return this.attr.decimalFloatingPoint("PLANNED-DURATION");
      }
      return null;
    }
    get endOnNext() {
      return this.attr.bool("END-ON-NEXT");
    }
    get isValid() {
      return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
    }
  };
  var LoadStats = class {
    constructor() {
      this.aborted = false;
      this.loaded = 0;
      this.retry = 0;
      this.total = 0;
      this.chunkCount = 0;
      this.bwEstimate = 0;
      this.loading = {
        start: 0,
        first: 0,
        end: 0
      };
      this.parsing = {
        start: 0,
        end: 0
      };
      this.buffering = {
        start: 0,
        first: 0,
        end: 0
      };
    }
  };
  var ElementaryStreamTypes = {
    AUDIO: "audio",
    VIDEO: "video",
    AUDIOVIDEO: "audiovideo"
  };
  var BaseSegment = class {
    constructor(baseurl) {
      this._byteRange = null;
      this._url = null;
      this.baseurl = void 0;
      this.relurl = void 0;
      this.elementaryStreams = {
        [ElementaryStreamTypes.AUDIO]: null,
        [ElementaryStreamTypes.VIDEO]: null,
        [ElementaryStreamTypes.AUDIOVIDEO]: null
      };
      this.baseurl = baseurl;
    }
    setByteRange(value, previous) {
      const params = value.split("@", 2);
      const byteRange = [];
      if (params.length === 1) {
        byteRange[0] = previous ? previous.byteRangeEndOffset : 0;
      } else {
        byteRange[0] = parseInt(params[1]);
      }
      byteRange[1] = parseInt(params[0]) + byteRange[0];
      this._byteRange = byteRange;
    }
    get byteRange() {
      if (!this._byteRange) {
        return [];
      }
      return this._byteRange;
    }
    get byteRangeStartOffset() {
      return this.byteRange[0];
    }
    get byteRangeEndOffset() {
      return this.byteRange[1];
    }
    get url() {
      if (!this._url && this.baseurl && this.relurl) {
        this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
          alwaysNormalize: true
        });
      }
      return this._url || "";
    }
    set url(value) {
      this._url = value;
    }
  };
  var Fragment3 = class extends BaseSegment {
    constructor(type, baseurl) {
      super(baseurl);
      this._decryptdata = null;
      this.rawProgramDateTime = null;
      this.programDateTime = null;
      this.tagList = [];
      this.duration = 0;
      this.sn = 0;
      this.levelkeys = void 0;
      this.type = void 0;
      this.loader = null;
      this.keyLoader = null;
      this.level = -1;
      this.cc = 0;
      this.startPTS = void 0;
      this.endPTS = void 0;
      this.startDTS = void 0;
      this.endDTS = void 0;
      this.start = 0;
      this.deltaPTS = void 0;
      this.maxStartPTS = void 0;
      this.minEndPTS = void 0;
      this.stats = new LoadStats();
      this.urlId = 0;
      this.data = void 0;
      this.bitrateTest = false;
      this.title = null;
      this.initSegment = null;
      this.endList = void 0;
      this.gap = void 0;
      this.type = type;
    }
    get decryptdata() {
      const {
        levelkeys
      } = this;
      if (!levelkeys && !this._decryptdata) {
        return null;
      }
      if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
        const key = this.levelkeys.identity;
        if (key) {
          this._decryptdata = key.getDecryptData(this.sn);
        } else {
          const keyFormats = Object.keys(this.levelkeys);
          if (keyFormats.length === 1) {
            return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
          }
        }
      }
      return this._decryptdata;
    }
    get end() {
      return this.start + this.duration;
    }
    get endProgramDateTime() {
      if (this.programDateTime === null) {
        return null;
      }
      if (!isFiniteNumber(this.programDateTime)) {
        return null;
      }
      const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
      return this.programDateTime + duration * 1e3;
    }
    get encrypted() {
      var _this$_decryptdata;
      if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
        return true;
      } else if (this.levelkeys) {
        const keyFormats = Object.keys(this.levelkeys);
        const len = keyFormats.length;
        if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
          return true;
        }
      }
      return false;
    }
    setKeyFormat(keyFormat) {
      if (this.levelkeys) {
        const key = this.levelkeys[keyFormat];
        if (key && !this._decryptdata) {
          this._decryptdata = key.getDecryptData(this.sn);
        }
      }
    }
    abortRequests() {
      var _this$loader, _this$keyLoader;
      (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();
      (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();
    }
    setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {
      const {
        elementaryStreams
      } = this;
      const info = elementaryStreams[type];
      if (!info) {
        elementaryStreams[type] = {
          startPTS,
          endPTS,
          startDTS,
          endDTS,
          partial
        };
        return;
      }
      info.startPTS = Math.min(info.startPTS, startPTS);
      info.endPTS = Math.max(info.endPTS, endPTS);
      info.startDTS = Math.min(info.startDTS, startDTS);
      info.endDTS = Math.max(info.endDTS, endDTS);
    }
    clearElementaryStreamInfo() {
      const {
        elementaryStreams
      } = this;
      elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
      elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
      elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
    }
  };
  var Part = class extends BaseSegment {
    constructor(partAttrs, frag, baseurl, index2, previous) {
      super(baseurl);
      this.fragOffset = 0;
      this.duration = 0;
      this.gap = false;
      this.independent = false;
      this.relurl = void 0;
      this.fragment = void 0;
      this.index = void 0;
      this.stats = new LoadStats();
      this.duration = partAttrs.decimalFloatingPoint("DURATION");
      this.gap = partAttrs.bool("GAP");
      this.independent = partAttrs.bool("INDEPENDENT");
      this.relurl = partAttrs.enumeratedString("URI");
      this.fragment = frag;
      this.index = index2;
      const byteRange = partAttrs.enumeratedString("BYTERANGE");
      if (byteRange) {
        this.setByteRange(byteRange, previous);
      }
      if (previous) {
        this.fragOffset = previous.fragOffset + previous.duration;
      }
    }
    get start() {
      return this.fragment.start + this.fragOffset;
    }
    get end() {
      return this.start + this.duration;
    }
    get loaded() {
      const {
        elementaryStreams
      } = this;
      return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
    }
  };
  var DEFAULT_TARGET_DURATION = 10;
  var LevelDetails = class {
    constructor(baseUrl) {
      this.PTSKnown = false;
      this.alignedSliding = false;
      this.averagetargetduration = void 0;
      this.endCC = 0;
      this.endSN = 0;
      this.fragments = void 0;
      this.fragmentHint = void 0;
      this.partList = null;
      this.dateRanges = void 0;
      this.live = true;
      this.ageHeader = 0;
      this.advancedDateTime = void 0;
      this.updated = true;
      this.advanced = true;
      this.availabilityDelay = void 0;
      this.misses = 0;
      this.startCC = 0;
      this.startSN = 0;
      this.startTimeOffset = null;
      this.targetduration = 0;
      this.totalduration = 0;
      this.type = null;
      this.url = void 0;
      this.m3u8 = "";
      this.version = null;
      this.canBlockReload = false;
      this.canSkipUntil = 0;
      this.canSkipDateRanges = false;
      this.skippedSegments = 0;
      this.recentlyRemovedDateranges = void 0;
      this.partHoldBack = 0;
      this.holdBack = 0;
      this.partTarget = 0;
      this.preloadHint = void 0;
      this.renditionReports = void 0;
      this.tuneInGoal = 0;
      this.deltaUpdateFailed = void 0;
      this.driftStartTime = 0;
      this.driftEndTime = 0;
      this.driftStart = 0;
      this.driftEnd = 0;
      this.encryptedFragments = void 0;
      this.playlistParsingError = null;
      this.variableList = null;
      this.hasVariableRefs = false;
      this.fragments = [];
      this.encryptedFragments = [];
      this.dateRanges = {};
      this.url = baseUrl;
    }
    reloaded(previous) {
      if (!previous) {
        this.advanced = true;
        this.updated = true;
        return;
      }
      const partSnDiff = this.lastPartSn - previous.lastPartSn;
      const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
      this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
      this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
      if (this.updated || this.advanced) {
        this.misses = Math.floor(previous.misses * 0.6);
      } else {
        this.misses = previous.misses + 1;
      }
      this.availabilityDelay = previous.availabilityDelay;
    }
    get hasProgramDateTime() {
      if (this.fragments.length) {
        return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
      }
      return false;
    }
    get levelTargetDuration() {
      return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
    }
    get drift() {
      const runTime = this.driftEndTime - this.driftStartTime;
      if (runTime > 0) {
        const runDuration = this.driftEnd - this.driftStart;
        return runDuration * 1e3 / runTime;
      }
      return 1;
    }
    get edge() {
      return this.partEnd || this.fragmentEnd;
    }
    get partEnd() {
      var _this$partList;
      if ((_this$partList = this.partList) != null && _this$partList.length) {
        return this.partList[this.partList.length - 1].end;
      }
      return this.fragmentEnd;
    }
    get fragmentEnd() {
      var _this$fragments;
      if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
        return this.fragments[this.fragments.length - 1].end;
      }
      return 0;
    }
    get age() {
      if (this.advancedDateTime) {
        return Math.max(Date.now() - this.advancedDateTime, 0) / 1e3;
      }
      return 0;
    }
    get lastPartIndex() {
      var _this$partList2;
      if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
        return this.partList[this.partList.length - 1].index;
      }
      return -1;
    }
    get lastPartSn() {
      var _this$partList3;
      if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
        return this.partList[this.partList.length - 1].fragment.sn;
      }
      return this.endSN;
    }
  };
  function base64Decode(base64encodedStr) {
    return Uint8Array.from(atob(base64encodedStr), (c2) => c2.charCodeAt(0));
  }
  function getKeyIdBytes(str) {
    const keyIdbytes = strToUtf8array(str).subarray(0, 16);
    const paddedkeyIdbytes = new Uint8Array(16);
    paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
    return paddedkeyIdbytes;
  }
  function changeEndianness(keyId) {
    const swap = function swap2(array, from, to) {
      const cur = array[from];
      array[from] = array[to];
      array[to] = cur;
    };
    swap(keyId, 0, 3);
    swap(keyId, 1, 2);
    swap(keyId, 4, 5);
    swap(keyId, 6, 7);
  }
  function convertDataUriToArrayBytes(uri) {
    const colonsplit = uri.split(":");
    let keydata = null;
    if (colonsplit[0] === "data" && colonsplit.length === 2) {
      const semicolonsplit = colonsplit[1].split(";");
      const commasplit = semicolonsplit[semicolonsplit.length - 1].split(",");
      if (commasplit.length === 2) {
        const isbase64 = commasplit[0] === "base64";
        const data = commasplit[1];
        if (isbase64) {
          semicolonsplit.splice(-1, 1);
          keydata = base64Decode(data);
        } else {
          keydata = getKeyIdBytes(data);
        }
      }
    }
    return keydata;
  }
  function strToUtf8array(str) {
    return Uint8Array.from(unescape(encodeURIComponent(str)), (c2) => c2.charCodeAt(0));
  }
  var KeySystems = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.fps",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "com.widevine.alpha"
  };
  var KeySystemFormats = {
    CLEARKEY: "org.w3.clearkey",
    FAIRPLAY: "com.apple.streamingkeydelivery",
    PLAYREADY: "com.microsoft.playready",
    WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
  };
  function keySystemFormatToKeySystemDomain(format) {
    switch (format) {
      case KeySystemFormats.FAIRPLAY:
        return KeySystems.FAIRPLAY;
      case KeySystemFormats.PLAYREADY:
        return KeySystems.PLAYREADY;
      case KeySystemFormats.WIDEVINE:
        return KeySystems.WIDEVINE;
      case KeySystemFormats.CLEARKEY:
        return KeySystems.CLEARKEY;
    }
  }
  var KeySystemIds = {
    WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
  };
  function keySystemIdToKeySystemDomain(systemId) {
    if (systemId === KeySystemIds.WIDEVINE) {
      return KeySystems.WIDEVINE;
    }
  }
  function keySystemDomainToKeySystemFormat(keySystem) {
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        return KeySystemFormats.FAIRPLAY;
      case KeySystems.PLAYREADY:
        return KeySystemFormats.PLAYREADY;
      case KeySystems.WIDEVINE:
        return KeySystemFormats.WIDEVINE;
      case KeySystems.CLEARKEY:
        return KeySystemFormats.CLEARKEY;
    }
  }
  function getKeySystemsForConfig(config) {
    const {
      drmSystems,
      widevineLicenseUrl
    } = config;
    const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter((keySystem) => !!drmSystems[keySystem]) : [];
    if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
      keySystemsToAttempt.push(KeySystems.WIDEVINE);
    }
    return keySystemsToAttempt;
  }
  var requestMediaKeySystemAccess = function() {
    if (typeof self !== "undefined" && self.navigator && self.navigator.requestMediaKeySystemAccess) {
      return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
    } else {
      return null;
    }
  }();
  function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
    let initDataTypes;
    switch (keySystem) {
      case KeySystems.FAIRPLAY:
        initDataTypes = ["cenc", "sinf"];
        break;
      case KeySystems.WIDEVINE:
      case KeySystems.PLAYREADY:
        initDataTypes = ["cenc"];
        break;
      case KeySystems.CLEARKEY:
        initDataTypes = ["cenc", "keyids"];
        break;
      default:
        throw new Error(`Unknown key-system: ${keySystem}`);
    }
    return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
  }
  function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
    const baseConfig = {
      initDataTypes,
      persistentState: drmSystemOptions.persistentState || "not-allowed",
      distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || "not-allowed",
      sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || "temporary"],
      audioCapabilities: audioCodecs.map((codec) => ({
        contentType: `audio/mp4; codecs="${codec}"`,
        robustness: drmSystemOptions.audioRobustness || "",
        encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
      })),
      videoCapabilities: videoCodecs.map((codec) => ({
        contentType: `video/mp4; codecs="${codec}"`,
        robustness: drmSystemOptions.videoRobustness || "",
        encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
      }))
    };
    return [baseConfig];
  }
  function sliceUint8(array, start, end) {
    return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
  }
  var isHeader$2 = (data, offset2) => {
    if (offset2 + 10 <= data.length) {
      if (data[offset2] === 73 && data[offset2 + 1] === 68 && data[offset2 + 2] === 51) {
        if (data[offset2 + 3] < 255 && data[offset2 + 4] < 255) {
          if (data[offset2 + 6] < 128 && data[offset2 + 7] < 128 && data[offset2 + 8] < 128 && data[offset2 + 9] < 128) {
            return true;
          }
        }
      }
    }
    return false;
  };
  var isFooter = (data, offset2) => {
    if (offset2 + 10 <= data.length) {
      if (data[offset2] === 51 && data[offset2 + 1] === 68 && data[offset2 + 2] === 73) {
        if (data[offset2 + 3] < 255 && data[offset2 + 4] < 255) {
          if (data[offset2 + 6] < 128 && data[offset2 + 7] < 128 && data[offset2 + 8] < 128 && data[offset2 + 9] < 128) {
            return true;
          }
        }
      }
    }
    return false;
  };
  var getID3Data = (data, offset2) => {
    const front = offset2;
    let length = 0;
    while (isHeader$2(data, offset2)) {
      length += 10;
      const size2 = readSize(data, offset2 + 6);
      length += size2;
      if (isFooter(data, offset2 + 10)) {
        length += 10;
      }
      offset2 += length;
    }
    if (length > 0) {
      return data.subarray(front, front + length);
    }
    return void 0;
  };
  var readSize = (data, offset2) => {
    let size2 = 0;
    size2 = (data[offset2] & 127) << 21;
    size2 |= (data[offset2 + 1] & 127) << 14;
    size2 |= (data[offset2 + 2] & 127) << 7;
    size2 |= data[offset2 + 3] & 127;
    return size2;
  };
  var canParse$2 = (data, offset2) => {
    return isHeader$2(data, offset2) && readSize(data, offset2 + 6) + 10 <= data.length - offset2;
  };
  var getTimeStamp = (data) => {
    const frames = getID3Frames(data);
    for (let i2 = 0; i2 < frames.length; i2++) {
      const frame = frames[i2];
      if (isTimeStampFrame(frame)) {
        return readTimeStamp(frame);
      }
    }
    return void 0;
  };
  var isTimeStampFrame = (frame) => {
    return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
  };
  var getFrameData = (data) => {
    const type = String.fromCharCode(data[0], data[1], data[2], data[3]);
    const size2 = readSize(data, 4);
    const offset2 = 10;
    return {
      type,
      size: size2,
      data: data.subarray(offset2, offset2 + size2)
    };
  };
  var getID3Frames = (id3Data) => {
    let offset2 = 0;
    const frames = [];
    while (isHeader$2(id3Data, offset2)) {
      const size2 = readSize(id3Data, offset2 + 6);
      offset2 += 10;
      const end = offset2 + size2;
      while (offset2 + 8 < end) {
        const frameData = getFrameData(id3Data.subarray(offset2));
        const frame = decodeFrame(frameData);
        if (frame) {
          frames.push(frame);
        }
        offset2 += frameData.size + 10;
      }
      if (isFooter(id3Data, offset2)) {
        offset2 += 10;
      }
    }
    return frames;
  };
  var decodeFrame = (frame) => {
    if (frame.type === "PRIV") {
      return decodePrivFrame(frame);
    } else if (frame.type[0] === "W") {
      return decodeURLFrame(frame);
    }
    return decodeTextFrame(frame);
  };
  var decodePrivFrame = (frame) => {
    if (frame.size < 2) {
      return void 0;
    }
    const owner = utf8ArrayToStr(frame.data, true);
    const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
    return {
      key: frame.type,
      info: owner,
      data: privateData.buffer
    };
  };
  var decodeTextFrame = (frame) => {
    if (frame.size < 2) {
      return void 0;
    }
    if (frame.type === "TXXX") {
      let index2 = 1;
      const description = utf8ArrayToStr(frame.data.subarray(index2), true);
      index2 += description.length + 1;
      const value = utf8ArrayToStr(frame.data.subarray(index2));
      return {
        key: frame.type,
        info: description,
        data: value
      };
    }
    const text = utf8ArrayToStr(frame.data.subarray(1));
    return {
      key: frame.type,
      data: text
    };
  };
  var decodeURLFrame = (frame) => {
    if (frame.type === "WXXX") {
      if (frame.size < 2) {
        return void 0;
      }
      let index2 = 1;
      const description = utf8ArrayToStr(frame.data.subarray(index2), true);
      index2 += description.length + 1;
      const value = utf8ArrayToStr(frame.data.subarray(index2));
      return {
        key: frame.type,
        info: description,
        data: value
      };
    }
    const url = utf8ArrayToStr(frame.data);
    return {
      key: frame.type,
      data: url
    };
  };
  var readTimeStamp = (timeStampFrame) => {
    if (timeStampFrame.data.byteLength === 8) {
      const data = new Uint8Array(timeStampFrame.data);
      const pts33Bit = data[3] & 1;
      let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
      timestamp /= 45;
      if (pts33Bit) {
        timestamp += 4772185884e-2;
      }
      return Math.round(timestamp);
    }
    return void 0;
  };
  var utf8ArrayToStr = (array, exitOnNull = false) => {
    const decoder2 = getTextDecoder();
    if (decoder2) {
      const decoded = decoder2.decode(array);
      if (exitOnNull) {
        const idx = decoded.indexOf("\0");
        return idx !== -1 ? decoded.substring(0, idx) : decoded;
      }
      return decoded.replace(/\0/g, "");
    }
    const len = array.length;
    let c2;
    let char2;
    let char3;
    let out = "";
    let i2 = 0;
    while (i2 < len) {
      c2 = array[i2++];
      if (c2 === 0 && exitOnNull) {
        return out;
      } else if (c2 === 0 || c2 === 3) {
        continue;
      }
      switch (c2 >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          out += String.fromCharCode(c2);
          break;
        case 12:
        case 13:
          char2 = array[i2++];
          out += String.fromCharCode((c2 & 31) << 6 | char2 & 63);
          break;
        case 14:
          char2 = array[i2++];
          char3 = array[i2++];
          out += String.fromCharCode((c2 & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
          break;
      }
    }
    return out;
  };
  var decoder;
  function getTextDecoder() {
    if (!decoder && typeof self.TextDecoder !== "undefined") {
      decoder = new self.TextDecoder("utf-8");
    }
    return decoder;
  }
  var Hex = {
    hexDump: function(array) {
      let str = "";
      for (let i2 = 0; i2 < array.length; i2++) {
        let h2 = array[i2].toString(16);
        if (h2.length < 2) {
          h2 = "0" + h2;
        }
        str += h2;
      }
      return str;
    }
  };
  var UINT32_MAX$1 = Math.pow(2, 32) - 1;
  var push = [].push;
  var RemuxerTrackIdConfig = {
    video: 1,
    audio: 2,
    id3: 3,
    text: 4
  };
  function bin2str(data) {
    return String.fromCharCode.apply(null, data);
  }
  function readUint16(buffer, offset2) {
    const val = buffer[offset2] << 8 | buffer[offset2 + 1];
    return val < 0 ? 65536 + val : val;
  }
  function readUint32(buffer, offset2) {
    const val = readSint32(buffer, offset2);
    return val < 0 ? 4294967296 + val : val;
  }
  function readSint32(buffer, offset2) {
    return buffer[offset2] << 24 | buffer[offset2 + 1] << 16 | buffer[offset2 + 2] << 8 | buffer[offset2 + 3];
  }
  function writeUint32(buffer, offset2, value) {
    buffer[offset2] = value >> 24;
    buffer[offset2 + 1] = value >> 16 & 255;
    buffer[offset2 + 2] = value >> 8 & 255;
    buffer[offset2 + 3] = value & 255;
  }
  function findBox(data, path) {
    const results = [];
    if (!path.length) {
      return results;
    }
    const end = data.byteLength;
    for (let i2 = 0; i2 < end; ) {
      const size2 = readUint32(data, i2);
      const type = bin2str(data.subarray(i2 + 4, i2 + 8));
      const endbox = size2 > 1 ? i2 + size2 : end;
      if (type === path[0]) {
        if (path.length === 1) {
          results.push(data.subarray(i2 + 8, endbox));
        } else {
          const subresults = findBox(data.subarray(i2 + 8, endbox), path.slice(1));
          if (subresults.length) {
            push.apply(results, subresults);
          }
        }
      }
      i2 = endbox;
    }
    return results;
  }
  function parseSegmentIndex(sidx) {
    const references = [];
    const version = sidx[0];
    let index2 = 8;
    const timescale = readUint32(sidx, index2);
    index2 += 4;
    const earliestPresentationTime = 0;
    const firstOffset = 0;
    if (version === 0) {
      index2 += 8;
    } else {
      index2 += 16;
    }
    index2 += 2;
    let startByte = sidx.length + firstOffset;
    const referencesCount = readUint16(sidx, index2);
    index2 += 2;
    for (let i2 = 0; i2 < referencesCount; i2++) {
      let referenceIndex = index2;
      const referenceInfo = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      const referenceSize = referenceInfo & 2147483647;
      const referenceType = (referenceInfo & 2147483648) >>> 31;
      if (referenceType === 1) {
        logger.warn("SIDX has hierarchical references (not supported)");
        return null;
      }
      const subsegmentDuration = readUint32(sidx, referenceIndex);
      referenceIndex += 4;
      references.push({
        referenceSize,
        subsegmentDuration,
        info: {
          duration: subsegmentDuration / timescale,
          start: startByte,
          end: startByte + referenceSize - 1
        }
      });
      startByte += referenceSize;
      referenceIndex += 4;
      index2 = referenceIndex;
    }
    return {
      earliestPresentationTime,
      timescale,
      version,
      referencesCount,
      references
    };
  }
  function parseInitSegment(initSegment) {
    const result = [];
    const traks = findBox(initSegment, ["moov", "trak"]);
    for (let i2 = 0; i2 < traks.length; i2++) {
      const trak = traks[i2];
      const tkhd = findBox(trak, ["tkhd"])[0];
      if (tkhd) {
        let version = tkhd[0];
        let index2 = version === 0 ? 12 : 20;
        const trackId = readUint32(tkhd, index2);
        const mdhd = findBox(trak, ["mdia", "mdhd"])[0];
        if (mdhd) {
          version = mdhd[0];
          index2 = version === 0 ? 12 : 20;
          const timescale = readUint32(mdhd, index2);
          const hdlr = findBox(trak, ["mdia", "hdlr"])[0];
          if (hdlr) {
            const hdlrType = bin2str(hdlr.subarray(8, 12));
            const type = {
              soun: ElementaryStreamTypes.AUDIO,
              vide: ElementaryStreamTypes.VIDEO
            }[hdlrType];
            if (type) {
              const stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
              let codec;
              if (stsd) {
                codec = bin2str(stsd.subarray(12, 16));
              }
              result[trackId] = {
                timescale,
                type
              };
              result[type] = {
                timescale,
                id: trackId,
                codec
              };
            }
          }
        }
      }
    }
    const trex = findBox(initSegment, ["moov", "mvex", "trex"]);
    trex.forEach((trex2) => {
      const trackId = readUint32(trex2, 4);
      const track = result[trackId];
      if (track) {
        track.default = {
          duration: readUint32(trex2, 12),
          flags: readUint32(trex2, 20)
        };
      }
    });
    return result;
  }
  function patchEncyptionData(initSegment, decryptdata) {
    if (!initSegment || !decryptdata) {
      return initSegment;
    }
    const keyId = decryptdata.keyId;
    if (keyId && decryptdata.isCommonEncryption) {
      const traks = findBox(initSegment, ["moov", "trak"]);
      traks.forEach((trak) => {
        const stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
        const sampleEntries = stsd.subarray(8);
        let encBoxes = findBox(sampleEntries, ["enca"]);
        const isAudio = encBoxes.length > 0;
        if (!isAudio) {
          encBoxes = findBox(sampleEntries, ["encv"]);
        }
        encBoxes.forEach((enc) => {
          const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
          const sinfBoxes = findBox(encBoxChildren, ["sinf"]);
          sinfBoxes.forEach((sinf) => {
            const tenc = parseSinf(sinf);
            if (tenc) {
              const tencKeyId = tenc.subarray(8, 24);
              if (!tencKeyId.some((b3) => b3 !== 0)) {
                logger.log(`[eme] Patching keyId in 'enc${isAudio ? "a" : "v"}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);
                tenc.set(keyId, 8);
              }
            }
          });
        });
      });
    }
    return initSegment;
  }
  function parseSinf(sinf) {
    const schm = findBox(sinf, ["schm"])[0];
    if (schm) {
      const scheme = bin2str(schm.subarray(4, 8));
      if (scheme === "cbcs" || scheme === "cenc") {
        return findBox(sinf, ["schi", "tenc"])[0];
      }
    }
    logger.error(`[eme] missing 'schm' box`);
    return null;
  }
  function getStartDTS(initData, fmp4) {
    return findBox(fmp4, ["moof", "traf"]).reduce((result, traf) => {
      const tfdt = findBox(traf, ["tfdt"])[0];
      const version = tfdt[0];
      const start = findBox(traf, ["tfhd"]).reduce((result2, tfhd) => {
        const id = readUint32(tfhd, 4);
        const track = initData[id];
        if (track) {
          let baseTime = readUint32(tfdt, 4);
          if (version === 1) {
            if (baseTime === UINT32_MAX$1) {
              logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);
              return result2;
            }
            baseTime *= UINT32_MAX$1 + 1;
            baseTime += readUint32(tfdt, 8);
          }
          const scale = track.timescale || 9e4;
          const startTime = baseTime / scale;
          if (isFinite(startTime) && (result2 === null || startTime < result2)) {
            return startTime;
          }
        }
        return result2;
      }, null);
      if (start !== null && isFinite(start) && (result === null || start < result)) {
        return start;
      }
      return result;
    }, null);
  }
  function getDuration(data, initData) {
    let rawDuration = 0;
    let videoDuration = 0;
    let audioDuration = 0;
    const trafs = findBox(data, ["moof", "traf"]);
    for (let i2 = 0; i2 < trafs.length; i2++) {
      const traf = trafs[i2];
      const tfhd = findBox(traf, ["tfhd"])[0];
      const id = readUint32(tfhd, 4);
      const track = initData[id];
      if (!track) {
        continue;
      }
      const trackDefault = track.default;
      const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);
      let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;
      if (tfhdFlags & 8) {
        if (tfhdFlags & 2) {
          sampleDuration = readUint32(tfhd, 12);
        } else {
          sampleDuration = readUint32(tfhd, 8);
        }
      }
      const timescale = track.timescale || 9e4;
      const truns = findBox(traf, ["trun"]);
      for (let j3 = 0; j3 < truns.length; j3++) {
        rawDuration = computeRawDurationFromSamples(truns[j3]);
        if (!rawDuration && sampleDuration) {
          const sampleCount = readUint32(truns[j3], 4);
          rawDuration = sampleDuration * sampleCount;
        }
        if (track.type === ElementaryStreamTypes.VIDEO) {
          videoDuration += rawDuration / timescale;
        } else if (track.type === ElementaryStreamTypes.AUDIO) {
          audioDuration += rawDuration / timescale;
        }
      }
    }
    if (videoDuration === 0 && audioDuration === 0) {
      let sidxDuration = 0;
      const sidxs = findBox(data, ["sidx"]);
      for (let i2 = 0; i2 < sidxs.length; i2++) {
        const sidx = parseSegmentIndex(sidxs[i2]);
        if (sidx != null && sidx.references) {
          sidxDuration += sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);
        }
      }
      return sidxDuration;
    }
    if (videoDuration) {
      return videoDuration;
    }
    return audioDuration;
  }
  function computeRawDurationFromSamples(trun) {
    const flags = readUint32(trun, 0);
    let offset2 = 8;
    if (flags & 1) {
      offset2 += 4;
    }
    if (flags & 4) {
      offset2 += 4;
    }
    let duration = 0;
    const sampleCount = readUint32(trun, 4);
    for (let i2 = 0; i2 < sampleCount; i2++) {
      if (flags & 256) {
        const sampleDuration = readUint32(trun, offset2);
        duration += sampleDuration;
        offset2 += 4;
      }
      if (flags & 512) {
        offset2 += 4;
      }
      if (flags & 1024) {
        offset2 += 4;
      }
      if (flags & 2048) {
        offset2 += 4;
      }
    }
    return duration;
  }
  function offsetStartDTS(initData, fmp4, timeOffset) {
    findBox(fmp4, ["moof", "traf"]).forEach((traf) => {
      findBox(traf, ["tfhd"]).forEach((tfhd) => {
        const id = readUint32(tfhd, 4);
        const track = initData[id];
        if (!track) {
          return;
        }
        const timescale = track.timescale || 9e4;
        findBox(traf, ["tfdt"]).forEach((tfdt) => {
          const version = tfdt[0];
          let baseMediaDecodeTime = readUint32(tfdt, 4);
          if (version === 0) {
            baseMediaDecodeTime -= timeOffset * timescale;
            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
            writeUint32(tfdt, 4, baseMediaDecodeTime);
          } else {
            baseMediaDecodeTime *= Math.pow(2, 32);
            baseMediaDecodeTime += readUint32(tfdt, 8);
            baseMediaDecodeTime -= timeOffset * timescale;
            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
            const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
            const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
            writeUint32(tfdt, 4, upper);
            writeUint32(tfdt, 8, lower);
          }
        });
      });
    });
  }
  function segmentValidRange(data) {
    const segmentedRange = {
      valid: null,
      remainder: null
    };
    const moofs = findBox(data, ["moof"]);
    if (!moofs) {
      return segmentedRange;
    } else if (moofs.length < 2) {
      segmentedRange.remainder = data;
      return segmentedRange;
    }
    const last = moofs[moofs.length - 1];
    segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);
    segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);
    return segmentedRange;
  }
  function appendUint8Array(data1, data2) {
    const temp = new Uint8Array(data1.length + data2.length);
    temp.set(data1);
    temp.set(data2, data1.length);
    return temp;
  }
  function parseSamples(timeOffset, track) {
    const seiSamples = [];
    const videoData = track.samples;
    const timescale = track.timescale;
    const trackId = track.id;
    let isHEVCFlavor = false;
    const moofs = findBox(videoData, ["moof"]);
    moofs.map((moof) => {
      const moofOffset = moof.byteOffset - 8;
      const trafs = findBox(moof, ["traf"]);
      trafs.map((traf) => {
        const baseTime = findBox(traf, ["tfdt"]).map((tfdt) => {
          const version = tfdt[0];
          let result = readUint32(tfdt, 4);
          if (version === 1) {
            result *= Math.pow(2, 32);
            result += readUint32(tfdt, 8);
          }
          return result / timescale;
        })[0];
        if (baseTime !== void 0) {
          timeOffset = baseTime;
        }
        return findBox(traf, ["tfhd"]).map((tfhd) => {
          const id = readUint32(tfhd, 4);
          const tfhdFlags = readUint32(tfhd, 0) & 16777215;
          const baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
          const sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
          const defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
          let defaultSampleDuration = 0;
          const defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
          let defaultSampleSize = 0;
          const defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
          let tfhdOffset = 8;
          if (id === trackId) {
            if (baseDataOffsetPresent) {
              tfhdOffset += 8;
            }
            if (sampleDescriptionIndexPresent) {
              tfhdOffset += 4;
            }
            if (defaultSampleDurationPresent) {
              defaultSampleDuration = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleSizePresent) {
              defaultSampleSize = readUint32(tfhd, tfhdOffset);
              tfhdOffset += 4;
            }
            if (defaultSampleFlagsPresent) {
              tfhdOffset += 4;
            }
            if (track.type === "video") {
              isHEVCFlavor = isHEVC(track.codec);
            }
            findBox(traf, ["trun"]).map((trun) => {
              const version = trun[0];
              const flags = readUint32(trun, 0) & 16777215;
              const dataOffsetPresent = (flags & 1) !== 0;
              let dataOffset = 0;
              const firstSampleFlagsPresent = (flags & 4) !== 0;
              const sampleDurationPresent = (flags & 256) !== 0;
              let sampleDuration = 0;
              const sampleSizePresent = (flags & 512) !== 0;
              let sampleSize = 0;
              const sampleFlagsPresent = (flags & 1024) !== 0;
              const sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
              let compositionOffset = 0;
              const sampleCount = readUint32(trun, 4);
              let trunOffset = 8;
              if (dataOffsetPresent) {
                dataOffset = readUint32(trun, trunOffset);
                trunOffset += 4;
              }
              if (firstSampleFlagsPresent) {
                trunOffset += 4;
              }
              let sampleOffset = dataOffset + moofOffset;
              for (let ix = 0; ix < sampleCount; ix++) {
                if (sampleDurationPresent) {
                  sampleDuration = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleDuration = defaultSampleDuration;
                }
                if (sampleSizePresent) {
                  sampleSize = readUint32(trun, trunOffset);
                  trunOffset += 4;
                } else {
                  sampleSize = defaultSampleSize;
                }
                if (sampleFlagsPresent) {
                  trunOffset += 4;
                }
                if (sampleCompositionOffsetsPresent) {
                  if (version === 0) {
                    compositionOffset = readUint32(trun, trunOffset);
                  } else {
                    compositionOffset = readSint32(trun, trunOffset);
                  }
                  trunOffset += 4;
                }
                if (track.type === ElementaryStreamTypes.VIDEO) {
                  let naluTotalSize = 0;
                  while (naluTotalSize < sampleSize) {
                    const naluSize = readUint32(videoData, sampleOffset);
                    sampleOffset += 4;
                    if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                      const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                      parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                    }
                    sampleOffset += naluSize;
                    naluTotalSize += naluSize + 4;
                  }
                }
                timeOffset += sampleDuration / timescale;
              }
            });
          }
        });
      });
    });
    return seiSamples;
  }
  function isHEVC(codec) {
    if (!codec) {
      return false;
    }
    const delimit = codec.indexOf(".");
    const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
    return baseCodec === "hvc1" || baseCodec === "hev1" || baseCodec === "dvh1" || baseCodec === "dvhe";
  }
  function isSEIMessage(isHEVCFlavor, naluHeader) {
    if (isHEVCFlavor) {
      const naluType = naluHeader >> 1 & 63;
      return naluType === 39 || naluType === 40;
    } else {
      const naluType = naluHeader & 31;
      return naluType === 6;
    }
  }
  function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
    const data = discardEPB(unescapedData);
    let seiPtr = 0;
    seiPtr += headerSize;
    let payloadType = 0;
    let payloadSize = 0;
    let endOfCaptions = false;
    let b3 = 0;
    while (seiPtr < data.length) {
      payloadType = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b3 = data[seiPtr++];
        payloadType += b3;
      } while (b3 === 255);
      payloadSize = 0;
      do {
        if (seiPtr >= data.length) {
          break;
        }
        b3 = data[seiPtr++];
        payloadSize += b3;
      } while (b3 === 255);
      const leftOver = data.length - seiPtr;
      if (!endOfCaptions && payloadType === 4 && seiPtr < data.length) {
        endOfCaptions = true;
        const countryCode = data[seiPtr++];
        if (countryCode === 181) {
          const providerCode = readUint16(data, seiPtr);
          seiPtr += 2;
          if (providerCode === 49) {
            const userStructure = readUint32(data, seiPtr);
            seiPtr += 4;
            if (userStructure === 1195456820) {
              const userDataType = data[seiPtr++];
              if (userDataType === 3) {
                const firstByte = data[seiPtr++];
                const totalCCs = 31 & firstByte;
                const enabled = 64 & firstByte;
                const totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                const byteArray = new Uint8Array(totalBytes);
                if (enabled) {
                  byteArray[0] = firstByte;
                  for (let i2 = 1; i2 < totalBytes; i2++) {
                    byteArray[i2] = data[seiPtr++];
                  }
                }
                samples.push({
                  type: userDataType,
                  payloadType,
                  pts,
                  bytes: byteArray
                });
              }
            }
          }
        }
      } else if (payloadType === 5 && payloadSize < leftOver) {
        endOfCaptions = true;
        if (payloadSize > 16) {
          const uuidStrArray = [];
          for (let i2 = 0; i2 < 16; i2++) {
            const _b = data[seiPtr++].toString(16);
            uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
            if (i2 === 3 || i2 === 5 || i2 === 7 || i2 === 9) {
              uuidStrArray.push("-");
            }
          }
          const length = payloadSize - 16;
          const userDataBytes = new Uint8Array(length);
          for (let i2 = 0; i2 < length; i2++) {
            userDataBytes[i2] = data[seiPtr++];
          }
          samples.push({
            payloadType,
            pts,
            uuid: uuidStrArray.join(""),
            userData: utf8ArrayToStr(userDataBytes),
            userDataBytes
          });
        }
      } else if (payloadSize < leftOver) {
        seiPtr += payloadSize;
      } else if (payloadSize > leftOver) {
        break;
      }
    }
  }
  function discardEPB(data) {
    const length = data.byteLength;
    const EPBPositions = [];
    let i2 = 1;
    while (i2 < length - 2) {
      if (data[i2] === 0 && data[i2 + 1] === 0 && data[i2 + 2] === 3) {
        EPBPositions.push(i2 + 2);
        i2 += 2;
      } else {
        i2++;
      }
    }
    if (EPBPositions.length === 0) {
      return data;
    }
    const newLength = length - EPBPositions.length;
    const newData = new Uint8Array(newLength);
    let sourceIndex = 0;
    for (i2 = 0; i2 < newLength; sourceIndex++, i2++) {
      if (sourceIndex === EPBPositions[0]) {
        sourceIndex++;
        EPBPositions.shift();
      }
      newData[i2] = data[sourceIndex];
    }
    return newData;
  }
  function parseEmsg(data) {
    const version = data[0];
    let schemeIdUri = "";
    let value = "";
    let timeScale = 0;
    let presentationTimeDelta = 0;
    let presentationTime = 0;
    let eventDuration = 0;
    let id = 0;
    let offset2 = 0;
    if (version === 0) {
      while (bin2str(data.subarray(offset2, offset2 + 1)) !== "\0") {
        schemeIdUri += bin2str(data.subarray(offset2, offset2 + 1));
        offset2 += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset2, offset2 + 1));
      offset2 += 1;
      while (bin2str(data.subarray(offset2, offset2 + 1)) !== "\0") {
        value += bin2str(data.subarray(offset2, offset2 + 1));
        offset2 += 1;
      }
      value += bin2str(data.subarray(offset2, offset2 + 1));
      offset2 += 1;
      timeScale = readUint32(data, 12);
      presentationTimeDelta = readUint32(data, 16);
      eventDuration = readUint32(data, 20);
      id = readUint32(data, 24);
      offset2 = 28;
    } else if (version === 1) {
      offset2 += 4;
      timeScale = readUint32(data, offset2);
      offset2 += 4;
      const leftPresentationTime = readUint32(data, offset2);
      offset2 += 4;
      const rightPresentationTime = readUint32(data, offset2);
      offset2 += 4;
      presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;
      if (!Number.isSafeInteger(presentationTime)) {
        presentationTime = Number.MAX_SAFE_INTEGER;
        logger.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
      }
      eventDuration = readUint32(data, offset2);
      offset2 += 4;
      id = readUint32(data, offset2);
      offset2 += 4;
      while (bin2str(data.subarray(offset2, offset2 + 1)) !== "\0") {
        schemeIdUri += bin2str(data.subarray(offset2, offset2 + 1));
        offset2 += 1;
      }
      schemeIdUri += bin2str(data.subarray(offset2, offset2 + 1));
      offset2 += 1;
      while (bin2str(data.subarray(offset2, offset2 + 1)) !== "\0") {
        value += bin2str(data.subarray(offset2, offset2 + 1));
        offset2 += 1;
      }
      value += bin2str(data.subarray(offset2, offset2 + 1));
      offset2 += 1;
    }
    const payload = data.subarray(offset2, data.byteLength);
    return {
      schemeIdUri,
      value,
      timeScale,
      presentationTime,
      presentationTimeDelta,
      eventDuration,
      id,
      payload
    };
  }
  function mp4Box(type, ...payload) {
    const len = payload.length;
    let size2 = 8;
    let i2 = len;
    while (i2--) {
      size2 += payload[i2].byteLength;
    }
    const result = new Uint8Array(size2);
    result[0] = size2 >> 24 & 255;
    result[1] = size2 >> 16 & 255;
    result[2] = size2 >> 8 & 255;
    result[3] = size2 & 255;
    result.set(type, 4);
    for (i2 = 0, size2 = 8; i2 < len; i2++) {
      result.set(payload[i2], size2);
      size2 += payload[i2].byteLength;
    }
    return result;
  }
  function mp4pssh(systemId, keyids, data) {
    if (systemId.byteLength !== 16) {
      throw new RangeError("Invalid system id");
    }
    let version;
    let kids;
    if (keyids) {
      version = 1;
      kids = new Uint8Array(keyids.length * 16);
      for (let ix = 0; ix < keyids.length; ix++) {
        const k3 = keyids[ix];
        if (k3.byteLength !== 16) {
          throw new RangeError("Invalid key");
        }
        kids.set(k3, ix * 16);
      }
    } else {
      version = 0;
      kids = new Uint8Array();
    }
    let kidCount;
    if (version > 0) {
      kidCount = new Uint8Array(4);
      if (keyids.length > 0) {
        new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
      }
    } else {
      kidCount = new Uint8Array();
    }
    const dataSize = new Uint8Array(4);
    if (data && data.byteLength > 0) {
      new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
    }
    return mp4Box(
      [112, 115, 115, 104],
      new Uint8Array([
        version,
        0,
        0,
        0
      ]),
      systemId,
      kidCount,
      kids,
      dataSize,
      data || new Uint8Array()
    );
  }
  function parsePssh(initData) {
    if (!(initData instanceof ArrayBuffer) || initData.byteLength < 32) {
      return null;
    }
    const result = {
      version: 0,
      systemId: "",
      kids: null,
      data: null
    };
    const view = new DataView(initData);
    const boxSize = view.getUint32(0);
    if (initData.byteLength !== boxSize && boxSize > 44) {
      return null;
    }
    const type = view.getUint32(4);
    if (type !== 1886614376) {
      return null;
    }
    result.version = view.getUint32(8) >>> 24;
    if (result.version > 1) {
      return null;
    }
    result.systemId = Hex.hexDump(new Uint8Array(initData, 12, 16));
    const dataSizeOrKidCount = view.getUint32(28);
    if (result.version === 0) {
      if (boxSize - 32 < dataSizeOrKidCount) {
        return null;
      }
      result.data = new Uint8Array(initData, 32, dataSizeOrKidCount);
    } else if (result.version === 1) {
      result.kids = [];
      for (let i2 = 0; i2 < dataSizeOrKidCount; i2++) {
        result.kids.push(new Uint8Array(initData, 32 + i2 * 16, 16));
      }
    }
    return result;
  }
  var keyUriToKeyIdMap = {};
  var LevelKey = class {
    static clearKeyUriToKeyIdMap() {
      keyUriToKeyIdMap = {};
    }
    constructor(method, uri, format, formatversions = [1], iv = null) {
      this.uri = void 0;
      this.method = void 0;
      this.keyFormat = void 0;
      this.keyFormatVersions = void 0;
      this.encrypted = void 0;
      this.isCommonEncryption = void 0;
      this.iv = null;
      this.key = null;
      this.keyId = null;
      this.pssh = null;
      this.method = method;
      this.uri = uri;
      this.keyFormat = format;
      this.keyFormatVersions = formatversions;
      this.iv = iv;
      this.encrypted = method ? method !== "NONE" : false;
      this.isCommonEncryption = this.encrypted && method !== "AES-128";
    }
    isSupported() {
      if (this.method) {
        if (this.method === "AES-128" || this.method === "NONE") {
          return true;
        }
        if (this.keyFormat === "identity") {
          return this.method === "SAMPLE-AES";
        } else {
          switch (this.keyFormat) {
            case KeySystemFormats.FAIRPLAY:
            case KeySystemFormats.WIDEVINE:
            case KeySystemFormats.PLAYREADY:
            case KeySystemFormats.CLEARKEY:
              return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
          }
        }
      }
      return false;
    }
    getDecryptData(sn2) {
      if (!this.encrypted || !this.uri) {
        return null;
      }
      if (this.method === "AES-128" && this.uri && !this.iv) {
        if (typeof sn2 !== "number") {
          if (this.method === "AES-128" && !this.iv) {
            logger.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`);
          }
          sn2 = 0;
        }
        const iv = createInitializationVector(sn2);
        const decryptdata = new LevelKey(this.method, this.uri, "identity", this.keyFormatVersions, iv);
        return decryptdata;
      }
      const keyBytes = convertDataUriToArrayBytes(this.uri);
      if (keyBytes) {
        switch (this.keyFormat) {
          case KeySystemFormats.WIDEVINE:
            this.pssh = keyBytes;
            if (keyBytes.length >= 22) {
              this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
            }
            break;
          case KeySystemFormats.PLAYREADY: {
            const PlayReadyKeySystemUUID = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
            this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
            const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
            const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));
            const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf("<"), keyByteStr.length);
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlKeyBytes, "text/xml");
            const keyData = xmlDoc.getElementsByTagName("KID")[0];
            if (keyData) {
              const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute("VALUE");
              if (keyId) {
                const keyIdArray = base64Decode(keyId).subarray(0, 16);
                changeEndianness(keyIdArray);
                this.keyId = keyIdArray;
              }
            }
            break;
          }
          default: {
            let keydata = keyBytes.subarray(0, 16);
            if (keydata.length !== 16) {
              const padded = new Uint8Array(16);
              padded.set(keydata, 16 - keydata.length);
              keydata = padded;
            }
            this.keyId = keydata;
            break;
          }
        }
      }
      if (!this.keyId || this.keyId.byteLength !== 16) {
        let keyId = keyUriToKeyIdMap[this.uri];
        if (!keyId) {
          const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
          keyId = new Uint8Array(16);
          const dv = new DataView(keyId.buffer, 12, 4);
          dv.setUint32(0, val);
          keyUriToKeyIdMap[this.uri] = keyId;
        }
        this.keyId = keyId;
      }
      return this;
    }
  };
  function createInitializationVector(segmentNumber) {
    const uint8View = new Uint8Array(16);
    for (let i2 = 12; i2 < 16; i2++) {
      uint8View[i2] = segmentNumber >> 8 * (15 - i2) & 255;
    }
    return uint8View;
  }
  var VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
  function hasVariableReferences(str) {
    return VARIABLE_REPLACEMENT_REGEX.test(str);
  }
  function substituteVariablesInAttributes(parsed, attr, attributeNames) {
    if (parsed.variableList !== null || parsed.hasVariableRefs) {
      for (let i2 = attributeNames.length; i2--; ) {
        const name = attributeNames[i2];
        const value = attr[name];
        if (value) {
          attr[name] = substituteVariables(parsed, value);
        }
      }
    }
  }
  function substituteVariables(parsed, value) {
    if (parsed.variableList !== null || parsed.hasVariableRefs) {
      const variableList = parsed.variableList;
      return value.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference) => {
        const variableName = variableReference.substring(2, variableReference.length - 1);
        const variableValue = variableList == null ? void 0 : variableList[variableName];
        if (variableValue === void 0) {
          parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${variableName}"`));
          return variableReference;
        }
        return variableValue;
      });
    }
    return value;
  }
  function addVariableDefinition(parsed, attr, parentUrl) {
    let variableList = parsed.variableList;
    if (!variableList) {
      parsed.variableList = variableList = {};
    }
    let NAME;
    let VALUE;
    if ("QUERYPARAM" in attr) {
      NAME = attr.QUERYPARAM;
      try {
        const searchParams = new self.URL(parentUrl).searchParams;
        if (searchParams.has(NAME)) {
          VALUE = searchParams.get(NAME);
        } else {
          throw new Error(`"${NAME}" does not match any query parameter in URI: "${parentUrl}"`);
        }
      } catch (error) {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));
      }
    } else {
      NAME = attr.NAME;
      VALUE = attr.VALUE;
    }
    if (NAME in variableList) {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${NAME}"`));
    } else {
      variableList[NAME] = VALUE || "";
    }
  }
  function importVariableDefinition(parsed, attr, sourceVariableList) {
    const IMPORT = attr.IMPORT;
    if (sourceVariableList && IMPORT in sourceVariableList) {
      let variableList = parsed.variableList;
      if (!variableList) {
        parsed.variableList = variableList = {};
      }
      variableList[IMPORT] = sourceVariableList[IMPORT];
    } else {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${IMPORT}"`));
    }
  }
  function getMediaSource() {
    if (typeof self === "undefined")
      return void 0;
    return self.MediaSource || self.WebKitMediaSource;
  }
  var sampleEntryCodesISO = {
    audio: {
      a3ds: true,
      "ac-3": true,
      "ac-4": true,
      alac: true,
      alaw: true,
      dra1: true,
      "dts+": true,
      "dts-": true,
      dtsc: true,
      dtse: true,
      dtsh: true,
      "ec-3": true,
      enca: true,
      g719: true,
      g726: true,
      m4ae: true,
      mha1: true,
      mha2: true,
      mhm1: true,
      mhm2: true,
      mlpa: true,
      mp4a: true,
      "raw ": true,
      Opus: true,
      opus: true,
      samr: true,
      sawb: true,
      sawp: true,
      sevc: true,
      sqcp: true,
      ssmv: true,
      twos: true,
      ulaw: true
    },
    video: {
      avc1: true,
      avc2: true,
      avc3: true,
      avc4: true,
      avcp: true,
      av01: true,
      drac: true,
      dva1: true,
      dvav: true,
      dvh1: true,
      dvhe: true,
      encv: true,
      hev1: true,
      hvc1: true,
      mjp2: true,
      mp4v: true,
      mvc1: true,
      mvc2: true,
      mvc3: true,
      mvc4: true,
      resv: true,
      rv60: true,
      s263: true,
      svc1: true,
      svc2: true,
      "vc-1": true,
      vp08: true,
      vp09: true
    },
    text: {
      stpp: true,
      wvtt: true
    }
  };
  var MediaSource$2 = getMediaSource();
  function isCodecType(codec, type) {
    const typeCodes = sampleEntryCodesISO[type];
    return !!typeCodes && typeCodes[codec.slice(0, 4)] === true;
  }
  function isCodecSupportedInMp4(codec, type) {
    var _MediaSource$isTypeSu;
    return (_MediaSource$isTypeSu = MediaSource$2 == null ? void 0 : MediaSource$2.isTypeSupported(`${type || "video"}/mp4;codecs="${codec}"`)) != null ? _MediaSource$isTypeSu : false;
  }
  var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
  var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
  var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m;
  var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
    /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
    /(?!#) *(\S[\S ]*)/.source,
    /#EXT-X-BYTERANGE:*(.+)/.source,
    /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
    /#.*/.source
  ].join("|"), "g");
  var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
  var M3U8Parser = class {
    static findGroup(groups, mediaGroupId) {
      for (let i2 = 0; i2 < groups.length; i2++) {
        const group = groups[i2];
        if (group.id === mediaGroupId) {
          return group;
        }
      }
    }
    static convertAVC1ToAVCOTI(codec) {
      const avcdata = codec.split(".");
      if (avcdata.length > 2) {
        let result = avcdata.shift() + ".";
        result += parseInt(avcdata.shift()).toString(16);
        result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
        return result;
      }
      return codec;
    }
    static resolve(url, baseUrl) {
      return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
        alwaysNormalize: true
      });
    }
    static isMediaPlaylist(str) {
      return IS_MEDIA_PLAYLIST.test(str);
    }
    static parseMasterPlaylist(string2, baseurl) {
      const hasVariableRefs = hasVariableReferences(string2);
      const parsed = {
        contentSteering: null,
        levels: [],
        playlistParsingError: null,
        sessionData: null,
        sessionKeys: null,
        startTimeOffset: null,
        variableList: null,
        hasVariableRefs
      };
      const levelsWithKnownCodecs = [];
      MASTER_PLAYLIST_REGEX.lastIndex = 0;
      let result;
      while ((result = MASTER_PLAYLIST_REGEX.exec(string2)) != null) {
        if (result[1]) {
          var _level$unknownCodecs;
          const attrs = new AttrList(result[1]);
          {
            substituteVariablesInAttributes(parsed, attrs, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
          }
          const uri = substituteVariables(parsed, result[2]);
          const level = {
            attrs,
            bitrate: attrs.decimalInteger("AVERAGE-BANDWIDTH") || attrs.decimalInteger("BANDWIDTH"),
            name: attrs.NAME,
            url: M3U8Parser.resolve(uri, baseurl)
          };
          const resolution = attrs.decimalResolution("RESOLUTION");
          if (resolution) {
            level.width = resolution.width;
            level.height = resolution.height;
          }
          setCodecs((attrs.CODECS || "").split(/[ ,]+/).filter((c2) => c2), level);
          if (level.videoCodec && level.videoCodec.indexOf("avc1") !== -1) {
            level.videoCodec = M3U8Parser.convertAVC1ToAVCOTI(level.videoCodec);
          }
          if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
            levelsWithKnownCodecs.push(level);
          }
          parsed.levels.push(level);
        } else if (result[3]) {
          const tag = result[3];
          const attributes = result[4];
          switch (tag) {
            case "SESSION-DATA": {
              const sessionAttrs = new AttrList(attributes);
              {
                substituteVariablesInAttributes(parsed, sessionAttrs, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
              }
              const dataId = sessionAttrs["DATA-ID"];
              if (dataId) {
                if (parsed.sessionData === null) {
                  parsed.sessionData = {};
                }
                parsed.sessionData[dataId] = sessionAttrs;
              }
              break;
            }
            case "SESSION-KEY": {
              const sessionKey = parseKey(attributes, baseurl, parsed);
              if (sessionKey.encrypted && sessionKey.isSupported()) {
                if (parsed.sessionKeys === null) {
                  parsed.sessionKeys = [];
                }
                parsed.sessionKeys.push(sessionKey);
              } else {
                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${attributes}"`);
              }
              break;
            }
            case "DEFINE": {
              {
                const variableAttributes = new AttrList(attributes);
                substituteVariablesInAttributes(parsed, variableAttributes, ["NAME", "VALUE", "QUERYPARAM"]);
                addVariableDefinition(parsed, variableAttributes, baseurl);
              }
              break;
            }
            case "CONTENT-STEERING": {
              const contentSteeringAttributes = new AttrList(attributes);
              {
                substituteVariablesInAttributes(parsed, contentSteeringAttributes, ["SERVER-URI", "PATHWAY-ID"]);
              }
              parsed.contentSteering = {
                uri: M3U8Parser.resolve(contentSteeringAttributes["SERVER-URI"], baseurl),
                pathwayId: contentSteeringAttributes["PATHWAY-ID"] || "."
              };
              break;
            }
            case "START": {
              parsed.startTimeOffset = parseStartTimeOffset(attributes);
              break;
            }
          }
        }
      }
      const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
      parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
      if (parsed.levels.length === 0) {
        parsed.playlistParsingError = new Error("no levels found in manifest");
      }
      return parsed;
    }
    static parseMasterPlaylistMedia(string2, baseurl, parsed) {
      let result;
      const results = {};
      const levels = parsed.levels;
      const groupsByType = {
        AUDIO: levels.map((level) => ({
          id: level.attrs.AUDIO,
          audioCodec: level.audioCodec
        })),
        SUBTITLES: levels.map((level) => ({
          id: level.attrs.SUBTITLES,
          textCodec: level.textCodec
        })),
        "CLOSED-CAPTIONS": []
      };
      let id = 0;
      MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
      while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string2)) !== null) {
        const attrs = new AttrList(result[1]);
        const type = attrs.TYPE;
        if (type) {
          const groups = groupsByType[type];
          const medias = results[type] || [];
          results[type] = medias;
          {
            substituteVariablesInAttributes(parsed, attrs, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
          }
          const media = {
            attrs,
            bitrate: 0,
            id: id++,
            groupId: attrs["GROUP-ID"] || "",
            instreamId: attrs["INSTREAM-ID"],
            name: attrs.NAME || attrs.LANGUAGE || "",
            type,
            default: attrs.bool("DEFAULT"),
            autoselect: attrs.bool("AUTOSELECT"),
            forced: attrs.bool("FORCED"),
            lang: attrs.LANGUAGE,
            url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ""
          };
          if (groups != null && groups.length) {
            const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];
            assignCodec(media, groupCodec, "audioCodec");
            assignCodec(media, groupCodec, "textCodec");
          }
          medias.push(media);
        }
      }
      return results;
    }
    static parseLevelPlaylist(string2, baseurl, id, type, levelUrlId, multivariantVariableList) {
      const level = new LevelDetails(baseurl);
      const fragments = level.fragments;
      let currentInitSegment = null;
      let currentSN = 0;
      let currentPart = 0;
      let totalduration = 0;
      let discontinuityCounter = 0;
      let prevFrag = null;
      let frag = new Fragment3(type, baseurl);
      let result;
      let i2;
      let levelkeys;
      let firstPdtIndex = -1;
      let createNextFrag = false;
      LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
      level.m3u8 = string2;
      level.hasVariableRefs = hasVariableReferences(string2);
      while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string2)) !== null) {
        if (createNextFrag) {
          createNextFrag = false;
          frag = new Fragment3(type, baseurl);
          frag.start = totalduration;
          frag.sn = currentSN;
          frag.cc = discontinuityCounter;
          frag.level = id;
          if (currentInitSegment) {
            frag.initSegment = currentInitSegment;
            frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
            currentInitSegment.rawProgramDateTime = null;
          }
        }
        const duration = result[1];
        if (duration) {
          frag.duration = parseFloat(duration);
          const title = (" " + result[2]).slice(1);
          frag.title = title || null;
          frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
        } else if (result[3]) {
          if (isFiniteNumber(frag.duration)) {
            frag.start = totalduration;
            if (levelkeys) {
              setFragLevelKeys(frag, levelkeys, level);
            }
            frag.sn = currentSN;
            frag.level = id;
            frag.cc = discontinuityCounter;
            frag.urlId = levelUrlId;
            fragments.push(frag);
            const uri = (" " + result[3]).slice(1);
            frag.relurl = substituteVariables(level, uri);
            assignProgramDateTime(frag, prevFrag);
            prevFrag = frag;
            totalduration += frag.duration;
            currentSN++;
            currentPart = 0;
            createNextFrag = true;
          }
        } else if (result[4]) {
          const data = (" " + result[4]).slice(1);
          if (prevFrag) {
            frag.setByteRange(data, prevFrag);
          } else {
            frag.setByteRange(data);
          }
        } else if (result[5]) {
          frag.rawProgramDateTime = (" " + result[5]).slice(1);
          frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
          if (firstPdtIndex === -1) {
            firstPdtIndex = fragments.length;
          }
        } else {
          result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
          if (!result) {
            logger.warn("No matches on slow regex match for level playlist!");
            continue;
          }
          for (i2 = 1; i2 < result.length; i2++) {
            if (typeof result[i2] !== "undefined") {
              break;
            }
          }
          const tag = (" " + result[i2]).slice(1);
          const value1 = (" " + result[i2 + 1]).slice(1);
          const value2 = result[i2 + 2] ? (" " + result[i2 + 2]).slice(1) : "";
          switch (tag) {
            case "PLAYLIST-TYPE":
              level.type = value1.toUpperCase();
              break;
            case "MEDIA-SEQUENCE":
              currentSN = level.startSN = parseInt(value1);
              break;
            case "SKIP": {
              const skipAttrs = new AttrList(value1);
              {
                substituteVariablesInAttributes(level, skipAttrs, ["RECENTLY-REMOVED-DATERANGES"]);
              }
              const skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
              if (isFiniteNumber(skippedSegments)) {
                level.skippedSegments = skippedSegments;
                for (let _i = skippedSegments; _i--; ) {
                  fragments.unshift(null);
                }
                currentSN += skippedSegments;
              }
              const recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
              if (recentlyRemovedDateranges) {
                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split("	");
              }
              break;
            }
            case "TARGETDURATION":
              level.targetduration = Math.max(parseInt(value1), 1);
              break;
            case "VERSION":
              level.version = parseInt(value1);
              break;
            case "EXTM3U":
              break;
            case "ENDLIST":
              level.live = false;
              break;
            case "#":
              if (value1 || value2) {
                frag.tagList.push(value2 ? [value1, value2] : [value1]);
              }
              break;
            case "DISCONTINUITY":
              discontinuityCounter++;
              frag.tagList.push(["DIS"]);
              break;
            case "GAP":
              frag.gap = true;
              frag.tagList.push([tag]);
              break;
            case "BITRATE":
              frag.tagList.push([tag, value1]);
              break;
            case "DATERANGE": {
              const dateRangeAttr = new AttrList(value1);
              {
                substituteVariablesInAttributes(level, dateRangeAttr, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]);
                substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);
              }
              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
              if (dateRange.isValid || level.skippedSegments) {
                level.dateRanges[dateRange.id] = dateRange;
              } else {
                logger.warn(`Ignoring invalid DATERANGE tag: "${value1}"`);
              }
              frag.tagList.push(["EXT-X-DATERANGE", value1]);
              break;
            }
            case "DEFINE": {
              {
                const variableAttributes = new AttrList(value1);
                substituteVariablesInAttributes(level, variableAttributes, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]);
                if ("IMPORT" in variableAttributes) {
                  importVariableDefinition(level, variableAttributes, multivariantVariableList);
                } else {
                  addVariableDefinition(level, variableAttributes, baseurl);
                }
              }
              break;
            }
            case "DISCONTINUITY-SEQUENCE":
              discontinuityCounter = parseInt(value1);
              break;
            case "KEY": {
              const levelKey = parseKey(value1, baseurl, level);
              if (levelKey.isSupported()) {
                if (levelKey.method === "NONE") {
                  levelkeys = void 0;
                  break;
                }
                if (!levelkeys) {
                  levelkeys = {};
                }
                if (levelkeys[levelKey.keyFormat]) {
                  levelkeys = _extends2({}, levelkeys);
                }
                levelkeys[levelKey.keyFormat] = levelKey;
              } else {
                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${value1}"`);
              }
              break;
            }
            case "START":
              level.startTimeOffset = parseStartTimeOffset(value1);
              break;
            case "MAP": {
              const mapAttrs = new AttrList(value1);
              {
                substituteVariablesInAttributes(level, mapAttrs, ["BYTERANGE", "URI"]);
              }
              if (frag.duration) {
                const init = new Fragment3(type, baseurl);
                setInitSegment(init, mapAttrs, id, levelkeys);
                currentInitSegment = init;
                frag.initSegment = currentInitSegment;
                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                }
              } else {
                setInitSegment(frag, mapAttrs, id, levelkeys);
                currentInitSegment = frag;
                createNextFrag = true;
              }
              break;
            }
            case "SERVER-CONTROL": {
              const serverControlAttrs = new AttrList(value1);
              level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
              level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
              level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
              level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
              break;
            }
            case "PART-INF": {
              const partInfAttrs = new AttrList(value1);
              level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
              break;
            }
            case "PART": {
              let partList = level.partList;
              if (!partList) {
                partList = level.partList = [];
              }
              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : void 0;
              const index2 = currentPart++;
              const partAttrs = new AttrList(value1);
              {
                substituteVariablesInAttributes(level, partAttrs, ["BYTERANGE", "URI"]);
              }
              const part = new Part(partAttrs, frag, baseurl, index2, previousFragmentPart);
              partList.push(part);
              frag.duration += part.duration;
              break;
            }
            case "PRELOAD-HINT": {
              const preloadHintAttrs = new AttrList(value1);
              {
                substituteVariablesInAttributes(level, preloadHintAttrs, ["URI"]);
              }
              level.preloadHint = preloadHintAttrs;
              break;
            }
            case "RENDITION-REPORT": {
              const renditionReportAttrs = new AttrList(value1);
              {
                substituteVariablesInAttributes(level, renditionReportAttrs, ["URI"]);
              }
              level.renditionReports = level.renditionReports || [];
              level.renditionReports.push(renditionReportAttrs);
              break;
            }
            default:
              logger.warn(`line parsed but not handled: ${result}`);
              break;
          }
        }
      }
      if (prevFrag && !prevFrag.relurl) {
        fragments.pop();
        totalduration -= prevFrag.duration;
        if (level.partList) {
          level.fragmentHint = prevFrag;
        }
      } else if (level.partList) {
        assignProgramDateTime(frag, prevFrag);
        frag.cc = discontinuityCounter;
        level.fragmentHint = frag;
        if (levelkeys) {
          setFragLevelKeys(frag, levelkeys, level);
        }
      }
      const fragmentLength = fragments.length;
      const firstFragment = fragments[0];
      const lastFragment = fragments[fragmentLength - 1];
      totalduration += level.skippedSegments * level.targetduration;
      if (totalduration > 0 && fragmentLength && lastFragment) {
        level.averagetargetduration = totalduration / fragmentLength;
        const lastSn = lastFragment.sn;
        level.endSN = lastSn !== "initSegment" ? lastSn : 0;
        if (!level.live) {
          lastFragment.endList = true;
        }
        if (firstFragment) {
          level.startCC = firstFragment.cc;
        }
      } else {
        level.endSN = 0;
        level.startCC = 0;
      }
      if (level.fragmentHint) {
        totalduration += level.fragmentHint.duration;
      }
      level.totalduration = totalduration;
      level.endCC = discontinuityCounter;
      if (firstPdtIndex > 0) {
        backfillProgramDateTimes(fragments, firstPdtIndex);
      }
      return level;
    }
  };
  function parseKey(keyTagAttributes, baseurl, parsed) {
    var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
    const keyAttrs = new AttrList(keyTagAttributes);
    {
      substituteVariablesInAttributes(parsed, keyAttrs, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
    }
    const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : "";
    const decrypturi = keyAttrs.URI;
    const decryptiv = keyAttrs.hexadecimalInteger("IV");
    const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
    const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : "identity";
    if (decrypturi && keyAttrs.IV && !decryptiv) {
      logger.error(`Invalid IV: ${keyAttrs.IV}`);
    }
    const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
    const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
    return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
  }
  function parseStartTimeOffset(startAttributes) {
    const startAttrs = new AttrList(startAttributes);
    const startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
    if (isFiniteNumber(startTimeOffset)) {
      return startTimeOffset;
    }
    return null;
  }
  function setCodecs(codecs, level) {
    ["video", "audio", "text"].forEach((type) => {
      const filtered = codecs.filter((codec) => isCodecType(codec, type));
      if (filtered.length) {
        const preferred = filtered.filter((codec) => {
          return codec.lastIndexOf("avc1", 0) === 0 || codec.lastIndexOf("mp4a", 0) === 0;
        });
        level[`${type}Codec`] = preferred.length > 0 ? preferred[0] : filtered[0];
        codecs = codecs.filter((codec) => filtered.indexOf(codec) === -1);
      }
    });
    level.unknownCodecs = codecs;
  }
  function assignCodec(media, groupItem, codecProperty) {
    const codecValue = groupItem[codecProperty];
    if (codecValue) {
      media[codecProperty] = codecValue;
    }
  }
  function backfillProgramDateTimes(fragments, firstPdtIndex) {
    let fragPrev = fragments[firstPdtIndex];
    for (let i2 = firstPdtIndex; i2--; ) {
      const frag = fragments[i2];
      if (!frag) {
        return;
      }
      frag.programDateTime = fragPrev.programDateTime - frag.duration * 1e3;
      fragPrev = frag;
    }
  }
  function assignProgramDateTime(frag, prevFrag) {
    if (frag.rawProgramDateTime) {
      frag.programDateTime = Date.parse(frag.rawProgramDateTime);
    } else if (prevFrag != null && prevFrag.programDateTime) {
      frag.programDateTime = prevFrag.endProgramDateTime;
    }
    if (!isFiniteNumber(frag.programDateTime)) {
      frag.programDateTime = null;
      frag.rawProgramDateTime = null;
    }
  }
  function setInitSegment(frag, mapAttrs, id, levelkeys) {
    frag.relurl = mapAttrs.URI;
    if (mapAttrs.BYTERANGE) {
      frag.setByteRange(mapAttrs.BYTERANGE);
    }
    frag.level = id;
    frag.sn = "initSegment";
    if (levelkeys) {
      frag.levelkeys = levelkeys;
    }
    frag.initSegment = null;
  }
  function setFragLevelKeys(frag, levelkeys, level) {
    frag.levelkeys = levelkeys;
    const {
      encryptedFragments
    } = level;
    if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some((format) => levelkeys[format].isCommonEncryption)) {
      encryptedFragments.push(frag);
    }
  }
  var PlaylistContextType = {
    MANIFEST: "manifest",
    LEVEL: "level",
    AUDIO_TRACK: "audioTrack",
    SUBTITLE_TRACK: "subtitleTrack"
  };
  var PlaylistLevelType = {
    MAIN: "main",
    AUDIO: "audio",
    SUBTITLE: "subtitle"
  };
  function mapContextToLevelType(context) {
    const {
      type
    } = context;
    switch (type) {
      case PlaylistContextType.AUDIO_TRACK:
        return PlaylistLevelType.AUDIO;
      case PlaylistContextType.SUBTITLE_TRACK:
        return PlaylistLevelType.SUBTITLE;
      default:
        return PlaylistLevelType.MAIN;
    }
  }
  function getResponseUrl(response, context) {
    let url = response.url;
    if (url === void 0 || url.indexOf("data:") === 0) {
      url = context.url;
    }
    return url;
  }
  var PlaylistLoader = class {
    constructor(hls) {
      this.hls = void 0;
      this.loaders = /* @__PURE__ */ Object.create(null);
      this.variableList = null;
      this.hls = hls;
      this.registerListeners();
    }
    startLoad(startPosition) {
    }
    stopLoad() {
      this.destroyInternalLoaders();
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
      hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
    }
    createInternalLoader(context) {
      const config = this.hls.config;
      const PLoader = config.pLoader;
      const Loader = config.loader;
      const InternalLoader = PLoader || Loader;
      const loader = new InternalLoader(config);
      this.loaders[context.type] = loader;
      return loader;
    }
    getInternalLoader(context) {
      return this.loaders[context.type];
    }
    resetInternalLoader(contextType) {
      if (this.loaders[contextType]) {
        delete this.loaders[contextType];
      }
    }
    destroyInternalLoaders() {
      for (const contextType in this.loaders) {
        const loader = this.loaders[contextType];
        if (loader) {
          loader.destroy();
        }
        this.resetInternalLoader(contextType);
      }
    }
    destroy() {
      this.variableList = null;
      this.unregisterListeners();
      this.destroyInternalLoaders();
    }
    onManifestLoading(event, data) {
      const {
        url
      } = data;
      this.variableList = null;
      this.load({
        id: null,
        level: 0,
        responseType: "text",
        type: PlaylistContextType.MANIFEST,
        url,
        deliveryDirectives: null
      });
    }
    onLevelLoading(event, data) {
      const {
        id,
        level,
        url,
        deliveryDirectives
      } = data;
      this.load({
        id,
        level,
        responseType: "text",
        type: PlaylistContextType.LEVEL,
        url,
        deliveryDirectives
      });
    }
    onAudioTrackLoading(event, data) {
      const {
        id,
        groupId,
        url,
        deliveryDirectives
      } = data;
      this.load({
        id,
        groupId,
        level: null,
        responseType: "text",
        type: PlaylistContextType.AUDIO_TRACK,
        url,
        deliveryDirectives
      });
    }
    onSubtitleTrackLoading(event, data) {
      const {
        id,
        groupId,
        url,
        deliveryDirectives
      } = data;
      this.load({
        id,
        groupId,
        level: null,
        responseType: "text",
        type: PlaylistContextType.SUBTITLE_TRACK,
        url,
        deliveryDirectives
      });
    }
    load(context) {
      var _context$deliveryDire;
      const config = this.hls.config;
      let loader = this.getInternalLoader(context);
      if (loader) {
        const loaderContext = loader.context;
        if (loaderContext && loaderContext.url === context.url) {
          logger.trace("[playlist-loader]: playlist request ongoing");
          return;
        }
        logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);
        loader.abort();
      }
      let loadPolicy;
      if (context.type === PlaylistContextType.MANIFEST) {
        loadPolicy = config.manifestLoadPolicy.default;
      } else {
        loadPolicy = _extends2({}, config.playlistLoadPolicy.default, {
          timeoutRetry: null,
          errorRetry: null
        });
      }
      loader = this.createInternalLoader(context);
      if ((_context$deliveryDire = context.deliveryDirectives) != null && _context$deliveryDire.part) {
        let levelDetails;
        if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
          levelDetails = this.hls.levels[context.level].details;
        } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
          levelDetails = this.hls.audioTracks[context.id].details;
        } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
          levelDetails = this.hls.subtitleTracks[context.id].details;
        }
        if (levelDetails) {
          const partTarget = levelDetails.partTarget;
          const targetDuration = levelDetails.targetduration;
          if (partTarget && targetDuration) {
            const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1e3;
            loadPolicy = _extends2({}, loadPolicy, {
              maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
              maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
            });
          }
        }
      }
      const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
      };
      const loaderCallbacks = {
        onSuccess: (response, stats, context2, networkDetails) => {
          const loader2 = this.getInternalLoader(context2);
          this.resetInternalLoader(context2.type);
          const string2 = response.data;
          if (string2.indexOf("#EXTM3U") !== 0) {
            this.handleManifestParsingError(response, context2, new Error("no EXTM3U delimiter"), networkDetails || null, stats);
            return;
          }
          stats.parsing.start = performance.now();
          if (M3U8Parser.isMediaPlaylist(string2)) {
            this.handleTrackOrLevelPlaylist(response, stats, context2, networkDetails || null, loader2);
          } else {
            this.handleMasterPlaylist(response, stats, context2, networkDetails);
          }
        },
        onError: (response, context2, networkDetails, stats) => {
          this.handleNetworkError(context2, networkDetails, false, response, stats);
        },
        onTimeout: (stats, context2, networkDetails) => {
          this.handleNetworkError(context2, networkDetails, true, void 0, stats);
        }
      };
      loader.load(context, loaderConfig, loaderCallbacks);
    }
    handleMasterPlaylist(response, stats, context, networkDetails) {
      const hls = this.hls;
      const string2 = response.data;
      const url = getResponseUrl(response, context);
      const parsedResult = M3U8Parser.parseMasterPlaylist(string2, url);
      if (parsedResult.playlistParsingError) {
        this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
        return;
      }
      const {
        contentSteering,
        levels,
        sessionData,
        sessionKeys,
        startTimeOffset,
        variableList
      } = parsedResult;
      this.variableList = variableList;
      const {
        AUDIO: audioTracks = [],
        SUBTITLES: subtitles,
        "CLOSED-CAPTIONS": captions
      } = M3U8Parser.parseMasterPlaylistMedia(string2, url, parsedResult);
      if (audioTracks.length) {
        const embeddedAudioFound = audioTracks.some((audioTrack) => !audioTrack.url);
        if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
          logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
          audioTracks.unshift({
            type: "main",
            name: "main",
            groupId: "main",
            default: false,
            autoselect: false,
            forced: false,
            id: -1,
            attrs: new AttrList({}),
            bitrate: 0,
            url: ""
          });
        }
      }
      hls.trigger(Events.MANIFEST_LOADED, {
        levels,
        audioTracks,
        subtitles,
        captions,
        contentSteering,
        url,
        stats,
        networkDetails,
        sessionData,
        sessionKeys,
        startTimeOffset,
        variableList
      });
    }
    handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
      const hls = this.hls;
      const {
        id,
        level,
        type
      } = context;
      const url = getResponseUrl(response, context);
      const levelUrlId = isFiniteNumber(id) ? id : 0;
      const levelId = isFiniteNumber(level) ? level : levelUrlId;
      const levelType = mapContextToLevelType(context);
      const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);
      if (type === PlaylistContextType.MANIFEST) {
        const singleLevel = {
          attrs: new AttrList({}),
          bitrate: 0,
          details: levelDetails,
          name: "",
          url
        };
        hls.trigger(Events.MANIFEST_LOADED, {
          levels: [singleLevel],
          audioTracks: [],
          url,
          stats,
          networkDetails,
          sessionData: null,
          sessionKeys: null,
          contentSteering: null,
          startTimeOffset: null,
          variableList: null
        });
      }
      stats.parsing.end = performance.now();
      context.levelDetails = levelDetails;
      this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
    }
    handleManifestParsingError(response, context, error, networkDetails, stats) {
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.MANIFEST_PARSING_ERROR,
        fatal: context.type === PlaylistContextType.MANIFEST,
        url: response.url,
        err: error,
        error,
        reason: error.message,
        response,
        context,
        networkDetails,
        stats
      });
    }
    handleNetworkError(context, networkDetails, timeout = false, response, stats) {
      let message = `A network ${timeout ? "timeout" : "error" + (response ? " (status " + response.code + ")" : "")} occurred while loading ${context.type}`;
      if (context.type === PlaylistContextType.LEVEL) {
        message += `: ${context.level} id: ${context.id}`;
      } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
        message += ` id: ${context.id} group-id: "${context.groupId}"`;
      }
      const error = new Error(message);
      logger.warn(`[playlist-loader]: ${message}`);
      let details = ErrorDetails.UNKNOWN;
      let fatal = false;
      const loader = this.getInternalLoader(context);
      switch (context.type) {
        case PlaylistContextType.MANIFEST:
          details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
          fatal = true;
          break;
        case PlaylistContextType.LEVEL:
          details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.AUDIO_TRACK:
          details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
          fatal = false;
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
          fatal = false;
          break;
      }
      if (loader) {
        this.resetInternalLoader(context.type);
      }
      const errorData = {
        type: ErrorTypes.NETWORK_ERROR,
        details,
        fatal,
        url: context.url,
        loader,
        context,
        error,
        networkDetails,
        stats
      };
      if (response) {
        const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;
        errorData.response = _objectSpread22({
          url,
          data: void 0
        }, response);
      }
      this.hls.trigger(Events.ERROR, errorData);
    }
    handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
      const hls = this.hls;
      const {
        type,
        level,
        id,
        groupId,
        deliveryDirectives
      } = context;
      const url = getResponseUrl(response, context);
      const parent = mapContextToLevelType(context);
      const levelIndex = typeof context.level === "number" && parent === PlaylistLevelType.MAIN ? level : void 0;
      if (!levelDetails.fragments.length) {
        const _error = new Error("No Segments found in Playlist");
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.LEVEL_EMPTY_ERROR,
          fatal: false,
          url,
          error: _error,
          reason: _error.message,
          response,
          context,
          level: levelIndex,
          parent,
          networkDetails,
          stats
        });
        return;
      }
      if (!levelDetails.targetduration) {
        levelDetails.playlistParsingError = new Error("Missing Target Duration");
      }
      const error = levelDetails.playlistParsingError;
      if (error) {
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.LEVEL_PARSING_ERROR,
          fatal: false,
          url,
          error,
          reason: error.message,
          response,
          context,
          level: levelIndex,
          parent,
          networkDetails,
          stats
        });
        return;
      }
      if (levelDetails.live && loader) {
        if (loader.getCacheAge) {
          levelDetails.ageHeader = loader.getCacheAge() || 0;
        }
        if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
          levelDetails.ageHeader = 0;
        }
      }
      switch (type) {
        case PlaylistContextType.MANIFEST:
        case PlaylistContextType.LEVEL:
          hls.trigger(Events.LEVEL_LOADED, {
            details: levelDetails,
            level: levelIndex || 0,
            id: id || 0,
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
        case PlaylistContextType.AUDIO_TRACK:
          hls.trigger(Events.AUDIO_TRACK_LOADED, {
            details: levelDetails,
            id: id || 0,
            groupId: groupId || "",
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
        case PlaylistContextType.SUBTITLE_TRACK:
          hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
            details: levelDetails,
            id: id || 0,
            groupId: groupId || "",
            stats,
            networkDetails,
            deliveryDirectives
          });
          break;
      }
    }
  };
  function sendAddTrackEvent(track, videoEl) {
    let event;
    try {
      event = new Event("addtrack");
    } catch (err) {
      event = document.createEvent("Event");
      event.initEvent("addtrack", false, false);
    }
    event.track = track;
    videoEl.dispatchEvent(event);
  }
  function addCueToTrack(track, cue) {
    const mode = track.mode;
    if (mode === "disabled") {
      track.mode = "hidden";
    }
    if (track.cues && !track.cues.getCueById(cue.id)) {
      try {
        track.addCue(cue);
        if (!track.cues.getCueById(cue.id)) {
          throw new Error(`addCue is failed for: ${cue}`);
        }
      } catch (err) {
        logger.debug(`[texttrack-utils]: ${err}`);
        try {
          const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
          textTrackCue.id = cue.id;
          track.addCue(textTrackCue);
        } catch (err2) {
          logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);
        }
      }
    }
    if (mode === "disabled") {
      track.mode = mode;
    }
  }
  function clearCurrentCues(track) {
    const mode = track.mode;
    if (mode === "disabled") {
      track.mode = "hidden";
    }
    if (track.cues) {
      for (let i2 = track.cues.length; i2--; ) {
        track.removeCue(track.cues[i2]);
      }
    }
    if (mode === "disabled") {
      track.mode = mode;
    }
  }
  function removeCuesInRange(track, start, end, predicate) {
    const mode = track.mode;
    if (mode === "disabled") {
      track.mode = "hidden";
    }
    if (track.cues && track.cues.length > 0) {
      const cues = getCuesInRange(track.cues, start, end);
      for (let i2 = 0; i2 < cues.length; i2++) {
        if (!predicate || predicate(cues[i2])) {
          track.removeCue(cues[i2]);
        }
      }
    }
    if (mode === "disabled") {
      track.mode = mode;
    }
  }
  function getFirstCueIndexAfterTime(cues, time) {
    if (time < cues[0].startTime) {
      return 0;
    }
    const len = cues.length - 1;
    if (time > cues[len].endTime) {
      return -1;
    }
    let left = 0;
    let right = len;
    while (left <= right) {
      const mid = Math.floor((right + left) / 2);
      if (time < cues[mid].startTime) {
        right = mid - 1;
      } else if (time > cues[mid].startTime && left < len) {
        left = mid + 1;
      } else {
        return mid;
      }
    }
    return cues[left].startTime - time < time - cues[right].startTime ? left : right;
  }
  function getCuesInRange(cues, start, end) {
    const cuesFound = [];
    const firstCueInRange = getFirstCueIndexAfterTime(cues, start);
    if (firstCueInRange > -1) {
      for (let i2 = firstCueInRange, len = cues.length; i2 < len; i2++) {
        const cue = cues[i2];
        if (cue.startTime >= start && cue.endTime <= end) {
          cuesFound.push(cue);
        } else if (cue.startTime > end) {
          return cuesFound;
        }
      }
    }
    return cuesFound;
  }
  var MetadataSchema = {
    audioId3: "org.id3",
    dateRange: "com.apple.quicktime.HLS",
    emsg: "https://aomedia.org/emsg/ID3"
  };
  var MIN_CUE_DURATION = 0.25;
  function getCueClass() {
    if (typeof self === "undefined")
      return void 0;
    return self.WebKitDataCue || self.VTTCue || self.TextTrackCue;
  }
  var MAX_CUE_ENDTIME = (() => {
    const Cue = getCueClass();
    try {
      new Cue(0, Number.POSITIVE_INFINITY, "");
    } catch (e3) {
      return Number.MAX_VALUE;
    }
    return Number.POSITIVE_INFINITY;
  })();
  function dateRangeDateToTimelineSeconds(date, offset2) {
    return date.getTime() / 1e3 - offset2;
  }
  function hexToArrayBuffer(str) {
    return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
  }
  var ID3TrackController = class {
    constructor(hls) {
      this.hls = void 0;
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      this.hls = hls;
      this._registerListeners();
    }
    destroy() {
      this._unregisterListeners();
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
      this.hls = null;
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    onMediaAttached(event, data) {
      this.media = data.media;
    }
    onMediaDetaching() {
      if (!this.id3Track) {
        return;
      }
      clearCurrentCues(this.id3Track);
      this.id3Track = null;
      this.media = null;
      this.dateRangeCuesAppended = {};
    }
    onManifestLoading() {
      this.dateRangeCuesAppended = {};
    }
    createTrack(media) {
      const track = this.getID3Track(media.textTracks);
      track.mode = "hidden";
      return track;
    }
    getID3Track(textTracks) {
      if (!this.media) {
        return;
      }
      for (let i2 = 0; i2 < textTracks.length; i2++) {
        const textTrack = textTracks[i2];
        if (textTrack.kind === "metadata" && textTrack.label === "id3") {
          sendAddTrackEvent(textTrack, this.media);
          return textTrack;
        }
      }
      return this.media.addTextTrack("metadata", "id3");
    }
    onFragParsingMetadata(event, data) {
      if (!this.media) {
        return;
      }
      const {
        hls: {
          config: {
            enableEmsgMetadataCues,
            enableID3MetadataCues
          }
        }
      } = this;
      if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
        return;
      }
      const {
        samples
      } = data;
      if (!this.id3Track) {
        this.id3Track = this.createTrack(this.media);
      }
      const Cue = getCueClass();
      for (let i2 = 0; i2 < samples.length; i2++) {
        const type = samples[i2].type;
        if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
          continue;
        }
        const frames = getID3Frames(samples[i2].data);
        if (frames) {
          const startTime = samples[i2].pts;
          let endTime = startTime + samples[i2].duration;
          if (endTime > MAX_CUE_ENDTIME) {
            endTime = MAX_CUE_ENDTIME;
          }
          const timeDiff = endTime - startTime;
          if (timeDiff <= 0) {
            endTime = startTime + MIN_CUE_DURATION;
          }
          for (let j3 = 0; j3 < frames.length; j3++) {
            const frame = frames[j3];
            if (!isTimeStampFrame(frame)) {
              this.updateId3CueEnds(startTime, type);
              const cue = new Cue(startTime, endTime, "");
              cue.value = frame;
              if (type) {
                cue.type = type;
              }
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
    updateId3CueEnds(startTime, type) {
      var _this$id3Track;
      const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;
      if (cues) {
        for (let i2 = cues.length; i2--; ) {
          const cue = cues[i2];
          if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
            cue.endTime = startTime;
          }
        }
      }
    }
    onBufferFlushing(event, {
      startOffset,
      endOffset,
      type
    }) {
      const {
        id3Track,
        hls
      } = this;
      if (!hls) {
        return;
      }
      const {
        config: {
          enableEmsgMetadataCues,
          enableID3MetadataCues
        }
      } = hls;
      if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
        let predicate;
        if (type === "audio") {
          predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
        } else if (type === "video") {
          predicate = (cue) => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
        } else {
          predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
        }
        removeCuesInRange(id3Track, startOffset, endOffset, predicate);
      }
    }
    onLevelUpdated(event, {
      details
    }) {
      if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
        return;
      }
      const {
        dateRangeCuesAppended,
        id3Track
      } = this;
      const {
        dateRanges
      } = details;
      const ids = Object.keys(dateRanges);
      if (id3Track) {
        const idsToRemove = Object.keys(dateRangeCuesAppended).filter((id) => !ids.includes(id));
        for (let i2 = idsToRemove.length; i2--; ) {
          const id = idsToRemove[i2];
          Object.keys(dateRangeCuesAppended[id].cues).forEach((key) => {
            id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
          });
          delete dateRangeCuesAppended[id];
        }
      }
      const lastFragment = details.fragments[details.fragments.length - 1];
      if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {
        return;
      }
      if (!this.id3Track) {
        this.id3Track = this.createTrack(this.media);
      }
      const dateTimeOffset = lastFragment.programDateTime / 1e3 - lastFragment.start;
      const Cue = getCueClass();
      for (let i2 = 0; i2 < ids.length; i2++) {
        const id = ids[i2];
        const dateRange = dateRanges[id];
        const appendedDateRangeCues = dateRangeCuesAppended[id];
        const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};
        let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;
        const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);
        let endTime = MAX_CUE_ENDTIME;
        const endDate = dateRange.endDate;
        if (endDate) {
          endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
          durationKnown = true;
        } else if (dateRange.endOnNext && !durationKnown) {
          const nextDateRangeWithSameClass = ids.reduce((filterMapArray, id2) => {
            const candidate = dateRanges[id2];
            if (candidate.class === dateRange.class && candidate.id !== id2 && candidate.startDate > dateRange.startDate) {
              filterMapArray.push(candidate);
            }
            return filterMapArray;
          }, []).sort((a2, b3) => a2.startDate.getTime() - b3.startDate.getTime())[0];
          if (nextDateRangeWithSameClass) {
            endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
            durationKnown = true;
          }
        }
        const attributes = Object.keys(dateRange.attr);
        for (let j3 = 0; j3 < attributes.length; j3++) {
          const key = attributes[j3];
          if (!isDateRangeCueAttribute(key)) {
            continue;
          }
          let cue = cues[key];
          if (cue) {
            if (durationKnown && !appendedDateRangeCues.durationKnown) {
              cue.endTime = endTime;
            }
          } else {
            let data = dateRange.attr[key];
            cue = new Cue(startTime, endTime, "");
            if (isSCTE35Attribute(key)) {
              data = hexToArrayBuffer(data);
            }
            cue.value = {
              key,
              data
            };
            cue.type = MetadataSchema.dateRange;
            cue.id = id;
            this.id3Track.addCue(cue);
            cues[key] = cue;
          }
        }
        dateRangeCuesAppended[id] = {
          cues,
          dateRange,
          durationKnown
        };
      }
    }
  };
  var LatencyController = class {
    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = null;
      this.levelDetails = null;
      this.currentTime = 0;
      this.stallCount = 0;
      this._latency = null;
      this.timeupdateHandler = () => this.timeupdate();
      this.hls = hls;
      this.config = hls.config;
      this.registerListeners();
    }
    get latency() {
      return this._latency || 0;
    }
    get maxLatency() {
      const {
        config,
        levelDetails
      } = this;
      if (config.liveMaxLatencyDuration !== void 0) {
        return config.liveMaxLatencyDuration;
      }
      return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
    }
    get targetLatency() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return null;
      }
      const {
        holdBack,
        partHoldBack,
        targetduration
      } = levelDetails;
      const {
        liveSyncDuration,
        liveSyncDurationCount,
        lowLatencyMode
      } = this.config;
      const userConfig = this.hls.userConfig;
      let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
      if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
        targetLatency = liveSyncDuration !== void 0 ? liveSyncDuration : liveSyncDurationCount * targetduration;
      }
      const maxLiveSyncOnStallIncrease = targetduration;
      const liveSyncOnStallIncrease = 1;
      return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
    }
    get liveSyncPosition() {
      const liveEdge = this.estimateLiveEdge();
      const targetLatency = this.targetLatency;
      const levelDetails = this.levelDetails;
      if (liveEdge === null || targetLatency === null || levelDetails === null) {
        return null;
      }
      const edge = levelDetails.edge;
      const syncPosition = liveEdge - targetLatency - this.edgeStalled;
      const min2 = edge - levelDetails.totalduration;
      const max2 = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
      return Math.min(Math.max(min2, syncPosition), max2);
    }
    get drift() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return 1;
      }
      return levelDetails.drift;
    }
    get edgeStalled() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return 0;
      }
      const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
      return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
    }
    get forwardBufferLength() {
      const {
        media,
        levelDetails
      } = this;
      if (!media || !levelDetails) {
        return 0;
      }
      const bufferedRanges = media.buffered.length;
      return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetaching();
      this.levelDetails = null;
      this.hls = this.timeupdateHandler = null;
    }
    registerListeners() {
      this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      this.hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      this.hls.off(Events.ERROR, this.onError, this);
    }
    onMediaAttached(event, data) {
      this.media = data.media;
      this.media.addEventListener("timeupdate", this.timeupdateHandler);
    }
    onMediaDetaching() {
      if (this.media) {
        this.media.removeEventListener("timeupdate", this.timeupdateHandler);
        this.media = null;
      }
    }
    onManifestLoading() {
      this.levelDetails = null;
      this._latency = null;
      this.stallCount = 0;
    }
    onLevelUpdated(event, {
      details
    }) {
      this.levelDetails = details;
      if (details.advanced) {
        this.timeupdate();
      }
      if (!details.live && this.media) {
        this.media.removeEventListener("timeupdate", this.timeupdateHandler);
      }
    }
    onError(event, data) {
      var _this$levelDetails;
      if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
        return;
      }
      this.stallCount++;
      if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
        logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency");
      }
    }
    timeupdate() {
      const {
        media,
        levelDetails
      } = this;
      if (!media || !levelDetails) {
        return;
      }
      this.currentTime = media.currentTime;
      const latency = this.computeLatency();
      if (latency === null) {
        return;
      }
      this._latency = latency;
      const {
        lowLatencyMode,
        maxLiveSyncPlaybackRate
      } = this.config;
      if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1) {
        return;
      }
      const targetLatency = this.targetLatency;
      if (targetLatency === null) {
        return;
      }
      const distanceFromTarget = latency - targetLatency;
      const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
      const inLiveRange = distanceFromTarget < liveMinLatencyDuration;
      if (levelDetails.live && inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
        const max2 = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
        const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
        media.playbackRate = Math.min(max2, Math.max(1, rate));
      } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
        media.playbackRate = 1;
      }
    }
    estimateLiveEdge() {
      const {
        levelDetails
      } = this;
      if (levelDetails === null) {
        return null;
      }
      return levelDetails.edge + levelDetails.age;
    }
    computeLatency() {
      const liveEdge = this.estimateLiveEdge();
      if (liveEdge === null) {
        return null;
      }
      return liveEdge - this.currentTime;
    }
  };
  var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", null];
  var HlsSkip = {
    No: "",
    Yes: "YES",
    v2: "v2"
  };
  function getSkipValue(details, msn) {
    const {
      canSkipUntil,
      canSkipDateRanges,
      endSN
    } = details;
    const snChangeGoal = msn !== void 0 ? msn - endSN : 0;
    if (canSkipUntil && snChangeGoal < canSkipUntil) {
      if (canSkipDateRanges) {
        return HlsSkip.v2;
      }
      return HlsSkip.Yes;
    }
    return HlsSkip.No;
  }
  var HlsUrlParameters = class {
    constructor(msn, part, skip) {
      this.msn = void 0;
      this.part = void 0;
      this.skip = void 0;
      this.msn = msn;
      this.part = part;
      this.skip = skip;
    }
    addDirectives(uri) {
      const url = new self.URL(uri);
      if (this.msn !== void 0) {
        url.searchParams.set("_HLS_msn", this.msn.toString());
      }
      if (this.part !== void 0) {
        url.searchParams.set("_HLS_part", this.part.toString());
      }
      if (this.skip) {
        url.searchParams.set("_HLS_skip", this.skip);
      }
      return url.href;
    }
  };
  var Level = class {
    constructor(data) {
      this._attrs = void 0;
      this.audioCodec = void 0;
      this.bitrate = void 0;
      this.codecSet = void 0;
      this.height = void 0;
      this.id = void 0;
      this.name = void 0;
      this.videoCodec = void 0;
      this.width = void 0;
      this.unknownCodecs = void 0;
      this.audioGroupIds = void 0;
      this.details = void 0;
      this.fragmentError = 0;
      this.loadError = 0;
      this.loaded = void 0;
      this.realBitrate = 0;
      this.textGroupIds = void 0;
      this.url = void 0;
      this._urlId = 0;
      this.url = [data.url];
      this._attrs = [data.attrs];
      this.bitrate = data.bitrate;
      if (data.details) {
        this.details = data.details;
      }
      this.id = data.id || 0;
      this.name = data.name;
      this.width = data.width || 0;
      this.height = data.height || 0;
      this.audioCodec = data.audioCodec;
      this.videoCodec = data.videoCodec;
      this.unknownCodecs = data.unknownCodecs;
      this.codecSet = [data.videoCodec, data.audioCodec].filter((c2) => c2).join(",").replace(/\.[^.,]+/g, "");
    }
    get maxBitrate() {
      return Math.max(this.realBitrate, this.bitrate);
    }
    get attrs() {
      return this._attrs[this._urlId];
    }
    get pathwayId() {
      return this.attrs["PATHWAY-ID"] || ".";
    }
    get uri() {
      return this.url[this._urlId] || "";
    }
    get urlId() {
      return this._urlId;
    }
    set urlId(value) {
      const newValue = value % this.url.length;
      if (this._urlId !== newValue) {
        this.fragmentError = 0;
        this.loadError = 0;
        this.details = void 0;
        this._urlId = newValue;
      }
    }
    get audioGroupId() {
      var _this$audioGroupIds;
      return (_this$audioGroupIds = this.audioGroupIds) == null ? void 0 : _this$audioGroupIds[this.urlId];
    }
    get textGroupId() {
      var _this$textGroupIds;
      return (_this$textGroupIds = this.textGroupIds) == null ? void 0 : _this$textGroupIds[this.urlId];
    }
    addFallback(data) {
      this.url.push(data.url);
      this._attrs.push(data.attrs);
    }
  };
  function updateFromToPTS(fragFrom, fragTo) {
    const fragToPTS = fragTo.startPTS;
    if (isFiniteNumber(fragToPTS)) {
      let duration = 0;
      let frag;
      if (fragTo.sn > fragFrom.sn) {
        duration = fragToPTS - fragFrom.start;
        frag = fragFrom;
      } else {
        duration = fragFrom.start - fragToPTS;
        frag = fragTo;
      }
      if (frag.duration !== duration) {
        frag.duration = duration;
      }
    } else if (fragTo.sn > fragFrom.sn) {
      const contiguous = fragFrom.cc === fragTo.cc;
      if (contiguous && fragFrom.minEndPTS) {
        fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
      } else {
        fragTo.start = fragFrom.start + fragFrom.duration;
      }
    } else {
      fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
    }
  }
  function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
    const parsedMediaDuration = endPTS - startPTS;
    if (parsedMediaDuration <= 0) {
      logger.warn("Fragment should have a positive duration", frag);
      endPTS = startPTS + frag.duration;
      endDTS = startDTS + frag.duration;
    }
    let maxStartPTS = startPTS;
    let minEndPTS = endPTS;
    const fragStartPts = frag.startPTS;
    const fragEndPts = frag.endPTS;
    if (isFiniteNumber(fragStartPts)) {
      const deltaPTS = Math.abs(fragStartPts - startPTS);
      if (!isFiniteNumber(frag.deltaPTS)) {
        frag.deltaPTS = deltaPTS;
      } else {
        frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
      }
      maxStartPTS = Math.max(startPTS, fragStartPts);
      startPTS = Math.min(startPTS, fragStartPts);
      startDTS = Math.min(startDTS, frag.startDTS);
      minEndPTS = Math.min(endPTS, fragEndPts);
      endPTS = Math.max(endPTS, fragEndPts);
      endDTS = Math.max(endDTS, frag.endDTS);
    }
    const drift = startPTS - frag.start;
    if (frag.start !== 0) {
      frag.start = startPTS;
    }
    frag.duration = endPTS - frag.start;
    frag.startPTS = startPTS;
    frag.maxStartPTS = maxStartPTS;
    frag.startDTS = startDTS;
    frag.endPTS = endPTS;
    frag.minEndPTS = minEndPTS;
    frag.endDTS = endDTS;
    const sn2 = frag.sn;
    if (!details || sn2 < details.startSN || sn2 > details.endSN) {
      return 0;
    }
    let i2;
    const fragIdx = sn2 - details.startSN;
    const fragments = details.fragments;
    fragments[fragIdx] = frag;
    for (i2 = fragIdx; i2 > 0; i2--) {
      updateFromToPTS(fragments[i2], fragments[i2 - 1]);
    }
    for (i2 = fragIdx; i2 < fragments.length - 1; i2++) {
      updateFromToPTS(fragments[i2], fragments[i2 + 1]);
    }
    if (details.fragmentHint) {
      updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
    }
    details.PTSKnown = details.alignedSliding = true;
    return drift;
  }
  function mergeDetails(oldDetails, newDetails) {
    let currentInitSegment = null;
    const oldFragments = oldDetails.fragments;
    for (let i2 = oldFragments.length - 1; i2 >= 0; i2--) {
      const oldInit = oldFragments[i2].initSegment;
      if (oldInit) {
        currentInitSegment = oldInit;
        break;
      }
    }
    if (oldDetails.fragmentHint) {
      delete oldDetails.fragmentHint.endPTS;
    }
    let ccOffset = 0;
    let PTSFrag;
    mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {
      if (oldFrag.relurl) {
        ccOffset = oldFrag.cc - newFrag.cc;
      }
      if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
        newFrag.start = newFrag.startPTS = oldFrag.startPTS;
        newFrag.startDTS = oldFrag.startDTS;
        newFrag.maxStartPTS = oldFrag.maxStartPTS;
        newFrag.endPTS = oldFrag.endPTS;
        newFrag.endDTS = oldFrag.endDTS;
        newFrag.minEndPTS = oldFrag.minEndPTS;
        newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
        if (newFrag.duration) {
          PTSFrag = newFrag;
        }
        newDetails.PTSKnown = newDetails.alignedSliding = true;
      }
      newFrag.elementaryStreams = oldFrag.elementaryStreams;
      newFrag.loader = oldFrag.loader;
      newFrag.stats = oldFrag.stats;
      newFrag.urlId = oldFrag.urlId;
      if (oldFrag.initSegment) {
        newFrag.initSegment = oldFrag.initSegment;
        currentInitSegment = oldFrag.initSegment;
      }
    });
    if (currentInitSegment) {
      const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
      fragmentsToCheck.forEach((frag) => {
        var _currentInitSegment;
        if (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl)) {
          frag.initSegment = currentInitSegment;
        }
      });
    }
    if (newDetails.skippedSegments) {
      newDetails.deltaUpdateFailed = newDetails.fragments.some((frag) => !frag);
      if (newDetails.deltaUpdateFailed) {
        logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
        for (let i2 = newDetails.skippedSegments; i2--; ) {
          newDetails.fragments.shift();
        }
        newDetails.startSN = newDetails.fragments[0].sn;
        newDetails.startCC = newDetails.fragments[0].cc;
      } else if (newDetails.canSkipDateRanges) {
        newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
      }
    }
    const newFragments = newDetails.fragments;
    if (ccOffset) {
      logger.warn("discontinuity sliding from playlist, take drift into account");
      for (let i2 = 0; i2 < newFragments.length; i2++) {
        newFragments[i2].cc += ccOffset;
      }
    }
    if (newDetails.skippedSegments) {
      newDetails.startCC = newDetails.fragments[0].cc;
    }
    mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {
      newPart.elementaryStreams = oldPart.elementaryStreams;
      newPart.stats = oldPart.stats;
    });
    if (PTSFrag) {
      updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
    } else {
      adjustSliding(oldDetails, newDetails);
    }
    if (newFragments.length) {
      newDetails.totalduration = newDetails.edge - newFragments[0].start;
    }
    newDetails.driftStartTime = oldDetails.driftStartTime;
    newDetails.driftStart = oldDetails.driftStart;
    const advancedDateTime = newDetails.advancedDateTime;
    if (newDetails.advanced && advancedDateTime) {
      const edge = newDetails.edge;
      if (!newDetails.driftStart) {
        newDetails.driftStartTime = advancedDateTime;
        newDetails.driftStart = edge;
      }
      newDetails.driftEndTime = advancedDateTime;
      newDetails.driftEnd = edge;
    } else {
      newDetails.driftEndTime = oldDetails.driftEndTime;
      newDetails.driftEnd = oldDetails.driftEnd;
      newDetails.advancedDateTime = oldDetails.advancedDateTime;
    }
  }
  function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
    const dateRanges = _extends2({}, oldDateRanges);
    if (recentlyRemovedDateranges) {
      recentlyRemovedDateranges.forEach((id) => {
        delete dateRanges[id];
      });
    }
    Object.keys(deltaDateRanges).forEach((id) => {
      const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);
      if (dateRange.isValid) {
        dateRanges[id] = dateRange;
      } else {
        logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(deltaDateRanges[id].attr)}"`);
      }
    });
    return dateRanges;
  }
  function mapPartIntersection(oldParts, newParts, intersectionFn) {
    if (oldParts && newParts) {
      let delta = 0;
      for (let i2 = 0, len = oldParts.length; i2 <= len; i2++) {
        const oldPart = oldParts[i2];
        const newPart = newParts[i2 + delta];
        if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {
          intersectionFn(oldPart, newPart);
        } else {
          delta--;
        }
      }
    }
  }
  function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
    const skippedSegments = newDetails.skippedSegments;
    const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
    const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
    const delta = newDetails.startSN - oldDetails.startSN;
    const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
    const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
    for (let i2 = start; i2 <= end; i2++) {
      const oldFrag = oldFrags[delta + i2];
      let newFrag = newFrags[i2];
      if (skippedSegments && !newFrag && i2 < skippedSegments) {
        newFrag = newDetails.fragments[i2] = oldFrag;
      }
      if (oldFrag && newFrag) {
        intersectionFn(oldFrag, newFrag);
      }
    }
  }
  function adjustSliding(oldDetails, newDetails) {
    const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
    const oldFragments = oldDetails.fragments;
    if (delta < 0 || delta >= oldFragments.length) {
      return;
    }
    addSliding(newDetails, oldFragments[delta].start);
  }
  function addSliding(details, start) {
    if (start) {
      const fragments = details.fragments;
      for (let i2 = details.skippedSegments; i2 < fragments.length; i2++) {
        fragments[i2].start += start;
      }
      if (details.fragmentHint) {
        details.fragmentHint.start += start;
      }
    }
  }
  function computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {
    let reloadInterval = 1e3 * newDetails.targetduration;
    if (newDetails.updated) {
      const fragments = newDetails.fragments;
      const liveEdgeMaxTargetDurations = 4;
      if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
        const lastSegmentDuration = fragments[fragments.length - 1].duration * 1e3;
        if (lastSegmentDuration < reloadInterval) {
          reloadInterval = lastSegmentDuration;
        }
      }
    } else {
      reloadInterval /= 2;
    }
    return Math.round(reloadInterval);
  }
  function getFragmentWithSN(level, sn2, fragCurrent) {
    if (!(level != null && level.details)) {
      return null;
    }
    const levelDetails = level.details;
    let fragment = levelDetails.fragments[sn2 - levelDetails.startSN];
    if (fragment) {
      return fragment;
    }
    fragment = levelDetails.fragmentHint;
    if (fragment && fragment.sn === sn2) {
      return fragment;
    }
    if (sn2 < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn2) {
      return fragCurrent;
    }
    return null;
  }
  function getPartWith(level, sn2, partIndex) {
    var _level$details;
    if (!(level != null && level.details)) {
      return null;
    }
    return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn2, partIndex);
  }
  function findPart(partList, sn2, partIndex) {
    if (partList) {
      for (let i2 = partList.length; i2--; ) {
        const part = partList[i2];
        if (part.index === partIndex && part.fragment.sn === sn2) {
          return part;
        }
      }
    }
    return null;
  }
  function isTimeoutError(error) {
    switch (error.details) {
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
      case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
        return true;
    }
    return false;
  }
  function getRetryConfig(loadPolicy, error) {
    const isTimeout = isTimeoutError(error);
    return loadPolicy.default[`${isTimeout ? "timeout" : "error"}Retry`];
  }
  function getRetryDelay(retryConfig, retryCount) {
    const backoffFactor = retryConfig.backoff === "linear" ? 1 : Math.pow(2, retryCount);
    return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
  }
  function getLoaderConfigWithoutReties(loderConfig) {
    return _objectSpread22(_objectSpread22({}, loderConfig), {
      errorRetry: null,
      timeoutRetry: null
    });
  }
  function shouldRetry(retryConfig, retryCount, isTimeout, httpStatus) {
    return !!retryConfig && retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
  }
  function retryForHttpStatus(httpStatus) {
    return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
  }
  var BinarySearch = {
    search: function(list, comparisonFn) {
      let minIndex = 0;
      let maxIndex = list.length - 1;
      let currentIndex = null;
      let currentElement = null;
      while (minIndex <= maxIndex) {
        currentIndex = (minIndex + maxIndex) / 2 | 0;
        currentElement = list[currentIndex];
        const comparisonResult = comparisonFn(currentElement);
        if (comparisonResult > 0) {
          minIndex = currentIndex + 1;
        } else if (comparisonResult < 0) {
          maxIndex = currentIndex - 1;
        } else {
          return currentElement;
        }
      }
      return null;
    }
  };
  function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
    if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
      return null;
    }
    const startPDT = fragments[0].programDateTime;
    if (PDTValue < (startPDT || 0)) {
      return null;
    }
    const endPDT = fragments[fragments.length - 1].endProgramDateTime;
    if (PDTValue >= (endPDT || 0)) {
      return null;
    }
    maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
    for (let seg = 0; seg < fragments.length; ++seg) {
      const frag = fragments[seg];
      if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
        return frag;
      }
    }
    return null;
  }
  function findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0) {
    let fragNext = null;
    if (fragPrevious) {
      fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
    } else if (bufferEnd === 0 && fragments[0].start === 0) {
      fragNext = fragments[0];
    }
    if (fragNext && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0) {
      return fragNext;
    }
    const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
    if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
      return foundFragment;
    }
    return fragNext;
  }
  function fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {
    if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
      return 0;
    }
    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
    if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
      return 1;
    } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
      return -1;
    }
    return 0;
  }
  function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
    const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1e3;
    const endProgramDateTime = candidate.endProgramDateTime || 0;
    return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
  }
  function findFragWithCC(fragments, cc) {
    return BinarySearch.search(fragments, (candidate) => {
      if (candidate.cc < cc) {
        return 1;
      } else if (candidate.cc > cc) {
        return -1;
      } else {
        return 0;
      }
    });
  }
  var RENDITION_PENALTY_DURATION_MS = 3e5;
  var NetworkErrorAction = {
    DoNothing: 0,
    SendEndCallback: 1,
    SendAlternateToPenaltyBox: 2,
    RemoveAlternatePermanently: 3,
    InsertDiscontinuity: 4,
    RetryRequest: 5
  };
  var ErrorActionFlags = {
    None: 0,
    MoveAllAlternatesMatchingHost: 1,
    MoveAllAlternatesMatchingHDCP: 2,
    SwitchToSDR: 4
  };
  var ErrorController = class {
    constructor(hls) {
      this.hls = void 0;
      this.playlistError = 0;
      this.penalizedRenditions = {};
      this.log = void 0;
      this.warn = void 0;
      this.error = void 0;
      this.hls = hls;
      this.log = logger.log.bind(logger, `[info]:`);
      this.warn = logger.warn.bind(logger, `[warning]:`);
      this.error = logger.error.bind(logger, `[error]:`);
      this.registerListeners();
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events.ERROR, this.onError, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events.ERROR, this.onError, this);
      hls.off(Events.ERROR, this.onErrorOut, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    }
    destroy() {
      this.unregisterListeners();
      this.hls = null;
      this.penalizedRenditions = {};
    }
    startLoad(startPosition) {
      this.playlistError = 0;
    }
    stopLoad() {
    }
    getVariantLevelIndex(frag) {
      return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
    }
    onManifestLoading() {
      this.playlistError = 0;
      this.penalizedRenditions = {};
    }
    onLevelUpdated() {
      this.playlistError = 0;
    }
    onError(event, data) {
      var _data$frag, _data$level;
      if (data.fatal) {
        return;
      }
      const hls = this.hls;
      const context = data.context;
      switch (data.details) {
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          data.errorAction = this.getFragRetryOrSwitchAction(data);
          return;
        case ErrorDetails.FRAG_PARSING_ERROR:
          if ((_data$frag = data.frag) != null && _data$frag.gap) {
            data.errorAction = {
              action: NetworkErrorAction.DoNothing,
              flags: ErrorActionFlags.None
            };
            return;
          }
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_DECRYPT_ERROR: {
          data.errorAction = this.getFragRetryOrSwitchAction(data);
          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
          return;
        }
        case ErrorDetails.LEVEL_EMPTY_ERROR:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          {
            var _data$context, _data$context$levelDe;
            const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
            if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
            } else {
              data.levelRetry = false;
              data.errorAction = this.getLevelSwitchAction(data, levelIndex);
            }
          }
          return;
        case ErrorDetails.LEVEL_LOAD_ERROR:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
          if (typeof (context == null ? void 0 : context.level) === "number") {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
          }
          return;
        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case ErrorDetails.SUBTITLE_LOAD_ERROR:
        case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
          if (context) {
            const level = hls.levels[hls.loadLevel];
            if (level && (context.type === PlaylistContextType.AUDIO_TRACK && context.groupId === level.audioGroupId || context.type === PlaylistContextType.SUBTITLE_TRACK && context.groupId === level.textGroupId)) {
              data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
              data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
              return;
            }
          }
          return;
        case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
          {
            const level = hls.levels[hls.loadLevel];
            const restrictedHdcpLevel = level == null ? void 0 : level.attrs["HDCP-LEVEL"];
            if (restrictedHdcpLevel) {
              data.errorAction = {
                action: NetworkErrorAction.SendAlternateToPenaltyBox,
                flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
                hdcpLevel: restrictedHdcpLevel
              };
            }
          }
          return;
        case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
        case ErrorDetails.REMUX_ALLOC_ERROR:
          data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
          return;
        case ErrorDetails.INTERNAL_EXCEPTION:
        case ErrorDetails.BUFFER_APPENDING_ERROR:
        case ErrorDetails.BUFFER_APPEND_ERROR:
        case ErrorDetails.BUFFER_FULL_ERROR:
        case ErrorDetails.LEVEL_SWITCH_ERROR:
        case ErrorDetails.BUFFER_STALLED_ERROR:
        case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
        case ErrorDetails.BUFFER_NUDGE_ON_STALL:
          data.errorAction = {
            action: NetworkErrorAction.DoNothing,
            flags: ErrorActionFlags.None
          };
          return;
      }
      if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
        const levelIndex = this.getVariantLevelIndex(data.frag);
        data.levelRetry = false;
        data.errorAction = this.getLevelSwitchAction(data, levelIndex);
        return;
      }
    }
    getPlaylistRetryOrSwitchAction(data, levelIndex) {
      var _data$response;
      const hls = this.hls;
      const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
      const retryCount = this.playlistError++;
      const httpStatus = (_data$response = data.response) == null ? void 0 : _data$response.code;
      const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), httpStatus);
      if (retry) {
        return {
          action: NetworkErrorAction.RetryRequest,
          flags: ErrorActionFlags.None,
          retryConfig,
          retryCount
        };
      }
      const errorAction = this.getLevelSwitchAction(data, levelIndex);
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = retryCount;
      }
      return errorAction;
    }
    getFragRetryOrSwitchAction(data) {
      const hls = this.hls;
      const variantLevelIndex = this.getVariantLevelIndex(data.frag);
      const level = hls.levels[variantLevelIndex];
      const {
        fragLoadPolicy,
        keyLoadPolicy
      } = hls.config;
      const retryConfig = getRetryConfig(data.details.startsWith("key") ? keyLoadPolicy : fragLoadPolicy, data);
      const fragmentErrors = hls.levels.reduce((acc, level2) => acc + level2.fragmentError, 0);
      if (level) {
        var _data$response2;
        if (data.details !== ErrorDetails.FRAG_GAP) {
          level.fragmentError++;
        }
        const httpStatus = (_data$response2 = data.response) == null ? void 0 : _data$response2.code;
        const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), httpStatus);
        if (retry) {
          return {
            action: NetworkErrorAction.RetryRequest,
            flags: ErrorActionFlags.None,
            retryConfig,
            retryCount: fragmentErrors
          };
        }
      }
      const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
      if (retryConfig) {
        errorAction.retryConfig = retryConfig;
        errorAction.retryCount = fragmentErrors;
      }
      return errorAction;
    }
    getLevelSwitchAction(data, levelIndex) {
      const hls = this.hls;
      if (levelIndex === null || levelIndex === void 0) {
        levelIndex = hls.loadLevel;
      }
      const level = this.hls.levels[levelIndex];
      if (level) {
        level.loadError++;
        if (hls.autoLevelEnabled) {
          var _data$frag2, _data$context2;
          let nextLevel = -1;
          const {
            levels,
            loadLevel,
            minAutoLevel,
            maxAutoLevel
          } = hls;
          const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;
          const {
            type: playlistErrorType,
            groupId: playlistErrorGroupId
          } = (_data$context2 = data.context) != null ? _data$context2 : {};
          for (let i2 = levels.length; i2--; ) {
            const candidate = (i2 + loadLevel) % levels.length;
            if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
              const levelCandidate = levels[candidate];
              if (data.details === ErrorDetails.FRAG_GAP && data.frag) {
                const levelDetails = levels[candidate].details;
                if (levelDetails) {
                  const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                  if (fragCandidate != null && fragCandidate.gap) {
                    continue;
                  }
                }
              } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && playlistErrorGroupId === levelCandidate.audioGroupId || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && playlistErrorGroupId === levelCandidate.textGroupId) {
                continue;
              } else if (fragErrorType === PlaylistLevelType.AUDIO && level.audioGroupId === levelCandidate.audioGroupId || fragErrorType === PlaylistLevelType.SUBTITLE && level.textGroupId === levelCandidate.textGroupId) {
                continue;
              }
              nextLevel = candidate;
              break;
            }
          }
          if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
            data.levelRetry = true;
            this.playlistError = 0;
            return {
              action: NetworkErrorAction.SendAlternateToPenaltyBox,
              flags: ErrorActionFlags.None,
              nextAutoLevel: nextLevel
            };
          }
        }
      }
      return {
        action: NetworkErrorAction.SendAlternateToPenaltyBox,
        flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
      };
    }
    onErrorOut(event, data) {
      var _data$errorAction;
      switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {
        case NetworkErrorAction.DoNothing:
          break;
        case NetworkErrorAction.SendAlternateToPenaltyBox:
          this.sendAlternateToPenaltyBox(data);
          if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
            data.fatal = true;
          }
          break;
      }
      if (data.fatal) {
        this.hls.stopLoad();
        return;
      }
    }
    sendAlternateToPenaltyBox(data) {
      const hls = this.hls;
      const errorAction = data.errorAction;
      if (!errorAction) {
        return;
      }
      const {
        flags,
        hdcpLevel,
        nextAutoLevel
      } = errorAction;
      switch (flags) {
        case ErrorActionFlags.None:
          this.switchLevel(data, nextAutoLevel);
          break;
        case ErrorActionFlags.MoveAllAlternatesMatchingHost:
          {
            if (!errorAction.resolved) {
              errorAction.resolved = this.redundantFailover(data);
            }
          }
          break;
        case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
          if (hdcpLevel) {
            hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
            errorAction.resolved = true;
          }
          this.warn(`Restricting playback to HDCP-LEVEL of "${hls.maxHdcpLevel}" or lower`);
          break;
      }
      if (!errorAction.resolved) {
        this.switchLevel(data, nextAutoLevel);
      }
    }
    switchLevel(data, levelIndex) {
      if (levelIndex !== void 0 && data.errorAction) {
        this.warn(`switching to level ${levelIndex} after ${data.details}`);
        this.hls.nextAutoLevel = levelIndex;
        data.errorAction.resolved = true;
        this.hls.nextLoadLevel = this.hls.nextAutoLevel;
      }
    }
    redundantFailover(data) {
      const {
        hls,
        penalizedRenditions
      } = this;
      const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
      const level = hls.levels[levelIndex];
      const redundantLevels = level.url.length;
      const errorUrlId = data.frag ? data.frag.urlId : level.urlId;
      if (level.urlId === errorUrlId && (!data.frag || level.details)) {
        this.penalizeRendition(level, data);
      }
      for (let i2 = 1; i2 < redundantLevels; i2++) {
        const newUrlId = (errorUrlId + i2) % redundantLevels;
        const penalizedRendition = penalizedRenditions[newUrlId];
        if (!penalizedRendition || checkExpired(penalizedRendition, data, penalizedRenditions[errorUrlId])) {
          this.warn(`Switching to Redundant Stream ${newUrlId + 1}/${redundantLevels}: "${level.url[newUrlId]}" after ${data.details}`);
          this.playlistError = 0;
          hls.levels.forEach((lv) => {
            lv.urlId = newUrlId;
          });
          hls.nextLoadLevel = levelIndex;
          return true;
        }
      }
      return false;
    }
    penalizeRendition(level, data) {
      const {
        penalizedRenditions
      } = this;
      const penalizedRendition = penalizedRenditions[level.urlId] || {
        lastErrorPerfMs: 0,
        errors: [],
        details: void 0
      };
      penalizedRendition.lastErrorPerfMs = performance.now();
      penalizedRendition.errors.push(data);
      penalizedRendition.details = level.details;
      penalizedRenditions[level.urlId] = penalizedRendition;
    }
  };
  function checkExpired(penalizedRendition, data, currentPenaltyState) {
    if (performance.now() - penalizedRendition.lastErrorPerfMs > RENDITION_PENALTY_DURATION_MS) {
      return true;
    }
    const lastErrorDetails = penalizedRendition.details;
    if (data.details === ErrorDetails.FRAG_GAP && lastErrorDetails && data.frag) {
      const position = data.frag.start;
      const candidateFrag = findFragmentByPTS(null, lastErrorDetails.fragments, position);
      if (candidateFrag && !candidateFrag.gap) {
        return true;
      }
    }
    if (currentPenaltyState && penalizedRendition.errors.length < currentPenaltyState.errors.length) {
      const lastCandidateError = penalizedRendition.errors[penalizedRendition.errors.length - 1];
      if (lastErrorDetails && lastCandidateError.frag && data.frag && Math.abs(lastCandidateError.frag.start - data.frag.start) > lastErrorDetails.targetduration * 3) {
        return true;
      }
    }
    return false;
  }
  var BasePlaylistController = class {
    constructor(hls, logPrefix) {
      this.hls = void 0;
      this.timer = -1;
      this.requestScheduled = -1;
      this.canLoad = false;
      this.log = void 0;
      this.warn = void 0;
      this.log = logger.log.bind(logger, `${logPrefix}:`);
      this.warn = logger.warn.bind(logger, `${logPrefix}:`);
      this.hls = hls;
    }
    destroy() {
      this.clearTimer();
      this.hls = this.log = this.warn = null;
    }
    clearTimer() {
      clearTimeout(this.timer);
      this.timer = -1;
    }
    startLoad() {
      this.canLoad = true;
      this.requestScheduled = -1;
      this.loadPlaylist();
    }
    stopLoad() {
      this.canLoad = false;
      this.clearTimer();
    }
    switchParams(playlistUri, previous) {
      const renditionReports = previous == null ? void 0 : previous.renditionReports;
      if (renditionReports) {
        let foundIndex = -1;
        for (let i2 = 0; i2 < renditionReports.length; i2++) {
          const attr = renditionReports[i2];
          let uri;
          try {
            uri = new self.URL(attr.URI, previous.url).href;
          } catch (error) {
            logger.warn(`Could not construct new URL for Rendition Report: ${error}`);
            uri = attr.URI || "";
          }
          if (uri === playlistUri) {
            foundIndex = i2;
            break;
          } else if (uri === playlistUri.substring(0, uri.length)) {
            foundIndex = i2;
          }
        }
        if (foundIndex !== -1) {
          const attr = renditionReports[foundIndex];
          const msn = parseInt(attr["LAST-MSN"]) || (previous == null ? void 0 : previous.lastPartSn);
          let part = parseInt(attr["LAST-PART"]) || (previous == null ? void 0 : previous.lastPartIndex);
          if (this.hls.config.lowLatencyMode) {
            const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
            if (part >= 0 && currentGoal > previous.partTarget) {
              part += 1;
            }
          }
          return new HlsUrlParameters(msn, part >= 0 ? part : void 0, HlsSkip.No);
        }
      }
    }
    loadPlaylist(hlsUrlParameters) {
      if (this.requestScheduled === -1) {
        this.requestScheduled = self.performance.now();
      }
    }
    shouldLoadPlaylist(playlist) {
      return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
    }
    shouldReloadPlaylist(playlist) {
      return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);
    }
    playlistLoaded(index2, data, previousDetails) {
      const {
        details,
        stats
      } = data;
      const now2 = self.performance.now();
      const elapsed = stats.loading.first ? Math.max(0, now2 - stats.loading.first) : 0;
      details.advancedDateTime = Date.now() - elapsed;
      if (details.live || previousDetails != null && previousDetails.live) {
        details.reloaded(previousDetails);
        if (previousDetails) {
          this.log(`live playlist ${index2} ${details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : details.updated ? "UPDATED" : "MISSED"}`);
        }
        if (previousDetails && details.fragments.length > 0) {
          mergeDetails(previousDetails, details);
        }
        if (!this.canLoad || !details.live) {
          return;
        }
        let deliveryDirectives;
        let msn = void 0;
        let part = void 0;
        if (details.canBlockReload && details.endSN && details.advanced) {
          const lowLatencyMode = this.hls.config.lowLatencyMode;
          const lastPartSn = details.lastPartSn;
          const endSn = details.endSN;
          const lastPartIndex = details.lastPartIndex;
          const hasParts = lastPartIndex !== -1;
          const lastPart = lastPartSn === endSn;
          const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
          if (hasParts) {
            msn = lastPart ? endSn + 1 : lastPartSn;
            part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
          } else {
            msn = endSn + 1;
          }
          const lastAdvanced = details.age;
          const cdnAge = lastAdvanced + details.ageHeader;
          let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
          if (currentGoal > 0) {
            if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
              this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);
              currentGoal = 0;
            } else {
              const segments = Math.floor(currentGoal / details.targetduration);
              msn += segments;
              if (part !== void 0) {
                const parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                part += parts;
              }
              this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);
            }
            details.tuneInGoal = currentGoal;
          }
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
          if (lowLatencyMode || !lastPart) {
            this.loadPlaylist(deliveryDirectives);
            return;
          }
        } else if (details.canBlockReload || details.canSkipUntil) {
          deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
        }
        const bufferInfo = this.hls.mainForwardBufferInfo;
        const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
        const distanceToLiveEdgeMs = (details.edge - position) * 1e3;
        const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
        if (details.updated && now2 > this.requestScheduled + reloadInterval) {
          this.requestScheduled = stats.loading.start;
        }
        if (msn !== void 0 && details.canBlockReload) {
          this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1e3 || 1e3);
        } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now2) {
          this.requestScheduled = now2;
        } else if (this.requestScheduled - now2 <= 0) {
          this.requestScheduled += reloadInterval;
        }
        let estimatedTimeUntilUpdate = this.requestScheduled - now2;
        estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
        this.log(`reload live playlist ${index2} in ${Math.round(estimatedTimeUntilUpdate)} ms`);
        this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);
      } else {
        this.clearTimer();
      }
    }
    getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
      let skip = getSkipValue(details, msn);
      if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
        msn = previousDeliveryDirectives.msn;
        part = previousDeliveryDirectives.part;
        skip = HlsSkip.No;
      }
      return new HlsUrlParameters(msn, part, skip);
    }
    checkRetry(errorEvent) {
      const errorDetails = errorEvent.details;
      const isTimeout = isTimeoutError(errorEvent);
      const errorAction = errorEvent.errorAction;
      const {
        action,
        retryCount = 0,
        retryConfig
      } = errorAction || {};
      const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
      if (retry) {
        var _errorEvent$context;
        this.requestScheduled = -1;
        if (retryCount >= retryConfig.maxNumRetry) {
          return false;
        }
        if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
          this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" without delivery-directives`);
          this.loadPlaylist();
        } else {
          const delay = getRetryDelay(retryConfig, retryCount);
          this.timer = self.setTimeout(() => this.loadPlaylist(), delay);
          this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" in ${delay}ms`);
        }
        errorEvent.levelRetry = true;
        errorAction.resolved = true;
      }
      return retry;
    }
  };
  var chromeOrFirefox;
  var LevelController = class extends BasePlaylistController {
    constructor(hls, contentSteeringController) {
      super(hls, "[level-controller]");
      this._levels = [];
      this._firstLevel = -1;
      this._startLevel = void 0;
      this.currentLevel = null;
      this.currentLevelIndex = -1;
      this.manualLevelIndex = -1;
      this.steering = void 0;
      this.onParsedComplete = void 0;
      this.steering = contentSteeringController;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    destroy() {
      this._unregisterListeners();
      this.steering = null;
      this.resetLevels();
      super.destroy();
    }
    startLoad() {
      const levels = this._levels;
      levels.forEach((level) => {
        level.loadError = 0;
        level.fragmentError = 0;
      });
      super.startLoad();
    }
    resetLevels() {
      this._startLevel = void 0;
      this.manualLevelIndex = -1;
      this.currentLevelIndex = -1;
      this.currentLevel = null;
      this._levels = [];
    }
    onManifestLoading(event, data) {
      this.resetLevels();
    }
    onManifestLoaded(event, data) {
      const levels = [];
      const levelSet = {};
      let levelFromSet;
      data.levels.forEach((levelParsed) => {
        var _levelParsed$audioCod;
        const attributes = levelParsed.attrs;
        if (((_levelParsed$audioCod = levelParsed.audioCodec) == null ? void 0 : _levelParsed$audioCod.indexOf("mp4a.40.34")) !== -1) {
          chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));
          if (chromeOrFirefox) {
            levelParsed.audioCodec = void 0;
          }
        }
        const {
          AUDIO,
          CODECS,
          "FRAME-RATE": FRAMERATE,
          "PATHWAY-ID": PATHWAY,
          RESOLUTION,
          SUBTITLES
        } = attributes;
        const contentSteeringPrefix = `${PATHWAY || "."}-`;
        const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}`;
        levelFromSet = levelSet[levelKey];
        if (!levelFromSet) {
          levelFromSet = new Level(levelParsed);
          levelSet[levelKey] = levelFromSet;
          levels.push(levelFromSet);
        } else {
          levelFromSet.addFallback(levelParsed);
        }
        addGroupId(levelFromSet, "audio", AUDIO);
        addGroupId(levelFromSet, "text", SUBTITLES);
      });
      this.filterAndSortMediaOptions(levels, data);
    }
    filterAndSortMediaOptions(unfilteredLevels, data) {
      let audioTracks = [];
      let subtitleTracks = [];
      let resolutionFound = false;
      let videoCodecFound = false;
      let audioCodecFound = false;
      let levels = unfilteredLevels.filter(({
        audioCodec,
        videoCodec,
        width,
        height,
        unknownCodecs
      }) => {
        resolutionFound || (resolutionFound = !!(width && height));
        videoCodecFound || (videoCodecFound = !!videoCodec);
        audioCodecFound || (audioCodecFound = !!audioCodec);
        return !(unknownCodecs != null && unknownCodecs.length) && (!audioCodec || isCodecSupportedInMp4(audioCodec, "audio")) && (!videoCodec || isCodecSupportedInMp4(videoCodec, "video"));
      });
      if ((resolutionFound || videoCodecFound) && audioCodecFound) {
        levels = levels.filter(({
          videoCodec,
          width,
          height
        }) => !!videoCodec || !!(width && height));
      }
      if (levels.length === 0) {
        Promise.resolve().then(() => {
          if (this.hls) {
            const error = new Error("no level with compatible codecs found in manifest");
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
              fatal: true,
              url: data.url,
              error,
              reason: error.message
            });
          }
        });
        return;
      }
      if (data.audioTracks) {
        audioTracks = data.audioTracks.filter((track) => !track.audioCodec || isCodecSupportedInMp4(track.audioCodec, "audio"));
        assignTrackIdsByGroup(audioTracks);
      }
      if (data.subtitles) {
        subtitleTracks = data.subtitles;
        assignTrackIdsByGroup(subtitleTracks);
      }
      const unsortedLevels = levels.slice(0);
      levels.sort((a2, b3) => {
        if (a2.attrs["HDCP-LEVEL"] !== b3.attrs["HDCP-LEVEL"]) {
          return (a2.attrs["HDCP-LEVEL"] || "") > (b3.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
        }
        if (a2.bitrate !== b3.bitrate) {
          return a2.bitrate - b3.bitrate;
        }
        if (a2.attrs["FRAME-RATE"] !== b3.attrs["FRAME-RATE"]) {
          return a2.attrs.decimalFloatingPoint("FRAME-RATE") - b3.attrs.decimalFloatingPoint("FRAME-RATE");
        }
        if (a2.attrs.SCORE !== b3.attrs.SCORE) {
          return a2.attrs.decimalFloatingPoint("SCORE") - b3.attrs.decimalFloatingPoint("SCORE");
        }
        if (resolutionFound && a2.height !== b3.height) {
          return a2.height - b3.height;
        }
        return 0;
      });
      let firstLevelInPlaylist = unsortedLevels[0];
      if (this.steering) {
        levels = this.steering.filterParsedLevels(levels);
        if (levels.length !== unsortedLevels.length) {
          for (let i2 = 0; i2 < unsortedLevels.length; i2++) {
            if (unsortedLevels[i2].pathwayId === levels[0].pathwayId) {
              firstLevelInPlaylist = unsortedLevels[i2];
              break;
            }
          }
        }
      }
      this._levels = levels;
      for (let i2 = 0; i2 < levels.length; i2++) {
        if (levels[i2] === firstLevelInPlaylist) {
          this._firstLevel = i2;
          this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelInPlaylist.bitrate}`);
          break;
        }
      }
      const audioOnly = audioCodecFound && !videoCodecFound;
      const edata = {
        levels,
        audioTracks,
        subtitleTracks,
        sessionData: data.sessionData,
        sessionKeys: data.sessionKeys,
        firstLevel: this._firstLevel,
        stats: data.stats,
        audio: audioCodecFound,
        video: videoCodecFound,
        altAudio: !audioOnly && audioTracks.some((t2) => !!t2.url)
      };
      this.hls.trigger(Events.MANIFEST_PARSED, edata);
      if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
        this.hls.startLoad(this.hls.config.startPosition);
      }
    }
    get levels() {
      if (this._levels.length === 0) {
        return null;
      }
      return this._levels;
    }
    get level() {
      return this.currentLevelIndex;
    }
    set level(newLevel) {
      const levels = this._levels;
      if (levels.length === 0) {
        return;
      }
      if (newLevel < 0 || newLevel >= levels.length) {
        const error = new Error("invalid level idx");
        const fatal = newLevel < 0;
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.LEVEL_SWITCH_ERROR,
          level: newLevel,
          fatal,
          error,
          reason: error.message
        });
        if (fatal) {
          return;
        }
        newLevel = Math.min(newLevel, levels.length - 1);
      }
      const lastLevelIndex = this.currentLevelIndex;
      const lastLevel = this.currentLevel;
      const lastPathwayId = lastLevel ? lastLevel.attrs["PATHWAY-ID"] : void 0;
      const level = levels[newLevel];
      const pathwayId = level.attrs["PATHWAY-ID"];
      this.currentLevelIndex = newLevel;
      this.currentLevel = level;
      if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {
        return;
      }
      this.log(`Switching to level ${newLevel}${pathwayId ? " with Pathway " + pathwayId : ""} from level ${lastLevelIndex}${lastPathwayId ? " with Pathway " + lastPathwayId : ""}`);
      const levelSwitchingData = _extends2({}, level, {
        level: newLevel,
        maxBitrate: level.maxBitrate,
        attrs: level.attrs,
        uri: level.uri,
        urlId: level.urlId
      });
      delete levelSwitchingData._attrs;
      delete levelSwitchingData._urlId;
      this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);
      const levelDetails = level.details;
      if (!levelDetails || levelDetails.live) {
        const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details);
        this.loadPlaylist(hlsUrlParameters);
      }
    }
    get manualLevel() {
      return this.manualLevelIndex;
    }
    set manualLevel(newLevel) {
      this.manualLevelIndex = newLevel;
      if (this._startLevel === void 0) {
        this._startLevel = newLevel;
      }
      if (newLevel !== -1) {
        this.level = newLevel;
      }
    }
    get firstLevel() {
      return this._firstLevel;
    }
    set firstLevel(newLevel) {
      this._firstLevel = newLevel;
    }
    get startLevel() {
      if (this._startLevel === void 0) {
        const configStartLevel = this.hls.config.startLevel;
        if (configStartLevel !== void 0) {
          return configStartLevel;
        } else {
          return this._firstLevel;
        }
      } else {
        return this._startLevel;
      }
    }
    set startLevel(newLevel) {
      this._startLevel = newLevel;
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
        this.checkRetry(data);
      }
    }
    onFragLoaded(event, {
      frag
    }) {
      if (frag !== void 0 && frag.type === PlaylistLevelType.MAIN) {
        const level = this._levels[frag.level];
        if (level !== void 0) {
          level.loadError = 0;
        }
      }
    }
    onLevelLoaded(event, data) {
      var _data$deliveryDirecti2;
      const {
        level,
        details
      } = data;
      const curLevel = this._levels[level];
      if (!curLevel) {
        var _data$deliveryDirecti;
        this.warn(`Invalid level index ${level}`);
        if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
          details.deltaUpdateFailed = true;
        }
        return;
      }
      if (level === this.currentLevelIndex) {
        if (curLevel.fragmentError === 0) {
          curLevel.loadError = 0;
        }
        this.playlistLoaded(level, data, curLevel.details);
      } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
        details.deltaUpdateFailed = true;
      }
    }
    onAudioTrackSwitched(event, data) {
      const currentLevel = this.currentLevel;
      if (!currentLevel) {
        return;
      }
      const audioGroupId = this.hls.audioTracks[data.id].groupId;
      if (currentLevel.audioGroupIds && currentLevel.audioGroupId !== audioGroupId) {
        let urlId = -1;
        for (let i2 = 0; i2 < currentLevel.audioGroupIds.length; i2++) {
          if (currentLevel.audioGroupIds[i2] === audioGroupId) {
            urlId = i2;
            break;
          }
        }
        if (urlId !== -1 && urlId !== currentLevel.urlId) {
          currentLevel.urlId = urlId;
          if (this.canLoad) {
            this.startLoad();
          }
        }
      }
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      const currentLevelIndex = this.currentLevelIndex;
      const currentLevel = this.currentLevel;
      if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {
        const id = currentLevel.urlId;
        let url = currentLevel.uri;
        if (hlsUrlParameters) {
          try {
            url = hlsUrlParameters.addDirectives(url);
          } catch (error) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
          }
        }
        const pathwayId = currentLevel.attrs["PATHWAY-ID"];
        this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== void 0 ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : ""} with${pathwayId ? " Pathway " + pathwayId : ""} URI ${id + 1}/${currentLevel.url.length} ${url}`);
        this.clearTimer();
        this.hls.trigger(Events.LEVEL_LOADING, {
          url,
          level: currentLevelIndex,
          id,
          deliveryDirectives: hlsUrlParameters || null
        });
      }
    }
    get nextLoadLevel() {
      if (this.manualLevelIndex !== -1) {
        return this.manualLevelIndex;
      } else {
        return this.hls.nextAutoLevel;
      }
    }
    set nextLoadLevel(nextLevel) {
      this.level = nextLevel;
      if (this.manualLevelIndex === -1) {
        this.hls.nextAutoLevel = nextLevel;
      }
    }
    removeLevel(levelIndex, urlId) {
      const filterLevelAndGroupByIdIndex = (url, id) => id !== urlId;
      const levels = this._levels.filter((level, index2) => {
        if (index2 !== levelIndex) {
          return true;
        }
        if (level.url.length > 1 && urlId !== void 0) {
          level.url = level.url.filter(filterLevelAndGroupByIdIndex);
          if (level.audioGroupIds) {
            level.audioGroupIds = level.audioGroupIds.filter(filterLevelAndGroupByIdIndex);
          }
          if (level.textGroupIds) {
            level.textGroupIds = level.textGroupIds.filter(filterLevelAndGroupByIdIndex);
          }
          level.urlId = 0;
          return true;
        }
        if (this.steering) {
          this.steering.removeLevel(level);
        }
        return false;
      });
      this.hls.trigger(Events.LEVELS_UPDATED, {
        levels
      });
    }
    onLevelsUpdated(event, {
      levels
    }) {
      levels.forEach((level, index2) => {
        const {
          details
        } = level;
        if (details != null && details.fragments) {
          details.fragments.forEach((fragment) => {
            fragment.level = index2;
          });
        }
      });
      this._levels = levels;
    }
  };
  function addGroupId(level, type, id) {
    if (!id) {
      return;
    }
    if (type === "audio") {
      if (!level.audioGroupIds) {
        level.audioGroupIds = [];
      }
      level.audioGroupIds[level.url.length - 1] = id;
    } else if (type === "text") {
      if (!level.textGroupIds) {
        level.textGroupIds = [];
      }
      level.textGroupIds[level.url.length - 1] = id;
    }
  }
  function assignTrackIdsByGroup(tracks) {
    const groups = {};
    tracks.forEach((track) => {
      const groupId = track.groupId || "";
      track.id = groups[groupId] = groups[groupId] || 0;
      groups[groupId]++;
    });
  }
  var FragmentState = {
    NOT_LOADED: "NOT_LOADED",
    APPENDING: "APPENDING",
    PARTIAL: "PARTIAL",
    OK: "OK"
  };
  var FragmentTracker = class {
    constructor(hls) {
      this.activePartLists = /* @__PURE__ */ Object.create(null);
      this.endListFragments = /* @__PURE__ */ Object.create(null);
      this.fragments = /* @__PURE__ */ Object.create(null);
      this.timeRanges = /* @__PURE__ */ Object.create(null);
      this.bufferPadding = 0.2;
      this.hls = void 0;
      this.hasGaps = false;
      this.hls = hls;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
    }
    destroy() {
      this._unregisterListeners();
      this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null;
    }
    getAppendedFrag(position, levelType) {
      const activeParts = this.activePartLists[levelType];
      if (activeParts) {
        for (let i2 = activeParts.length; i2--; ) {
          const activePart = activeParts[i2];
          if (!activePart) {
            break;
          }
          const appendedPTS = activePart.end;
          if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
            return activePart;
          }
        }
      }
      return this.getBufferedFrag(position, levelType);
    }
    getBufferedFrag(position, levelType) {
      const {
        fragments
      } = this;
      const keys = Object.keys(fragments);
      for (let i2 = keys.length; i2--; ) {
        const fragmentEntity = fragments[keys[i2]];
        if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
          const frag = fragmentEntity.body;
          if (frag.start <= position && position <= frag.end) {
            return frag;
          }
        }
      }
      return null;
    }
    detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {
      if (this.timeRanges) {
        this.timeRanges[elementaryStream] = timeRange;
      }
      const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;
      Object.keys(this.fragments).forEach((key) => {
        const fragmentEntity = this.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (appendedPartSn >= fragmentEntity.body.sn) {
          return;
        }
        if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
          if (fragmentEntity.body.type === playlistType) {
            this.removeFragment(fragmentEntity.body);
          }
          return;
        }
        const esData = fragmentEntity.range[elementaryStream];
        if (!esData) {
          return;
        }
        esData.time.some((time) => {
          const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
          if (isNotBuffered) {
            this.removeFragment(fragmentEntity.body);
          }
          return isNotBuffered;
        });
      });
    }
    detectPartialFragments(data) {
      const timeRanges = this.timeRanges;
      const {
        frag,
        part
      } = data;
      if (!timeRanges || frag.sn === "initSegment") {
        return;
      }
      const fragKey = getFragmentKey(frag);
      const fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
        return;
      }
      const isFragHint = !frag.relurl;
      Object.keys(timeRanges).forEach((elementaryStream) => {
        const streamInfo = frag.elementaryStreams[elementaryStream];
        if (!streamInfo) {
          return;
        }
        const timeRange = timeRanges[elementaryStream];
        const partial = isFragHint || streamInfo.partial === true;
        fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);
      });
      fragmentEntity.loaded = null;
      if (Object.keys(fragmentEntity.range).length) {
        fragmentEntity.buffered = true;
        const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
        if (endList) {
          this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
        }
        if (!isPartial(fragmentEntity)) {
          this.removeParts(frag.sn - 1, frag.type);
        }
      } else {
        this.removeFragment(fragmentEntity.body);
      }
    }
    removeParts(snToKeep, levelType) {
      const activeParts = this.activePartLists[levelType];
      if (!activeParts) {
        return;
      }
      this.activePartLists[levelType] = activeParts.filter((part) => part.fragment.sn >= snToKeep);
    }
    fragBuffered(frag, force) {
      const fragKey = getFragmentKey(frag);
      let fragmentEntity = this.fragments[fragKey];
      if (!fragmentEntity && force) {
        fragmentEntity = this.fragments[fragKey] = {
          body: frag,
          appendedPTS: null,
          loaded: null,
          buffered: false,
          range: /* @__PURE__ */ Object.create(null)
        };
        if (frag.gap) {
          this.hasGaps = true;
        }
      }
      if (fragmentEntity) {
        fragmentEntity.loaded = null;
        fragmentEntity.buffered = true;
      }
    }
    getBufferedTimes(fragment, part, partial, timeRange) {
      const buffered = {
        time: [],
        partial
      };
      const startPTS = fragment.start;
      const endPTS = fragment.end;
      const minEndPTS = fragment.minEndPTS || endPTS;
      const maxStartPTS = fragment.maxStartPTS || startPTS;
      for (let i2 = 0; i2 < timeRange.length; i2++) {
        const startTime = timeRange.start(i2) - this.bufferPadding;
        const endTime = timeRange.end(i2) + this.bufferPadding;
        if (maxStartPTS >= startTime && minEndPTS <= endTime) {
          buffered.time.push({
            startPTS: Math.max(startPTS, timeRange.start(i2)),
            endPTS: Math.min(endPTS, timeRange.end(i2))
          });
          break;
        } else if (startPTS < endTime && endPTS > startTime) {
          buffered.partial = true;
          buffered.time.push({
            startPTS: Math.max(startPTS, timeRange.start(i2)),
            endPTS: Math.min(endPTS, timeRange.end(i2))
          });
        } else if (endPTS <= startTime) {
          break;
        }
      }
      return buffered;
    }
    getPartialFragment(time) {
      let bestFragment = null;
      let timePadding;
      let startTime;
      let endTime;
      let bestOverlap = 0;
      const {
        bufferPadding,
        fragments
      } = this;
      Object.keys(fragments).forEach((key) => {
        const fragmentEntity = fragments[key];
        if (!fragmentEntity) {
          return;
        }
        if (isPartial(fragmentEntity)) {
          startTime = fragmentEntity.body.start - bufferPadding;
          endTime = fragmentEntity.body.end + bufferPadding;
          if (time >= startTime && time <= endTime) {
            timePadding = Math.min(time - startTime, endTime - time);
            if (bestOverlap <= timePadding) {
              bestFragment = fragmentEntity.body;
              bestOverlap = timePadding;
            }
          }
        }
      });
      return bestFragment;
    }
    isEndListAppended(type) {
      const lastFragmentEntity = this.endListFragments[type];
      return lastFragmentEntity !== void 0 && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
    }
    getState(fragment) {
      const fragKey = getFragmentKey(fragment);
      const fragmentEntity = this.fragments[fragKey];
      if (fragmentEntity) {
        if (!fragmentEntity.buffered) {
          return FragmentState.APPENDING;
        } else if (isPartial(fragmentEntity)) {
          return FragmentState.PARTIAL;
        } else {
          return FragmentState.OK;
        }
      }
      return FragmentState.NOT_LOADED;
    }
    isTimeBuffered(startPTS, endPTS, timeRange) {
      let startTime;
      let endTime;
      for (let i2 = 0; i2 < timeRange.length; i2++) {
        startTime = timeRange.start(i2) - this.bufferPadding;
        endTime = timeRange.end(i2) + this.bufferPadding;
        if (startPTS >= startTime && endPTS <= endTime) {
          return true;
        }
        if (endPTS <= startTime) {
          return false;
        }
      }
      return false;
    }
    onFragLoaded(event, data) {
      const {
        frag,
        part
      } = data;
      if (frag.sn === "initSegment" || frag.bitrateTest) {
        return;
      }
      const loaded = part ? null : data;
      const fragKey = getFragmentKey(frag);
      this.fragments[fragKey] = {
        body: frag,
        appendedPTS: null,
        loaded,
        buffered: false,
        range: /* @__PURE__ */ Object.create(null)
      };
    }
    onBufferAppended(event, data) {
      const {
        frag,
        part,
        timeRanges
      } = data;
      if (frag.sn === "initSegment") {
        return;
      }
      const playlistType = frag.type;
      if (part) {
        let activeParts = this.activePartLists[playlistType];
        if (!activeParts) {
          this.activePartLists[playlistType] = activeParts = [];
        }
        activeParts.push(part);
      }
      this.timeRanges = timeRanges;
      Object.keys(timeRanges).forEach((elementaryStream) => {
        const timeRange = timeRanges[elementaryStream];
        this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);
      });
    }
    onFragBuffered(event, data) {
      this.detectPartialFragments(data);
    }
    hasFragment(fragment) {
      const fragKey = getFragmentKey(fragment);
      return !!this.fragments[fragKey];
    }
    hasParts(type) {
      var _this$activePartLists;
      return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
    }
    removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
      if (withGapOnly && !this.hasGaps) {
        return;
      }
      Object.keys(this.fragments).forEach((key) => {
        const fragmentEntity = this.fragments[key];
        if (!fragmentEntity) {
          return;
        }
        const frag = fragmentEntity.body;
        if (frag.type !== playlistType || withGapOnly && !frag.gap) {
          return;
        }
        if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
          this.removeFragment(frag);
        }
      });
    }
    removeFragment(fragment) {
      const fragKey = getFragmentKey(fragment);
      fragment.stats.loaded = 0;
      fragment.clearElementaryStreamInfo();
      const activeParts = this.activePartLists[fragment.type];
      if (activeParts) {
        const snToRemove = fragment.sn;
        this.activePartLists[fragment.type] = activeParts.filter((part) => part.fragment.sn !== snToRemove);
      }
      delete this.fragments[fragKey];
      if (fragment.endList) {
        delete this.endListFragments[fragment.type];
      }
    }
    removeAllFragments() {
      this.fragments = /* @__PURE__ */ Object.create(null);
      this.endListFragments = /* @__PURE__ */ Object.create(null);
      this.activePartLists = /* @__PURE__ */ Object.create(null);
      this.hasGaps = false;
    }
  };
  function isPartial(fragmentEntity) {
    var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
    return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));
  }
  function getFragmentKey(fragment) {
    return `${fragment.type}_${fragment.level}_${fragment.urlId}_${fragment.sn}`;
  }
  var MIN_CHUNK_SIZE = Math.pow(2, 17);
  var FragmentLoader = class {
    constructor(config) {
      this.config = void 0;
      this.loader = null;
      this.partLoadTimeout = -1;
      this.config = config;
    }
    destroy() {
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
    }
    abort() {
      if (this.loader) {
        this.loader.abort();
      }
    }
    load(frag, onProgress) {
      const url = frag.url;
      if (!url) {
        return Promise.reject(new LoadError({
          type: ErrorTypes.NETWORK_ERROR,
          details: ErrorDetails.FRAG_LOAD_ERROR,
          fatal: false,
          frag,
          error: new Error(`Fragment does not have a ${url ? "part list" : "url"}`),
          networkDetails: null
        }));
      }
      this.abort();
      const config = this.config;
      const FragmentILoader = config.fLoader;
      const DefaultILoader = config.loader;
      return new Promise((resolve, reject) => {
        if (this.loader) {
          this.loader.destroy();
        }
        if (frag.gap) {
          if (frag.tagList.some((tags) => tags[0] === "GAP")) {
            reject(createGapLoadError(frag));
            return;
          } else {
            frag.gap = false;
          }
        }
        const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
        const loaderContext = createLoaderContext(frag);
        const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
        };
        frag.stats = loader.stats;
        loader.load(loaderContext, loaderConfig, {
          onSuccess: (response, stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            let payload = response.data;
            if (context.resetIV && frag.decryptdata) {
              frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
              payload = payload.slice(16);
            }
            resolve({
              frag,
              part: null,
              payload,
              networkDetails
            });
          },
          onError: (response, context, networkDetails, stats) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag,
              response: _objectSpread22({
                url,
                data: void 0
              }, response),
              error: new Error(`HTTP Error ${response.code} ${response.text}`),
              networkDetails,
              stats
            }));
          },
          onAbort: (stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag,
              error: new Error("Aborted"),
              networkDetails,
              stats
            }));
          },
          onTimeout: (stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag,
              error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
              networkDetails,
              stats
            }));
          },
          onProgress: (stats, context, data, networkDetails) => {
            if (onProgress) {
              onProgress({
                frag,
                part: null,
                payload: data,
                networkDetails
              });
            }
          }
        });
      });
    }
    loadPart(frag, part, onProgress) {
      this.abort();
      const config = this.config;
      const FragmentILoader = config.fLoader;
      const DefaultILoader = config.loader;
      return new Promise((resolve, reject) => {
        if (this.loader) {
          this.loader.destroy();
        }
        if (frag.gap || part.gap) {
          reject(createGapLoadError(frag, part));
          return;
        }
        const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
        const loaderContext = createLoaderContext(frag, part);
        const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0,
          highWaterMark: MIN_CHUNK_SIZE
        };
        part.stats = loader.stats;
        loader.load(loaderContext, loaderConfig, {
          onSuccess: (response, stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            this.updateStatsFromPart(frag, part);
            const partLoadedData = {
              frag,
              part,
              payload: response.data,
              networkDetails
            };
            onProgress(partLoadedData);
            resolve(partLoadedData);
          },
          onError: (response, context, networkDetails, stats) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag,
              part,
              response: _objectSpread22({
                url: loaderContext.url,
                data: void 0
              }, response),
              error: new Error(`HTTP Error ${response.code} ${response.text}`),
              networkDetails,
              stats
            }));
          },
          onAbort: (stats, context, networkDetails) => {
            frag.stats.aborted = part.stats.aborted;
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.INTERNAL_ABORTED,
              fatal: false,
              frag,
              part,
              error: new Error("Aborted"),
              networkDetails,
              stats
            }));
          },
          onTimeout: (stats, context, networkDetails) => {
            this.resetLoader(frag, loader);
            reject(new LoadError({
              type: ErrorTypes.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_TIMEOUT,
              fatal: false,
              frag,
              part,
              error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
              networkDetails,
              stats
            }));
          }
        });
      });
    }
    updateStatsFromPart(frag, part) {
      const fragStats = frag.stats;
      const partStats = part.stats;
      const partTotal = partStats.total;
      fragStats.loaded += partStats.loaded;
      if (partTotal) {
        const estTotalParts = Math.round(frag.duration / part.duration);
        const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
        const estRemainingParts = estTotalParts - estLoadedParts;
        const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
        fragStats.total = fragStats.loaded + estRemainingBytes;
      } else {
        fragStats.total = Math.max(fragStats.loaded, fragStats.total);
      }
      const fragLoading = fragStats.loading;
      const partLoading = partStats.loading;
      if (fragLoading.start) {
        fragLoading.first += partLoading.first - partLoading.start;
      } else {
        fragLoading.start = partLoading.start;
        fragLoading.first = partLoading.first;
      }
      fragLoading.end = partLoading.end;
    }
    resetLoader(frag, loader) {
      frag.loader = null;
      if (this.loader === loader) {
        self.clearTimeout(this.partLoadTimeout);
        this.loader = null;
      }
      loader.destroy();
    }
  };
  function createLoaderContext(frag, part = null) {
    const segment = part || frag;
    const loaderContext = {
      frag,
      part,
      responseType: "arraybuffer",
      url: segment.url,
      headers: {},
      rangeStart: 0,
      rangeEnd: 0
    };
    const start = segment.byteRangeStartOffset;
    const end = segment.byteRangeEndOffset;
    if (isFiniteNumber(start) && isFiniteNumber(end)) {
      var _frag$decryptdata;
      let byteRangeStart = start;
      let byteRangeEnd = end;
      if (frag.sn === "initSegment" && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === "AES-128") {
        const fragmentLen = end - start;
        if (fragmentLen % 16) {
          byteRangeEnd = end + (16 - fragmentLen % 16);
        }
        if (start !== 0) {
          loaderContext.resetIV = true;
          byteRangeStart = start - 16;
        }
      }
      loaderContext.rangeStart = byteRangeStart;
      loaderContext.rangeEnd = byteRangeEnd;
    }
    return loaderContext;
  }
  function createGapLoadError(frag, part) {
    const error = new Error(`GAP ${frag.gap ? "tag" : "attribute"} found`);
    const errorData = {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_GAP,
      fatal: false,
      frag,
      error,
      networkDetails: null
    };
    if (part) {
      errorData.part = part;
    }
    (part ? part : frag).stats.aborted = true;
    return new LoadError(errorData);
  }
  var LoadError = class extends Error {
    constructor(data) {
      super(data.error.message);
      this.data = void 0;
      this.data = data;
    }
  };
  var KeyLoader = class {
    constructor(config) {
      this.config = void 0;
      this.keyUriToKeyInfo = {};
      this.emeController = null;
      this.config = config;
    }
    abort(type) {
      for (const uri in this.keyUriToKeyInfo) {
        const loader = this.keyUriToKeyInfo[uri].loader;
        if (loader) {
          if (type && type !== loader.context.frag.type) {
            return;
          }
          loader.abort();
        }
      }
    }
    detach() {
      for (const uri in this.keyUriToKeyInfo) {
        const keyInfo = this.keyUriToKeyInfo[uri];
        if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
          delete this.keyUriToKeyInfo[uri];
        }
      }
    }
    destroy() {
      this.detach();
      for (const uri in this.keyUriToKeyInfo) {
        const loader = this.keyUriToKeyInfo[uri].loader;
        if (loader) {
          loader.destroy();
        }
      }
      this.keyUriToKeyInfo = {};
    }
    createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {
      return new LoadError({
        type: ErrorTypes.NETWORK_ERROR,
        details,
        fatal: false,
        frag,
        response,
        error,
        networkDetails
      });
    }
    loadClear(loadingFrag, encryptedFragments) {
      if (this.emeController && this.config.emeEnabled) {
        const {
          sn: sn2,
          cc
        } = loadingFrag;
        for (let i2 = 0; i2 < encryptedFragments.length; i2++) {
          const frag = encryptedFragments[i2];
          if (cc <= frag.cc && (sn2 === "initSegment" || frag.sn === "initSegment" || sn2 < frag.sn)) {
            this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
              frag.setKeyFormat(keySystemFormat);
            });
            break;
          }
        }
      }
    }
    load(frag) {
      if (!frag.decryptdata && frag.encrypted && this.emeController) {
        return this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
          return this.loadInternal(frag, keySystemFormat);
        });
      }
      return this.loadInternal(frag);
    }
    loadInternal(frag, keySystemFormat) {
      var _keyInfo, _keyInfo2;
      if (keySystemFormat) {
        frag.setKeyFormat(keySystemFormat);
      }
      const decryptdata = frag.decryptdata;
      if (!decryptdata) {
        const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : "Missing decryption data on fragment in onKeyLoading");
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));
      }
      const uri = decryptdata.uri;
      if (!uri) {
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${uri}"`)));
      }
      let keyInfo = this.keyUriToKeyInfo[uri];
      if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
        decryptdata.key = keyInfo.decryptdata.key;
        return Promise.resolve({
          frag,
          keyInfo
        });
      }
      if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
        var _keyInfo$mediaKeySess;
        switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {
          case void 0:
          case "status-pending":
          case "usable":
          case "usable-in-future":
            return keyInfo.keyLoadPromise.then((keyLoadedData) => {
              decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
              return {
                frag,
                keyInfo
              };
            });
        }
      }
      keyInfo = this.keyUriToKeyInfo[uri] = {
        decryptdata,
        keyLoadPromise: null,
        loader: null,
        mediaKeySessionContext: null
      };
      switch (decryptdata.method) {
        case "ISO-23001-7":
        case "SAMPLE-AES":
        case "SAMPLE-AES-CENC":
        case "SAMPLE-AES-CTR":
          if (decryptdata.keyFormat === "identity") {
            return this.loadKeyHTTP(keyInfo, frag);
          }
          return this.loadKeyEME(keyInfo, frag);
        case "AES-128":
          return this.loadKeyHTTP(keyInfo, frag);
        default:
          return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${decryptdata.method}"`)));
      }
    }
    loadKeyEME(keyInfo, frag) {
      const keyLoadedData = {
        frag,
        keyInfo
      };
      if (this.emeController && this.config.emeEnabled) {
        const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
        if (keySessionContextPromise) {
          return (keyInfo.keyLoadPromise = keySessionContextPromise.then((keySessionContext) => {
            keyInfo.mediaKeySessionContext = keySessionContext;
            return keyLoadedData;
          })).catch((error) => {
            keyInfo.keyLoadPromise = null;
            throw error;
          });
        }
      }
      return Promise.resolve(keyLoadedData);
    }
    loadKeyHTTP(keyInfo, frag) {
      const config = this.config;
      const Loader = config.loader;
      const keyLoader = new Loader(config);
      frag.keyLoader = keyInfo.loader = keyLoader;
      return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {
        const loaderContext = {
          keyInfo,
          frag,
          responseType: "arraybuffer",
          url: keyInfo.decryptdata.uri
        };
        const loadPolicy = config.keyLoadPolicy.default;
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        };
        const loaderCallbacks = {
          onSuccess: (response, stats, context, networkDetails) => {
            const {
              frag: frag2,
              keyInfo: keyInfo2,
              url: uri
            } = context;
            if (!frag2.decryptdata || keyInfo2 !== this.keyUriToKeyInfo[uri]) {
              return reject(this.createKeyLoadError(frag2, ErrorDetails.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), networkDetails));
            }
            keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
            frag2.keyLoader = null;
            keyInfo2.loader = null;
            resolve({
              frag: frag2,
              keyInfo: keyInfo2
            });
          },
          onError: (response, context, networkDetails, stats) => {
            this.resetLoader(context);
            reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread22({
              url: loaderContext.url,
              data: void 0
            }, response)));
          },
          onTimeout: (stats, context, networkDetails) => {
            this.resetLoader(context);
            reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), networkDetails));
          },
          onAbort: (stats, context, networkDetails) => {
            this.resetLoader(context);
            reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error("key loading aborted"), networkDetails));
          }
        };
        keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
      });
    }
    resetLoader(context) {
      const {
        frag,
        keyInfo,
        url: uri
      } = context;
      const loader = keyInfo.loader;
      if (frag.keyLoader === loader) {
        frag.keyLoader = null;
        keyInfo.loader = null;
      }
      delete this.keyUriToKeyInfo[uri];
      if (loader) {
        loader.destroy();
      }
    }
  };
  var TaskLoop = class {
    constructor() {
      this._boundTick = void 0;
      this._tickTimer = null;
      this._tickInterval = null;
      this._tickCallCount = 0;
      this._boundTick = this.tick.bind(this);
    }
    destroy() {
      this.onHandlerDestroying();
      this.onHandlerDestroyed();
    }
    onHandlerDestroying() {
      this.clearNextTick();
      this.clearInterval();
    }
    onHandlerDestroyed() {
    }
    hasInterval() {
      return !!this._tickInterval;
    }
    hasNextTick() {
      return !!this._tickTimer;
    }
    setInterval(millis) {
      if (!this._tickInterval) {
        this._tickCallCount = 0;
        this._tickInterval = self.setInterval(this._boundTick, millis);
        return true;
      }
      return false;
    }
    clearInterval() {
      if (this._tickInterval) {
        self.clearInterval(this._tickInterval);
        this._tickInterval = null;
        return true;
      }
      return false;
    }
    clearNextTick() {
      if (this._tickTimer) {
        self.clearTimeout(this._tickTimer);
        this._tickTimer = null;
        return true;
      }
      return false;
    }
    tick() {
      this._tickCallCount++;
      if (this._tickCallCount === 1) {
        this.doTick();
        if (this._tickCallCount > 1) {
          this.tickImmediate();
        }
        this._tickCallCount = 0;
      }
    }
    tickImmediate() {
      this.clearNextTick();
      this._tickTimer = self.setTimeout(this._boundTick, 0);
    }
    doTick() {
    }
  };
  var noopBuffered = {
    length: 0,
    start: () => 0,
    end: () => 0
  };
  var BufferHelper = class {
    static isBuffered(media, position) {
      try {
        if (media) {
          const buffered = BufferHelper.getBuffered(media);
          for (let i2 = 0; i2 < buffered.length; i2++) {
            if (position >= buffered.start(i2) && position <= buffered.end(i2)) {
              return true;
            }
          }
        }
      } catch (error) {
      }
      return false;
    }
    static bufferInfo(media, pos, maxHoleDuration) {
      try {
        if (media) {
          const vbuffered = BufferHelper.getBuffered(media);
          const buffered = [];
          let i2;
          for (i2 = 0; i2 < vbuffered.length; i2++) {
            buffered.push({
              start: vbuffered.start(i2),
              end: vbuffered.end(i2)
            });
          }
          return this.bufferedInfo(buffered, pos, maxHoleDuration);
        }
      } catch (error) {
      }
      return {
        len: 0,
        start: pos,
        end: pos,
        nextStart: void 0
      };
    }
    static bufferedInfo(buffered, pos, maxHoleDuration) {
      pos = Math.max(0, pos);
      buffered.sort(function(a2, b3) {
        const diff = a2.start - b3.start;
        if (diff) {
          return diff;
        } else {
          return b3.end - a2.end;
        }
      });
      let buffered2 = [];
      if (maxHoleDuration) {
        for (let i2 = 0; i2 < buffered.length; i2++) {
          const buf2len = buffered2.length;
          if (buf2len) {
            const buf2end = buffered2[buf2len - 1].end;
            if (buffered[i2].start - buf2end < maxHoleDuration) {
              if (buffered[i2].end > buf2end) {
                buffered2[buf2len - 1].end = buffered[i2].end;
              }
            } else {
              buffered2.push(buffered[i2]);
            }
          } else {
            buffered2.push(buffered[i2]);
          }
        }
      } else {
        buffered2 = buffered;
      }
      let bufferLen = 0;
      let bufferStartNext;
      let bufferStart = pos;
      let bufferEnd = pos;
      for (let i2 = 0; i2 < buffered2.length; i2++) {
        const start = buffered2[i2].start;
        const end = buffered2[i2].end;
        if (pos + maxHoleDuration >= start && pos < end) {
          bufferStart = start;
          bufferEnd = end;
          bufferLen = bufferEnd - pos;
        } else if (pos + maxHoleDuration < start) {
          bufferStartNext = start;
          break;
        }
      }
      return {
        len: bufferLen,
        start: bufferStart || 0,
        end: bufferEnd || 0,
        nextStart: bufferStartNext
      };
    }
    static getBuffered(media) {
      try {
        return media.buffered;
      } catch (e3) {
        logger.log("failed to get media.buffered", e3);
        return noopBuffered;
      }
    }
  };
  var ChunkMetadata = class {
    constructor(level, sn2, id, size2 = 0, part = -1, partial = false) {
      this.level = void 0;
      this.sn = void 0;
      this.part = void 0;
      this.id = void 0;
      this.size = void 0;
      this.partial = void 0;
      this.transmuxing = getNewPerformanceTiming();
      this.buffering = {
        audio: getNewPerformanceTiming(),
        video: getNewPerformanceTiming(),
        audiovideo: getNewPerformanceTiming()
      };
      this.level = level;
      this.sn = sn2;
      this.id = id;
      this.size = size2;
      this.part = part;
      this.partial = partial;
    }
  };
  function getNewPerformanceTiming() {
    return {
      start: 0,
      executeStart: 0,
      executeEnd: 0,
      end: 0
    };
  }
  function findFirstFragWithCC(fragments, cc) {
    let firstFrag = null;
    for (let i2 = 0, len = fragments.length; i2 < len; i2++) {
      const currentFrag = fragments[i2];
      if (currentFrag && currentFrag.cc === cc) {
        firstFrag = currentFrag;
        break;
      }
    }
    return firstFrag;
  }
  function shouldAlignOnDiscontinuities(lastFrag, lastLevel, details) {
    if (lastLevel.details) {
      if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
        return true;
      }
    }
    return false;
  }
  function findDiscontinuousReferenceFrag(prevDetails, curDetails, referenceIndex = 0) {
    const prevFrags = prevDetails.fragments;
    const curFrags = curDetails.fragments;
    if (!curFrags.length || !prevFrags.length) {
      logger.log("No fragments to align");
      return;
    }
    const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
    if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
      logger.log("No frag in previous level to align on");
      return;
    }
    return prevStartFrag;
  }
  function adjustFragmentStart(frag, sliding) {
    if (frag) {
      const start = frag.start + sliding;
      frag.start = frag.startPTS = start;
      frag.endPTS = start + frag.duration;
    }
  }
  function adjustSlidingStart(sliding, details) {
    const fragments = details.fragments;
    for (let i2 = 0, len = fragments.length; i2 < len; i2++) {
      adjustFragmentStart(fragments[i2], sliding);
    }
    if (details.fragmentHint) {
      adjustFragmentStart(details.fragmentHint, sliding);
    }
    details.alignedSliding = true;
  }
  function alignStream(lastFrag, lastLevel, details) {
    if (!lastLevel) {
      return;
    }
    alignDiscontinuities(lastFrag, details, lastLevel);
    if (!details.alignedSliding && lastLevel.details) {
      alignPDT(details, lastLevel.details);
    }
    if (!details.alignedSliding && lastLevel.details && !details.skippedSegments) {
      adjustSliding(lastLevel.details, details);
    }
  }
  function alignDiscontinuities(lastFrag, details, lastLevel) {
    if (shouldAlignOnDiscontinuities(lastFrag, lastLevel, details)) {
      const referenceFrag = findDiscontinuousReferenceFrag(lastLevel.details, details);
      if (referenceFrag && isFiniteNumber(referenceFrag.start)) {
        logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);
        adjustSlidingStart(referenceFrag.start, details);
      }
    }
  }
  function alignPDT(details, lastDetails) {
    if (!lastDetails.fragments.length || !details.hasProgramDateTime || !lastDetails.hasProgramDateTime) {
      return;
    }
    const lastPDT = lastDetails.fragments[0].programDateTime;
    const newPDT = details.fragments[0].programDateTime;
    const sliding = (newPDT - lastPDT) / 1e3 + lastDetails.fragments[0].start;
    if (sliding && isFiniteNumber(sliding)) {
      logger.log(`Adjusting PTS using programDateTime delta ${newPDT - lastPDT}ms, sliding:${sliding.toFixed(3)} ${details.url} `);
      adjustSlidingStart(sliding, details);
    }
  }
  function alignMediaPlaylistByPDT(details, refDetails) {
    if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
      return;
    }
    const fragments = details.fragments;
    const refFragments = refDetails.fragments;
    if (!fragments.length || !refFragments.length) {
      return;
    }
    const middleFrag = Math.round(refFragments.length / 2) - 1;
    const refFrag = refFragments[middleFrag];
    const frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.round(fragments.length / 2) - 1];
    const refPDT = refFrag.programDateTime;
    const targetPDT = frag.programDateTime;
    if (refPDT === null || targetPDT === null) {
      return;
    }
    const delta = (targetPDT - refPDT) / 1e3 - (frag.start - refFrag.start);
    adjustSlidingStart(delta, details);
  }
  var AESCrypto = class {
    constructor(subtle, iv) {
      this.subtle = void 0;
      this.aesIV = void 0;
      this.subtle = subtle;
      this.aesIV = iv;
    }
    decrypt(data, key) {
      return this.subtle.decrypt({
        name: "AES-CBC",
        iv: this.aesIV
      }, key, data);
    }
  };
  var FastAESKey = class {
    constructor(subtle, key) {
      this.subtle = void 0;
      this.key = void 0;
      this.subtle = subtle;
      this.key = key;
    }
    expandKey() {
      return this.subtle.importKey("raw", this.key, {
        name: "AES-CBC"
      }, false, ["encrypt", "decrypt"]);
    }
  };
  function removePadding(array) {
    const outputBytes = array.byteLength;
    const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
    if (paddingBytes) {
      return sliceUint8(array, 0, outputBytes - paddingBytes);
    }
    return array;
  }
  var AESDecryptor = class {
    constructor() {
      this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
      this.sBox = new Uint32Array(256);
      this.invSBox = new Uint32Array(256);
      this.key = new Uint32Array(0);
      this.ksRows = 0;
      this.keySize = 0;
      this.keySchedule = void 0;
      this.invKeySchedule = void 0;
      this.initTable();
    }
    uint8ArrayToUint32Array_(arrayBuffer) {
      const view = new DataView(arrayBuffer);
      const newArray = new Uint32Array(4);
      for (let i2 = 0; i2 < 4; i2++) {
        newArray[i2] = view.getUint32(i2 * 4);
      }
      return newArray;
    }
    initTable() {
      const sBox = this.sBox;
      const invSBox = this.invSBox;
      const subMix = this.subMix;
      const subMix0 = subMix[0];
      const subMix1 = subMix[1];
      const subMix2 = subMix[2];
      const subMix3 = subMix[3];
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      const d3 = new Uint32Array(256);
      let x2 = 0;
      let xi = 0;
      let i2 = 0;
      for (i2 = 0; i2 < 256; i2++) {
        if (i2 < 128) {
          d3[i2] = i2 << 1;
        } else {
          d3[i2] = i2 << 1 ^ 283;
        }
      }
      for (i2 = 0; i2 < 256; i2++) {
        let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 255 ^ 99;
        sBox[x2] = sx;
        invSBox[sx] = x2;
        const x22 = d3[x2];
        const x4 = d3[x22];
        const x8 = d3[x4];
        let t2 = d3[sx] * 257 ^ sx * 16843008;
        subMix0[x2] = t2 << 24 | t2 >>> 8;
        subMix1[x2] = t2 << 16 | t2 >>> 16;
        subMix2[x2] = t2 << 8 | t2 >>> 24;
        subMix3[x2] = t2;
        t2 = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x2 * 16843008;
        invSubMix0[sx] = t2 << 24 | t2 >>> 8;
        invSubMix1[sx] = t2 << 16 | t2 >>> 16;
        invSubMix2[sx] = t2 << 8 | t2 >>> 24;
        invSubMix3[sx] = t2;
        if (!x2) {
          x2 = xi = 1;
        } else {
          x2 = x22 ^ d3[d3[d3[x8 ^ x22]]];
          xi ^= d3[d3[xi]];
        }
      }
    }
    expandKey(keyBuffer) {
      const key = this.uint8ArrayToUint32Array_(keyBuffer);
      let sameKey = true;
      let offset2 = 0;
      while (offset2 < key.length && sameKey) {
        sameKey = key[offset2] === this.key[offset2];
        offset2++;
      }
      if (sameKey) {
        return;
      }
      this.key = key;
      const keySize = this.keySize = key.length;
      if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
        throw new Error("Invalid aes key size=" + keySize);
      }
      const ksRows = this.ksRows = (keySize + 6 + 1) * 4;
      let ksRow;
      let invKsRow;
      const keySchedule = this.keySchedule = new Uint32Array(ksRows);
      const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
      const sbox = this.sBox;
      const rcon = this.rcon;
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      let prev;
      let t2;
      for (ksRow = 0; ksRow < ksRows; ksRow++) {
        if (ksRow < keySize) {
          prev = keySchedule[ksRow] = key[ksRow];
          continue;
        }
        t2 = prev;
        if (ksRow % keySize === 0) {
          t2 = t2 << 8 | t2 >>> 24;
          t2 = sbox[t2 >>> 24] << 24 | sbox[t2 >>> 16 & 255] << 16 | sbox[t2 >>> 8 & 255] << 8 | sbox[t2 & 255];
          t2 ^= rcon[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          t2 = sbox[t2 >>> 24] << 24 | sbox[t2 >>> 16 & 255] << 16 | sbox[t2 >>> 8 & 255] << 8 | sbox[t2 & 255];
        }
        keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t2) >>> 0;
      }
      for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {
        ksRow = ksRows - invKsRow;
        if (invKsRow & 3) {
          t2 = keySchedule[ksRow];
        } else {
          t2 = keySchedule[ksRow - 4];
        }
        if (invKsRow < 4 || ksRow <= 4) {
          invKeySchedule[invKsRow] = t2;
        } else {
          invKeySchedule[invKsRow] = invSubMix0[sbox[t2 >>> 24]] ^ invSubMix1[sbox[t2 >>> 16 & 255]] ^ invSubMix2[sbox[t2 >>> 8 & 255]] ^ invSubMix3[sbox[t2 & 255]];
        }
        invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
      }
    }
    networkToHostOrderSwap(word) {
      return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
    }
    decrypt(inputArrayBuffer, offset2, aesIV) {
      const nRounds = this.keySize + 6;
      const invKeySchedule = this.invKeySchedule;
      const invSBOX = this.invSBox;
      const invSubMix = this.invSubMix;
      const invSubMix0 = invSubMix[0];
      const invSubMix1 = invSubMix[1];
      const invSubMix2 = invSubMix[2];
      const invSubMix3 = invSubMix[3];
      const initVector = this.uint8ArrayToUint32Array_(aesIV);
      let initVector0 = initVector[0];
      let initVector1 = initVector[1];
      let initVector2 = initVector[2];
      let initVector3 = initVector[3];
      const inputInt32 = new Int32Array(inputArrayBuffer);
      const outputInt32 = new Int32Array(inputInt32.length);
      let t0, t1, t2, t3;
      let s0, s1, s2, s3;
      let inputWords0, inputWords1, inputWords2, inputWords3;
      let ksRow, i2;
      const swapWord = this.networkToHostOrderSwap;
      while (offset2 < inputInt32.length) {
        inputWords0 = swapWord(inputInt32[offset2]);
        inputWords1 = swapWord(inputInt32[offset2 + 1]);
        inputWords2 = swapWord(inputInt32[offset2 + 2]);
        inputWords3 = swapWord(inputInt32[offset2 + 3]);
        s0 = inputWords0 ^ invKeySchedule[0];
        s1 = inputWords3 ^ invKeySchedule[1];
        s2 = inputWords2 ^ invKeySchedule[2];
        s3 = inputWords1 ^ invKeySchedule[3];
        ksRow = 4;
        for (i2 = 1; i2 < nRounds; i2++) {
          t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
          t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
          t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
          t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
          ksRow = ksRow + 4;
        }
        t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
        t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
        t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
        t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
        outputInt32[offset2] = swapWord(t0 ^ initVector0);
        outputInt32[offset2 + 1] = swapWord(t3 ^ initVector1);
        outputInt32[offset2 + 2] = swapWord(t2 ^ initVector2);
        outputInt32[offset2 + 3] = swapWord(t1 ^ initVector3);
        initVector0 = inputWords0;
        initVector1 = inputWords1;
        initVector2 = inputWords2;
        initVector3 = inputWords3;
        offset2 = offset2 + 4;
      }
      return outputInt32.buffer;
    }
  };
  var CHUNK_SIZE = 16;
  var Decrypter = class {
    constructor(config, {
      removePKCS7Padding = true
    } = {}) {
      this.logEnabled = true;
      this.removePKCS7Padding = void 0;
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
      this.useSoftware = void 0;
      this.useSoftware = config.enableSoftwareAES;
      this.removePKCS7Padding = removePKCS7Padding;
      if (removePKCS7Padding) {
        try {
          const browserCrypto = self.crypto;
          if (browserCrypto) {
            this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
          }
        } catch (e3) {
        }
      }
      if (this.subtle === null) {
        this.useSoftware = true;
      }
    }
    destroy() {
      this.subtle = null;
      this.softwareDecrypter = null;
      this.key = null;
      this.fastAesKey = null;
      this.remainderData = null;
      this.currentIV = null;
      this.currentResult = null;
    }
    isSync() {
      return this.useSoftware;
    }
    flush() {
      const {
        currentResult,
        remainderData
      } = this;
      if (!currentResult || remainderData) {
        this.reset();
        return null;
      }
      const data = new Uint8Array(currentResult);
      this.reset();
      if (this.removePKCS7Padding) {
        return removePadding(data);
      }
      return data;
    }
    reset() {
      this.currentResult = null;
      this.currentIV = null;
      this.remainderData = null;
      if (this.softwareDecrypter) {
        this.softwareDecrypter = null;
      }
    }
    decrypt(data, key, iv) {
      if (this.useSoftware) {
        return new Promise((resolve, reject) => {
          this.softwareDecrypt(new Uint8Array(data), key, iv);
          const decryptResult = this.flush();
          if (decryptResult) {
            resolve(decryptResult.buffer);
          } else {
            reject(new Error("[softwareDecrypt] Failed to decrypt data"));
          }
        });
      }
      return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
    }
    softwareDecrypt(data, key, iv) {
      const {
        currentIV,
        currentResult,
        remainderData
      } = this;
      this.logOnce("JS AES decrypt");
      if (remainderData) {
        data = appendUint8Array(remainderData, data);
        this.remainderData = null;
      }
      const currentChunk = this.getValidChunk(data);
      if (!currentChunk.length) {
        return null;
      }
      if (currentIV) {
        iv = currentIV;
      }
      let softwareDecrypter = this.softwareDecrypter;
      if (!softwareDecrypter) {
        softwareDecrypter = this.softwareDecrypter = new AESDecryptor();
      }
      softwareDecrypter.expandKey(key);
      const result = currentResult;
      this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
      this.currentIV = sliceUint8(currentChunk, -16).buffer;
      if (!result) {
        return null;
      }
      return result;
    }
    webCryptoDecrypt(data, key, iv) {
      const subtle = this.subtle;
      if (this.key !== key || !this.fastAesKey) {
        this.key = key;
        this.fastAesKey = new FastAESKey(subtle, key);
      }
      return this.fastAesKey.expandKey().then((aesKey) => {
        if (!subtle) {
          return Promise.reject(new Error("web crypto not initialized"));
        }
        this.logOnce("WebCrypto AES decrypt");
        const crypto2 = new AESCrypto(subtle, new Uint8Array(iv));
        return crypto2.decrypt(data.buffer, aesKey);
      }).catch((err) => {
        logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);
        return this.onWebCryptoError(data, key, iv);
      });
    }
    onWebCryptoError(data, key, iv) {
      this.useSoftware = true;
      this.logEnabled = true;
      this.softwareDecrypt(data, key, iv);
      const decryptResult = this.flush();
      if (decryptResult) {
        return decryptResult.buffer;
      }
      throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data");
    }
    getValidChunk(data) {
      let currentChunk = data;
      const splitPoint = data.length - data.length % CHUNK_SIZE;
      if (splitPoint !== data.length) {
        currentChunk = sliceUint8(data, 0, splitPoint);
        this.remainderData = sliceUint8(data, splitPoint);
      }
      return currentChunk;
    }
    logOnce(msg) {
      if (!this.logEnabled) {
        return;
      }
      logger.log(`[decrypter]: ${msg}`);
      this.logEnabled = false;
    }
  };
  var TimeRanges = {
    toString: function(r2) {
      let log = "";
      const len = r2.length;
      for (let i2 = 0; i2 < len; i2++) {
        log += `[${r2.start(i2).toFixed(3)}-${r2.end(i2).toFixed(3)}]`;
      }
      return log;
    }
  };
  var State = {
    STOPPED: "STOPPED",
    IDLE: "IDLE",
    KEY_LOADING: "KEY_LOADING",
    FRAG_LOADING: "FRAG_LOADING",
    FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
    WAITING_TRACK: "WAITING_TRACK",
    PARSING: "PARSING",
    PARSED: "PARSED",
    ENDED: "ENDED",
    ERROR: "ERROR",
    WAITING_INIT_PTS: "WAITING_INIT_PTS",
    WAITING_LEVEL: "WAITING_LEVEL"
  };
  var BaseStreamController = class extends TaskLoop {
    constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
      super();
      this.hls = void 0;
      this.fragPrevious = null;
      this.fragCurrent = null;
      this.fragmentTracker = void 0;
      this.transmuxer = null;
      this._state = State.STOPPED;
      this.playlistType = void 0;
      this.media = null;
      this.mediaBuffer = null;
      this.config = void 0;
      this.bitrateTest = false;
      this.lastCurrentTime = 0;
      this.nextLoadPosition = 0;
      this.startPosition = 0;
      this.startTimeOffset = null;
      this.loadedmetadata = false;
      this.retryDate = 0;
      this.levels = null;
      this.fragmentLoader = void 0;
      this.keyLoader = void 0;
      this.levelLastLoaded = null;
      this.startFragRequested = false;
      this.decrypter = void 0;
      this.initPTS = [];
      this.onvseeking = null;
      this.onvended = null;
      this.logPrefix = "";
      this.log = void 0;
      this.warn = void 0;
      this.playlistType = playlistType;
      this.logPrefix = logPrefix;
      this.log = logger.log.bind(logger, `${logPrefix}:`);
      this.warn = logger.warn.bind(logger, `${logPrefix}:`);
      this.hls = hls;
      this.fragmentLoader = new FragmentLoader(hls.config);
      this.keyLoader = keyLoader;
      this.fragmentTracker = fragmentTracker;
      this.config = hls.config;
      this.decrypter = new Decrypter(hls.config);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    doTick() {
      this.onTickEnd();
    }
    onTickEnd() {
    }
    startLoad(startPosition) {
    }
    stopLoad() {
      this.fragmentLoader.abort();
      this.keyLoader.abort(this.playlistType);
      const frag = this.fragCurrent;
      if (frag != null && frag.loader) {
        frag.abortRequests();
        this.fragmentTracker.removeFragment(frag);
      }
      this.resetTransmuxer();
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.clearInterval();
      this.clearNextTick();
      this.state = State.STOPPED;
    }
    _streamEnded(bufferInfo, levelDetails) {
      if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
        return false;
      }
      const partList = levelDetails.partList;
      if (partList != null && partList.length) {
        const lastPart = partList[partList.length - 1];
        const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
        return lastPartBuffered;
      }
      const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
      return this.fragmentTracker.isEndListAppended(playlistType);
    }
    getLevelDetails() {
      if (this.levels && this.levelLastLoaded !== null) {
        var _this$levels$this$lev;
        return (_this$levels$this$lev = this.levels[this.levelLastLoaded]) == null ? void 0 : _this$levels$this$lev.details;
      }
    }
    onMediaAttached(event, data) {
      const media = this.media = this.mediaBuffer = data.media;
      this.onvseeking = this.onMediaSeeking.bind(this);
      this.onvended = this.onMediaEnded.bind(this);
      media.addEventListener("seeking", this.onvseeking);
      media.addEventListener("ended", this.onvended);
      const config = this.config;
      if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
        this.startLoad(config.startPosition);
      }
    }
    onMediaDetaching() {
      const media = this.media;
      if (media != null && media.ended) {
        this.log("MSE detaching and video ended, reset startPosition");
        this.startPosition = this.lastCurrentTime = 0;
      }
      if (media && this.onvseeking && this.onvended) {
        media.removeEventListener("seeking", this.onvseeking);
        media.removeEventListener("ended", this.onvended);
        this.onvseeking = this.onvended = null;
      }
      if (this.keyLoader) {
        this.keyLoader.detach();
      }
      this.media = this.mediaBuffer = null;
      this.loadedmetadata = false;
      this.fragmentTracker.removeAllFragments();
      this.stopLoad();
    }
    onMediaSeeking() {
      const {
        config,
        fragCurrent,
        media,
        mediaBuffer,
        state
      } = this;
      const currentTime = media ? media.currentTime : 0;
      const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
      this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);
      if (this.state === State.ENDED) {
        this.resetLoadingState();
      } else if (fragCurrent) {
        const tolerance = config.maxFragLookUpTolerance;
        const fragStartOffset = fragCurrent.start - tolerance;
        const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
        if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
          const pastFragment = currentTime > fragEndOffset;
          if (currentTime < fragStartOffset || pastFragment) {
            if (pastFragment && fragCurrent.loader) {
              this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
              fragCurrent.abortRequests();
              this.resetLoadingState();
            }
            this.fragPrevious = null;
          }
        }
      }
      if (media) {
        this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
        this.lastCurrentTime = currentTime;
      }
      if (!this.loadedmetadata && !bufferInfo.len) {
        this.nextLoadPosition = this.startPosition = currentTime;
      }
      this.tickImmediate();
    }
    onMediaEnded() {
      this.startPosition = this.lastCurrentTime = 0;
    }
    onManifestLoaded(event, data) {
      this.startTimeOffset = data.startTimeOffset;
      this.initPTS = [];
    }
    onHandlerDestroying() {
      this.stopLoad();
      super.onHandlerDestroying();
    }
    onHandlerDestroyed() {
      this.state = State.STOPPED;
      if (this.fragmentLoader) {
        this.fragmentLoader.destroy();
      }
      if (this.keyLoader) {
        this.keyLoader.destroy();
      }
      if (this.decrypter) {
        this.decrypter.destroy();
      }
      this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
      super.onHandlerDestroyed();
    }
    loadFragment(frag, level, targetBufferTime) {
      this._loadFragForPlayback(frag, level, targetBufferTime);
    }
    _loadFragForPlayback(frag, level, targetBufferTime) {
      const progressCallback = (data) => {
        if (this.fragContextChanged(frag)) {
          this.warn(`Fragment ${frag.sn}${data.part ? " p: " + data.part.index : ""} of level ${frag.level} was dropped during download.`);
          this.fragmentTracker.removeFragment(frag);
          return;
        }
        frag.stats.chunkCount++;
        this._handleFragmentLoadProgress(data);
      };
      this._doFragLoad(frag, level, targetBufferTime, progressCallback).then((data) => {
        if (!data) {
          return;
        }
        const state = this.state;
        if (this.fragContextChanged(frag)) {
          if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {
            this.fragmentTracker.removeFragment(frag);
            this.state = State.IDLE;
          }
          return;
        }
        if ("payload" in data) {
          this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);
          this.hls.trigger(Events.FRAG_LOADED, data);
        }
        this._handleFragmentLoadComplete(data);
      }).catch((reason) => {
        if (this.state === State.STOPPED || this.state === State.ERROR) {
          return;
        }
        this.warn(reason);
        this.resetFragmentLoading(frag);
      });
    }
    clearTrackerIfNeeded(frag) {
      var _this$mediaBuffer;
      const {
        fragmentTracker
      } = this;
      const fragState = fragmentTracker.getState(frag);
      if (fragState === FragmentState.APPENDING) {
        const playlistType = frag.type;
        const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
        const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
        if (this.reduceMaxBufferLength(minForwardBufferLength)) {
          fragmentTracker.removeFragment(frag);
        }
      } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {
        fragmentTracker.removeAllFragments();
      } else if (fragmentTracker.hasParts(frag.type)) {
        fragmentTracker.detectPartialFragments({
          frag,
          part: null,
          stats: frag.stats,
          id: frag.type
        });
        if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
          fragmentTracker.removeFragment(frag);
        }
      }
    }
    checkLiveUpdate(details) {
      if (details.updated && !details.live) {
        const lastFragment = details.fragments[details.fragments.length - 1];
        this.fragmentTracker.detectPartialFragments({
          frag: lastFragment,
          part: null,
          stats: lastFragment.stats,
          id: lastFragment.type
        });
      }
      if (!details.fragments[0]) {
        details.deltaUpdateFailed = true;
      }
    }
    flushMainBuffer(startOffset, endOffset, type = null) {
      if (!(startOffset - endOffset)) {
        return;
      }
      const flushScope = {
        startOffset,
        endOffset,
        type
      };
      this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
    }
    _loadInitSegment(frag, level) {
      this._doFragLoad(frag, level).then((data) => {
        if (!data || this.fragContextChanged(frag) || !this.levels) {
          throw new Error("init load aborted");
        }
        return data;
      }).then((data) => {
        const {
          hls
        } = this;
        const {
          payload
        } = data;
        const decryptData = frag.decryptdata;
        if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
          const startTime = self.performance.now();
          return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err) => {
            hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.FRAG_DECRYPT_ERROR,
              fatal: false,
              error: err,
              reason: err.message,
              frag
            });
            throw err;
          }).then((decryptedData) => {
            const endTime = self.performance.now();
            hls.trigger(Events.FRAG_DECRYPTED, {
              frag,
              payload: decryptedData,
              stats: {
                tstart: startTime,
                tdecrypt: endTime
              }
            });
            data.payload = decryptedData;
            return data;
          });
        }
        return data;
      }).then((data) => {
        const {
          fragCurrent,
          hls,
          levels
        } = this;
        if (!levels) {
          throw new Error("init load aborted, missing levels");
        }
        const stats = frag.stats;
        this.state = State.IDLE;
        level.fragmentError = 0;
        frag.data = new Uint8Array(data.payload);
        stats.parsing.start = stats.buffering.start = self.performance.now();
        stats.parsing.end = stats.buffering.end = self.performance.now();
        if (data.frag === fragCurrent) {
          hls.trigger(Events.FRAG_BUFFERED, {
            stats,
            frag: fragCurrent,
            part: null,
            id: frag.type
          });
        }
        this.tick();
      }).catch((reason) => {
        if (this.state === State.STOPPED || this.state === State.ERROR) {
          return;
        }
        this.warn(reason);
        this.resetFragmentLoading(frag);
      });
    }
    fragContextChanged(frag) {
      const {
        fragCurrent
      } = this;
      return !frag || !fragCurrent || frag.level !== fragCurrent.level || frag.sn !== fragCurrent.sn || frag.urlId !== fragCurrent.urlId;
    }
    fragBufferedComplete(frag, part) {
      var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
      const media = this.mediaBuffer ? this.mediaBuffer : this.media;
      this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? " part: " + part.index : ""} of ${this.playlistType === PlaylistLevelType.MAIN ? "level" : "track"} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : "(detached)"})`);
      this.state = State.IDLE;
      if (!media) {
        return;
      }
      if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {
        this.loadedmetadata = true;
        this.seekToStartPos();
      }
      this.tick();
    }
    seekToStartPos() {
    }
    _handleFragmentLoadComplete(fragLoadedEndData) {
      const {
        transmuxer
      } = this;
      if (!transmuxer) {
        return;
      }
      const {
        frag,
        part,
        partsLoaded
      } = fragLoadedEndData;
      const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some((fragLoaded) => !fragLoaded);
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
      transmuxer.flush(chunkMeta);
    }
    _handleFragmentLoadProgress(frag) {
    }
    _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {
      var _frag$decryptdata;
      const details = level == null ? void 0 : level.details;
      if (!this.levels || !details) {
        throw new Error(`frag load aborted, missing level${details ? "" : " detail"}s`);
      }
      let keyLoadingPromise = null;
      if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
        this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === "[stream-controller]" ? "level" : "track"} ${frag.level}`);
        this.state = State.KEY_LOADING;
        this.fragCurrent = frag;
        keyLoadingPromise = this.keyLoader.load(frag).then((keyLoadedData) => {
          if (!this.fragContextChanged(keyLoadedData.frag)) {
            this.hls.trigger(Events.KEY_LOADED, keyLoadedData);
            if (this.state === State.KEY_LOADING) {
              this.state = State.IDLE;
            }
            return keyLoadedData;
          }
        });
        this.hls.trigger(Events.KEY_LOADING, {
          frag
        });
        if (this.fragCurrent === null) {
          keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));
        }
      } else if (!frag.encrypted && details.encryptedFragments.length) {
        this.keyLoader.loadClear(frag, details.encryptedFragments);
      }
      targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
      if (this.config.lowLatencyMode && frag.sn !== "initSegment") {
        const partList = details.partList;
        if (partList && progressCallback) {
          if (targetBufferTime > frag.end && details.fragmentHint) {
            frag = details.fragmentHint;
          }
          const partIndex = this.getNextPart(partList, frag, targetBufferTime);
          if (partIndex > -1) {
            const part = partList[partIndex];
            this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
            this.nextLoadPosition = part.start + part.duration;
            this.state = State.FRAG_LOADING;
            let _result;
            if (keyLoadingPromise) {
              _result = keyLoadingPromise.then((keyLoadedData) => {
                if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {
                  return null;
                }
                return this.doFragPartsLoad(frag, part, level, progressCallback);
              }).catch((error) => this.handleFragLoadError(error));
            } else {
              _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch((error) => this.handleFragLoadError(error));
            }
            this.hls.trigger(Events.FRAG_LOADING, {
              frag,
              part,
              targetBufferTime
            });
            if (this.fragCurrent === null) {
              return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));
            }
            return _result;
          } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
            return Promise.resolve(null);
          }
        }
      }
      this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? "of [" + details.startSN + "-" + details.endSN + "] " : ""}${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
      if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
        this.nextLoadPosition = frag.start + frag.duration;
      }
      this.state = State.FRAG_LOADING;
      const dataOnProgress = this.config.progressive;
      let result;
      if (dataOnProgress && keyLoadingPromise) {
        result = keyLoadingPromise.then((keyLoadedData) => {
          if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {
            return null;
          }
          return this.fragmentLoader.load(frag, progressCallback);
        }).catch((error) => this.handleFragLoadError(error));
      } else {
        result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : void 0), keyLoadingPromise]).then(([fragLoadedData]) => {
          if (!dataOnProgress && fragLoadedData && progressCallback) {
            progressCallback(fragLoadedData);
          }
          return fragLoadedData;
        }).catch((error) => this.handleFragLoadError(error));
      }
      this.hls.trigger(Events.FRAG_LOADING, {
        frag,
        targetBufferTime
      });
      if (this.fragCurrent === null) {
        return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));
      }
      return result;
    }
    doFragPartsLoad(frag, fromPart, level, progressCallback) {
      return new Promise((resolve, reject) => {
        var _level$details;
        const partsLoaded = [];
        const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;
        const loadPart = (part) => {
          this.fragmentLoader.loadPart(frag, part, progressCallback).then((partLoadedData) => {
            partsLoaded[part.index] = partLoadedData;
            const loadedPart = partLoadedData.part;
            this.hls.trigger(Events.FRAG_LOADED, partLoadedData);
            const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
            if (nextPart) {
              loadPart(nextPart);
            } else {
              return resolve({
                frag,
                part: loadedPart,
                partsLoaded
              });
            }
          }).catch(reject);
        };
        loadPart(fromPart);
      });
    }
    handleFragLoadError(error) {
      if ("data" in error) {
        const data = error.data;
        if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
          this.handleFragLoadAborted(data.frag, data.part);
        } else {
          this.hls.trigger(Events.ERROR, data);
        }
      } else {
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.OTHER_ERROR,
          details: ErrorDetails.INTERNAL_EXCEPTION,
          err: error,
          error,
          fatal: true
        });
      }
      return null;
    }
    _handleTransmuxerFlush(chunkMeta) {
      const context = this.getCurrentContext(chunkMeta);
      if (!context || this.state !== State.PARSING) {
        if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
          this.state = State.IDLE;
        }
        return;
      }
      const {
        frag,
        part,
        level
      } = context;
      const now2 = self.performance.now();
      frag.stats.parsing.end = now2;
      if (part) {
        part.stats.parsing.end = now2;
      }
      this.updateLevelTiming(frag, part, level, chunkMeta.partial);
    }
    getCurrentContext(chunkMeta) {
      const {
        levels,
        fragCurrent
      } = this;
      const {
        level: levelIndex,
        sn: sn2,
        part: partIndex
      } = chunkMeta;
      if (!(levels != null && levels[levelIndex])) {
        this.warn(`Levels object was unset while buffering fragment ${sn2} of level ${levelIndex}. The current chunk will not be buffered.`);
        return null;
      }
      const level = levels[levelIndex];
      const part = partIndex > -1 ? getPartWith(level, sn2, partIndex) : null;
      const frag = part ? part.fragment : getFragmentWithSN(level, sn2, fragCurrent);
      if (!frag) {
        return null;
      }
      if (fragCurrent && fragCurrent !== frag) {
        frag.stats = fragCurrent.stats;
      }
      return {
        frag,
        part,
        level
      };
    }
    bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
      var _buffer;
      if (!data || this.state !== State.PARSING) {
        return;
      }
      const {
        data1,
        data2
      } = data;
      let buffer = data1;
      if (data1 && data2) {
        buffer = appendUint8Array(data1, data2);
      }
      if (!((_buffer = buffer) != null && _buffer.length)) {
        return;
      }
      const segment = {
        type: data.type,
        frag,
        part,
        chunkMeta,
        parent: frag.type,
        data: buffer
      };
      this.hls.trigger(Events.BUFFER_APPENDING, segment);
      if (data.dropped && data.independent && !part) {
        if (noBacktracking) {
          return;
        }
        this.flushBufferGap(frag);
      }
    }
    flushBufferGap(frag) {
      const media = this.media;
      if (!media) {
        return;
      }
      if (!BufferHelper.isBuffered(media, media.currentTime)) {
        this.flushMainBuffer(0, frag.start);
        return;
      }
      const currentTime = media.currentTime;
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const fragDuration = frag.duration;
      const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
      const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
      if (frag.start - start > segmentFraction) {
        this.flushMainBuffer(start, frag.start);
      }
    }
    getFwdBufferInfo(bufferable, type) {
      const pos = this.getLoadPosition();
      if (!isFiniteNumber(pos)) {
        return null;
      }
      return this.getFwdBufferInfoAtPos(bufferable, pos, type);
    }
    getFwdBufferInfoAtPos(bufferable, pos, type) {
      const {
        config: {
          maxBufferHole
        }
      } = this;
      const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
      if (bufferInfo.len === 0 && bufferInfo.nextStart !== void 0) {
        const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
        if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
          return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));
        }
      }
      return bufferInfo;
    }
    getMaxBufferLength(levelBitrate) {
      const {
        config
      } = this;
      let maxBufLen;
      if (levelBitrate) {
        maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
      } else {
        maxBufLen = config.maxBufferLength;
      }
      return Math.min(maxBufLen, config.maxMaxBufferLength);
    }
    reduceMaxBufferLength(threshold) {
      const config = this.config;
      const minLength = threshold || config.maxBufferLength;
      if (config.maxMaxBufferLength >= minLength) {
        config.maxMaxBufferLength /= 2;
        this.warn(`Reduce max buffer length to ${config.maxMaxBufferLength}s`);
        return true;
      }
      return false;
    }
    getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {
      const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);
      if (fragOrPart && "fragment" in fragOrPart) {
        return fragOrPart.fragment;
      }
      return fragOrPart;
    }
    getNextFragment(pos, levelDetails) {
      const fragments = levelDetails.fragments;
      const fragLen = fragments.length;
      if (!fragLen) {
        return null;
      }
      const {
        config
      } = this;
      const start = fragments[0].start;
      let frag;
      if (levelDetails.live) {
        const initialLiveManifestSize = config.initialLiveManifestSize;
        if (fragLen < initialLiveManifestSize) {
          this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);
          return null;
        }
        if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1) {
          frag = this.getInitialLiveFragment(levelDetails, fragments);
          this.startPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
        }
      } else if (pos <= start) {
        frag = fragments[0];
      }
      if (!frag) {
        const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
        frag = this.getFragmentAtPosition(pos, end, levelDetails);
      }
      return this.mapToInitFragWhenRequired(frag);
    }
    isLoopLoading(frag, targetBufferTime) {
      const trackerState = this.fragmentTracker.getState(frag);
      return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
    }
    getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
      const gapStart = frag.gap;
      const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
      if (nextFragment === null) {
        return nextFragment;
      }
      frag = nextFragment;
      if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {
        const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);
        if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
          this.log(`buffer full after gaps in "${playlistType}" playlist starting at sn: ${frag.sn}`);
          return null;
        }
      }
      return frag;
    }
    mapToInitFragWhenRequired(frag) {
      if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {
        return frag.initSegment;
      }
      return frag;
    }
    getNextPart(partList, frag, targetBufferTime) {
      let nextPart = -1;
      let contiguous = false;
      let independentAttrOmitted = true;
      for (let i2 = 0, len = partList.length; i2 < len; i2++) {
        const part = partList[i2];
        independentAttrOmitted = independentAttrOmitted && !part.independent;
        if (nextPart > -1 && targetBufferTime < part.start) {
          break;
        }
        const loaded = part.loaded;
        if (loaded) {
          nextPart = -1;
        } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
          nextPart = i2;
        }
        contiguous = loaded;
      }
      return nextPart;
    }
    loadedEndOfParts(partList, targetBufferTime) {
      const lastPart = partList[partList.length - 1];
      return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
    }
    getInitialLiveFragment(levelDetails, fragments) {
      const fragPrevious = this.fragPrevious;
      let frag = null;
      if (fragPrevious) {
        if (levelDetails.hasProgramDateTime) {
          this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);
          frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
        }
        if (!frag) {
          const targetSN = fragPrevious.sn + 1;
          if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
            const fragNext = fragments[targetSN - levelDetails.startSN];
            if (fragPrevious.cc === fragNext.cc) {
              frag = fragNext;
              this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);
            }
          }
          if (!frag) {
            frag = findFragWithCC(fragments, fragPrevious.cc);
            if (frag) {
              this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);
            }
          }
        }
      } else {
        const liveStart = this.hls.liveSyncPosition;
        if (liveStart !== null) {
          frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
        }
      }
      return frag;
    }
    getFragmentAtPosition(bufferEnd, end, levelDetails) {
      const {
        config
      } = this;
      let {
        fragPrevious
      } = this;
      let {
        fragments,
        endSN
      } = levelDetails;
      const {
        fragmentHint
      } = levelDetails;
      const tolerance = config.maxFragLookUpTolerance;
      const partList = levelDetails.partList;
      const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);
      if (loadingParts && fragmentHint && !this.bitrateTest) {
        fragments = fragments.concat(fragmentHint);
        endSN = fragmentHint.sn;
      }
      let frag;
      if (bufferEnd < end) {
        const lookupTolerance = bufferEnd > end - tolerance ? 0 : tolerance;
        frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
      } else {
        frag = fragments[fragments.length - 1];
      }
      if (frag) {
        const curSNIdx = frag.sn - levelDetails.startSN;
        const fragState = this.fragmentTracker.getState(frag);
        if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
          fragPrevious = frag;
        }
        if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {
          const sameLevel = fragPrevious && frag.level === fragPrevious.level;
          if (sameLevel) {
            const nextFrag = fragments[curSNIdx + 1];
            if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
              frag = nextFrag;
            } else {
              frag = null;
            }
          }
        }
      }
      return frag;
    }
    synchronizeToLiveEdge(levelDetails) {
      const {
        config,
        media
      } = this;
      if (!media) {
        return;
      }
      const liveSyncPosition = this.hls.liveSyncPosition;
      const currentTime = media.currentTime;
      const start = levelDetails.fragments[0].start;
      const end = levelDetails.edge;
      const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
      if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
        const maxLatency = config.liveMaxLatencyDuration !== void 0 ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
        if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
          if (!this.loadedmetadata) {
            this.nextLoadPosition = liveSyncPosition;
          }
          if (media.readyState) {
            this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);
            media.currentTime = liveSyncPosition;
          }
        }
      }
    }
    alignPlaylists(details, previousDetails) {
      const {
        levels,
        levelLastLoaded,
        fragPrevious
      } = this;
      const lastLevel = levelLastLoaded !== null ? levels[levelLastLoaded] : null;
      const length = details.fragments.length;
      if (!length) {
        this.warn(`No fragments in live playlist`);
        return 0;
      }
      const slidingStart = details.fragments[0].start;
      const firstLevelLoad = !previousDetails;
      const aligned = details.alignedSliding && isFiniteNumber(slidingStart);
      if (firstLevelLoad || !aligned && !slidingStart) {
        alignStream(fragPrevious, lastLevel, details);
        const alignedSlidingStart = details.fragments[0].start;
        this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : "na"}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : "na"} fragments: ${length}`);
        return alignedSlidingStart;
      }
      return slidingStart;
    }
    waitForCdnTuneIn(details) {
      const advancePartLimit = 3;
      return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
    }
    setStartPosition(details, sliding) {
      let startPosition = this.startPosition;
      if (startPosition < sliding) {
        startPosition = -1;
      }
      if (startPosition === -1 || this.lastCurrentTime === -1) {
        const offsetInMultivariantPlaylist = this.startTimeOffset !== null;
        const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
        if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
          startPosition = sliding + startTimeOffset;
          if (startTimeOffset < 0) {
            startPosition += details.totalduration;
          }
          startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
          this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? "multivariant" : "media"} playlist, adjust startPosition to ${startPosition}`);
          this.startPosition = startPosition;
        } else if (details.live) {
          startPosition = this.hls.liveSyncPosition || sliding;
        } else {
          this.startPosition = startPosition = 0;
        }
        this.lastCurrentTime = startPosition;
      }
      this.nextLoadPosition = startPosition;
    }
    getLoadPosition() {
      const {
        media
      } = this;
      let pos = 0;
      if (this.loadedmetadata && media) {
        pos = media.currentTime;
      } else if (this.nextLoadPosition) {
        pos = this.nextLoadPosition;
      }
      return pos;
    }
    handleFragLoadAborted(frag, part) {
      if (this.transmuxer && frag.sn !== "initSegment" && frag.stats.aborted) {
        this.warn(`Fragment ${frag.sn}${part ? " part " + part.index : ""} of level ${frag.level} was aborted`);
        this.resetFragmentLoading(frag);
      }
    }
    resetFragmentLoading(frag) {
      if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
        this.state = State.IDLE;
      }
    }
    onFragmentOrKeyLoadError(filterType, data) {
      if (data.chunkMeta && !data.frag) {
        const context = this.getCurrentContext(data.chunkMeta);
        if (context) {
          data.frag = context.frag;
        }
      }
      const frag = data.frag;
      if (!frag || frag.type !== filterType || !this.levels) {
        return;
      }
      if (this.fragContextChanged(frag)) {
        var _this$fragCurrent2;
        this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);
        return;
      }
      const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
      if (gapTagEncountered) {
        this.fragmentTracker.fragBuffered(frag, true);
      }
      const errorAction = data.errorAction;
      const {
        action,
        retryCount = 0,
        retryConfig
      } = errorAction || {};
      if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {
        var _this$levelLastLoaded;
        this.resetStartWhenNotLoaded((_this$levelLastLoaded = this.levelLastLoaded) != null ? _this$levelLastLoaded : frag.level);
        const delay = getRetryDelay(retryConfig, retryCount);
        this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);
        errorAction.resolved = true;
        this.retryDate = self.performance.now() + delay;
        this.state = State.FRAG_LOADING_WAITING_RETRY;
      } else if (retryConfig && errorAction) {
        this.resetFragmentErrors(filterType);
        if (retryCount < retryConfig.maxNumRetry) {
          if (!gapTagEncountered) {
            errorAction.resolved = true;
          }
        } else {
          logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);
        }
      } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {
        this.state = State.WAITING_LEVEL;
      } else {
        this.state = State.ERROR;
      }
      this.tickImmediate();
    }
    reduceLengthAndFlushBuffer(data) {
      if (this.state === State.PARSING || this.state === State.PARSED) {
        const playlistType = data.parent;
        const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
        const buffered = bufferedInfo && bufferedInfo.len > 0.5;
        if (buffered) {
          this.reduceMaxBufferLength(bufferedInfo.len);
        }
        const flushBuffer = !buffered;
        if (flushBuffer) {
          this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);
        }
        if (data.frag) {
          this.fragmentTracker.removeFragment(data.frag);
          this.nextLoadPosition = data.frag.start;
        }
        this.resetLoadingState();
        return flushBuffer;
      }
      return false;
    }
    resetFragmentErrors(filterType) {
      if (filterType === PlaylistLevelType.AUDIO) {
        this.fragCurrent = null;
      }
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
      }
      if (this.state !== State.STOPPED) {
        this.state = State.IDLE;
      }
    }
    afterBufferFlushed(media, bufferType, playlistType) {
      if (!media) {
        return;
      }
      const bufferedTimeRanges = BufferHelper.getBuffered(media);
      this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
      if (this.state === State.ENDED) {
        this.resetLoadingState();
      }
    }
    resetLoadingState() {
      this.log("Reset loading state");
      this.fragCurrent = null;
      this.fragPrevious = null;
      this.state = State.IDLE;
    }
    resetStartWhenNotLoaded(level) {
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        const details = this.levels ? this.levels[level].details : null;
        if (details != null && details.live) {
          this.startPosition = -1;
          this.setStartPosition(details, 0);
          this.resetLoadingState();
        } else {
          this.nextLoadPosition = this.startPosition;
        }
      }
    }
    resetWhenMissingContext(chunkMeta) {
      var _this$levelLastLoaded2;
      this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);
      this.removeUnbufferedFrags();
      this.resetStartWhenNotLoaded((_this$levelLastLoaded2 = this.levelLastLoaded) != null ? _this$levelLastLoaded2 : chunkMeta.level);
      this.resetLoadingState();
    }
    removeUnbufferedFrags(start = 0) {
      this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);
    }
    updateLevelTiming(frag, part, level, partial) {
      var _this$transmuxer;
      const details = level.details;
      if (!details) {
        this.warn("level.details undefined");
        return;
      }
      const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {
        const info = frag.elementaryStreams[type];
        if (info) {
          const parsedDuration = info.endPTS - info.startPTS;
          if (parsedDuration <= 0) {
            this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);
            return result || false;
          }
          const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
          this.hls.trigger(Events.LEVEL_PTS_UPDATED, {
            details,
            level,
            drift,
            type,
            frag,
            start: info.startPTS,
            end: info.endPTS
          });
          return true;
        }
        return result;
      }, false);
      if (parsed) {
        level.fragmentError = 0;
      } else if (((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {
        const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);
        if (level.fragmentError === 0) {
          level.fragmentError++;
          frag.gap = true;
          this.fragmentTracker.removeFragment(frag);
          this.fragmentTracker.fragBuffered(frag, true);
        }
        this.warn(error.message);
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: false,
          error,
          frag,
          reason: `Found no media in msn ${frag.sn} of level "${level.url}"`
        });
        if (!this.hls) {
          return;
        }
        this.resetTransmuxer();
      }
      this.state = State.PARSED;
      this.hls.trigger(Events.FRAG_PARSED, {
        frag,
        part
      });
    }
    resetTransmuxer() {
      if (this.transmuxer) {
        this.transmuxer.destroy();
        this.transmuxer = null;
      }
    }
    recoverWorkerError(data) {
      if (data.event === "demuxerWorker") {
        var _ref, _this$levelLastLoaded3, _this$fragCurrent3;
        this.fragmentTracker.removeAllFragments();
        this.resetTransmuxer();
        this.resetStartWhenNotLoaded((_ref = (_this$levelLastLoaded3 = this.levelLastLoaded) != null ? _this$levelLastLoaded3 : (_this$fragCurrent3 = this.fragCurrent) == null ? void 0 : _this$fragCurrent3.level) != null ? _ref : 0);
        this.resetLoadingState();
      }
    }
    set state(nextState) {
      const previousState = this._state;
      if (previousState !== nextState) {
        this._state = nextState;
        this.log(`${previousState}->${nextState}`);
      }
    }
    get state() {
      return this._state;
    }
  };
  function getSourceBuffer() {
    return self.SourceBuffer || self.WebKitSourceBuffer;
  }
  function isSupported() {
    const mediaSource = getMediaSource();
    if (!mediaSource) {
      return false;
    }
    const sourceBuffer = getSourceBuffer();
    const isTypeSupported = mediaSource && typeof mediaSource.isTypeSupported === "function" && mediaSource.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
    const sourceBufferValidAPI = !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
    return !!isTypeSupported && !!sourceBufferValidAPI;
  }
  function changeTypeSupported() {
    var _sourceBuffer$prototy;
    const sourceBuffer = getSourceBuffer();
    return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === "function";
  }
  function hasUMDWorker() {
    return typeof __HLS_WORKER_BUNDLE__ === "function";
  }
  function injectWorker() {
    const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
      type: "text/javascript"
    });
    const objectURL = self.URL.createObjectURL(blob);
    const worker = new self.Worker(objectURL);
    return {
      worker,
      objectURL
    };
  }
  function loadWorker(path) {
    const scriptURL = new self.URL(path, self.location.href).href;
    const worker = new self.Worker(scriptURL);
    return {
      worker,
      scriptURL
    };
  }
  function dummyTrack(type = "", inputTimeScale = 9e4) {
    return {
      type,
      id: -1,
      pid: -1,
      inputTimeScale,
      sequenceNumber: -1,
      samples: [],
      dropped: 0
    };
  }
  var BaseAudioDemuxer = class {
    constructor() {
      this._audioTrack = void 0;
      this._id3Track = void 0;
      this.frameIndex = 0;
      this.cachedData = null;
      this.basePTS = null;
      this.initPTS = null;
      this.lastPTS = null;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      this._id3Track = {
        type: "id3",
        id: 3,
        pid: -1,
        inputTimeScale: 9e4,
        sequenceNumber: 0,
        samples: [],
        dropped: 0
      };
    }
    resetTimeStamp(deaultTimestamp) {
      this.initPTS = deaultTimestamp;
      this.resetContiguity();
    }
    resetContiguity() {
      this.basePTS = null;
      this.lastPTS = null;
      this.frameIndex = 0;
    }
    canParse(data, offset2) {
      return false;
    }
    appendFrame(track, data, offset2) {
    }
    demux(data, timeOffset) {
      if (this.cachedData) {
        data = appendUint8Array(this.cachedData, data);
        this.cachedData = null;
      }
      let id3Data = getID3Data(data, 0);
      let offset2 = id3Data ? id3Data.length : 0;
      let lastDataIndex;
      const track = this._audioTrack;
      const id3Track = this._id3Track;
      const timestamp = id3Data ? getTimeStamp(id3Data) : void 0;
      const length = data.length;
      if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
        this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
        this.lastPTS = this.basePTS;
      }
      if (this.lastPTS === null) {
        this.lastPTS = this.basePTS;
      }
      if (id3Data && id3Data.length > 0) {
        id3Track.samples.push({
          pts: this.lastPTS,
          dts: this.lastPTS,
          data: id3Data,
          type: MetadataSchema.audioId3,
          duration: Number.POSITIVE_INFINITY
        });
      }
      while (offset2 < length) {
        if (this.canParse(data, offset2)) {
          const frame = this.appendFrame(track, data, offset2);
          if (frame) {
            this.frameIndex++;
            this.lastPTS = frame.sample.pts;
            offset2 += frame.length;
            lastDataIndex = offset2;
          } else {
            offset2 = length;
          }
        } else if (canParse$2(data, offset2)) {
          id3Data = getID3Data(data, offset2);
          id3Track.samples.push({
            pts: this.lastPTS,
            dts: this.lastPTS,
            data: id3Data,
            type: MetadataSchema.audioId3,
            duration: Number.POSITIVE_INFINITY
          });
          offset2 += id3Data.length;
          lastDataIndex = offset2;
        } else {
          offset2++;
        }
        if (offset2 === length && lastDataIndex !== length) {
          const partialData = sliceUint8(data, lastDataIndex);
          if (this.cachedData) {
            this.cachedData = appendUint8Array(this.cachedData, partialData);
          } else {
            this.cachedData = partialData;
          }
        }
      }
      return {
        audioTrack: track,
        videoTrack: dummyTrack(),
        id3Track,
        textTrack: dummyTrack()
      };
    }
    demuxSampleAes(data, keyData, timeOffset) {
      return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
    }
    flush(timeOffset) {
      const cachedData = this.cachedData;
      if (cachedData) {
        this.cachedData = null;
        this.demux(cachedData, 0);
      }
      return {
        audioTrack: this._audioTrack,
        videoTrack: dummyTrack(),
        id3Track: this._id3Track,
        textTrack: dummyTrack()
      };
    }
    destroy() {
    }
  };
  var initPTSFn = (timestamp, timeOffset, initPTS) => {
    if (isFiniteNumber(timestamp)) {
      return timestamp * 90;
    }
    const init90kHz = initPTS ? initPTS.baseTime * 9e4 / initPTS.timescale : 0;
    return timeOffset * 9e4 + init90kHz;
  };
  function getAudioConfig(observer, data, offset2, audioCodec) {
    let adtsObjectType;
    let adtsExtensionSamplingIndex;
    let adtsChannelConfig;
    let config;
    const userAgent = navigator.userAgent.toLowerCase();
    const manifestCodec = audioCodec;
    const adtsSamplingRates = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350];
    adtsObjectType = ((data[offset2 + 2] & 192) >>> 6) + 1;
    const adtsSamplingIndex = (data[offset2 + 2] & 60) >>> 2;
    if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
      observer.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        fatal: true,
        reason: `invalid ADTS sampling index:${adtsSamplingIndex}`
      });
      return;
    }
    adtsChannelConfig = (data[offset2 + 2] & 1) << 2;
    adtsChannelConfig |= (data[offset2 + 3] & 192) >>> 6;
    logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);
    if (/firefox/i.test(userAgent)) {
      if (adtsSamplingIndex >= 6) {
        adtsObjectType = 5;
        config = new Array(4);
        adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
      } else {
        adtsObjectType = 2;
        config = new Array(2);
        adtsExtensionSamplingIndex = adtsSamplingIndex;
      }
    } else if (userAgent.indexOf("android") !== -1) {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSamplingIndex = adtsSamplingIndex;
    } else {
      adtsObjectType = 5;
      config = new Array(4);
      if (audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {
        adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
      } else {
        if (audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {
          adtsObjectType = 2;
          config = new Array(2);
        }
        adtsExtensionSamplingIndex = adtsSamplingIndex;
      }
    }
    config[0] = adtsObjectType << 3;
    config[0] |= (adtsSamplingIndex & 14) >> 1;
    config[1] |= (adtsSamplingIndex & 1) << 7;
    config[1] |= adtsChannelConfig << 3;
    if (adtsObjectType === 5) {
      config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
      config[2] = (adtsExtensionSamplingIndex & 1) << 7;
      config[2] |= 2 << 2;
      config[3] = 0;
    }
    return {
      config,
      samplerate: adtsSamplingRates[adtsSamplingIndex],
      channelCount: adtsChannelConfig,
      codec: "mp4a.40." + adtsObjectType,
      manifestCodec
    };
  }
  function isHeaderPattern$1(data, offset2) {
    return data[offset2] === 255 && (data[offset2 + 1] & 246) === 240;
  }
  function getHeaderLength(data, offset2) {
    return data[offset2 + 1] & 1 ? 7 : 9;
  }
  function getFullFrameLength(data, offset2) {
    return (data[offset2 + 3] & 3) << 11 | data[offset2 + 4] << 3 | (data[offset2 + 5] & 224) >>> 5;
  }
  function canGetFrameLength(data, offset2) {
    return offset2 + 5 < data.length;
  }
  function isHeader$1(data, offset2) {
    return offset2 + 1 < data.length && isHeaderPattern$1(data, offset2);
  }
  function canParse$1(data, offset2) {
    return canGetFrameLength(data, offset2) && isHeaderPattern$1(data, offset2) && getFullFrameLength(data, offset2) <= data.length - offset2;
  }
  function probe$1(data, offset2) {
    if (isHeader$1(data, offset2)) {
      const headerLength = getHeaderLength(data, offset2);
      if (offset2 + headerLength >= data.length) {
        return false;
      }
      const frameLength = getFullFrameLength(data, offset2);
      if (frameLength <= headerLength) {
        return false;
      }
      const newOffset = offset2 + frameLength;
      return newOffset === data.length || isHeader$1(data, newOffset);
    }
    return false;
  }
  function initTrackConfig(track, observer, data, offset2, audioCodec) {
    if (!track.samplerate) {
      const config = getAudioConfig(observer, data, offset2, audioCodec);
      if (!config) {
        return;
      }
      track.config = config.config;
      track.samplerate = config.samplerate;
      track.channelCount = config.channelCount;
      track.codec = config.codec;
      track.manifestCodec = config.manifestCodec;
      logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);
    }
  }
  function getFrameDuration(samplerate) {
    return 1024 * 9e4 / samplerate;
  }
  function parseFrameHeader(data, offset2) {
    const headerLength = getHeaderLength(data, offset2);
    if (offset2 + headerLength <= data.length) {
      const frameLength = getFullFrameLength(data, offset2) - headerLength;
      if (frameLength > 0) {
        return {
          headerLength,
          frameLength
        };
      }
    }
  }
  function appendFrame$1(track, data, offset2, pts, frameIndex) {
    const frameDuration = getFrameDuration(track.samplerate);
    const stamp = pts + frameIndex * frameDuration;
    const header = parseFrameHeader(data, offset2);
    let unit;
    if (header) {
      const {
        frameLength,
        headerLength
      } = header;
      const _length = headerLength + frameLength;
      const missing = Math.max(0, offset2 + _length - data.length);
      if (missing) {
        unit = new Uint8Array(_length - headerLength);
        unit.set(data.subarray(offset2 + headerLength, data.length), 0);
      } else {
        unit = data.subarray(offset2 + headerLength, offset2 + _length);
      }
      const _sample = {
        unit,
        pts: stamp
      };
      if (!missing) {
        track.samples.push(_sample);
      }
      return {
        sample: _sample,
        length: _length,
        missing
      };
    }
    const length = data.length - offset2;
    unit = new Uint8Array(length);
    unit.set(data.subarray(offset2, data.length), 0);
    const sample = {
      unit,
      pts: stamp
    };
    return {
      sample,
      length,
      missing: -1
    };
  }
  var AACDemuxer = class extends BaseAudioDemuxer {
    constructor(observer, config) {
      super();
      this.observer = void 0;
      this.config = void 0;
      this.observer = observer;
      this.config = config;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: "audio/adts",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "aac",
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 9e4,
        dropped: 0
      };
    }
    static probe(data) {
      if (!data) {
        return false;
      }
      const id3Data = getID3Data(data, 0) || [];
      let offset2 = id3Data.length;
      for (let length = data.length; offset2 < length; offset2++) {
        if (probe$1(data, offset2)) {
          logger.log("ADTS sync word found !");
          return true;
        }
      }
      return false;
    }
    canParse(data, offset2) {
      return canParse$1(data, offset2);
    }
    appendFrame(track, data, offset2) {
      initTrackConfig(track, this.observer, data, offset2, track.manifestCodec);
      const frame = appendFrame$1(track, data, offset2, this.basePTS, this.frameIndex);
      if (frame && frame.missing === 0) {
        return frame;
      }
    }
  };
  var emsgSchemePattern = /\/emsg[-/]ID3/i;
  var MP4Demuxer = class {
    constructor(observer, config) {
      this.remainderData = null;
      this.timeOffset = 0;
      this.config = void 0;
      this.videoTrack = void 0;
      this.audioTrack = void 0;
      this.id3Track = void 0;
      this.txtTrack = void 0;
      this.config = config;
    }
    resetTimeStamp() {
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      const videoTrack = this.videoTrack = dummyTrack("video", 1);
      const audioTrack = this.audioTrack = dummyTrack("audio", 1);
      const captionTrack = this.txtTrack = dummyTrack("text", 1);
      this.id3Track = dummyTrack("id3", 1);
      this.timeOffset = 0;
      if (!(initSegment != null && initSegment.byteLength)) {
        return;
      }
      const initData = parseInitSegment(initSegment);
      if (initData.video) {
        const {
          id,
          timescale,
          codec
        } = initData.video;
        videoTrack.id = id;
        videoTrack.timescale = captionTrack.timescale = timescale;
        videoTrack.codec = codec;
      }
      if (initData.audio) {
        const {
          id,
          timescale,
          codec
        } = initData.audio;
        audioTrack.id = id;
        audioTrack.timescale = timescale;
        audioTrack.codec = codec;
      }
      captionTrack.id = RemuxerTrackIdConfig.text;
      videoTrack.sampleDuration = 0;
      videoTrack.duration = audioTrack.duration = trackDuration;
    }
    resetContiguity() {
      this.remainderData = null;
    }
    static probe(data) {
      data = data.length > 16384 ? data.subarray(0, 16384) : data;
      return findBox(data, ["moof"]).length > 0;
    }
    demux(data, timeOffset) {
      this.timeOffset = timeOffset;
      let videoSamples = data;
      const videoTrack = this.videoTrack;
      const textTrack = this.txtTrack;
      if (this.config.progressive) {
        if (this.remainderData) {
          videoSamples = appendUint8Array(this.remainderData, data);
        }
        const segmentedData = segmentValidRange(videoSamples);
        this.remainderData = segmentedData.remainder;
        videoTrack.samples = segmentedData.valid || new Uint8Array();
      } else {
        videoTrack.samples = videoSamples;
      }
      const id3Track = this.extractID3Track(videoTrack, timeOffset);
      textTrack.samples = parseSamples(timeOffset, videoTrack);
      return {
        videoTrack,
        audioTrack: this.audioTrack,
        id3Track,
        textTrack: this.txtTrack
      };
    }
    flush() {
      const timeOffset = this.timeOffset;
      const videoTrack = this.videoTrack;
      const textTrack = this.txtTrack;
      videoTrack.samples = this.remainderData || new Uint8Array();
      this.remainderData = null;
      const id3Track = this.extractID3Track(videoTrack, this.timeOffset);
      textTrack.samples = parseSamples(timeOffset, videoTrack);
      return {
        videoTrack,
        audioTrack: dummyTrack(),
        id3Track,
        textTrack: dummyTrack()
      };
    }
    extractID3Track(videoTrack, timeOffset) {
      const id3Track = this.id3Track;
      if (videoTrack.samples.length) {
        const emsgs = findBox(videoTrack.samples, ["emsg"]);
        if (emsgs) {
          emsgs.forEach((data) => {
            const emsgInfo = parseEmsg(data);
            if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
              const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
              let duration = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
              if (duration <= 1e-3) {
                duration = Number.POSITIVE_INFINITY;
              }
              const payload = emsgInfo.payload;
              id3Track.samples.push({
                data: payload,
                len: payload.byteLength,
                dts: pts,
                pts,
                type: MetadataSchema.emsg,
                duration
              });
            }
          });
        }
      }
      return id3Track;
    }
    demuxSampleAes(data, keyData, timeOffset) {
      return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
    }
    destroy() {
    }
  };
  var chromeVersion$1 = null;
  var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
  var SamplingRateMap = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3];
  var SamplesCoefficients = [
    [
      0,
      72,
      144,
      12
    ],
    [
      0,
      0,
      0,
      0
    ],
    [
      0,
      72,
      144,
      12
    ],
    [
      0,
      144,
      144,
      12
    ]
  ];
  var BytesInSlot = [
    0,
    1,
    1,
    4
  ];
  function appendFrame(track, data, offset2, pts, frameIndex) {
    if (offset2 + 24 > data.length) {
      return;
    }
    const header = parseHeader(data, offset2);
    if (header && offset2 + header.frameLength <= data.length) {
      const frameDuration = header.samplesPerFrame * 9e4 / header.sampleRate;
      const stamp = pts + frameIndex * frameDuration;
      const sample = {
        unit: data.subarray(offset2, offset2 + header.frameLength),
        pts: stamp,
        dts: stamp
      };
      track.config = [];
      track.channelCount = header.channelCount;
      track.samplerate = header.sampleRate;
      track.samples.push(sample);
      return {
        sample,
        length: header.frameLength,
        missing: 0
      };
    }
  }
  function parseHeader(data, offset2) {
    const mpegVersion = data[offset2 + 1] >> 3 & 3;
    const mpegLayer = data[offset2 + 1] >> 1 & 3;
    const bitRateIndex = data[offset2 + 2] >> 4 & 15;
    const sampleRateIndex = data[offset2 + 2] >> 2 & 3;
    if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
      const paddingBit = data[offset2 + 2] >> 1 & 1;
      const channelMode = data[offset2 + 3] >> 6;
      const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
      const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1e3;
      const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
      const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
      const channelCount = channelMode === 3 ? 1 : 2;
      const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
      const bytesInSlot = BytesInSlot[mpegLayer];
      const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
      const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
      if (chromeVersion$1 === null) {
        const userAgent = navigator.userAgent || "";
        const result = userAgent.match(/Chrome\/(\d+)/i);
        chromeVersion$1 = result ? parseInt(result[1]) : 0;
      }
      const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
      if (needChromeFix && mpegLayer === 2 && bitRate >= 224e3 && channelMode === 0) {
        data[offset2 + 3] = data[offset2 + 3] | 128;
      }
      return {
        sampleRate,
        channelCount,
        frameLength,
        samplesPerFrame
      };
    }
  }
  function isHeaderPattern(data, offset2) {
    return data[offset2] === 255 && (data[offset2 + 1] & 224) === 224 && (data[offset2 + 1] & 6) !== 0;
  }
  function isHeader(data, offset2) {
    return offset2 + 1 < data.length && isHeaderPattern(data, offset2);
  }
  function canParse(data, offset2) {
    const headerSize = 4;
    return isHeaderPattern(data, offset2) && headerSize <= data.length - offset2;
  }
  function probe(data, offset2) {
    if (offset2 + 1 < data.length && isHeaderPattern(data, offset2)) {
      const headerLength = 4;
      const header = parseHeader(data, offset2);
      let frameLength = headerLength;
      if (header != null && header.frameLength) {
        frameLength = header.frameLength;
      }
      const newOffset = offset2 + frameLength;
      return newOffset === data.length || isHeader(data, newOffset);
    }
    return false;
  }
  var ExpGolomb = class {
    constructor(data) {
      this.data = void 0;
      this.bytesAvailable = void 0;
      this.word = void 0;
      this.bitsAvailable = void 0;
      this.data = data;
      this.bytesAvailable = data.byteLength;
      this.word = 0;
      this.bitsAvailable = 0;
    }
    loadWord() {
      const data = this.data;
      const bytesAvailable = this.bytesAvailable;
      const position = data.byteLength - bytesAvailable;
      const workingBytes = new Uint8Array(4);
      const availableBytes = Math.min(4, bytesAvailable);
      if (availableBytes === 0) {
        throw new Error("no bytes available");
      }
      workingBytes.set(data.subarray(position, position + availableBytes));
      this.word = new DataView(workingBytes.buffer).getUint32(0);
      this.bitsAvailable = availableBytes * 8;
      this.bytesAvailable -= availableBytes;
    }
    skipBits(count) {
      let skipBytes;
      count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
      if (this.bitsAvailable > count) {
        this.word <<= count;
        this.bitsAvailable -= count;
      } else {
        count -= this.bitsAvailable;
        skipBytes = count >> 3;
        count -= skipBytes << 3;
        this.bytesAvailable -= skipBytes;
        this.loadWord();
        this.word <<= count;
        this.bitsAvailable -= count;
      }
    }
    readBits(size2) {
      let bits = Math.min(this.bitsAvailable, size2);
      const valu = this.word >>> 32 - bits;
      if (size2 > 32) {
        logger.error("Cannot read more than 32 bits at a time");
      }
      this.bitsAvailable -= bits;
      if (this.bitsAvailable > 0) {
        this.word <<= bits;
      } else if (this.bytesAvailable > 0) {
        this.loadWord();
      } else {
        throw new Error("no bits available");
      }
      bits = size2 - bits;
      if (bits > 0 && this.bitsAvailable) {
        return valu << bits | this.readBits(bits);
      } else {
        return valu;
      }
    }
    skipLZ() {
      let leadingZeroCount;
      for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
        if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
          this.word <<= leadingZeroCount;
          this.bitsAvailable -= leadingZeroCount;
          return leadingZeroCount;
        }
      }
      this.loadWord();
      return leadingZeroCount + this.skipLZ();
    }
    skipUEG() {
      this.skipBits(1 + this.skipLZ());
    }
    skipEG() {
      this.skipBits(1 + this.skipLZ());
    }
    readUEG() {
      const clz = this.skipLZ();
      return this.readBits(clz + 1) - 1;
    }
    readEG() {
      const valu = this.readUEG();
      if (1 & valu) {
        return 1 + valu >>> 1;
      } else {
        return -1 * (valu >>> 1);
      }
    }
    readBoolean() {
      return this.readBits(1) === 1;
    }
    readUByte() {
      return this.readBits(8);
    }
    readUShort() {
      return this.readBits(16);
    }
    readUInt() {
      return this.readBits(32);
    }
    skipScalingList(count) {
      let lastScale = 8;
      let nextScale = 8;
      let deltaScale;
      for (let j3 = 0; j3 < count; j3++) {
        if (nextScale !== 0) {
          deltaScale = this.readEG();
          nextScale = (lastScale + deltaScale + 256) % 256;
        }
        lastScale = nextScale === 0 ? lastScale : nextScale;
      }
    }
    readSPS() {
      let frameCropLeftOffset = 0;
      let frameCropRightOffset = 0;
      let frameCropTopOffset = 0;
      let frameCropBottomOffset = 0;
      let numRefFramesInPicOrderCntCycle;
      let scalingListCount;
      let i2;
      const readUByte = this.readUByte.bind(this);
      const readBits = this.readBits.bind(this);
      const readUEG = this.readUEG.bind(this);
      const readBoolean = this.readBoolean.bind(this);
      const skipBits = this.skipBits.bind(this);
      const skipEG = this.skipEG.bind(this);
      const skipUEG = this.skipUEG.bind(this);
      const skipScalingList = this.skipScalingList.bind(this);
      readUByte();
      const profileIdc = readUByte();
      readBits(5);
      skipBits(3);
      readUByte();
      skipUEG();
      if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
        const chromaFormatIdc = readUEG();
        if (chromaFormatIdc === 3) {
          skipBits(1);
        }
        skipUEG();
        skipUEG();
        skipBits(1);
        if (readBoolean()) {
          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
          for (i2 = 0; i2 < scalingListCount; i2++) {
            if (readBoolean()) {
              if (i2 < 6) {
                skipScalingList(16);
              } else {
                skipScalingList(64);
              }
            }
          }
        }
      }
      skipUEG();
      const picOrderCntType = readUEG();
      if (picOrderCntType === 0) {
        readUEG();
      } else if (picOrderCntType === 1) {
        skipBits(1);
        skipEG();
        skipEG();
        numRefFramesInPicOrderCntCycle = readUEG();
        for (i2 = 0; i2 < numRefFramesInPicOrderCntCycle; i2++) {
          skipEG();
        }
      }
      skipUEG();
      skipBits(1);
      const picWidthInMbsMinus1 = readUEG();
      const picHeightInMapUnitsMinus1 = readUEG();
      const frameMbsOnlyFlag = readBits(1);
      if (frameMbsOnlyFlag === 0) {
        skipBits(1);
      }
      skipBits(1);
      if (readBoolean()) {
        frameCropLeftOffset = readUEG();
        frameCropRightOffset = readUEG();
        frameCropTopOffset = readUEG();
        frameCropBottomOffset = readUEG();
      }
      let pixelRatio = [1, 1];
      if (readBoolean()) {
        if (readBoolean()) {
          const aspectRatioIdc = readUByte();
          switch (aspectRatioIdc) {
            case 1:
              pixelRatio = [1, 1];
              break;
            case 2:
              pixelRatio = [12, 11];
              break;
            case 3:
              pixelRatio = [10, 11];
              break;
            case 4:
              pixelRatio = [16, 11];
              break;
            case 5:
              pixelRatio = [40, 33];
              break;
            case 6:
              pixelRatio = [24, 11];
              break;
            case 7:
              pixelRatio = [20, 11];
              break;
            case 8:
              pixelRatio = [32, 11];
              break;
            case 9:
              pixelRatio = [80, 33];
              break;
            case 10:
              pixelRatio = [18, 11];
              break;
            case 11:
              pixelRatio = [15, 11];
              break;
            case 12:
              pixelRatio = [64, 33];
              break;
            case 13:
              pixelRatio = [160, 99];
              break;
            case 14:
              pixelRatio = [4, 3];
              break;
            case 15:
              pixelRatio = [3, 2];
              break;
            case 16:
              pixelRatio = [2, 1];
              break;
            case 255: {
              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
              break;
            }
          }
        }
      }
      return {
        width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
        pixelRatio
      };
    }
    readSliceType() {
      this.readUByte();
      this.readUEG();
      return this.readUEG();
    }
  };
  var SampleAesDecrypter = class {
    constructor(observer, config, keyData) {
      this.keyData = void 0;
      this.decrypter = void 0;
      this.keyData = keyData;
      this.decrypter = new Decrypter(config, {
        removePKCS7Padding: false
      });
    }
    decryptBuffer(encryptedData) {
      return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);
    }
    decryptAacSample(samples, sampleIndex, callback) {
      const curUnit = samples[sampleIndex].unit;
      if (curUnit.length <= 16) {
        return;
      }
      const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
      const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
      this.decryptBuffer(encryptedBuffer).then((decryptedBuffer) => {
        const decryptedData = new Uint8Array(decryptedBuffer);
        curUnit.set(decryptedData, 16);
        if (!this.decrypter.isSync()) {
          this.decryptAacSamples(samples, sampleIndex + 1, callback);
        }
      });
    }
    decryptAacSamples(samples, sampleIndex, callback) {
      for (; ; sampleIndex++) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }
        if (samples[sampleIndex].unit.length < 32) {
          continue;
        }
        this.decryptAacSample(samples, sampleIndex, callback);
        if (!this.decrypter.isSync()) {
          return;
        }
      }
    }
    getAvcEncryptedData(decodedData) {
      const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
      const encryptedData = new Int8Array(encryptedDataLen);
      let outputPos = 0;
      for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
        encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return encryptedData;
    }
    getAvcDecryptedUnit(decodedData, decryptedData) {
      const uint8DecryptedData = new Uint8Array(decryptedData);
      let inputPos = 0;
      for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
        decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
      }
      return decodedData;
    }
    decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
      const decodedData = discardEPB(curUnit.data);
      const encryptedData = this.getAvcEncryptedData(decodedData);
      this.decryptBuffer(encryptedData.buffer).then((decryptedBuffer) => {
        curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);
        if (!this.decrypter.isSync()) {
          this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
        }
      });
    }
    decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
      if (samples instanceof Uint8Array) {
        throw new Error("Cannot decrypt samples of type Uint8Array");
      }
      for (; ; sampleIndex++, unitIndex = 0) {
        if (sampleIndex >= samples.length) {
          callback();
          return;
        }
        const curUnits = samples[sampleIndex].units;
        for (; ; unitIndex++) {
          if (unitIndex >= curUnits.length) {
            break;
          }
          const curUnit = curUnits[unitIndex];
          if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
            continue;
          }
          this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
          if (!this.decrypter.isSync()) {
            return;
          }
        }
      }
    }
  };
  var PACKET_LENGTH = 188;
  var TSDemuxer = class {
    constructor(observer, config, typeSupported) {
      this.observer = void 0;
      this.config = void 0;
      this.typeSupported = void 0;
      this.sampleAes = null;
      this.pmtParsed = false;
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this._duration = 0;
      this._pmtId = -1;
      this._avcTrack = void 0;
      this._audioTrack = void 0;
      this._id3Track = void 0;
      this._txtTrack = void 0;
      this.aacOverFlow = null;
      this.avcSample = null;
      this.remainderData = null;
      this.observer = observer;
      this.config = config;
      this.typeSupported = typeSupported;
    }
    static probe(data) {
      const syncOffset = TSDemuxer.syncOffset(data);
      if (syncOffset > 0) {
        logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);
      }
      return syncOffset !== -1;
    }
    static syncOffset(data) {
      const length = data.length;
      let scanwindow = Math.min(PACKET_LENGTH * 5, data.length - PACKET_LENGTH) + 1;
      let i2 = 0;
      while (i2 < scanwindow) {
        let foundPat = false;
        let packetStart = -1;
        let tsPackets = 0;
        for (let j3 = i2; j3 < length; j3 += PACKET_LENGTH) {
          if (data[j3] === 71) {
            tsPackets++;
            if (packetStart === -1) {
              packetStart = j3;
              if (packetStart !== 0) {
                scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
              }
            }
            if (!foundPat) {
              foundPat = parsePID(data, j3) === 0;
            }
            if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j3 + PACKET_LENGTH > scanwindow)) {
              return packetStart;
            }
          } else if (tsPackets) {
            return -1;
          } else {
            break;
          }
        }
        i2++;
      }
      return -1;
    }
    static createTrack(type, duration) {
      return {
        container: type === "video" || type === "audio" ? "video/mp2t" : void 0,
        type,
        id: RemuxerTrackIdConfig[type],
        pid: -1,
        inputTimeScale: 9e4,
        sequenceNumber: 0,
        samples: [],
        dropped: 0,
        duration: type === "audio" ? duration : void 0
      };
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      this.pmtParsed = false;
      this._pmtId = -1;
      this._avcTrack = TSDemuxer.createTrack("video");
      this._audioTrack = TSDemuxer.createTrack("audio", trackDuration);
      this._id3Track = TSDemuxer.createTrack("id3");
      this._txtTrack = TSDemuxer.createTrack("text");
      this._audioTrack.segmentCodec = "aac";
      this.aacOverFlow = null;
      this.avcSample = null;
      this.remainderData = null;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this._duration = trackDuration;
    }
    resetTimeStamp() {
    }
    resetContiguity() {
      const {
        _audioTrack,
        _avcTrack,
        _id3Track
      } = this;
      if (_audioTrack) {
        _audioTrack.pesData = null;
      }
      if (_avcTrack) {
        _avcTrack.pesData = null;
      }
      if (_id3Track) {
        _id3Track.pesData = null;
      }
      this.aacOverFlow = null;
      this.avcSample = null;
      this.remainderData = null;
    }
    demux(data, timeOffset, isSampleAes = false, flush = false) {
      if (!isSampleAes) {
        this.sampleAes = null;
      }
      let pes;
      const videoTrack = this._avcTrack;
      const audioTrack = this._audioTrack;
      const id3Track = this._id3Track;
      const textTrack = this._txtTrack;
      let avcId = videoTrack.pid;
      let avcData = videoTrack.pesData;
      let audioId = audioTrack.pid;
      let id3Id = id3Track.pid;
      let audioData = audioTrack.pesData;
      let id3Data = id3Track.pesData;
      let unknownPID = null;
      let pmtParsed = this.pmtParsed;
      let pmtId = this._pmtId;
      let len = data.length;
      if (this.remainderData) {
        data = appendUint8Array(this.remainderData, data);
        len = data.length;
        this.remainderData = null;
      }
      if (len < PACKET_LENGTH && !flush) {
        this.remainderData = data;
        return {
          audioTrack,
          videoTrack,
          id3Track,
          textTrack
        };
      }
      const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));
      len -= (len - syncOffset) % PACKET_LENGTH;
      if (len < data.byteLength && !flush) {
        this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
      }
      let tsPacketErrors = 0;
      for (let start = syncOffset; start < len; start += PACKET_LENGTH) {
        if (data[start] === 71) {
          const stt = !!(data[start + 1] & 64);
          const pid = parsePID(data, start);
          const atf = (data[start + 3] & 48) >> 4;
          let offset2;
          if (atf > 1) {
            offset2 = start + 5 + data[start + 4];
            if (offset2 === start + PACKET_LENGTH) {
              continue;
            }
          } else {
            offset2 = start + 4;
          }
          switch (pid) {
            case avcId:
              if (stt) {
                if (avcData && (pes = parsePES(avcData))) {
                  this.parseAVCPES(videoTrack, textTrack, pes, false);
                }
                avcData = {
                  data: [],
                  size: 0
                };
              }
              if (avcData) {
                avcData.data.push(data.subarray(offset2, start + PACKET_LENGTH));
                avcData.size += start + PACKET_LENGTH - offset2;
              }
              break;
            case audioId:
              if (stt) {
                if (audioData && (pes = parsePES(audioData))) {
                  switch (audioTrack.segmentCodec) {
                    case "aac":
                      this.parseAACPES(audioTrack, pes);
                      break;
                    case "mp3":
                      this.parseMPEGPES(audioTrack, pes);
                      break;
                  }
                }
                audioData = {
                  data: [],
                  size: 0
                };
              }
              if (audioData) {
                audioData.data.push(data.subarray(offset2, start + PACKET_LENGTH));
                audioData.size += start + PACKET_LENGTH - offset2;
              }
              break;
            case id3Id:
              if (stt) {
                if (id3Data && (pes = parsePES(id3Data))) {
                  this.parseID3PES(id3Track, pes);
                }
                id3Data = {
                  data: [],
                  size: 0
                };
              }
              if (id3Data) {
                id3Data.data.push(data.subarray(offset2, start + PACKET_LENGTH));
                id3Data.size += start + PACKET_LENGTH - offset2;
              }
              break;
            case 0:
              if (stt) {
                offset2 += data[offset2] + 1;
              }
              pmtId = this._pmtId = parsePAT(data, offset2);
              break;
            case pmtId: {
              if (stt) {
                offset2 += data[offset2] + 1;
              }
              const parsedPIDs = parsePMT(data, offset2, this.typeSupported, isSampleAes);
              avcId = parsedPIDs.avc;
              if (avcId > 0) {
                videoTrack.pid = avcId;
              }
              audioId = parsedPIDs.audio;
              if (audioId > 0) {
                audioTrack.pid = audioId;
                audioTrack.segmentCodec = parsedPIDs.segmentCodec;
              }
              id3Id = parsedPIDs.id3;
              if (id3Id > 0) {
                id3Track.pid = id3Id;
              }
              if (unknownPID !== null && !pmtParsed) {
                logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);
                unknownPID = null;
                start = syncOffset - 188;
              }
              pmtParsed = this.pmtParsed = true;
              break;
            }
            case 17:
            case 8191:
              break;
            default:
              unknownPID = pid;
              break;
          }
        } else {
          tsPacketErrors++;
        }
      }
      if (tsPacketErrors > 0) {
        const error = new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`);
        this.observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: false,
          error,
          reason: error.message
        });
      }
      videoTrack.pesData = avcData;
      audioTrack.pesData = audioData;
      id3Track.pesData = id3Data;
      const demuxResult = {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      };
      if (flush) {
        this.extractRemainingSamples(demuxResult);
      }
      return demuxResult;
    }
    flush() {
      const {
        remainderData
      } = this;
      this.remainderData = null;
      let result;
      if (remainderData) {
        result = this.demux(remainderData, -1, false, true);
      } else {
        result = {
          videoTrack: this._avcTrack,
          audioTrack: this._audioTrack,
          id3Track: this._id3Track,
          textTrack: this._txtTrack
        };
      }
      this.extractRemainingSamples(result);
      if (this.sampleAes) {
        return this.decrypt(result, this.sampleAes);
      }
      return result;
    }
    extractRemainingSamples(demuxResult) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = demuxResult;
      const avcData = videoTrack.pesData;
      const audioData = audioTrack.pesData;
      const id3Data = id3Track.pesData;
      let pes;
      if (avcData && (pes = parsePES(avcData))) {
        this.parseAVCPES(videoTrack, textTrack, pes, true);
        videoTrack.pesData = null;
      } else {
        videoTrack.pesData = avcData;
      }
      if (audioData && (pes = parsePES(audioData))) {
        switch (audioTrack.segmentCodec) {
          case "aac":
            this.parseAACPES(audioTrack, pes);
            break;
          case "mp3":
            this.parseMPEGPES(audioTrack, pes);
            break;
        }
        audioTrack.pesData = null;
      } else {
        if (audioData != null && audioData.size) {
          logger.log("last AAC PES packet truncated,might overlap between fragments");
        }
        audioTrack.pesData = audioData;
      }
      if (id3Data && (pes = parsePES(id3Data))) {
        this.parseID3PES(id3Track, pes);
        id3Track.pesData = null;
      } else {
        id3Track.pesData = id3Data;
      }
    }
    demuxSampleAes(data, keyData, timeOffset) {
      const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
      const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
      return this.decrypt(demuxResult, sampleAes);
    }
    decrypt(demuxResult, sampleAes) {
      return new Promise((resolve) => {
        const {
          audioTrack,
          videoTrack
        } = demuxResult;
        if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
          sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {
            if (videoTrack.samples) {
              sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
                resolve(demuxResult);
              });
            } else {
              resolve(demuxResult);
            }
          });
        } else if (videoTrack.samples) {
          sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
            resolve(demuxResult);
          });
        }
      });
    }
    destroy() {
      this._duration = 0;
    }
    parseAVCPES(track, textTrack, pes, last) {
      const units = this.parseAVCNALu(track, pes.data);
      let avcSample = this.avcSample;
      let push2;
      let spsfound = false;
      pes.data = null;
      if (avcSample && units.length && !track.audFound) {
        pushAccessUnit(avcSample, track);
        avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, "");
      }
      units.forEach((unit) => {
        var _avcSample2;
        switch (unit.type) {
          case 1: {
            let iskey = false;
            push2 = true;
            const data = unit.data;
            if (spsfound && data.length > 4) {
              const sliceType = new ExpGolomb(data).readSliceType();
              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                iskey = true;
              }
            }
            if (iskey) {
              var _avcSample;
              if ((_avcSample = avcSample) != null && _avcSample.frame && !avcSample.key) {
                pushAccessUnit(avcSample, track);
                avcSample = this.avcSample = null;
              }
            }
            if (!avcSample) {
              avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
            }
            avcSample.frame = true;
            avcSample.key = iskey;
            break;
          }
          case 5:
            push2 = true;
            if ((_avcSample2 = avcSample) != null && _avcSample2.frame && !avcSample.key) {
              pushAccessUnit(avcSample, track);
              avcSample = this.avcSample = null;
            }
            if (!avcSample) {
              avcSample = this.avcSample = createAVCSample(true, pes.pts, pes.dts, "");
            }
            avcSample.key = true;
            avcSample.frame = true;
            break;
          case 6: {
            push2 = true;
            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
            break;
          }
          case 7:
            push2 = true;
            spsfound = true;
            if (!track.sps) {
              const sps = unit.data;
              const expGolombDecoder = new ExpGolomb(sps);
              const config = expGolombDecoder.readSPS();
              track.width = config.width;
              track.height = config.height;
              track.pixelRatio = config.pixelRatio;
              track.sps = [sps];
              track.duration = this._duration;
              const codecarray = sps.subarray(1, 4);
              let codecstring = "avc1.";
              for (let i2 = 0; i2 < 3; i2++) {
                let h2 = codecarray[i2].toString(16);
                if (h2.length < 2) {
                  h2 = "0" + h2;
                }
                codecstring += h2;
              }
              track.codec = codecstring;
            }
            break;
          case 8:
            push2 = true;
            if (!track.pps) {
              track.pps = [unit.data];
            }
            break;
          case 9:
            push2 = false;
            track.audFound = true;
            if (avcSample) {
              pushAccessUnit(avcSample, track);
            }
            avcSample = this.avcSample = createAVCSample(false, pes.pts, pes.dts, "");
            break;
          case 12:
            push2 = true;
            break;
          default:
            push2 = false;
            if (avcSample) {
              avcSample.debug += "unknown NAL " + unit.type + " ";
            }
            break;
        }
        if (avcSample && push2) {
          const units2 = avcSample.units;
          units2.push(unit);
        }
      });
      if (last && avcSample) {
        pushAccessUnit(avcSample, track);
        this.avcSample = null;
      }
    }
    getLastNalUnit(samples) {
      var _avcSample3;
      let avcSample = this.avcSample;
      let lastUnit;
      if (!avcSample || avcSample.units.length === 0) {
        avcSample = samples[samples.length - 1];
      }
      if ((_avcSample3 = avcSample) != null && _avcSample3.units) {
        const units = avcSample.units;
        lastUnit = units[units.length - 1];
      }
      return lastUnit;
    }
    parseAVCNALu(track, array) {
      const len = array.byteLength;
      let state = track.naluState || 0;
      const lastState = state;
      const units = [];
      let i2 = 0;
      let value;
      let overflow;
      let unitType;
      let lastUnitStart = -1;
      let lastUnitType = 0;
      if (state === -1) {
        lastUnitStart = 0;
        lastUnitType = array[0] & 31;
        state = 0;
        i2 = 1;
      }
      while (i2 < len) {
        value = array[i2++];
        if (!state) {
          state = value ? 0 : 1;
          continue;
        }
        if (state === 1) {
          state = value ? 0 : 2;
          continue;
        }
        if (!value) {
          state = 3;
        } else if (value === 1) {
          if (lastUnitStart >= 0) {
            const unit = {
              data: array.subarray(lastUnitStart, i2 - state - 1),
              type: lastUnitType
            };
            units.push(unit);
          } else {
            const lastUnit = this.getLastNalUnit(track.samples);
            if (lastUnit) {
              if (lastState && i2 <= 4 - lastState) {
                if (lastUnit.state) {
                  lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                }
              }
              overflow = i2 - state - 1;
              if (overflow > 0) {
                const tmp = new Uint8Array(lastUnit.data.byteLength + overflow);
                tmp.set(lastUnit.data, 0);
                tmp.set(array.subarray(0, overflow), lastUnit.data.byteLength);
                lastUnit.data = tmp;
                lastUnit.state = 0;
              }
            }
          }
          if (i2 < len) {
            unitType = array[i2] & 31;
            lastUnitStart = i2;
            lastUnitType = unitType;
            state = 0;
          } else {
            state = -1;
          }
        } else {
          state = 0;
        }
      }
      if (lastUnitStart >= 0 && state >= 0) {
        const unit = {
          data: array.subarray(lastUnitStart, len),
          type: lastUnitType,
          state
        };
        units.push(unit);
      }
      if (units.length === 0) {
        const lastUnit = this.getLastNalUnit(track.samples);
        if (lastUnit) {
          const tmp = new Uint8Array(lastUnit.data.byteLength + array.byteLength);
          tmp.set(lastUnit.data, 0);
          tmp.set(array, lastUnit.data.byteLength);
          lastUnit.data = tmp;
        }
      }
      track.naluState = state;
      return units;
    }
    parseAACPES(track, pes) {
      let startOffset = 0;
      const aacOverFlow = this.aacOverFlow;
      let data = pes.data;
      if (aacOverFlow) {
        this.aacOverFlow = null;
        const frameMissingBytes = aacOverFlow.missing;
        const sampleLength = aacOverFlow.sample.unit.byteLength;
        if (frameMissingBytes === -1) {
          const tmp = new Uint8Array(sampleLength + data.byteLength);
          tmp.set(aacOverFlow.sample.unit, 0);
          tmp.set(data, sampleLength);
          data = tmp;
        } else {
          const frameOverflowBytes = sampleLength - frameMissingBytes;
          aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
          track.samples.push(aacOverFlow.sample);
          startOffset = aacOverFlow.missing;
        }
      }
      let offset2;
      let len;
      for (offset2 = startOffset, len = data.length; offset2 < len - 1; offset2++) {
        if (isHeader$1(data, offset2)) {
          break;
        }
      }
      if (offset2 !== startOffset) {
        let reason;
        const recoverable = offset2 < len - 1;
        if (recoverable) {
          reason = `AAC PES did not start with ADTS header,offset:${offset2}`;
        } else {
          reason = "No ADTS header found in AAC PES";
        }
        const error = new Error(reason);
        logger.warn(`parsing error: ${reason}`);
        this.observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: false,
          levelRetry: recoverable,
          error,
          reason
        });
        if (!recoverable) {
          return;
        }
      }
      initTrackConfig(track, this.observer, data, offset2, this.audioCodec);
      let pts;
      if (pes.pts !== void 0) {
        pts = pes.pts;
      } else if (aacOverFlow) {
        const frameDuration = getFrameDuration(track.samplerate);
        pts = aacOverFlow.sample.pts + frameDuration;
      } else {
        logger.warn("[tsdemuxer]: AAC PES unknown PTS");
        return;
      }
      let frameIndex = 0;
      let frame;
      while (offset2 < len) {
        frame = appendFrame$1(track, data, offset2, pts, frameIndex);
        offset2 += frame.length;
        if (!frame.missing) {
          frameIndex++;
          for (; offset2 < len - 1; offset2++) {
            if (isHeader$1(data, offset2)) {
              break;
            }
          }
        } else {
          this.aacOverFlow = frame;
          break;
        }
      }
    }
    parseMPEGPES(track, pes) {
      const data = pes.data;
      const length = data.length;
      let frameIndex = 0;
      let offset2 = 0;
      const pts = pes.pts;
      if (pts === void 0) {
        logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
        return;
      }
      while (offset2 < length) {
        if (isHeader(data, offset2)) {
          const frame = appendFrame(track, data, offset2, pts, frameIndex);
          if (frame) {
            offset2 += frame.length;
            frameIndex++;
          } else {
            break;
          }
        } else {
          offset2++;
        }
      }
    }
    parseID3PES(id3Track, pes) {
      if (pes.pts === void 0) {
        logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
        return;
      }
      const id3Sample = _extends2({}, pes, {
        type: this._avcTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
        duration: Number.POSITIVE_INFINITY
      });
      id3Track.samples.push(id3Sample);
    }
  };
  function createAVCSample(key, pts, dts, debug) {
    return {
      key,
      frame: false,
      pts,
      dts,
      units: [],
      debug,
      length: 0
    };
  }
  function parsePID(data, offset2) {
    return ((data[offset2 + 1] & 31) << 8) + data[offset2 + 2];
  }
  function parsePAT(data, offset2) {
    return (data[offset2 + 10] & 31) << 8 | data[offset2 + 11];
  }
  function parsePMT(data, offset2, typeSupported, isSampleAes) {
    const result = {
      audio: -1,
      avc: -1,
      id3: -1,
      segmentCodec: "aac"
    };
    const sectionLength = (data[offset2 + 1] & 15) << 8 | data[offset2 + 2];
    const tableEnd = offset2 + 3 + sectionLength - 4;
    const programInfoLength = (data[offset2 + 10] & 15) << 8 | data[offset2 + 11];
    offset2 += 12 + programInfoLength;
    while (offset2 < tableEnd) {
      const pid = parsePID(data, offset2);
      switch (data[offset2]) {
        case 207:
          if (!isSampleAes) {
            logger.log("ADTS AAC with AES-128-CBC frame encryption found in unencrypted stream");
            break;
          }
        case 15:
          if (result.audio === -1) {
            result.audio = pid;
          }
          break;
        case 21:
          if (result.id3 === -1) {
            result.id3 = pid;
          }
          break;
        case 219:
          if (!isSampleAes) {
            logger.log("H.264 with AES-128-CBC slice encryption found in unencrypted stream");
            break;
          }
        case 27:
          if (result.avc === -1) {
            result.avc = pid;
          }
          break;
        case 3:
        case 4:
          if (typeSupported.mpeg !== true && typeSupported.mp3 !== true) {
            logger.log("MPEG audio found, not supported in this browser");
          } else if (result.audio === -1) {
            result.audio = pid;
            result.segmentCodec = "mp3";
          }
          break;
        case 36:
          logger.warn("Unsupported HEVC stream type found");
          break;
      }
      offset2 += ((data[offset2 + 3] & 15) << 8 | data[offset2 + 4]) + 5;
    }
    return result;
  }
  function parsePES(stream) {
    let i2 = 0;
    let frag;
    let pesLen;
    let pesHdrLen;
    let pesPts;
    let pesDts;
    const data = stream.data;
    if (!stream || stream.size === 0) {
      return null;
    }
    while (data[0].length < 19 && data.length > 1) {
      const newData = new Uint8Array(data[0].length + data[1].length);
      newData.set(data[0]);
      newData.set(data[1], data[0].length);
      data[0] = newData;
      data.splice(1, 1);
    }
    frag = data[0];
    const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
    if (pesPrefix === 1) {
      pesLen = (frag[4] << 8) + frag[5];
      if (pesLen && pesLen > stream.size - 6) {
        return null;
      }
      const pesFlags = frag[7];
      if (pesFlags & 192) {
        pesPts = (frag[9] & 14) * 536870912 + (frag[10] & 255) * 4194304 + (frag[11] & 254) * 16384 + (frag[12] & 255) * 128 + (frag[13] & 254) / 2;
        if (pesFlags & 64) {
          pesDts = (frag[14] & 14) * 536870912 + (frag[15] & 255) * 4194304 + (frag[16] & 254) * 16384 + (frag[17] & 255) * 128 + (frag[18] & 254) / 2;
          if (pesPts - pesDts > 60 * 9e4) {
            logger.warn(`${Math.round((pesPts - pesDts) / 9e4)}s delta between PTS and DTS, align them`);
            pesPts = pesDts;
          }
        } else {
          pesDts = pesPts;
        }
      }
      pesHdrLen = frag[8];
      let payloadStartOffset = pesHdrLen + 9;
      if (stream.size <= payloadStartOffset) {
        return null;
      }
      stream.size -= payloadStartOffset;
      const pesData = new Uint8Array(stream.size);
      for (let j3 = 0, dataLen = data.length; j3 < dataLen; j3++) {
        frag = data[j3];
        let len = frag.byteLength;
        if (payloadStartOffset) {
          if (payloadStartOffset > len) {
            payloadStartOffset -= len;
            continue;
          } else {
            frag = frag.subarray(payloadStartOffset);
            len -= payloadStartOffset;
            payloadStartOffset = 0;
          }
        }
        pesData.set(frag, i2);
        i2 += len;
      }
      if (pesLen) {
        pesLen -= pesHdrLen + 3;
      }
      return {
        data: pesData,
        pts: pesPts,
        dts: pesDts,
        len: pesLen
      };
    }
    return null;
  }
  function pushAccessUnit(avcSample, avcTrack) {
    if (avcSample.units.length && avcSample.frame) {
      if (avcSample.pts === void 0) {
        const samples = avcTrack.samples;
        const nbSamples = samples.length;
        if (nbSamples) {
          const lastSample = samples[nbSamples - 1];
          avcSample.pts = lastSample.pts;
          avcSample.dts = lastSample.dts;
        } else {
          avcTrack.dropped++;
          return;
        }
      }
      avcTrack.samples.push(avcSample);
    }
    if (avcSample.debug.length) {
      logger.log(avcSample.pts + "/" + avcSample.dts + ":" + avcSample.debug);
    }
  }
  var MP3Demuxer = class extends BaseAudioDemuxer {
    resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
      super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
      this._audioTrack = {
        container: "audio/mpeg",
        type: "audio",
        id: 2,
        pid: -1,
        sequenceNumber: 0,
        segmentCodec: "mp3",
        samples: [],
        manifestCodec: audioCodec,
        duration: trackDuration,
        inputTimeScale: 9e4,
        dropped: 0
      };
    }
    static probe(data) {
      if (!data) {
        return false;
      }
      const id3Data = getID3Data(data, 0) || [];
      let offset2 = id3Data.length;
      for (let length = data.length; offset2 < length; offset2++) {
        if (probe(data, offset2)) {
          logger.log("MPEG Audio sync word found !");
          return true;
        }
      }
      return false;
    }
    canParse(data, offset2) {
      return canParse(data, offset2);
    }
    appendFrame(track, data, offset2) {
      if (this.basePTS === null) {
        return;
      }
      return appendFrame(track, data, offset2, this.basePTS, this.frameIndex);
    }
  };
  var AAC = class {
    static getSilentFrame(codec, channelCount) {
      switch (codec) {
        case "mp4a.40.2":
          if (channelCount === 1) {
            return new Uint8Array([0, 200, 0, 128, 35, 128]);
          } else if (channelCount === 2) {
            return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
          } else if (channelCount === 3) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
          } else if (channelCount === 4) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
          } else if (channelCount === 5) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
          } else if (channelCount === 6) {
            return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
          }
          break;
        default:
          if (channelCount === 1) {
            return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          } else if (channelCount === 2) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          } else if (channelCount === 3) {
            return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
          }
          break;
      }
      return void 0;
    }
  };
  var UINT32_MAX = Math.pow(2, 32) - 1;
  var MP4 = class {
    static init() {
      MP4.types = {
        avc1: [],
        avcC: [],
        btrt: [],
        dinf: [],
        dref: [],
        esds: [],
        ftyp: [],
        hdlr: [],
        mdat: [],
        mdhd: [],
        mdia: [],
        mfhd: [],
        minf: [],
        moof: [],
        moov: [],
        mp4a: [],
        ".mp3": [],
        mvex: [],
        mvhd: [],
        pasp: [],
        sdtp: [],
        stbl: [],
        stco: [],
        stsc: [],
        stsd: [],
        stsz: [],
        stts: [],
        tfdt: [],
        tfhd: [],
        traf: [],
        trak: [],
        trun: [],
        trex: [],
        tkhd: [],
        vmhd: [],
        smhd: []
      };
      let i2;
      for (i2 in MP4.types) {
        if (MP4.types.hasOwnProperty(i2)) {
          MP4.types[i2] = [i2.charCodeAt(0), i2.charCodeAt(1), i2.charCodeAt(2), i2.charCodeAt(3)];
        }
      }
      const videoHdlr = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        118,
        105,
        100,
        101,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        86,
        105,
        100,
        101,
        111,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
      ]);
      const audioHdlr = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        115,
        111,
        117,
        110,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        83,
        111,
        117,
        110,
        100,
        72,
        97,
        110,
        100,
        108,
        101,
        114,
        0
      ]);
      MP4.HDLR_TYPES = {
        video: videoHdlr,
        audio: audioHdlr
      };
      const dref = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        12,
        117,
        114,
        108,
        32,
        0,
        0,
        0,
        1
      ]);
      const stco = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      MP4.STTS = MP4.STSC = MP4.STCO = stco;
      MP4.STSZ = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      MP4.VMHD = new Uint8Array([
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      MP4.SMHD = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      MP4.STSD = new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
      const majorBrand = new Uint8Array([105, 115, 111, 109]);
      const avc1Brand = new Uint8Array([97, 118, 99, 49]);
      const minorVersion = new Uint8Array([0, 0, 0, 1]);
      MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
      MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
    }
    static box(type, ...payload) {
      let size2 = 8;
      let i2 = payload.length;
      const len = i2;
      while (i2--) {
        size2 += payload[i2].byteLength;
      }
      const result = new Uint8Array(size2);
      result[0] = size2 >> 24 & 255;
      result[1] = size2 >> 16 & 255;
      result[2] = size2 >> 8 & 255;
      result[3] = size2 & 255;
      result.set(type, 4);
      for (i2 = 0, size2 = 8; i2 < len; i2++) {
        result.set(payload[i2], size2);
        size2 += payload[i2].byteLength;
      }
      return result;
    }
    static hdlr(type) {
      return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
    }
    static mdat(data) {
      return MP4.box(MP4.types.mdat, data);
    }
    static mdhd(timescale, duration) {
      duration *= timescale;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.mdhd, new Uint8Array([
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        upperWordDuration >> 24,
        upperWordDuration >> 16 & 255,
        upperWordDuration >> 8 & 255,
        upperWordDuration & 255,
        lowerWordDuration >> 24,
        lowerWordDuration >> 16 & 255,
        lowerWordDuration >> 8 & 255,
        lowerWordDuration & 255,
        85,
        196,
        0,
        0
      ]));
    }
    static mdia(track) {
      return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
    }
    static mfhd(sequenceNumber) {
      return MP4.box(MP4.types.mfhd, new Uint8Array([
        0,
        0,
        0,
        0,
        sequenceNumber >> 24,
        sequenceNumber >> 16 & 255,
        sequenceNumber >> 8 & 255,
        sequenceNumber & 255
      ]));
    }
    static minf(track) {
      if (track.type === "audio") {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
      } else {
        return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
      }
    }
    static moof(sn2, baseMediaDecodeTime, track) {
      return MP4.box(MP4.types.moof, MP4.mfhd(sn2), MP4.traf(track, baseMediaDecodeTime));
    }
    static moov(tracks) {
      let i2 = tracks.length;
      const boxes = [];
      while (i2--) {
        boxes[i2] = MP4.trak(tracks[i2]);
      }
      return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
    }
    static mvex(tracks) {
      let i2 = tracks.length;
      const boxes = [];
      while (i2--) {
        boxes[i2] = MP4.trex(tracks[i2]);
      }
      return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);
    }
    static mvhd(timescale, duration) {
      duration *= timescale;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      const bytes = new Uint8Array([
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        timescale >> 24 & 255,
        timescale >> 16 & 255,
        timescale >> 8 & 255,
        timescale & 255,
        upperWordDuration >> 24,
        upperWordDuration >> 16 & 255,
        upperWordDuration >> 8 & 255,
        upperWordDuration & 255,
        lowerWordDuration >> 24,
        lowerWordDuration >> 16 & 255,
        lowerWordDuration >> 8 & 255,
        lowerWordDuration & 255,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        255,
        255,
        255,
        255
      ]);
      return MP4.box(MP4.types.mvhd, bytes);
    }
    static sdtp(track) {
      const samples = track.samples || [];
      const bytes = new Uint8Array(4 + samples.length);
      let i2;
      let flags;
      for (i2 = 0; i2 < samples.length; i2++) {
        flags = samples[i2].flags;
        bytes[i2 + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
      }
      return MP4.box(MP4.types.sdtp, bytes);
    }
    static stbl(track) {
      return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
    }
    static avc1(track) {
      let sps = [];
      let pps = [];
      let i2;
      let data;
      let len;
      for (i2 = 0; i2 < track.sps.length; i2++) {
        data = track.sps[i2];
        len = data.byteLength;
        sps.push(len >>> 8 & 255);
        sps.push(len & 255);
        sps = sps.concat(Array.prototype.slice.call(data));
      }
      for (i2 = 0; i2 < track.pps.length; i2++) {
        data = track.pps[i2];
        len = data.byteLength;
        pps.push(len >>> 8 & 255);
        pps.push(len & 255);
        pps = pps.concat(Array.prototype.slice.call(data));
      }
      const avcc = MP4.box(MP4.types.avcC, new Uint8Array([
        1,
        sps[3],
        sps[4],
        sps[5],
        252 | 3,
        224 | track.sps.length
      ].concat(sps).concat([
        track.pps.length
      ]).concat(pps)));
      const width = track.width;
      const height = track.height;
      const hSpacing = track.pixelRatio[0];
      const vSpacing = track.pixelRatio[1];
      return MP4.box(
        MP4.types.avc1,
        new Uint8Array([
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          width >> 8 & 255,
          width & 255,
          height >> 8 & 255,
          height & 255,
          0,
          72,
          0,
          0,
          0,
          72,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          1,
          18,
          100,
          97,
          105,
          108,
          121,
          109,
          111,
          116,
          105,
          111,
          110,
          47,
          104,
          108,
          115,
          46,
          106,
          115,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          24,
          17,
          17
        ]),
        avcc,
        MP4.box(MP4.types.btrt, new Uint8Array([
          0,
          28,
          156,
          128,
          0,
          45,
          198,
          192,
          0,
          45,
          198,
          192
        ])),
        MP4.box(MP4.types.pasp, new Uint8Array([
          hSpacing >> 24,
          hSpacing >> 16 & 255,
          hSpacing >> 8 & 255,
          hSpacing & 255,
          vSpacing >> 24,
          vSpacing >> 16 & 255,
          vSpacing >> 8 & 255,
          vSpacing & 255
        ]))
      );
    }
    static esds(track) {
      const configlen = track.config.length;
      return new Uint8Array([
        0,
        0,
        0,
        0,
        3,
        23 + configlen,
        0,
        1,
        0,
        4,
        15 + configlen,
        64,
        21,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        5
      ].concat([configlen]).concat(track.config).concat([6, 1, 2]));
    }
    static mp4a(track) {
      const samplerate = track.samplerate;
      return MP4.box(MP4.types.mp4a, new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        samplerate >> 8 & 255,
        samplerate & 255,
        0,
        0
      ]), MP4.box(MP4.types.esds, MP4.esds(track)));
    }
    static mp3(track) {
      const samplerate = track.samplerate;
      return MP4.box(MP4.types[".mp3"], new Uint8Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        track.channelCount,
        0,
        16,
        0,
        0,
        0,
        0,
        samplerate >> 8 & 255,
        samplerate & 255,
        0,
        0
      ]));
    }
    static stsd(track) {
      if (track.type === "audio") {
        if (track.segmentCodec === "mp3" && track.codec === "mp3") {
          return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
        }
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
      } else {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
      }
    }
    static tkhd(track) {
      const id = track.id;
      const duration = track.duration * track.timescale;
      const width = track.width;
      const height = track.height;
      const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
      const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
      return MP4.box(MP4.types.tkhd, new Uint8Array([
        1,
        0,
        0,
        7,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        3,
        id >> 24 & 255,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        0,
        upperWordDuration >> 24,
        upperWordDuration >> 16 & 255,
        upperWordDuration >> 8 & 255,
        upperWordDuration & 255,
        lowerWordDuration >> 24,
        lowerWordDuration >> 16 & 255,
        lowerWordDuration >> 8 & 255,
        lowerWordDuration & 255,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        64,
        0,
        0,
        0,
        width >> 8 & 255,
        width & 255,
        0,
        0,
        height >> 8 & 255,
        height & 255,
        0,
        0
      ]));
    }
    static traf(track, baseMediaDecodeTime) {
      const sampleDependencyTable = MP4.sdtp(track);
      const id = track.id;
      const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
      const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
      return MP4.box(
        MP4.types.traf,
        MP4.box(MP4.types.tfhd, new Uint8Array([
          0,
          0,
          0,
          0,
          id >> 24,
          id >> 16 & 255,
          id >> 8 & 255,
          id & 255
        ])),
        MP4.box(MP4.types.tfdt, new Uint8Array([
          1,
          0,
          0,
          0,
          upperWordBaseMediaDecodeTime >> 24,
          upperWordBaseMediaDecodeTime >> 16 & 255,
          upperWordBaseMediaDecodeTime >> 8 & 255,
          upperWordBaseMediaDecodeTime & 255,
          lowerWordBaseMediaDecodeTime >> 24,
          lowerWordBaseMediaDecodeTime >> 16 & 255,
          lowerWordBaseMediaDecodeTime >> 8 & 255,
          lowerWordBaseMediaDecodeTime & 255
        ])),
        MP4.trun(track, sampleDependencyTable.length + 16 + 20 + 8 + 16 + 8 + 8),
        sampleDependencyTable
      );
    }
    static trak(track) {
      track.duration = track.duration || 4294967295;
      return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
    }
    static trex(track) {
      const id = track.id;
      return MP4.box(MP4.types.trex, new Uint8Array([
        0,
        0,
        0,
        0,
        id >> 24,
        id >> 16 & 255,
        id >> 8 & 255,
        id & 255,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1,
        0,
        1
      ]));
    }
    static trun(track, offset2) {
      const samples = track.samples || [];
      const len = samples.length;
      const arraylen = 12 + 16 * len;
      const array = new Uint8Array(arraylen);
      let i2;
      let sample;
      let duration;
      let size2;
      let flags;
      let cts;
      offset2 += 8 + arraylen;
      array.set([
        track.type === "video" ? 1 : 0,
        0,
        15,
        1,
        len >>> 24 & 255,
        len >>> 16 & 255,
        len >>> 8 & 255,
        len & 255,
        offset2 >>> 24 & 255,
        offset2 >>> 16 & 255,
        offset2 >>> 8 & 255,
        offset2 & 255
      ], 0);
      for (i2 = 0; i2 < len; i2++) {
        sample = samples[i2];
        duration = sample.duration;
        size2 = sample.size;
        flags = sample.flags;
        cts = sample.cts;
        array.set([
          duration >>> 24 & 255,
          duration >>> 16 & 255,
          duration >>> 8 & 255,
          duration & 255,
          size2 >>> 24 & 255,
          size2 >>> 16 & 255,
          size2 >>> 8 & 255,
          size2 & 255,
          flags.isLeading << 2 | flags.dependsOn,
          flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
          flags.degradPrio & 240 << 8,
          flags.degradPrio & 15,
          cts >>> 24 & 255,
          cts >>> 16 & 255,
          cts >>> 8 & 255,
          cts & 255
        ], 12 + 16 * i2);
      }
      return MP4.box(MP4.types.trun, array);
    }
    static initSegment(tracks) {
      if (!MP4.types) {
        MP4.init();
      }
      const movie = MP4.moov(tracks);
      const result = new Uint8Array(MP4.FTYP.byteLength + movie.byteLength);
      result.set(MP4.FTYP);
      result.set(movie, MP4.FTYP.byteLength);
      return result;
    }
  };
  MP4.types = void 0;
  MP4.HDLR_TYPES = void 0;
  MP4.STTS = void 0;
  MP4.STSC = void 0;
  MP4.STCO = void 0;
  MP4.STSZ = void 0;
  MP4.VMHD = void 0;
  MP4.SMHD = void 0;
  MP4.STSD = void 0;
  MP4.FTYP = void 0;
  MP4.DINF = void 0;
  var MPEG_TS_CLOCK_FREQ_HZ = 9e4;
  function toTimescaleFromBase(baseTime, destScale, srcBase = 1, round2 = false) {
    const result = baseTime * destScale * srcBase;
    return round2 ? Math.round(result) : result;
  }
  function toTimescaleFromScale(baseTime, destScale, srcScale = 1, round2 = false) {
    return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round2);
  }
  function toMsFromMpegTsClock(baseTime, round2 = false) {
    return toTimescaleFromBase(baseTime, 1e3, 1 / MPEG_TS_CLOCK_FREQ_HZ, round2);
  }
  function toMpegTsClockFromTimescale(baseTime, srcScale = 1) {
    return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
  }
  var MAX_SILENT_FRAME_DURATION = 10 * 1e3;
  var AAC_SAMPLES_PER_FRAME = 1024;
  var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
  var chromeVersion = null;
  var safariWebkitVersion = null;
  var MP4Remuxer = class {
    constructor(observer, config, typeSupported, vendor = "") {
      this.observer = void 0;
      this.config = void 0;
      this.typeSupported = void 0;
      this.ISGenerated = false;
      this._initPTS = null;
      this._initDTS = null;
      this.nextAvcDts = null;
      this.nextAudioPts = null;
      this.videoSampleDuration = null;
      this.isAudioContiguous = false;
      this.isVideoContiguous = false;
      this.observer = observer;
      this.config = config;
      this.typeSupported = typeSupported;
      this.ISGenerated = false;
      if (chromeVersion === null) {
        const userAgent = navigator.userAgent || "";
        const result = userAgent.match(/Chrome\/(\d+)/i);
        chromeVersion = result ? parseInt(result[1]) : 0;
      }
      if (safariWebkitVersion === null) {
        const result = navigator.userAgent.match(/Safari\/(\d+)/i);
        safariWebkitVersion = result ? parseInt(result[1]) : 0;
      }
    }
    destroy() {
    }
    resetTimeStamp(defaultTimeStamp) {
      logger.log("[mp4-remuxer]: initPTS & initDTS reset");
      this._initPTS = this._initDTS = defaultTimeStamp;
    }
    resetNextTimestamp() {
      logger.log("[mp4-remuxer]: reset next timestamp");
      this.isVideoContiguous = false;
      this.isAudioContiguous = false;
    }
    resetInitSegment() {
      logger.log("[mp4-remuxer]: ISGenerated flag reset");
      this.ISGenerated = false;
    }
    getVideoStartPts(videoSamples) {
      let rolloverDetected = false;
      const startPTS = videoSamples.reduce((minPTS, sample) => {
        const delta = sample.pts - minPTS;
        if (delta < -4294967296) {
          rolloverDetected = true;
          return normalizePts(minPTS, sample.pts);
        } else if (delta > 0) {
          return minPTS;
        } else {
          return sample.pts;
        }
      }, videoSamples[0].pts);
      if (rolloverDetected) {
        logger.debug("PTS rollover detected");
      }
      return startPTS;
    }
    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
      let video;
      let audio;
      let initSegment;
      let text;
      let id3;
      let independent;
      let audioTimeOffset = timeOffset;
      let videoTimeOffset = timeOffset;
      const hasAudio = audioTrack.pid > -1;
      const hasVideo = videoTrack.pid > -1;
      const length = videoTrack.samples.length;
      const enoughAudioSamples = audioTrack.samples.length > 0;
      const enoughVideoSamples = flush && length > 0 || length > 1;
      const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
      if (canRemuxAvc) {
        if (!this.ISGenerated) {
          initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
        }
        const isVideoContiguous = this.isVideoContiguous;
        let firstKeyFrameIndex = -1;
        let firstKeyFramePTS;
        if (enoughVideoSamples) {
          firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
          if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
            independent = true;
            if (firstKeyFrameIndex > 0) {
              logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);
              const startPTS = this.getVideoStartPts(videoTrack.samples);
              videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
              videoTrack.dropped += firstKeyFrameIndex;
              videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
              firstKeyFramePTS = videoTimeOffset;
            } else if (firstKeyFrameIndex === -1) {
              logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);
              independent = false;
            }
          }
        }
        if (this.ISGenerated) {
          if (enoughAudioSamples && enoughVideoSamples) {
            const startPTS = this.getVideoStartPts(videoTrack.samples);
            const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;
            const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
            audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
            videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
          }
          if (enoughAudioSamples) {
            if (!audioTrack.samplerate) {
              logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
            }
            audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : void 0);
            if (enoughVideoSamples) {
              const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
              if (!videoTrack.inputTimeScale) {
                logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected");
                initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
              }
              video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
            }
          } else if (enoughVideoSamples) {
            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
          }
          if (video) {
            video.firstKeyFrame = firstKeyFrameIndex;
            video.independent = firstKeyFrameIndex !== -1;
            video.firstKeyFramePTS = firstKeyFramePTS;
          }
        }
      }
      if (this.ISGenerated && this._initPTS && this._initDTS) {
        if (id3Track.samples.length) {
          id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
        }
        if (textTrack.samples.length) {
          text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
        }
      }
      return {
        audio,
        video,
        initSegment,
        independent,
        text,
        id3
      };
    }
    generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
      const audioSamples = audioTrack.samples;
      const videoSamples = videoTrack.samples;
      const typeSupported = this.typeSupported;
      const tracks = {};
      const _initPTS = this._initPTS;
      let computePTSDTS = !_initPTS || accurateTimeOffset;
      let container2 = "audio/mp4";
      let initPTS;
      let initDTS;
      let timescale;
      if (computePTSDTS) {
        initPTS = initDTS = Infinity;
      }
      if (audioTrack.config && audioSamples.length) {
        audioTrack.timescale = audioTrack.samplerate;
        switch (audioTrack.segmentCodec) {
          case "mp3":
            if (typeSupported.mpeg) {
              container2 = "audio/mpeg";
              audioTrack.codec = "";
            } else if (typeSupported.mp3) {
              audioTrack.codec = "mp3";
            }
            break;
        }
        tracks.audio = {
          id: "audio",
          container: container2,
          codec: audioTrack.codec,
          initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),
          metadata: {
            channelCount: audioTrack.channelCount
          }
        };
        if (computePTSDTS) {
          timescale = audioTrack.inputTimeScale;
          if (!_initPTS || timescale !== _initPTS.timescale) {
            initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
          } else {
            computePTSDTS = false;
          }
        }
      }
      if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
        videoTrack.timescale = videoTrack.inputTimeScale;
        tracks.video = {
          id: "main",
          container: "video/mp4",
          codec: videoTrack.codec,
          initSegment: MP4.initSegment([videoTrack]),
          metadata: {
            width: videoTrack.width,
            height: videoTrack.height
          }
        };
        if (computePTSDTS) {
          timescale = videoTrack.inputTimeScale;
          if (!_initPTS || timescale !== _initPTS.timescale) {
            const startPTS = this.getVideoStartPts(videoSamples);
            const startOffset = Math.round(timescale * timeOffset);
            initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
            initPTS = Math.min(initPTS, startPTS - startOffset);
          } else {
            computePTSDTS = false;
          }
        }
      }
      if (Object.keys(tracks).length) {
        this.ISGenerated = true;
        if (computePTSDTS) {
          this._initPTS = {
            baseTime: initPTS,
            timescale
          };
          this._initDTS = {
            baseTime: initDTS,
            timescale
          };
        } else {
          initPTS = timescale = void 0;
        }
        return {
          tracks,
          initPTS,
          timescale
        };
      }
    }
    remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
      const timeScale = track.inputTimeScale;
      const inputSamples = track.samples;
      const outputSamples = [];
      const nbSamples = inputSamples.length;
      const initPTS = this._initPTS;
      let nextAvcDts = this.nextAvcDts;
      let offset2 = 8;
      let mp4SampleDuration = this.videoSampleDuration;
      let firstDTS;
      let lastDTS;
      let minPTS = Number.POSITIVE_INFINITY;
      let maxPTS = Number.NEGATIVE_INFINITY;
      let sortSamples = false;
      if (!contiguous || nextAvcDts === null) {
        const pts = timeOffset * timeScale;
        const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
        nextAvcDts = pts - cts;
      }
      const initTime = initPTS.baseTime * timeScale / initPTS.timescale;
      for (let i2 = 0; i2 < nbSamples; i2++) {
        const sample = inputSamples[i2];
        sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);
        sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);
        if (sample.dts < inputSamples[i2 > 0 ? i2 - 1 : i2].dts) {
          sortSamples = true;
        }
      }
      if (sortSamples) {
        inputSamples.sort(function(a2, b3) {
          const deltadts = a2.dts - b3.dts;
          const deltapts = a2.pts - b3.pts;
          return deltadts || deltapts;
        });
      }
      firstDTS = inputSamples[0].dts;
      lastDTS = inputSamples[inputSamples.length - 1].dts;
      const inputDuration = lastDTS - firstDTS;
      const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
      if (contiguous) {
        const delta = firstDTS - nextAvcDts;
        const foundHole = delta > averageSampleDuration;
        const foundOverlap = delta < -1;
        if (foundHole || foundOverlap) {
          if (foundHole) {
            logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected, filling it`);
          } else {
            logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected`);
          }
          if (!foundOverlap || nextAvcDts >= inputSamples[0].pts) {
            firstDTS = nextAvcDts;
            const firstPTS = inputSamples[0].pts - delta;
            inputSamples[0].dts = firstDTS;
            inputSamples[0].pts = firstPTS;
            logger.log(`Video: First PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);
          }
        }
      }
      firstDTS = Math.max(0, firstDTS);
      let nbNalu = 0;
      let naluLen = 0;
      for (let i2 = 0; i2 < nbSamples; i2++) {
        const sample = inputSamples[i2];
        const units = sample.units;
        const nbUnits = units.length;
        let sampleLen = 0;
        for (let j3 = 0; j3 < nbUnits; j3++) {
          sampleLen += units[j3].data.length;
        }
        naluLen += sampleLen;
        nbNalu += nbUnits;
        sample.length = sampleLen;
        sample.dts = Math.max(sample.dts, firstDTS);
        minPTS = Math.min(sample.pts, minPTS);
        maxPTS = Math.max(sample.pts, maxPTS);
      }
      lastDTS = inputSamples[nbSamples - 1].dts;
      const mdatSize = naluLen + 4 * nbNalu + 8;
      let mdat;
      try {
        mdat = new Uint8Array(mdatSize);
      } catch (err) {
        this.observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes.MUX_ERROR,
          details: ErrorDetails.REMUX_ALLOC_ERROR,
          fatal: false,
          error: err,
          bytes: mdatSize,
          reason: `fail allocating video mdat ${mdatSize}`
        });
        return;
      }
      const view = new DataView(mdat.buffer);
      view.setUint32(0, mdatSize);
      mdat.set(MP4.types.mdat, 4);
      let stretchedLastFrame = false;
      let minDtsDelta = Number.POSITIVE_INFINITY;
      let minPtsDelta = Number.POSITIVE_INFINITY;
      let maxDtsDelta = Number.NEGATIVE_INFINITY;
      let maxPtsDelta = Number.NEGATIVE_INFINITY;
      for (let i2 = 0; i2 < nbSamples; i2++) {
        const avcSample = inputSamples[i2];
        const avcSampleUnits = avcSample.units;
        let mp4SampleLength = 0;
        for (let j3 = 0, nbUnits = avcSampleUnits.length; j3 < nbUnits; j3++) {
          const unit = avcSampleUnits[j3];
          const unitData = unit.data;
          const unitDataLen = unit.data.byteLength;
          view.setUint32(offset2, unitDataLen);
          offset2 += 4;
          mdat.set(unitData, offset2);
          offset2 += unitDataLen;
          mp4SampleLength += 4 + unitDataLen;
        }
        let ptsDelta;
        if (i2 < nbSamples - 1) {
          mp4SampleDuration = inputSamples[i2 + 1].dts - avcSample.dts;
          ptsDelta = inputSamples[i2 + 1].pts - avcSample.pts;
        } else {
          const config = this.config;
          const lastFrameDuration = i2 > 0 ? avcSample.dts - inputSamples[i2 - 1].dts : averageSampleDuration;
          ptsDelta = i2 > 0 ? avcSample.pts - inputSamples[i2 - 1].pts : averageSampleDuration;
          if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
            const gapTolerance = Math.floor(config.maxBufferHole * timeScale);
            const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - avcSample.pts;
            if (deltaToFrameEnd > gapTolerance) {
              mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
              if (mp4SampleDuration < 0) {
                mp4SampleDuration = lastFrameDuration;
              } else {
                stretchedLastFrame = true;
              }
              logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);
            } else {
              mp4SampleDuration = lastFrameDuration;
            }
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        }
        const compositionTimeOffset = Math.round(avcSample.pts - avcSample.dts);
        minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
        maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
        minPtsDelta = Math.min(minPtsDelta, ptsDelta);
        maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
        outputSamples.push(new Mp4Sample(avcSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
      }
      if (outputSamples.length) {
        if (chromeVersion) {
          if (chromeVersion < 70) {
            const flags = outputSamples[0].flags;
            flags.dependsOn = 2;
            flags.isNonSync = 0;
          }
        } else if (safariWebkitVersion) {
          if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
            logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
            let dts = firstDTS;
            for (let i2 = 0, len = outputSamples.length; i2 < len; i2++) {
              const nextDts = dts + outputSamples[i2].duration;
              const pts = dts + outputSamples[i2].cts;
              if (i2 < len - 1) {
                const nextPts = nextDts + outputSamples[i2 + 1].cts;
                outputSamples[i2].duration = nextPts - pts;
              } else {
                outputSamples[i2].duration = i2 ? outputSamples[i2 - 1].duration : averageSampleDuration;
              }
              outputSamples[i2].cts = 0;
              dts = nextDts;
            }
          }
        }
      }
      mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
      this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
      this.videoSampleDuration = mp4SampleDuration;
      this.isVideoContiguous = true;
      const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends2({}, track, {
        samples: outputSamples
      }));
      const type = "video";
      const data = {
        data1: moof,
        data2: mdat,
        startPTS: minPTS / timeScale,
        endPTS: (maxPTS + mp4SampleDuration) / timeScale,
        startDTS: firstDTS / timeScale,
        endDTS: nextAvcDts / timeScale,
        type,
        hasAudio: false,
        hasVideo: true,
        nb: outputSamples.length,
        dropped: track.dropped
      };
      track.samples = [];
      track.dropped = 0;
      return data;
    }
    remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
      const inputTimeScale = track.inputTimeScale;
      const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
      const scaleFactor = inputTimeScale / mp4timeScale;
      const mp4SampleDuration = track.segmentCodec === "aac" ? AAC_SAMPLES_PER_FRAME : MPEG_AUDIO_SAMPLE_PER_FRAME;
      const inputSampleDuration = mp4SampleDuration * scaleFactor;
      const initPTS = this._initPTS;
      const rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
      const outputSamples = [];
      const alignedWithVideo = videoTimeOffset !== void 0;
      let inputSamples = track.samples;
      let offset2 = rawMPEG ? 0 : 8;
      let nextAudioPts = this.nextAudioPts || -1;
      const timeOffsetMpegTS = timeOffset * inputTimeScale;
      const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
      this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9e3 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);
      inputSamples.forEach(function(sample) {
        sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);
      });
      if (!contiguous || nextAudioPts < 0) {
        inputSamples = inputSamples.filter((sample) => sample.pts >= 0);
        if (!inputSamples.length) {
          return;
        }
        if (videoTimeOffset === 0) {
          nextAudioPts = 0;
        } else if (accurateTimeOffset && !alignedWithVideo) {
          nextAudioPts = Math.max(0, timeOffsetMpegTS);
        } else {
          nextAudioPts = inputSamples[0].pts;
        }
      }
      if (track.segmentCodec === "aac") {
        const maxAudioFramesDrift = this.config.maxAudioFramesDrift;
        for (let i2 = 0, nextPts = nextAudioPts; i2 < inputSamples.length; i2++) {
          const sample = inputSamples[i2];
          const pts = sample.pts;
          const delta = pts - nextPts;
          const duration = Math.abs(1e3 * delta / inputTimeScale);
          if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
            if (i2 === 0) {
              logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1e3 * delta / inputTimeScale)} ms.`);
              this.nextAudioPts = nextAudioPts = nextPts = pts;
            }
          } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
            let missing = Math.round(delta / inputSampleDuration);
            nextPts = pts - missing * inputSampleDuration;
            if (nextPts < 0) {
              missing--;
              nextPts += inputSampleDuration;
            }
            if (i2 === 0) {
              this.nextAudioPts = nextAudioPts = nextPts;
            }
            logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1e3 * delta / inputTimeScale)} ms gap.`);
            for (let j3 = 0; j3 < missing; j3++) {
              const newStamp = Math.max(nextPts, 0);
              let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
              if (!fillFrame) {
                logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
                fillFrame = sample.unit.subarray();
              }
              inputSamples.splice(i2, 0, {
                unit: fillFrame,
                pts: newStamp
              });
              nextPts += inputSampleDuration;
              i2++;
            }
          }
          sample.pts = nextPts;
          nextPts += inputSampleDuration;
        }
      }
      let firstPTS = null;
      let lastPTS = null;
      let mdat;
      let mdatSize = 0;
      let sampleLength = inputSamples.length;
      while (sampleLength--) {
        mdatSize += inputSamples[sampleLength].unit.byteLength;
      }
      for (let j3 = 0, _nbSamples = inputSamples.length; j3 < _nbSamples; j3++) {
        const audioSample = inputSamples[j3];
        const unit = audioSample.unit;
        let pts = audioSample.pts;
        if (lastPTS !== null) {
          const prevSample = outputSamples[j3 - 1];
          prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);
        } else {
          if (contiguous && track.segmentCodec === "aac") {
            pts = nextAudioPts;
          }
          firstPTS = pts;
          if (mdatSize > 0) {
            mdatSize += offset2;
            try {
              mdat = new Uint8Array(mdatSize);
            } catch (err) {
              this.observer.emit(Events.ERROR, Events.ERROR, {
                type: ErrorTypes.MUX_ERROR,
                details: ErrorDetails.REMUX_ALLOC_ERROR,
                fatal: false,
                error: err,
                bytes: mdatSize,
                reason: `fail allocating audio mdat ${mdatSize}`
              });
              return;
            }
            if (!rawMPEG) {
              const view = new DataView(mdat.buffer);
              view.setUint32(0, mdatSize);
              mdat.set(MP4.types.mdat, 4);
            }
          } else {
            return;
          }
        }
        mdat.set(unit, offset2);
        const unitLen = unit.byteLength;
        offset2 += unitLen;
        outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
        lastPTS = pts;
      }
      const nbSamples = outputSamples.length;
      if (!nbSamples) {
        return;
      }
      const lastSample = outputSamples[outputSamples.length - 1];
      this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
      const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends2({}, track, {
        samples: outputSamples
      }));
      track.samples = [];
      const start = firstPTS / inputTimeScale;
      const end = nextAudioPts / inputTimeScale;
      const type = "audio";
      const audioData = {
        data1: moof,
        data2: mdat,
        startPTS: start,
        endPTS: end,
        startDTS: start,
        endDTS: end,
        type,
        hasAudio: true,
        hasVideo: false,
        nb: nbSamples
      };
      this.isAudioContiguous = true;
      return audioData;
    }
    remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
      const inputTimeScale = track.inputTimeScale;
      const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
      const scaleFactor = inputTimeScale / mp4timeScale;
      const nextAudioPts = this.nextAudioPts;
      const initDTS = this._initDTS;
      const init90kHz = initDTS.baseTime * 9e4 / initDTS.timescale;
      const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;
      const endDTS = videoData.endDTS * inputTimeScale + init90kHz;
      const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
      const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
      const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
      logger.warn("[mp4-remuxer]: remux empty Audio");
      if (!silentFrame) {
        logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
        return;
      }
      const samples = [];
      for (let i2 = 0; i2 < nbSamples; i2++) {
        const stamp = startDTS + i2 * frameDuration;
        samples.push({
          unit: silentFrame,
          pts: stamp,
          dts: stamp
        });
      }
      track.samples = samples;
      return this.remuxAudio(track, timeOffset, contiguous, false);
    }
  };
  function normalizePts(value, reference) {
    let offset2;
    if (reference === null) {
      return value;
    }
    if (reference < value) {
      offset2 = -8589934592;
    } else {
      offset2 = 8589934592;
    }
    while (Math.abs(value - reference) > 4294967296) {
      value += offset2;
    }
    return value;
  }
  function findKeyframeIndex(samples) {
    for (let i2 = 0; i2 < samples.length; i2++) {
      if (samples[i2].key) {
        return i2;
      }
    }
    return -1;
  }
  function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
    const length = track.samples.length;
    if (!length) {
      return;
    }
    const inputTimeScale = track.inputTimeScale;
    for (let index2 = 0; index2 < length; index2++) {
      const sample = track.samples[index2];
      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
      sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    }
    const samples = track.samples;
    track.samples = [];
    return {
      samples
    };
  }
  function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
    const length = track.samples.length;
    if (!length) {
      return;
    }
    const inputTimeScale = track.inputTimeScale;
    for (let index2 = 0; index2 < length; index2++) {
      const sample = track.samples[index2];
      sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    }
    track.samples.sort((a2, b3) => a2.pts - b3.pts);
    const samples = track.samples;
    track.samples = [];
    return {
      samples
    };
  }
  var Mp4Sample = class {
    constructor(isKeyframe, duration, size2, cts) {
      this.size = void 0;
      this.duration = void 0;
      this.cts = void 0;
      this.flags = void 0;
      this.duration = duration;
      this.size = size2;
      this.cts = cts;
      this.flags = new Mp4SampleFlags(isKeyframe);
    }
  };
  var Mp4SampleFlags = class {
    constructor(isKeyframe) {
      this.isLeading = 0;
      this.isDependedOn = 0;
      this.hasRedundancy = 0;
      this.degradPrio = 0;
      this.dependsOn = 1;
      this.isNonSync = 1;
      this.dependsOn = isKeyframe ? 2 : 1;
      this.isNonSync = isKeyframe ? 0 : 1;
    }
  };
  var PassThroughRemuxer = class {
    constructor() {
      this.emitInitSegment = false;
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this.initData = void 0;
      this.initPTS = null;
      this.initTracks = void 0;
      this.lastEndTime = null;
    }
    destroy() {
    }
    resetTimeStamp(defaultInitPTS) {
      this.initPTS = defaultInitPTS;
      this.lastEndTime = null;
    }
    resetNextTimestamp() {
      this.lastEndTime = null;
    }
    resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));
      this.emitInitSegment = true;
    }
    generateInitSegment(initSegment) {
      let {
        audioCodec,
        videoCodec
      } = this;
      if (!(initSegment != null && initSegment.byteLength)) {
        this.initTracks = void 0;
        this.initData = void 0;
        return;
      }
      const initData = this.initData = parseInitSegment(initSegment);
      if (!audioCodec) {
        audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);
      }
      if (!videoCodec) {
        videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);
      }
      const tracks = {};
      if (initData.audio && initData.video) {
        tracks.audiovideo = {
          container: "video/mp4",
          codec: audioCodec + "," + videoCodec,
          initSegment,
          id: "main"
        };
      } else if (initData.audio) {
        tracks.audio = {
          container: "audio/mp4",
          codec: audioCodec,
          initSegment,
          id: "audio"
        };
      } else if (initData.video) {
        tracks.video = {
          container: "video/mp4",
          codec: videoCodec,
          initSegment,
          id: "main"
        };
      } else {
        logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
      }
      this.initTracks = tracks;
    }
    remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
      var _initData, _initData2;
      let {
        initPTS,
        lastEndTime
      } = this;
      const result = {
        audio: void 0,
        video: void 0,
        text: textTrack,
        id3: id3Track,
        initSegment: void 0
      };
      if (!isFiniteNumber(lastEndTime)) {
        lastEndTime = this.lastEndTime = timeOffset || 0;
      }
      const data = videoTrack.samples;
      if (!(data != null && data.length)) {
        return result;
      }
      const initSegment = {
        initPTS: void 0,
        timescale: 1
      };
      let initData = this.initData;
      if (!((_initData = initData) != null && _initData.length)) {
        this.generateInitSegment(data);
        initData = this.initData;
      }
      if (!((_initData2 = initData) != null && _initData2.length)) {
        logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
        return result;
      }
      if (this.emitInitSegment) {
        initSegment.tracks = this.initTracks;
        this.emitInitSegment = false;
      }
      const duration = getDuration(data, initData);
      const startDTS = getStartDTS(initData, data);
      const decodeTime = startDTS === null ? timeOffset : startDTS;
      if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {
        initSegment.initPTS = decodeTime - timeOffset;
        if (initPTS && initPTS.timescale === 1) {
          logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);
        }
        this.initPTS = initPTS = {
          baseTime: initSegment.initPTS,
          timescale: 1
        };
      }
      const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;
      const endTime = startTime + duration;
      offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);
      if (duration > 0) {
        this.lastEndTime = endTime;
      } else {
        logger.warn("Duration parsed from mp4 should be greater than zero");
        this.resetNextTimestamp();
      }
      const hasAudio = !!initData.audio;
      const hasVideo = !!initData.video;
      let type = "";
      if (hasAudio) {
        type += "audio";
      }
      if (hasVideo) {
        type += "video";
      }
      const track = {
        data1: data,
        startPTS: startTime,
        startDTS: startTime,
        endPTS: endTime,
        endDTS: endTime,
        type,
        hasAudio,
        hasVideo,
        nb: 1,
        dropped: 0
      };
      result.audio = track.type === "audio" ? track : void 0;
      result.video = track.type !== "audio" ? track : void 0;
      result.initSegment = initSegment;
      result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
      if (textTrack.samples.length) {
        result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
      }
      return result;
    }
  };
  function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {
    if (initPTS === null) {
      return true;
    }
    const minDuration = Math.max(duration, 1);
    const startTime = startDTS - initPTS.baseTime / initPTS.timescale;
    return Math.abs(startTime - timeOffset) > minDuration;
  }
  function getParsedTrackCodec(track, type) {
    const parsedCodec = track == null ? void 0 : track.codec;
    if (parsedCodec && parsedCodec.length > 4) {
      return parsedCodec;
    }
    if (parsedCodec === "hvc1" || parsedCodec === "hev1") {
      return "hvc1.1.6.L120.90";
    }
    if (parsedCodec === "av01") {
      return "av01.0.04M.08";
    }
    if (parsedCodec === "avc1" || type === ElementaryStreamTypes.VIDEO) {
      return "avc1.42e01e";
    }
    return "mp4a.40.5";
  }
  var now;
  try {
    now = self.performance.now.bind(self.performance);
  } catch (err) {
    logger.debug("Unable to use Performance API on this environment");
    now = typeof self !== "undefined" && self.Date.now;
  }
  var muxConfig = [{
    demux: MP4Demuxer,
    remux: PassThroughRemuxer
  }, {
    demux: TSDemuxer,
    remux: MP4Remuxer
  }, {
    demux: AACDemuxer,
    remux: MP4Remuxer
  }, {
    demux: MP3Demuxer,
    remux: MP4Remuxer
  }];
  var Transmuxer = class {
    constructor(observer, typeSupported, config, vendor, id) {
      this.async = false;
      this.observer = void 0;
      this.typeSupported = void 0;
      this.config = void 0;
      this.vendor = void 0;
      this.id = void 0;
      this.demuxer = void 0;
      this.remuxer = void 0;
      this.decrypter = void 0;
      this.probe = void 0;
      this.decryptionPromise = null;
      this.transmuxConfig = void 0;
      this.currentTransmuxState = void 0;
      this.observer = observer;
      this.typeSupported = typeSupported;
      this.config = config;
      this.vendor = vendor;
      this.id = id;
    }
    configure(transmuxConfig) {
      this.transmuxConfig = transmuxConfig;
      if (this.decrypter) {
        this.decrypter.reset();
      }
    }
    push(data, decryptdata, chunkMeta, state) {
      const stats = chunkMeta.transmuxing;
      stats.executeStart = now();
      let uintData = new Uint8Array(data);
      const {
        currentTransmuxState,
        transmuxConfig
      } = this;
      if (state) {
        this.currentTransmuxState = state;
      }
      const {
        contiguous,
        discontinuity,
        trackSwitch,
        accurateTimeOffset,
        timeOffset,
        initSegmentChange
      } = state || currentTransmuxState;
      const {
        audioCodec,
        videoCodec,
        defaultInitPts,
        duration,
        initSegmentData
      } = transmuxConfig;
      const keyData = getEncryptionType(uintData, decryptdata);
      if (keyData && keyData.method === "AES-128") {
        const decrypter = this.getDecrypter();
        if (decrypter.isSync()) {
          let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
          const loadingParts = chunkMeta.part > -1;
          if (loadingParts) {
            decryptedData = decrypter.flush();
          }
          if (!decryptedData) {
            stats.executeEnd = now();
            return emptyResult(chunkMeta);
          }
          uintData = new Uint8Array(decryptedData);
        } else {
          this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then((decryptedData) => {
            const result2 = this.push(decryptedData, null, chunkMeta);
            this.decryptionPromise = null;
            return result2;
          });
          return this.decryptionPromise;
        }
      }
      const resetMuxers = this.needsProbing(discontinuity, trackSwitch);
      if (resetMuxers) {
        const error = this.configureTransmuxer(uintData);
        if (error) {
          logger.warn(`[transmuxer] ${error.message}`);
          this.observer.emit(Events.ERROR, Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: false,
            error,
            reason: error.message
          });
          stats.executeEnd = now();
          return emptyResult(chunkMeta);
        }
      }
      if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
        this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
      }
      if (discontinuity || initSegmentChange || resetMuxers) {
        this.resetInitialTimestamp(defaultInitPts);
      }
      if (!contiguous) {
        this.resetContiguity();
      }
      const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
      const currentState = this.currentTransmuxState;
      currentState.contiguous = true;
      currentState.discontinuity = false;
      currentState.trackSwitch = false;
      stats.executeEnd = now();
      return result;
    }
    flush(chunkMeta) {
      const stats = chunkMeta.transmuxing;
      stats.executeStart = now();
      const {
        decrypter,
        currentTransmuxState,
        decryptionPromise
      } = this;
      if (decryptionPromise) {
        return decryptionPromise.then(() => {
          return this.flush(chunkMeta);
        });
      }
      const transmuxResults = [];
      const {
        timeOffset
      } = currentTransmuxState;
      if (decrypter) {
        const decryptedData = decrypter.flush();
        if (decryptedData) {
          transmuxResults.push(this.push(decryptedData, null, chunkMeta));
        }
      }
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        stats.executeEnd = now();
        return [emptyResult(chunkMeta)];
      }
      const demuxResultOrPromise = demuxer.flush(timeOffset);
      if (isPromise(demuxResultOrPromise)) {
        return demuxResultOrPromise.then((demuxResult) => {
          this.flushRemux(transmuxResults, demuxResult, chunkMeta);
          return transmuxResults;
        });
      }
      this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
      return transmuxResults;
    }
    flushRemux(transmuxResults, demuxResult, chunkMeta) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = demuxResult;
      const {
        accurateTimeOffset,
        timeOffset
      } = this.currentTransmuxState;
      logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? " p: " + chunkMeta.part : ""} of level ${chunkMeta.level}`);
      const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
      transmuxResults.push({
        remuxResult,
        chunkMeta
      });
      chunkMeta.transmuxing.executeEnd = now();
    }
    resetInitialTimestamp(defaultInitPts) {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetTimeStamp(defaultInitPts);
      remuxer.resetTimeStamp(defaultInitPts);
    }
    resetContiguity() {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetContiguity();
      remuxer.resetNextTimestamp();
    }
    resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
      const {
        demuxer,
        remuxer
      } = this;
      if (!demuxer || !remuxer) {
        return;
      }
      demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
      remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
    }
    destroy() {
      if (this.demuxer) {
        this.demuxer.destroy();
        this.demuxer = void 0;
      }
      if (this.remuxer) {
        this.remuxer.destroy();
        this.remuxer = void 0;
      }
    }
    transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
      let result;
      if (keyData && keyData.method === "SAMPLE-AES") {
        result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
      } else {
        result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
      }
      return result;
    }
    transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
      const {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);
      const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
      return {
        remuxResult,
        chunkMeta
      };
    }
    transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
      return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then((demuxResult) => {
        const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);
        return {
          remuxResult,
          chunkMeta
        };
      });
    }
    configureTransmuxer(data) {
      const {
        config,
        observer,
        typeSupported,
        vendor
      } = this;
      let mux;
      for (let i2 = 0, len = muxConfig.length; i2 < len; i2++) {
        if (muxConfig[i2].demux.probe(data)) {
          mux = muxConfig[i2];
          break;
        }
      }
      if (!mux) {
        return new Error("Failed to find demuxer by probing fragment data");
      }
      const demuxer = this.demuxer;
      const remuxer = this.remuxer;
      const Remuxer = mux.remux;
      const Demuxer = mux.demux;
      if (!remuxer || !(remuxer instanceof Remuxer)) {
        this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
      }
      if (!demuxer || !(demuxer instanceof Demuxer)) {
        this.demuxer = new Demuxer(observer, config, typeSupported);
        this.probe = Demuxer.probe;
      }
    }
    needsProbing(discontinuity, trackSwitch) {
      return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
    }
    getDecrypter() {
      let decrypter = this.decrypter;
      if (!decrypter) {
        decrypter = this.decrypter = new Decrypter(this.config);
      }
      return decrypter;
    }
  };
  function getEncryptionType(data, decryptData) {
    let encryptionType = null;
    if (data.byteLength > 0 && decryptData != null && decryptData.key != null && decryptData.iv !== null && decryptData.method != null) {
      encryptionType = decryptData;
    }
    return encryptionType;
  }
  var emptyResult = (chunkMeta) => ({
    remuxResult: {},
    chunkMeta
  });
  function isPromise(p2) {
    return "then" in p2 && p2.then instanceof Function;
  }
  var TransmuxConfig = class {
    constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
      this.audioCodec = void 0;
      this.videoCodec = void 0;
      this.initSegmentData = void 0;
      this.duration = void 0;
      this.defaultInitPts = void 0;
      this.audioCodec = audioCodec;
      this.videoCodec = videoCodec;
      this.initSegmentData = initSegmentData;
      this.duration = duration;
      this.defaultInitPts = defaultInitPts || null;
    }
  };
  var TransmuxState = class {
    constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
      this.discontinuity = void 0;
      this.contiguous = void 0;
      this.accurateTimeOffset = void 0;
      this.trackSwitch = void 0;
      this.timeOffset = void 0;
      this.initSegmentChange = void 0;
      this.discontinuity = discontinuity;
      this.contiguous = contiguous;
      this.accurateTimeOffset = accurateTimeOffset;
      this.trackSwitch = trackSwitch;
      this.timeOffset = timeOffset;
      this.initSegmentChange = initSegmentChange;
    }
  };
  var eventemitter3 = { exports: {} };
  (function(module2) {
    var has = Object.prototype.hasOwnProperty, prefix = "~";
    function Events2() {
    }
    if (Object.create) {
      Events2.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events2().__proto__)
        prefix = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events2();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events2();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
        ee2[i2] = handlers[i2].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j3;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once)
            this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                  args[j3 - 1] = arguments[j3];
                }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn2 || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events2();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    {
      module2.exports = EventEmitter2;
    }
  })(eventemitter3);
  var eventemitter3Exports = eventemitter3.exports;
  var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
  var MediaSource$1 = getMediaSource() || {
    isTypeSupported: () => false
  };
  var TransmuxerInterface = class {
    constructor(hls, id, onTransmuxComplete, onFlush) {
      this.error = null;
      this.hls = void 0;
      this.id = void 0;
      this.observer = void 0;
      this.frag = null;
      this.part = null;
      this.useWorker = void 0;
      this.workerContext = null;
      this.onwmsg = void 0;
      this.transmuxer = null;
      this.onTransmuxComplete = void 0;
      this.onFlush = void 0;
      const config = hls.config;
      this.hls = hls;
      this.id = id;
      this.useWorker = !!config.enableWorker;
      this.onTransmuxComplete = onTransmuxComplete;
      this.onFlush = onFlush;
      const forwardMessage = (ev, data) => {
        data = data || {};
        data.frag = this.frag;
        data.id = this.id;
        if (ev === Events.ERROR) {
          this.error = data.error;
        }
        this.hls.trigger(ev, data);
      };
      this.observer = new EventEmitter();
      this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);
      this.observer.on(Events.ERROR, forwardMessage);
      const typeSupported = {
        mp4: MediaSource$1.isTypeSupported("video/mp4"),
        mpeg: MediaSource$1.isTypeSupported("audio/mpeg"),
        mp3: MediaSource$1.isTypeSupported('audio/mp4; codecs="mp3"')
      };
      const vendor = navigator.vendor;
      if (this.useWorker && typeof Worker !== "undefined") {
        const canCreateWorker = config.workerPath || hasUMDWorker();
        if (canCreateWorker) {
          try {
            if (config.workerPath) {
              logger.log(`loading Web Worker ${config.workerPath} for "${id}"`);
              this.workerContext = loadWorker(config.workerPath);
            } else {
              logger.log(`injecting Web Worker for "${id}"`);
              this.workerContext = injectWorker();
            }
            this.onwmsg = (ev) => this.onWorkerMessage(ev);
            const {
              worker
            } = this.workerContext;
            worker.addEventListener("message", this.onwmsg);
            worker.onerror = (event) => {
              const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);
              config.enableWorker = false;
              logger.warn(`Error in "${id}" Web Worker, fallback to inline`);
              this.hls.trigger(Events.ERROR, {
                type: ErrorTypes.OTHER_ERROR,
                details: ErrorDetails.INTERNAL_EXCEPTION,
                fatal: false,
                event: "demuxerWorker",
                error
              });
            };
            worker.postMessage({
              cmd: "init",
              typeSupported,
              vendor,
              id,
              config: JSON.stringify(config)
            });
          } catch (err) {
            logger.warn(`Error setting up "${id}" Web Worker, fallback to inline`, err);
            this.resetWorker();
            this.error = null;
            this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);
          }
          return;
        }
      }
      this.transmuxer = new Transmuxer(this.observer, typeSupported, config, vendor, id);
    }
    resetWorker() {
      if (this.workerContext) {
        const {
          worker,
          objectURL
        } = this.workerContext;
        if (objectURL) {
          self.URL.revokeObjectURL(objectURL);
        }
        worker.removeEventListener("message", this.onwmsg);
        worker.onerror = null;
        worker.terminate();
        this.workerContext = null;
      }
    }
    destroy() {
      if (this.workerContext) {
        this.resetWorker();
        this.onwmsg = void 0;
      } else {
        const transmuxer = this.transmuxer;
        if (transmuxer) {
          transmuxer.destroy();
          this.transmuxer = null;
        }
      }
      const observer = this.observer;
      if (observer) {
        observer.removeAllListeners();
      }
      this.frag = null;
      this.observer = null;
      this.hls = null;
    }
    push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
      var _frag$initSegment, _lastFrag$initSegment;
      chunkMeta.transmuxing.start = self.performance.now();
      const {
        transmuxer
      } = this;
      const timeOffset = part ? part.start : frag.start;
      const decryptdata = frag.decryptdata;
      const lastFrag = this.frag;
      const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
      const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
      const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
      const partDiff = this.part ? chunkMeta.part - this.part.index : -1;
      const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);
      const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
      const now2 = self.performance.now();
      if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
        frag.stats.parsing.start = now2;
      }
      if (part && (partDiff || !contiguous)) {
        part.stats.parsing.start = now2;
      }
      const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));
      const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
      if (!contiguous || discontinuity || initSegmentChange) {
        logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}
        discontinuity: ${discontinuity}
        trackSwitch: ${trackSwitch}
        contiguous: ${contiguous}
        accurateTimeOffset: ${accurateTimeOffset}
        timeOffset: ${timeOffset}
        initSegmentChange: ${initSegmentChange}`);
        const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
        this.configureTransmuxer(config);
      }
      this.frag = frag;
      this.part = part;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          cmd: "demux",
          data,
          decryptdata,
          chunkMeta,
          state
        }, data instanceof ArrayBuffer ? [data] : []);
      } else if (transmuxer) {
        const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
        if (isPromise(transmuxResult)) {
          transmuxer.async = true;
          transmuxResult.then((data2) => {
            this.handleTransmuxComplete(data2);
          }).catch((error) => {
            this.transmuxerError(error, chunkMeta, "transmuxer-interface push error");
          });
        } else {
          transmuxer.async = false;
          this.handleTransmuxComplete(transmuxResult);
        }
      }
    }
    flush(chunkMeta) {
      chunkMeta.transmuxing.start = self.performance.now();
      const {
        transmuxer
      } = this;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          cmd: "flush",
          chunkMeta
        });
      } else if (transmuxer) {
        let transmuxResult = transmuxer.flush(chunkMeta);
        const asyncFlush = isPromise(transmuxResult);
        if (asyncFlush || transmuxer.async) {
          if (!isPromise(transmuxResult)) {
            transmuxResult = Promise.resolve(transmuxResult);
          }
          transmuxResult.then((data) => {
            this.handleFlushResult(data, chunkMeta);
          }).catch((error) => {
            this.transmuxerError(error, chunkMeta, "transmuxer-interface flush error");
          });
        } else {
          this.handleFlushResult(transmuxResult, chunkMeta);
        }
      }
    }
    transmuxerError(error, chunkMeta, reason) {
      if (!this.hls) {
        return;
      }
      this.error = error;
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        chunkMeta,
        fatal: false,
        error,
        err: error,
        reason
      });
    }
    handleFlushResult(results, chunkMeta) {
      results.forEach((result) => {
        this.handleTransmuxComplete(result);
      });
      this.onFlush(chunkMeta);
    }
    onWorkerMessage(ev) {
      const data = ev.data;
      const hls = this.hls;
      switch (data.event) {
        case "init": {
          var _this$workerContext;
          const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;
          if (objectURL) {
            self.URL.revokeObjectURL(objectURL);
          }
          break;
        }
        case "transmuxComplete": {
          this.handleTransmuxComplete(data.data);
          break;
        }
        case "flush": {
          this.onFlush(data.data);
          break;
        }
        case "workerLog":
          if (logger[data.data.logType]) {
            logger[data.data.logType](data.data.message);
          }
          break;
        default: {
          data.data = data.data || {};
          data.data.frag = this.frag;
          data.data.id = this.id;
          hls.trigger(data.event, data.data);
          break;
        }
      }
    }
    configureTransmuxer(config) {
      const {
        transmuxer
      } = this;
      if (this.workerContext) {
        this.workerContext.worker.postMessage({
          cmd: "configure",
          config
        });
      } else if (transmuxer) {
        transmuxer.configure(config);
      }
    }
    handleTransmuxComplete(result) {
      result.chunkMeta.transmuxing.end = self.performance.now();
      this.onTransmuxComplete(result);
    }
  };
  var STALL_MINIMUM_DURATION_MS = 250;
  var MAX_START_GAP_JUMP = 2;
  var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
  var SKIP_BUFFER_RANGE_START = 0.05;
  var GapController = class {
    constructor(config, media, fragmentTracker, hls) {
      this.config = void 0;
      this.media = null;
      this.fragmentTracker = void 0;
      this.hls = void 0;
      this.nudgeRetry = 0;
      this.stallReported = false;
      this.stalled = null;
      this.moved = false;
      this.seeking = false;
      this.config = config;
      this.media = media;
      this.fragmentTracker = fragmentTracker;
      this.hls = hls;
    }
    destroy() {
      this.media = null;
      this.hls = this.fragmentTracker = null;
    }
    poll(lastCurrentTime, activeFrag) {
      const {
        config,
        media,
        stalled
      } = this;
      if (media === null) {
        return;
      }
      const {
        currentTime,
        seeking
      } = media;
      const seeked = this.seeking && !seeking;
      const beginSeek = !this.seeking && seeking;
      this.seeking = seeking;
      if (currentTime !== lastCurrentTime) {
        this.moved = true;
        if (stalled !== null) {
          if (this.stallReported) {
            const _stalledDuration = self.performance.now() - stalled;
            logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);
            this.stallReported = false;
          }
          this.stalled = null;
          this.nudgeRetry = 0;
        }
        return;
      }
      if (beginSeek || seeked) {
        this.stalled = null;
        return;
      }
      if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {
        return;
      }
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const isBuffered = bufferInfo.len > 0;
      const nextStart = bufferInfo.nextStart || 0;
      if (!isBuffered && !nextStart) {
        return;
      }
      if (seeking) {
        const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
        const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
        if (hasEnoughBuffer || noBufferGap) {
          return;
        }
        this.moved = false;
      }
      if (!this.moved && this.stalled !== null) {
        var _level$details;
        const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
        const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
        const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;
        const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
        const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);
        if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {
          this._trySkipBufferHole(partialOrGap);
          return;
        }
      }
      const tnow = self.performance.now();
      if (stalled === null) {
        this.stalled = tnow;
        return;
      }
      const stalledDuration = tnow - stalled;
      if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
        this._reportStall(bufferInfo);
        if (!this.media) {
          return;
        }
      }
      const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
      this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
    }
    _tryFixBufferStall(bufferInfo, stalledDurationMs) {
      const {
        config,
        fragmentTracker,
        media
      } = this;
      if (media === null) {
        return;
      }
      const currentTime = media.currentTime;
      const partial = fragmentTracker.getPartialFragment(currentTime);
      if (partial) {
        const targetTime = this._trySkipBufferHole(partial);
        if (targetTime || !this.media) {
          return;
        }
      }
      if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1e3) {
        logger.warn("Trying to nudge playhead over buffer-hole");
        this.stalled = null;
        this._tryNudgeBuffer();
      }
    }
    _reportStall(bufferInfo) {
      const {
        hls,
        media,
        stallReported
      } = this;
      if (!stallReported && media) {
        this.stallReported = true;
        const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);
        logger.warn(error.message);
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_STALLED_ERROR,
          fatal: false,
          error,
          buffer: bufferInfo.len
        });
      }
    }
    _trySkipBufferHole(partial) {
      const {
        config,
        hls,
        media
      } = this;
      if (media === null) {
        return 0;
      }
      const currentTime = media.currentTime;
      const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
      const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
      if (startTime) {
        const bufferStarved = bufferInfo.len <= config.maxBufferHole;
        const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
        const gapLength = startTime - currentTime;
        if (gapLength > 0 && (bufferStarved || waiting)) {
          if (gapLength > config.maxBufferHole) {
            const {
              fragmentTracker
            } = this;
            let startGap = false;
            if (currentTime === 0) {
              const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
              if (startFrag && startTime < startFrag.end) {
                startGap = true;
              }
            }
            if (!startGap) {
              const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);
              if (startProvisioned) {
                let moreToLoad = false;
                let pos = startProvisioned.end;
                while (pos < startTime) {
                  const provisioned = fragmentTracker.getPartialFragment(pos);
                  if (provisioned) {
                    pos += provisioned.duration;
                  } else {
                    moreToLoad = true;
                    break;
                  }
                }
                if (moreToLoad) {
                  return 0;
                }
              }
            }
          }
          const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
          logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);
          this.moved = true;
          this.stalled = null;
          media.currentTime = targetTime;
          if (partial && !partial.gap) {
            const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);
            hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
              fatal: false,
              error,
              reason: error.message,
              frag: partial
            });
          }
          return targetTime;
        }
      }
      return 0;
    }
    _tryNudgeBuffer() {
      const {
        config,
        hls,
        media,
        nudgeRetry
      } = this;
      if (media === null) {
        return;
      }
      const currentTime = media.currentTime;
      this.nudgeRetry++;
      if (nudgeRetry < config.nudgeMaxRetry) {
        const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
        const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);
        logger.warn(error.message);
        media.currentTime = targetTime;
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
          error,
          fatal: false
        });
      } else {
        const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);
        logger.error(error.message);
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_STALLED_ERROR,
          error,
          fatal: true
        });
      }
    }
  };
  var TICK_INTERVAL$2 = 100;
  var StreamController = class extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, "[stream-controller]", PlaylistLevelType.MAIN);
      this.audioCodecSwap = false;
      this.gapController = null;
      this.level = -1;
      this._forceStartLoad = false;
      this.altAudio = false;
      this.audioOnly = false;
      this.fragPlaying = null;
      this.onvplaying = null;
      this.onvseeked = null;
      this.fragLastKbps = 0;
      this.couldBacktrack = false;
      this.backtrackFragment = null;
      this.audioCodecSwitch = false;
      this.videoBuffer = null;
      this._registerListeners();
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
      hls.on(Events.ERROR, this.onError, this);
      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
      hls.off(Events.ERROR, this.onError, this);
      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    onHandlerDestroying() {
      this._unregisterListeners();
      this.onMediaDetaching();
    }
    startLoad(startPosition) {
      if (this.levels) {
        const {
          lastCurrentTime,
          hls
        } = this;
        this.stopLoad();
        this.setInterval(TICK_INTERVAL$2);
        this.level = -1;
        if (!this.startFragRequested) {
          let startLevel = hls.startLevel;
          if (startLevel === -1) {
            if (hls.config.testBandwidth && this.levels.length > 1) {
              startLevel = 0;
              this.bitrateTest = true;
            } else {
              startLevel = hls.nextAutoLevel;
            }
          }
          this.level = hls.nextLoadLevel = startLevel;
          this.loadedmetadata = false;
        }
        if (lastCurrentTime > 0 && startPosition === -1) {
          this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
          startPosition = lastCurrentTime;
        }
        this.state = State.IDLE;
        this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
        this.tick();
      } else {
        this._forceStartLoad = true;
        this.state = State.STOPPED;
      }
    }
    stopLoad() {
      this._forceStartLoad = false;
      super.stopLoad();
    }
    doTick() {
      switch (this.state) {
        case State.WAITING_LEVEL: {
          var _levels$level;
          const {
            levels,
            level
          } = this;
          const details = levels == null ? void 0 : (_levels$level = levels[level]) == null ? void 0 : _levels$level.details;
          if (details && (!details.live || this.levelLastLoaded === this.level)) {
            if (this.waitForCdnTuneIn(details)) {
              break;
            }
            this.state = State.IDLE;
            break;
          } else if (this.hls.nextLoadLevel !== this.level) {
            this.state = State.IDLE;
            break;
          }
          break;
        }
        case State.FRAG_LOADING_WAITING_RETRY:
          {
            var _this$media;
            const now2 = self.performance.now();
            const retryDate = this.retryDate;
            if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
              this.resetStartWhenNotLoaded(this.level);
              this.state = State.IDLE;
            }
          }
          break;
      }
      if (this.state === State.IDLE) {
        this.doTickIdle();
      }
      this.onTickEnd();
    }
    onTickEnd() {
      super.onTickEnd();
      this.checkBuffer();
      this.checkFragmentChanged();
    }
    doTickIdle() {
      const {
        hls,
        levelLastLoaded,
        levels,
        media
      } = this;
      const {
        config,
        nextLoadLevel: level
      } = hls;
      if (levelLastLoaded === null || !media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }
      if (this.altAudio && this.audioOnly) {
        return;
      }
      if (!(levels != null && levels[level])) {
        return;
      }
      const levelInfo = levels[level];
      const bufferInfo = this.getMainFwdBufferInfo();
      if (bufferInfo === null) {
        return;
      }
      const lastDetails = this.getLevelDetails();
      if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
        const data = {};
        if (this.altAudio) {
          data.type = "video";
        }
        this.hls.trigger(Events.BUFFER_EOS, data);
        this.state = State.ENDED;
        return;
      }
      if (hls.loadLevel !== level && hls.manualLevel === -1) {
        this.log(`Adapting to level ${level} from level ${this.level}`);
      }
      this.level = hls.nextLoadLevel = level;
      const levelDetails = levelInfo.details;
      if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== level) {
        this.level = level;
        this.state = State.WAITING_LEVEL;
        return;
      }
      const bufferLen = bufferInfo.len;
      const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
      if (bufferLen >= maxBufLen) {
        return;
      }
      if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
        this.backtrackFragment = null;
      }
      const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
      let frag = this.getNextFragment(targetBufferTime, levelDetails);
      if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== "initSegment" && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
        var _this$backtrackFragme;
        const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
        const fragIdx = backtrackSn - levelDetails.startSN;
        const backtrackFrag = levelDetails.fragments[fragIdx - 1];
        if (backtrackFrag && frag.cc === backtrackFrag.cc) {
          frag = backtrackFrag;
          this.fragmentTracker.removeFragment(backtrackFrag);
        }
      } else if (this.backtrackFragment && bufferInfo.len) {
        this.backtrackFragment = null;
      }
      if (frag && this.isLoopLoading(frag, targetBufferTime)) {
        const gapStart = frag.gap;
        if (!gapStart) {
          const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
          const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
          if (mediaBuffer) {
            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
          }
        }
        frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
      }
      if (!frag) {
        return;
      }
      if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
        frag = frag.initSegment;
      }
      this.loadFragment(frag, levelInfo, targetBufferTime);
    }
    loadFragment(frag, level, targetBufferTime) {
      const fragState = this.fragmentTracker.getState(frag);
      this.fragCurrent = frag;
      if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
        if (frag.sn === "initSegment") {
          this._loadInitSegment(frag, level);
        } else if (this.bitrateTest) {
          this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);
          this._loadBitrateTestFrag(frag, level);
        } else {
          this.startFragRequested = true;
          super.loadFragment(frag, level, targetBufferTime);
        }
      } else {
        this.clearTrackerIfNeeded(frag);
      }
    }
    getBufferedFrag(position) {
      return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
    }
    followingBufferedFrag(frag) {
      if (frag) {
        return this.getBufferedFrag(frag.end + 0.5);
      }
      return null;
    }
    immediateLevelSwitch() {
      this.abortCurrentFrag();
      this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
    }
    nextLevelSwitch() {
      const {
        levels,
        media
      } = this;
      if (media != null && media.readyState) {
        let fetchdelay;
        const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
        if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
          this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
        }
        const levelDetails = this.getLevelDetails();
        if (levelDetails != null && levelDetails.live) {
          const bufferInfo = this.getMainFwdBufferInfo();
          if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
            return;
          }
        }
        if (!media.paused && levels) {
          const nextLevelId = this.hls.nextLoadLevel;
          const nextLevel = levels[nextLevelId];
          const fragLastKbps = this.fragLastKbps;
          if (fragLastKbps && this.fragCurrent) {
            fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1e3 * fragLastKbps) + 1;
          } else {
            fetchdelay = 0;
          }
        } else {
          fetchdelay = 0;
        }
        const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
        if (bufferedFrag) {
          const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
          if (nextBufferedFrag) {
            this.abortCurrentFrag();
            const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
            const fragDuration = nextBufferedFrag.duration;
            const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * 0.5), fragDuration * 0.75));
            this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
          }
        }
      }
    }
    abortCurrentFrag() {
      const fragCurrent = this.fragCurrent;
      this.fragCurrent = null;
      this.backtrackFragment = null;
      if (fragCurrent) {
        fragCurrent.abortRequests();
        this.fragmentTracker.removeFragment(fragCurrent);
      }
      switch (this.state) {
        case State.KEY_LOADING:
        case State.FRAG_LOADING:
        case State.FRAG_LOADING_WAITING_RETRY:
        case State.PARSING:
        case State.PARSED:
          this.state = State.IDLE;
          break;
      }
      this.nextLoadPosition = this.getLoadPosition();
    }
    flushMainBuffer(startOffset, endOffset) {
      super.flushMainBuffer(startOffset, endOffset, this.altAudio ? "video" : null);
    }
    onMediaAttached(event, data) {
      super.onMediaAttached(event, data);
      const media = data.media;
      this.onvplaying = this.onMediaPlaying.bind(this);
      this.onvseeked = this.onMediaSeeked.bind(this);
      media.addEventListener("playing", this.onvplaying);
      media.addEventListener("seeked", this.onvseeked);
      this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);
    }
    onMediaDetaching() {
      const {
        media
      } = this;
      if (media && this.onvplaying && this.onvseeked) {
        media.removeEventListener("playing", this.onvplaying);
        media.removeEventListener("seeked", this.onvseeked);
        this.onvplaying = this.onvseeked = null;
        this.videoBuffer = null;
      }
      this.fragPlaying = null;
      if (this.gapController) {
        this.gapController.destroy();
        this.gapController = null;
      }
      super.onMediaDetaching();
    }
    onMediaPlaying() {
      this.tick();
    }
    onMediaSeeked() {
      const media = this.media;
      const currentTime = media ? media.currentTime : null;
      if (isFiniteNumber(currentTime)) {
        this.log(`Media seeked to ${currentTime.toFixed(3)}`);
      }
      const bufferInfo = this.getMainFwdBufferInfo();
      if (bufferInfo === null || bufferInfo.len === 0) {
        this.warn(`Main forward buffer length on "seeked" event ${bufferInfo ? bufferInfo.len : "empty"})`);
        return;
      }
      this.tick();
    }
    onManifestLoading() {
      this.log("Trigger BUFFER_RESET");
      this.hls.trigger(Events.BUFFER_RESET, void 0);
      this.fragmentTracker.removeAllFragments();
      this.couldBacktrack = false;
      this.startPosition = this.lastCurrentTime = 0;
      this.levels = this.fragPlaying = this.backtrackFragment = null;
      this.altAudio = this.audioOnly = false;
    }
    onManifestParsed(event, data) {
      let aac = false;
      let heaac = false;
      let codec;
      data.levels.forEach((level) => {
        codec = level.audioCodec;
        if (codec) {
          if (codec.indexOf("mp4a.40.2") !== -1) {
            aac = true;
          }
          if (codec.indexOf("mp4a.40.5") !== -1) {
            heaac = true;
          }
        }
      });
      this.audioCodecSwitch = aac && heaac && !changeTypeSupported();
      if (this.audioCodecSwitch) {
        this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
      }
      this.levels = data.levels;
      this.startFragRequested = false;
    }
    onLevelLoading(event, data) {
      const {
        levels
      } = this;
      if (!levels || this.state !== State.IDLE) {
        return;
      }
      const level = levels[data.level];
      if (!level.details || level.details.live && this.levelLastLoaded !== data.level || this.waitForCdnTuneIn(level.details)) {
        this.state = State.WAITING_LEVEL;
      }
    }
    onLevelLoaded(event, data) {
      var _curLevel$details;
      const {
        levels
      } = this;
      const newLevelId = data.level;
      const newDetails = data.details;
      const duration = newDetails.totalduration;
      if (!levels) {
        this.warn(`Levels were reset while loading level ${newLevelId}`);
        return;
      }
      this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);
      const curLevel = levels[newLevelId];
      const fragCurrent = this.fragCurrent;
      if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
        if ((fragCurrent.level !== data.level || fragCurrent.urlId !== curLevel.urlId) && fragCurrent.loader) {
          this.abortCurrentFrag();
        }
      }
      let sliding = 0;
      if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
        this.checkLiveUpdate(newDetails);
        if (newDetails.deltaUpdateFailed) {
          return;
        }
        sliding = this.alignPlaylists(newDetails, curLevel.details);
      }
      curLevel.details = newDetails;
      this.levelLastLoaded = newLevelId;
      this.hls.trigger(Events.LEVEL_UPDATED, {
        details: newDetails,
        level: newLevelId
      });
      if (this.state === State.WAITING_LEVEL) {
        if (this.waitForCdnTuneIn(newDetails)) {
          return;
        }
        this.state = State.IDLE;
      }
      if (!this.startFragRequested) {
        this.setStartPosition(newDetails, sliding);
      } else if (newDetails.live) {
        this.synchronizeToLiveEdge(newDetails);
      }
      this.tick();
    }
    _handleFragmentLoadProgress(data) {
      var _frag$initSegment;
      const {
        frag,
        part,
        payload
      } = data;
      const {
        levels
      } = this;
      if (!levels) {
        this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
        return;
      }
      const currentLevel = levels[frag.level];
      const details = currentLevel.details;
      if (!details) {
        this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      const videoCodec = currentLevel.videoCodec;
      const accurateTimeOffset = details.PTSKnown || !details.live;
      const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
      const audioCodec = this._getAudioCodec(currentLevel);
      const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
      const partIndex = part ? part.index : -1;
      const partial = partIndex !== -1;
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
      const initPTS = this.initPTS[frag.cc];
      transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
    }
    onAudioTrackSwitching(event, data) {
      const fromAltAudio = this.altAudio;
      const altAudio = !!data.url;
      if (!altAudio) {
        if (this.mediaBuffer !== this.media) {
          this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
          this.mediaBuffer = this.media;
          const fragCurrent = this.fragCurrent;
          if (fragCurrent) {
            this.log("Switching to main audio track, cancel main fragment load");
            fragCurrent.abortRequests();
            this.fragmentTracker.removeFragment(fragCurrent);
          }
          this.resetTransmuxer();
          this.resetLoadingState();
        } else if (this.audioOnly) {
          this.resetTransmuxer();
        }
        const hls = this.hls;
        if (fromAltAudio) {
          hls.trigger(Events.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: Number.POSITIVE_INFINITY,
            type: null
          });
          this.fragmentTracker.removeAllFragments();
        }
        hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
      }
    }
    onAudioTrackSwitched(event, data) {
      const trackId = data.id;
      const altAudio = !!this.hls.audioTracks[trackId].url;
      if (altAudio) {
        const videoBuffer = this.videoBuffer;
        if (videoBuffer && this.mediaBuffer !== videoBuffer) {
          this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
          this.mediaBuffer = videoBuffer;
        }
      }
      this.altAudio = altAudio;
      this.tick();
    }
    onBufferCreated(event, data) {
      const tracks = data.tracks;
      let mediaTrack;
      let name;
      let alternate = false;
      for (const type in tracks) {
        const track = tracks[type];
        if (track.id === "main") {
          name = type;
          mediaTrack = track;
          if (type === "video") {
            const videoTrack = tracks[type];
            if (videoTrack) {
              this.videoBuffer = videoTrack.buffer;
            }
          }
        } else {
          alternate = true;
        }
      }
      if (alternate && mediaTrack) {
        this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);
        this.mediaBuffer = mediaTrack.buffer;
      } else {
        this.mediaBuffer = this.media;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      if (frag && frag.type !== PlaylistLevelType.MAIN) {
        return;
      }
      if (this.fragContextChanged(frag)) {
        this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);
        if (this.state === State.PARSED) {
          this.state = State.IDLE;
        }
        return;
      }
      const stats = part ? part.stats : frag.stats;
      this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
      if (frag.sn !== "initSegment") {
        this.fragPrevious = frag;
      }
      this.fragBufferedComplete(frag, part);
    }
    onError(event, data) {
      var _data$context;
      if (data.fatal) {
        this.state = State.ERROR;
        return;
      }
      switch (data.details) {
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_PARSING_ERROR:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
          break;
        case ErrorDetails.LEVEL_LOAD_ERROR:
        case ErrorDetails.LEVEL_LOAD_TIMEOUT:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {
            this.state = State.IDLE;
          }
          break;
        case ErrorDetails.BUFFER_FULL_ERROR:
          if (!data.parent || data.parent !== "main") {
            return;
          }
          if (this.reduceLengthAndFlushBuffer(data)) {
            this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
          }
          break;
        case ErrorDetails.INTERNAL_EXCEPTION:
          this.recoverWorkerError(data);
          break;
      }
    }
    checkBuffer() {
      const {
        media,
        gapController
      } = this;
      if (!media || !gapController || !media.readyState) {
        return;
      }
      if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {
        const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;
        gapController.poll(this.lastCurrentTime, activeFrag);
      }
      this.lastCurrentTime = media.currentTime;
    }
    onFragLoadEmergencyAborted() {
      this.state = State.IDLE;
      if (!this.loadedmetadata) {
        this.startFragRequested = false;
        this.nextLoadPosition = this.startPosition;
      }
      this.tickImmediate();
    }
    onBufferFlushed(event, {
      type
    }) {
      if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
      }
    }
    onLevelsUpdated(event, data) {
      this.levels = data.levels;
    }
    swapAudioCodec() {
      this.audioCodecSwap = !this.audioCodecSwap;
    }
    seekToStartPos() {
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const currentTime = media.currentTime;
      let startPosition = this.startPosition;
      if (startPosition >= 0 && currentTime < startPosition) {
        if (media.seeking) {
          this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);
          return;
        }
        const buffered = BufferHelper.getBuffered(media);
        const bufferStart = buffered.length ? buffered.start(0) : 0;
        const delta = bufferStart - startPosition;
        if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
          this.log(`adjusting start position by ${delta} to match buffer start`);
          startPosition += delta;
          this.startPosition = startPosition;
        }
        this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);
        media.currentTime = startPosition;
      }
    }
    _getAudioCodec(currentLevel) {
      let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
      if (this.audioCodecSwap && audioCodec) {
        this.log("Swapping audio codec");
        if (audioCodec.indexOf("mp4a.40.5") !== -1) {
          audioCodec = "mp4a.40.2";
        } else {
          audioCodec = "mp4a.40.5";
        }
      }
      return audioCodec;
    }
    _loadBitrateTestFrag(frag, level) {
      frag.bitrateTest = true;
      this._doFragLoad(frag, level).then((data) => {
        const {
          hls
        } = this;
        if (!data || this.fragContextChanged(frag)) {
          return;
        }
        level.fragmentError = 0;
        this.state = State.IDLE;
        this.startFragRequested = false;
        this.bitrateTest = false;
        const stats = frag.stats;
        stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
        hls.trigger(Events.FRAG_LOADED, data);
        frag.bitrateTest = false;
      });
    }
    _handleTransmuxComplete(transmuxResult) {
      var _id3$samples;
      const id = "main";
      const {
        hls
      } = this;
      const {
        remuxResult,
        chunkMeta
      } = transmuxResult;
      const context = this.getCurrentContext(chunkMeta);
      if (!context) {
        this.resetWhenMissingContext(chunkMeta);
        return;
      }
      const {
        frag,
        part,
        level
      } = context;
      const {
        video,
        text,
        id3,
        initSegment
      } = remuxResult;
      const {
        details
      } = level;
      const audio = this.altAudio ? void 0 : remuxResult.audio;
      if (this.fragContextChanged(frag)) {
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      this.state = State.PARSING;
      if (initSegment) {
        if (initSegment != null && initSegment.tracks) {
          const mapFragment = frag.initSegment || frag;
          this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
          hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
            frag: mapFragment,
            id,
            tracks: initSegment.tracks
          });
        }
        const initPTS = initSegment.initPTS;
        const timescale = initSegment.timescale;
        if (isFiniteNumber(initPTS)) {
          this.initPTS[frag.cc] = {
            baseTime: initPTS,
            timescale
          };
          hls.trigger(Events.INIT_PTS_FOUND, {
            frag,
            id,
            initPTS,
            timescale
          });
        }
      }
      if (video && details && frag.sn !== "initSegment") {
        const prevFrag = details.fragments[frag.sn - 1 - details.startSN];
        const isFirstFragment = frag.sn === details.startSN;
        const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
        if (remuxResult.independent !== false) {
          const {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          } = video;
          if (part) {
            part.elementaryStreams[video.type] = {
              startPTS,
              endPTS,
              startDTS,
              endDTS
            };
          } else {
            if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
              this.couldBacktrack = true;
            }
            if (video.dropped && video.independent) {
              const bufferInfo = this.getMainFwdBufferInfo();
              const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
              const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
              if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
                this.backtrack(frag);
                return;
              } else if (isFirstInDiscontinuity) {
                frag.gap = true;
              }
              frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
            }
          }
          frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
          if (this.backtrackFragment) {
            this.backtrackFragment = frag;
          }
          this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
        } else if (isFirstFragment || isFirstInDiscontinuity) {
          frag.gap = true;
        } else {
          this.backtrack(frag);
          return;
        }
      }
      if (audio) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = audio;
        if (part) {
          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        }
        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
        this.bufferFragmentData(audio, frag, part, chunkMeta);
      }
      if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
        const emittedID3 = {
          id,
          frag,
          details,
          samples: id3.samples
        };
        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
      }
      if (details && text) {
        const emittedText = {
          id,
          frag,
          details,
          samples: text.samples
        };
        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
      }
    }
    _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
      if (this.state !== State.PARSING) {
        return;
      }
      this.audioOnly = !!tracks.audio && !tracks.video;
      if (this.altAudio && !this.audioOnly) {
        delete tracks.audio;
      }
      const {
        audio,
        video,
        audiovideo
      } = tracks;
      if (audio) {
        let audioCodec = currentLevel.audioCodec;
        const ua = navigator.userAgent.toLowerCase();
        if (this.audioCodecSwitch) {
          if (audioCodec) {
            if (audioCodec.indexOf("mp4a.40.5") !== -1) {
              audioCodec = "mp4a.40.2";
            } else {
              audioCodec = "mp4a.40.5";
            }
          }
          if (audio.metadata.channelCount !== 1 && ua.indexOf("firefox") === -1) {
            audioCodec = "mp4a.40.5";
          }
        }
        if (ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
          audioCodec = "mp4a.40.2";
          this.log(`Android: force audio codec to ${audioCodec}`);
        }
        if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
          this.log(`Swapping manifest audio codec "${currentLevel.audioCodec}" for "${audioCodec}"`);
        }
        audio.levelCodec = audioCodec;
        audio.id = "main";
        this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ""}/${currentLevel.audioCodec || ""}/${audio.codec}]`);
      }
      if (video) {
        video.levelCodec = currentLevel.videoCodec;
        video.id = "main";
        this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ""}/${video.codec}]`);
      }
      if (audiovideo) {
        this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.attrs.CODECS || ""}/${audiovideo.codec}]`);
      }
      this.hls.trigger(Events.BUFFER_CODECS, tracks);
      Object.keys(tracks).forEach((trackName) => {
        const track = tracks[trackName];
        const initSegment = track.initSegment;
        if (initSegment != null && initSegment.byteLength) {
          this.hls.trigger(Events.BUFFER_APPENDING, {
            type: trackName,
            data: initSegment,
            frag,
            part: null,
            chunkMeta,
            parent: frag.type
          });
        }
      });
      this.tick();
    }
    getMainFwdBufferInfo() {
      return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);
    }
    backtrack(frag) {
      this.couldBacktrack = true;
      this.backtrackFragment = frag;
      this.resetTransmuxer();
      this.flushBufferGap(frag);
      this.fragmentTracker.removeFragment(frag);
      this.fragPrevious = null;
      this.nextLoadPosition = frag.start;
      this.state = State.IDLE;
    }
    checkFragmentChanged() {
      const video = this.media;
      let fragPlayingCurrent = null;
      if (video && video.readyState > 1 && video.seeking === false) {
        const currentTime = video.currentTime;
        if (BufferHelper.isBuffered(video, currentTime)) {
          fragPlayingCurrent = this.getAppendedFrag(currentTime);
        } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
          fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
        }
        if (fragPlayingCurrent) {
          this.backtrackFragment = null;
          const fragPlaying = this.fragPlaying;
          const fragCurrentLevel = fragPlayingCurrent.level;
          if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel || fragPlayingCurrent.urlId !== fragPlaying.urlId) {
            this.fragPlaying = fragPlayingCurrent;
            this.hls.trigger(Events.FRAG_CHANGED, {
              frag: fragPlayingCurrent
            });
            if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
              this.hls.trigger(Events.LEVEL_SWITCHED, {
                level: fragCurrentLevel
              });
            }
          }
        }
      }
    }
    get nextLevel() {
      const frag = this.nextBufferedFrag;
      if (frag) {
        return frag.level;
      }
      return -1;
    }
    get currentFrag() {
      const media = this.media;
      if (media) {
        return this.fragPlaying || this.getAppendedFrag(media.currentTime);
      }
      return null;
    }
    get currentProgramDateTime() {
      const media = this.media;
      if (media) {
        const currentTime = media.currentTime;
        const frag = this.currentFrag;
        if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {
          const epocMs = frag.programDateTime + (currentTime - frag.start) * 1e3;
          return new Date(epocMs);
        }
      }
      return null;
    }
    get currentLevel() {
      const frag = this.currentFrag;
      if (frag) {
        return frag.level;
      }
      return -1;
    }
    get nextBufferedFrag() {
      const frag = this.currentFrag;
      if (frag) {
        return this.followingBufferedFrag(frag);
      }
      return null;
    }
    get forceStartLoad() {
      return this._forceStartLoad;
    }
  };
  var EWMA = class {
    constructor(halfLife, estimate = 0, weight = 0) {
      this.halfLife = void 0;
      this.alpha_ = void 0;
      this.estimate_ = void 0;
      this.totalWeight_ = void 0;
      this.halfLife = halfLife;
      this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
      this.estimate_ = estimate;
      this.totalWeight_ = weight;
    }
    sample(weight, value) {
      const adjAlpha = Math.pow(this.alpha_, weight);
      this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
      this.totalWeight_ += weight;
    }
    getTotalWeight() {
      return this.totalWeight_;
    }
    getEstimate() {
      if (this.alpha_) {
        const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
        if (zeroFactor) {
          return this.estimate_ / zeroFactor;
        }
      }
      return this.estimate_;
    }
  };
  var EwmaBandWidthEstimator = class {
    constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {
      this.defaultEstimate_ = void 0;
      this.minWeight_ = void 0;
      this.minDelayMs_ = void 0;
      this.slow_ = void 0;
      this.fast_ = void 0;
      this.defaultTTFB_ = void 0;
      this.ttfb_ = void 0;
      this.defaultEstimate_ = defaultEstimate;
      this.minWeight_ = 1e-3;
      this.minDelayMs_ = 50;
      this.slow_ = new EWMA(slow);
      this.fast_ = new EWMA(fast);
      this.defaultTTFB_ = defaultTTFB;
      this.ttfb_ = new EWMA(slow);
    }
    update(slow, fast) {
      const {
        slow_,
        fast_,
        ttfb_
      } = this;
      if (slow_.halfLife !== slow) {
        this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
      }
      if (fast_.halfLife !== fast) {
        this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
      }
      if (ttfb_.halfLife !== slow) {
        this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
      }
    }
    sample(durationMs, numBytes) {
      durationMs = Math.max(durationMs, this.minDelayMs_);
      const numBits = 8 * numBytes;
      const durationS = durationMs / 1e3;
      const bandwidthInBps = numBits / durationS;
      this.fast_.sample(durationS, bandwidthInBps);
      this.slow_.sample(durationS, bandwidthInBps);
    }
    sampleTTFB(ttfb) {
      const seconds = ttfb / 1e3;
      const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
      this.ttfb_.sample(weight, Math.max(ttfb, 5));
    }
    canEstimate() {
      return this.fast_.getTotalWeight() >= this.minWeight_;
    }
    getEstimate() {
      if (this.canEstimate()) {
        return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
      } else {
        return this.defaultEstimate_;
      }
    }
    getEstimateTTFB() {
      if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
        return this.ttfb_.getEstimate();
      } else {
        return this.defaultTTFB_;
      }
    }
    destroy() {
    }
  };
  var AbrController = class {
    constructor(hls) {
      this.hls = void 0;
      this.lastLevelLoadSec = 0;
      this.lastLoadedFragLevel = 0;
      this._nextAutoLevel = -1;
      this.timer = -1;
      this.onCheck = this._abandonRulesCheck.bind(this);
      this.fragCurrent = null;
      this.partCurrent = null;
      this.bitrateTestDelay = 0;
      this.bwEstimator = void 0;
      this.hls = hls;
      const config = hls.config;
      this.bwEstimator = new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
      this.registerListeners();
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    }
    destroy() {
      this.unregisterListeners();
      this.clearTimer();
      this.hls = this.onCheck = null;
      this.fragCurrent = this.partCurrent = null;
    }
    onFragLoading(event, data) {
      var _data$part;
      const frag = data.frag;
      if (this.ignoreFragment(frag)) {
        return;
      }
      this.fragCurrent = frag;
      this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
      this.clearTimer();
      this.timer = self.setInterval(this.onCheck, 100);
    }
    onLevelSwitching(event, data) {
      this.clearTimer();
    }
    getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
      const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
      const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;
      return fragLoadSec + playlistLoadSec;
    }
    onLevelLoaded(event, data) {
      const config = this.hls.config;
      const {
        total,
        bwEstimate
      } = data.stats;
      if (isFiniteNumber(total) && isFiniteNumber(bwEstimate)) {
        this.lastLevelLoadSec = 8 * total / bwEstimate;
      }
      if (data.details.live) {
        this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
      } else {
        this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
      }
    }
    _abandonRulesCheck() {
      const {
        fragCurrent: frag,
        partCurrent: part,
        hls
      } = this;
      const {
        autoLevelEnabled,
        media
      } = hls;
      if (!frag || !media) {
        return;
      }
      const now2 = performance.now();
      const stats = part ? part.stats : frag.stats;
      const duration = part ? part.duration : frag.duration;
      const timeLoading = now2 - stats.loading.start;
      if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level === 0) {
        this.clearTimer();
        this._nextAutoLevel = -1;
        return;
      }
      if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
        return;
      }
      const bufferInfo = hls.mainForwardBufferInfo;
      if (bufferInfo === null) {
        return;
      }
      const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
      const playbackRate = Math.abs(media.playbackRate);
      if (timeLoading <= Math.max(ttfbEstimate, 1e3 * (duration / (playbackRate * 2)))) {
        return;
      }
      const bufferStarvationDelay = bufferInfo.len / playbackRate;
      if (bufferStarvationDelay >= 2 * duration / playbackRate) {
        return;
      }
      const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
      const loadedFirstByte = stats.loaded && ttfb > -1;
      const bwEstimate = this.bwEstimator.getEstimate();
      const {
        levels,
        minAutoLevel
      } = hls;
      const level = levels[frag.level];
      const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.maxBitrate / 8));
      let timeStreaming = timeLoading - ttfb;
      if (timeStreaming < 1 && loadedFirstByte) {
        timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
      }
      const loadRate = loadedFirstByte ? stats.loaded * 1e3 / timeStreaming : 0;
      const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1e3;
      if (fragLoadedDelay <= bufferStarvationDelay) {
        return;
      }
      const bwe = loadRate ? loadRate * 8 : bwEstimate;
      let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
      let nextLoadLevel;
      for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {
        const levelNextBitrate = levels[nextLoadLevel].maxBitrate;
        fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1e3, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);
        if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
          break;
        }
      }
      if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
        return;
      }
      if (fragLevelNextLoadedDelay > duration * 10) {
        return;
      }
      hls.nextLoadLevel = nextLoadLevel;
      if (loadedFirstByte) {
        this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
      } else {
        this.bwEstimator.sampleTTFB(timeLoading);
      }
      this.clearTimer();
      logger.warn(`[abr] Fragment ${frag.sn}${part ? " part " + part.index : ""} of level ${frag.level} is loading too slowly;
      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s
      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s
      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s
      TTFB estimate: ${ttfb}
      Current BW estimate: ${isFiniteNumber(bwEstimate) ? (bwEstimate / 1024).toFixed(3) : "Unknown"} Kb/s
      New BW estimate: ${(this.bwEstimator.getEstimate() / 1024).toFixed(3)} Kb/s
      Aborting and switching to level ${nextLoadLevel}`);
      if (frag.loader) {
        this.fragCurrent = this.partCurrent = null;
        frag.abortRequests();
      }
      hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
        frag,
        part,
        stats
      });
    }
    onFragLoaded(event, {
      frag,
      part
    }) {
      const stats = part ? part.stats : frag.stats;
      if (frag.type === PlaylistLevelType.MAIN) {
        this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      this.clearTimer();
      this.lastLoadedFragLevel = frag.level;
      this._nextAutoLevel = -1;
      if (this.hls.config.abrMaxWithRealBitrate) {
        const duration = part ? part.duration : frag.duration;
        const level = this.hls.levels[frag.level];
        const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
        const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
        level.loaded = {
          bytes: loadedBytes,
          duration: loadedDuration
        };
        level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
      }
      if (frag.bitrateTest) {
        const fragBufferedData = {
          stats,
          frag,
          part,
          id: frag.type
        };
        this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
        frag.bitrateTest = false;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      const stats = part != null && part.stats.loaded ? part.stats : frag.stats;
      if (stats.aborted) {
        return;
      }
      if (this.ignoreFragment(frag)) {
        return;
      }
      const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
      this.bwEstimator.sample(processingMs, stats.loaded);
      stats.bwEstimate = this.bwEstimator.getEstimate();
      if (frag.bitrateTest) {
        this.bitrateTestDelay = processingMs / 1e3;
      } else {
        this.bitrateTestDelay = 0;
      }
    }
    ignoreFragment(frag) {
      return frag.type !== PlaylistLevelType.MAIN || frag.sn === "initSegment";
    }
    clearTimer() {
      self.clearInterval(this.timer);
    }
    get nextAutoLevel() {
      const forcedAutoLevel = this._nextAutoLevel;
      const bwEstimator = this.bwEstimator;
      if (forcedAutoLevel !== -1 && !bwEstimator.canEstimate()) {
        return forcedAutoLevel;
      }
      let nextABRAutoLevel = this.getNextABRAutoLevel();
      if (forcedAutoLevel !== -1) {
        const levels = this.hls.levels;
        if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
          return forcedAutoLevel;
        }
      }
      if (forcedAutoLevel !== -1) {
        nextABRAutoLevel = Math.min(forcedAutoLevel, nextABRAutoLevel);
      }
      return nextABRAutoLevel;
    }
    getNextABRAutoLevel() {
      const {
        fragCurrent,
        partCurrent,
        hls
      } = this;
      const {
        maxAutoLevel,
        config,
        minAutoLevel,
        media
      } = hls;
      const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
      const avgbw = this.bwEstimator ? this.bwEstimator.getEstimate() : config.abrEwmaDefaultEstimate;
      const bufferInfo = hls.mainForwardBufferInfo;
      const bufferStarvationDelay = (bufferInfo ? bufferInfo.len : 0) / playbackRate;
      let bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, config.abrBandWidthFactor, config.abrBandWidthUpFactor);
      if (bestLevel >= 0) {
        return bestLevel;
      }
      logger.trace(`[abr] ${bufferStarvationDelay ? "rebuffering expected" : "buffer is empty"}, finding optimal quality level`);
      let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
      let bwFactor = config.abrBandWidthFactor;
      let bwUpFactor = config.abrBandWidthUpFactor;
      if (!bufferStarvationDelay) {
        const bitrateTestDelay = this.bitrateTestDelay;
        if (bitrateTestDelay) {
          const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
          maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
          logger.trace(`[abr] bitrate test took ${Math.round(1e3 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * maxStarvationDelay)} ms`);
          bwFactor = bwUpFactor = 1;
        }
      }
      bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay + maxStarvationDelay, bwFactor, bwUpFactor);
      return Math.max(bestLevel, 0);
    }
    findBestLevel(currentBw, minAutoLevel, maxAutoLevel, maxFetchDuration, bwFactor, bwUpFactor) {
      var _level$details;
      const {
        fragCurrent,
        partCurrent,
        lastLoadedFragLevel: currentLevel
      } = this;
      const {
        levels
      } = this.hls;
      const level = levels[currentLevel];
      const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);
      const currentCodecSet = level == null ? void 0 : level.codecSet;
      const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
      const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1e3;
      let levelSkippedMin = minAutoLevel;
      let levelSkippedMax = -1;
      for (let i2 = maxAutoLevel; i2 >= minAutoLevel; i2--) {
        const levelInfo = levels[i2];
        if (!levelInfo || currentCodecSet && levelInfo.codecSet !== currentCodecSet) {
          if (levelInfo) {
            levelSkippedMin = Math.min(i2, levelSkippedMin);
            levelSkippedMax = Math.max(i2, levelSkippedMax);
          }
          continue;
        }
        if (levelSkippedMax !== -1) {
          logger.trace(`[abr] Skipped level(s) ${levelSkippedMin}-${levelSkippedMax} with CODECS:"${levels[levelSkippedMax].attrs.CODECS}"; not compatible with "${level.attrs.CODECS}"`);
        }
        const levelDetails = levelInfo.details;
        const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;
        let adjustedbw;
        if (i2 <= currentLevel) {
          adjustedbw = bwFactor * currentBw;
        } else {
          adjustedbw = bwUpFactor * currentBw;
        }
        const bitrate = levels[i2].maxBitrate;
        const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === void 0);
        logger.trace(`[abr] level:${i2} adjustedbw-bitrate:${Math.round(adjustedbw - bitrate)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)}`);
        if (adjustedbw > bitrate && (fetchDuration === 0 || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration)) {
          return i2;
        }
      }
      return -1;
    }
    set nextAutoLevel(nextLevel) {
      this._nextAutoLevel = nextLevel;
    }
  };
  var ChunkCache = class {
    constructor() {
      this.chunks = [];
      this.dataLength = 0;
    }
    push(chunk) {
      this.chunks.push(chunk);
      this.dataLength += chunk.length;
    }
    flush() {
      const {
        chunks,
        dataLength
      } = this;
      let result;
      if (!chunks.length) {
        return new Uint8Array(0);
      } else if (chunks.length === 1) {
        result = chunks[0];
      } else {
        result = concatUint8Arrays(chunks, dataLength);
      }
      this.reset();
      return result;
    }
    reset() {
      this.chunks.length = 0;
      this.dataLength = 0;
    }
  };
  function concatUint8Arrays(chunks, dataLength) {
    const result = new Uint8Array(dataLength);
    let offset2 = 0;
    for (let i2 = 0; i2 < chunks.length; i2++) {
      const chunk = chunks[i2];
      result.set(chunk, offset2);
      offset2 += chunk.length;
    }
    return result;
  }
  var TICK_INTERVAL$1 = 100;
  var AudioStreamController = class extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, "[audio-stream-controller]", PlaylistLevelType.AUDIO);
      this.videoBuffer = null;
      this.videoTrackCC = -1;
      this.waitingVideoCC = -1;
      this.bufferedTrack = null;
      this.switchingTrack = null;
      this.trackId = -1;
      this.waitingData = null;
      this.mainDetails = null;
      this.bufferFlushed = false;
      this.cachedTrackLoadedData = null;
      this._registerListeners();
    }
    onHandlerDestroying() {
      this._unregisterListeners();
      this.mainDetails = null;
      this.bufferedTrack = null;
      this.switchingTrack = null;
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
      hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
      hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
      hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    onInitPtsFound(event, {
      frag,
      id,
      initPTS,
      timescale
    }) {
      if (id === "main") {
        const cc = frag.cc;
        this.initPTS[frag.cc] = {
          baseTime: initPTS,
          timescale
        };
        this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);
        this.videoTrackCC = cc;
        if (this.state === State.WAITING_INIT_PTS) {
          this.tick();
        }
      }
    }
    startLoad(startPosition) {
      if (!this.levels) {
        this.startPosition = startPosition;
        this.state = State.STOPPED;
        return;
      }
      const lastCurrentTime = this.lastCurrentTime;
      this.stopLoad();
      this.setInterval(TICK_INTERVAL$1);
      if (lastCurrentTime > 0 && startPosition === -1) {
        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
        startPosition = lastCurrentTime;
        this.state = State.IDLE;
      } else {
        this.loadedmetadata = false;
        this.state = State.WAITING_TRACK;
      }
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    }
    doTick() {
      switch (this.state) {
        case State.IDLE:
          this.doTickIdle();
          break;
        case State.WAITING_TRACK: {
          var _levels$trackId;
          const {
            levels,
            trackId
          } = this;
          const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;
          if (details) {
            if (this.waitForCdnTuneIn(details)) {
              break;
            }
            this.state = State.WAITING_INIT_PTS;
          }
          break;
        }
        case State.FRAG_LOADING_WAITING_RETRY: {
          var _this$media;
          const now2 = performance.now();
          const retryDate = this.retryDate;
          if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
            this.log("RetryDate reached, switch back to IDLE state");
            this.resetStartWhenNotLoaded(this.trackId);
            this.state = State.IDLE;
          }
          break;
        }
        case State.WAITING_INIT_PTS: {
          const waitingData = this.waitingData;
          if (waitingData) {
            const {
              frag,
              part,
              cache,
              complete
            } = waitingData;
            if (this.initPTS[frag.cc] !== void 0) {
              this.waitingData = null;
              this.waitingVideoCC = -1;
              this.state = State.FRAG_LOADING;
              const payload = cache.flush();
              const data = {
                frag,
                part,
                payload,
                networkDetails: null
              };
              this._handleFragmentLoadProgress(data);
              if (complete) {
                super._handleFragmentLoadComplete(data);
              }
            } else if (this.videoTrackCC !== this.waitingVideoCC) {
              this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);
              this.clearWaitingFragment();
            } else {
              const pos = this.getLoadPosition();
              const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
              const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
              if (waitingFragmentAtPosition < 0) {
                this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);
                this.clearWaitingFragment();
              }
            }
          } else {
            this.state = State.IDLE;
          }
        }
      }
      this.onTickEnd();
    }
    clearWaitingFragment() {
      const waitingData = this.waitingData;
      if (waitingData) {
        this.fragmentTracker.removeFragment(waitingData.frag);
        this.waitingData = null;
        this.waitingVideoCC = -1;
        this.state = State.IDLE;
      }
    }
    resetLoadingState() {
      this.clearWaitingFragment();
      super.resetLoadingState();
    }
    onTickEnd() {
      const {
        media
      } = this;
      if (!(media != null && media.readyState)) {
        return;
      }
      this.lastCurrentTime = media.currentTime;
    }
    doTickIdle() {
      const {
        hls,
        levels,
        media,
        trackId
      } = this;
      const config = hls.config;
      if (!(levels != null && levels[trackId])) {
        return;
      }
      if (!media && (this.startFragRequested || !config.startFragPrefetch)) {
        return;
      }
      const levelInfo = levels[trackId];
      const trackDetails = levelInfo.details;
      if (!trackDetails || trackDetails.live && this.levelLastLoaded !== trackId || this.waitForCdnTuneIn(trackDetails)) {
        this.state = State.WAITING_TRACK;
        return;
      }
      const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
      if (this.bufferFlushed && bufferable) {
        this.bufferFlushed = false;
        this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);
      }
      const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);
      if (bufferInfo === null) {
        return;
      }
      const {
        bufferedTrack,
        switchingTrack
      } = this;
      if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {
        hls.trigger(Events.BUFFER_EOS, {
          type: "audio"
        });
        this.state = State.ENDED;
        return;
      }
      const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);
      const bufferLen = bufferInfo.len;
      const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);
      if (bufferLen >= maxBufLen && !switchingTrack) {
        return;
      }
      const fragments = trackDetails.fragments;
      const start = fragments[0].start;
      let targetBufferTime = bufferInfo.end;
      if (switchingTrack && media) {
        const pos = this.getLoadPosition();
        if (bufferedTrack && switchingTrack.attrs !== bufferedTrack.attrs) {
          targetBufferTime = pos;
        }
        if (trackDetails.PTSKnown && pos < start) {
          if (bufferInfo.end > start || bufferInfo.nextStart) {
            this.log("Alt audio track ahead of main track, seek to start of alt audio track");
            media.currentTime = start + 0.05;
          }
        }
      }
      let frag = this.getNextFragment(targetBufferTime, trackDetails);
      let atGap = false;
      if (frag && this.isLoopLoading(frag, targetBufferTime)) {
        atGap = !!frag.gap;
        frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
      }
      if (!frag) {
        this.bufferFlushed = true;
        return;
      }
      const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;
      if (atBufferSyncLimit || !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {
        const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);
        if (mainFrag === null) {
          return;
        }
        atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);
        if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {
          return;
        }
      }
      this.loadFragment(frag, levelInfo, targetBufferTime);
    }
    getMaxBufferLength(mainBufferLength) {
      const maxConfigBuffer = super.getMaxBufferLength();
      if (!mainBufferLength) {
        return maxConfigBuffer;
      }
      return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);
    }
    onMediaDetaching() {
      this.videoBuffer = null;
      super.onMediaDetaching();
    }
    onAudioTracksUpdated(event, {
      audioTracks
    }) {
      this.resetTransmuxer();
      this.levels = audioTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
    }
    onAudioTrackSwitching(event, data) {
      const altAudio = !!data.url;
      this.trackId = data.id;
      const {
        fragCurrent
      } = this;
      if (fragCurrent) {
        fragCurrent.abortRequests();
        this.removeUnbufferedFrags(fragCurrent.start);
      }
      this.resetLoadingState();
      if (!altAudio) {
        this.resetTransmuxer();
      } else {
        this.setInterval(TICK_INTERVAL$1);
      }
      if (altAudio) {
        this.switchingTrack = data;
        this.state = State.IDLE;
      } else {
        this.switchingTrack = null;
        this.bufferedTrack = data;
        this.state = State.STOPPED;
      }
      this.tick();
    }
    onManifestLoading() {
      this.fragmentTracker.removeAllFragments();
      this.startPosition = this.lastCurrentTime = 0;
      this.bufferFlushed = false;
      this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;
      this.startFragRequested = false;
      this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;
    }
    onLevelLoaded(event, data) {
      this.mainDetails = data.details;
      if (this.cachedTrackLoadedData !== null) {
        this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
        this.cachedTrackLoadedData = null;
      }
    }
    onAudioTrackLoaded(event, data) {
      var _track$details;
      if (this.mainDetails == null) {
        this.cachedTrackLoadedData = data;
        return;
      }
      const {
        levels
      } = this;
      const {
        details: newDetails,
        id: trackId
      } = data;
      if (!levels) {
        this.warn(`Audio tracks were reset while loading level ${trackId}`);
        return;
      }
      this.log(`Track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""},duration:${newDetails.totalduration}`);
      const track = levels[trackId];
      let sliding = 0;
      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
        this.checkLiveUpdate(newDetails);
        const mainDetails = this.mainDetails;
        if (newDetails.deltaUpdateFailed || !mainDetails) {
          return;
        }
        if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
          alignMediaPlaylistByPDT(newDetails, mainDetails);
          sliding = newDetails.fragments[0].start;
        } else {
          sliding = this.alignPlaylists(newDetails, track.details);
        }
      }
      track.details = newDetails;
      this.levelLastLoaded = trackId;
      if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
        this.setStartPosition(track.details, sliding);
      }
      if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
        this.state = State.IDLE;
      }
      this.tick();
    }
    _handleFragmentLoadProgress(data) {
      var _frag$initSegment;
      const {
        frag,
        part,
        payload
      } = data;
      const {
        config,
        trackId,
        levels
      } = this;
      if (!levels) {
        this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
        return;
      }
      const track = levels[trackId];
      if (!track) {
        this.warn("Audio track is undefined on fragment load progress");
        return;
      }
      const details = track.details;
      if (!details) {
        this.warn("Audio track details undefined on fragment load progress");
        this.removeUnbufferedFrags(frag.start);
        return;
      }
      const audioCodec = config.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
      let transmuxer = this.transmuxer;
      if (!transmuxer) {
        transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
      }
      const initPTS = this.initPTS[frag.cc];
      const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;
      if (initPTS !== void 0) {
        const accurateTimeOffset = false;
        const partIndex = part ? part.index : -1;
        const partial = partIndex !== -1;
        const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
        transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
      } else {
        this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);
        const {
          cache
        } = this.waitingData = this.waitingData || {
          frag,
          part,
          cache: new ChunkCache(),
          complete: false
        };
        cache.push(new Uint8Array(payload));
        this.waitingVideoCC = this.videoTrackCC;
        this.state = State.WAITING_INIT_PTS;
      }
    }
    _handleFragmentLoadComplete(fragLoadedData) {
      if (this.waitingData) {
        this.waitingData.complete = true;
        return;
      }
      super._handleFragmentLoadComplete(fragLoadedData);
    }
    onBufferReset() {
      this.mediaBuffer = this.videoBuffer = null;
      this.loadedmetadata = false;
    }
    onBufferCreated(event, data) {
      const audioTrack = data.tracks.audio;
      if (audioTrack) {
        this.mediaBuffer = audioTrack.buffer || null;
      }
      if (data.tracks.video) {
        this.videoBuffer = data.tracks.video.buffer || null;
      }
    }
    onFragBuffered(event, data) {
      const {
        frag,
        part
      } = data;
      if (frag.type !== PlaylistLevelType.AUDIO) {
        if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {
          const bufferable = this.videoBuffer || this.media;
          if (bufferable) {
            const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);
            if (bufferedTimeRanges.length) {
              this.loadedmetadata = true;
            }
          }
        }
        return;
      }
      if (this.fragContextChanged(frag)) {
        this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
        return;
      }
      if (frag.sn !== "initSegment") {
        this.fragPrevious = frag;
        const track = this.switchingTrack;
        if (track) {
          this.bufferedTrack = track;
          this.switchingTrack = null;
          this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread22({}, track));
        }
      }
      this.fragBufferedComplete(frag, part);
    }
    onError(event, data) {
      var _data$context;
      if (data.fatal) {
        this.state = State.ERROR;
        return;
      }
      switch (data.details) {
        case ErrorDetails.FRAG_GAP:
        case ErrorDetails.FRAG_PARSING_ERROR:
        case ErrorDetails.FRAG_DECRYPT_ERROR:
        case ErrorDetails.FRAG_LOAD_ERROR:
        case ErrorDetails.FRAG_LOAD_TIMEOUT:
        case ErrorDetails.KEY_LOAD_ERROR:
        case ErrorDetails.KEY_LOAD_TIMEOUT:
          this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);
          break;
        case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
        case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
        case ErrorDetails.LEVEL_PARSING_ERROR:
          if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {
            this.state = State.IDLE;
          }
          break;
        case ErrorDetails.BUFFER_FULL_ERROR:
          if (!data.parent || data.parent !== "audio") {
            return;
          }
          if (this.reduceLengthAndFlushBuffer(data)) {
            this.bufferedTrack = null;
            super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
          }
          break;
        case ErrorDetails.INTERNAL_EXCEPTION:
          this.recoverWorkerError(data);
          break;
      }
    }
    onBufferFlushed(event, {
      type
    }) {
      if (type === ElementaryStreamTypes.AUDIO) {
        this.bufferFlushed = true;
        if (this.state === State.ENDED) {
          this.state = State.IDLE;
        }
      }
    }
    _handleTransmuxComplete(transmuxResult) {
      var _id3$samples;
      const id = "audio";
      const {
        hls
      } = this;
      const {
        remuxResult,
        chunkMeta
      } = transmuxResult;
      const context = this.getCurrentContext(chunkMeta);
      if (!context) {
        this.resetWhenMissingContext(chunkMeta);
        return;
      }
      const {
        frag,
        part,
        level
      } = context;
      const {
        details
      } = level;
      const {
        audio,
        text,
        id3,
        initSegment
      } = remuxResult;
      if (this.fragContextChanged(frag) || !details) {
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      this.state = State.PARSING;
      if (this.switchingTrack && audio) {
        this.completeAudioSwitch(this.switchingTrack);
      }
      if (initSegment != null && initSegment.tracks) {
        const mapFragment = frag.initSegment || frag;
        this._bufferInitSegment(initSegment.tracks, mapFragment, chunkMeta);
        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
          frag: mapFragment,
          id,
          tracks: initSegment.tracks
        });
      }
      if (audio) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = audio;
        if (part) {
          part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        }
        frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
        this.bufferFragmentData(audio, frag, part, chunkMeta);
      }
      if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
        const emittedID3 = _extends2({
          id,
          frag,
          details
        }, id3);
        hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
      }
      if (text) {
        const emittedText = _extends2({
          id,
          frag,
          details
        }, text);
        hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
      }
    }
    _bufferInitSegment(tracks, frag, chunkMeta) {
      if (this.state !== State.PARSING) {
        return;
      }
      if (tracks.video) {
        delete tracks.video;
      }
      const track = tracks.audio;
      if (!track) {
        return;
      }
      track.levelCodec = track.codec;
      track.id = "audio";
      this.log(`Init audio buffer, container:${track.container}, codecs[parsed]=[${track.codec}]`);
      this.hls.trigger(Events.BUFFER_CODECS, tracks);
      const initSegment = track.initSegment;
      if (initSegment != null && initSegment.byteLength) {
        const segment = {
          type: "audio",
          frag,
          part: null,
          chunkMeta,
          parent: frag.type,
          data: initSegment
        };
        this.hls.trigger(Events.BUFFER_APPENDING, segment);
      }
      this.tick();
    }
    loadFragment(frag, track, targetBufferTime) {
      const fragState = this.fragmentTracker.getState(frag);
      this.fragCurrent = frag;
      if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
        var _track$details2;
        if (frag.sn === "initSegment") {
          this._loadInitSegment(frag, track);
        } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {
          this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);
          this.state = State.WAITING_INIT_PTS;
        } else {
          this.startFragRequested = true;
          super.loadFragment(frag, track, targetBufferTime);
        }
      } else {
        this.clearTrackerIfNeeded(frag);
      }
    }
    completeAudioSwitch(switchingTrack) {
      const {
        hls,
        media,
        bufferedTrack
      } = this;
      const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;
      const switchAttributes = switchingTrack.attrs;
      if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedAttributes.NAME !== switchAttributes.NAME || bufferedAttributes.LANGUAGE !== switchAttributes.LANGUAGE)) {
        this.log("Switching audio track : flushing all audio");
        super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
      }
      this.bufferedTrack = switchingTrack;
      this.switchingTrack = null;
      hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread22({}, switchingTrack));
    }
  };
  var AudioTrackController = class extends BasePlaylistController {
    constructor(hls) {
      super(hls, "[audio-track-controller]");
      this.tracks = [];
      this.groupId = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
      this.registerListeners();
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    destroy() {
      this.unregisterListeners();
      this.tracks.length = 0;
      this.tracksInGroup.length = 0;
      this.currentTrack = null;
      super.destroy();
    }
    onManifestLoading() {
      this.tracks = [];
      this.groupId = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.currentTrack = null;
      this.selectDefaultTrack = true;
    }
    onManifestParsed(event, data) {
      this.tracks = data.audioTracks || [];
    }
    onAudioTrackLoaded(event, data) {
      const {
        id,
        groupId,
        details
      } = data;
      const trackInActiveGroup = this.tracksInGroup[id];
      if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
        this.warn(`Track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup.groupId}`);
        return;
      }
      const curDetails = trackInActiveGroup.details;
      trackInActiveGroup.details = data.details;
      this.log(`audio-track ${id} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
      if (id === this.trackId) {
        this.playlistLoaded(id, data, curDetails);
      }
    }
    onLevelLoading(event, data) {
      this.switchLevel(data.level);
    }
    onLevelSwitching(event, data) {
      this.switchLevel(data.level);
    }
    switchLevel(levelIndex) {
      const levelInfo = this.hls.levels[levelIndex];
      if (!(levelInfo != null && levelInfo.audioGroupIds)) {
        return;
      }
      const audioGroupId = levelInfo.audioGroupIds[levelInfo.urlId];
      if (this.groupId !== audioGroupId) {
        this.groupId = audioGroupId || null;
        const audioTracks = this.tracks.filter((track) => !audioGroupId || track.groupId === audioGroupId);
        if (this.selectDefaultTrack && !audioTracks.some((track) => track.default)) {
          this.selectDefaultTrack = false;
        }
        this.tracksInGroup = audioTracks;
        const audioTracksUpdated = {
          audioTracks
        };
        this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group:${audioGroupId}`);
        this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
        this.selectInitialTrack();
      } else if (this.shouldReloadPlaylist(this.currentTrack)) {
        this.setAudioTrack(this.trackId);
      }
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
        this.requestScheduled = -1;
        this.checkRetry(data);
      }
    }
    get audioTracks() {
      return this.tracksInGroup;
    }
    get audioTrack() {
      return this.trackId;
    }
    set audioTrack(newId) {
      this.selectDefaultTrack = false;
      this.setAudioTrack(newId);
    }
    setAudioTrack(newId) {
      const tracks = this.tracksInGroup;
      if (newId < 0 || newId >= tracks.length) {
        this.warn("Invalid id passed to audio-track controller");
        return;
      }
      this.clearTimer();
      const lastTrack = this.currentTrack;
      tracks[this.trackId];
      const track = tracks[newId];
      const {
        groupId,
        name
      } = track;
      this.log(`Switching to audio-track ${newId} "${name}" lang:${track.lang} group:${groupId}`);
      this.trackId = newId;
      this.currentTrack = track;
      this.selectDefaultTrack = false;
      this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread22({}, track));
      if (track.details && !track.details.live) {
        return;
      }
      const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);
      this.loadPlaylist(hlsUrlParameters);
    }
    selectInitialTrack() {
      const audioTracks = this.tracksInGroup;
      const trackId = this.findTrackId(this.currentTrack) | this.findTrackId(null);
      if (trackId !== -1) {
        this.setAudioTrack(trackId);
      } else {
        const error = new Error(`No track found for running audio group-ID: ${this.groupId} track count: ${audioTracks.length}`);
        this.warn(error.message);
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
          fatal: true,
          error
        });
      }
    }
    findTrackId(currentTrack) {
      const audioTracks = this.tracksInGroup;
      for (let i2 = 0; i2 < audioTracks.length; i2++) {
        const track = audioTracks[i2];
        if (!this.selectDefaultTrack || track.default) {
          if (!currentTrack || currentTrack.attrs["STABLE-RENDITION-ID"] !== void 0 && currentTrack.attrs["STABLE-RENDITION-ID"] === track.attrs["STABLE-RENDITION-ID"]) {
            return track.id;
          }
          if (currentTrack.name === track.name && currentTrack.lang === track.lang) {
            return track.id;
          }
        }
      }
      return -1;
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      const audioTrack = this.tracksInGroup[this.trackId];
      if (this.shouldLoadPlaylist(audioTrack)) {
        const id = audioTrack.id;
        const groupId = audioTrack.groupId;
        let url = audioTrack.url;
        if (hlsUrlParameters) {
          try {
            url = hlsUrlParameters.addDirectives(url);
          } catch (error) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
          }
        }
        this.log(`loading audio-track playlist ${id} "${audioTrack.name}" lang:${audioTrack.lang} group:${groupId}`);
        this.clearTimer();
        this.hls.trigger(Events.AUDIO_TRACK_LOADING, {
          url,
          id,
          groupId,
          deliveryDirectives: hlsUrlParameters || null
        });
      }
    }
  };
  function subtitleOptionsIdentical(trackList1, trackList2) {
    if (trackList1.length !== trackList2.length) {
      return false;
    }
    for (let i2 = 0; i2 < trackList1.length; i2++) {
      if (!subtitleAttributesIdentical(trackList1[i2].attrs, trackList2[i2].attrs)) {
        return false;
      }
    }
    return true;
  }
  function subtitleAttributesIdentical(attrs1, attrs2) {
    const stableRenditionId = attrs1["STABLE-RENDITION-ID"];
    if (stableRenditionId) {
      return stableRenditionId === attrs2["STABLE-RENDITION-ID"];
    }
    return !["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED"].some((subtitleAttribute) => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);
  }
  var TICK_INTERVAL = 500;
  var SubtitleStreamController = class extends BaseStreamController {
    constructor(hls, fragmentTracker, keyLoader) {
      super(hls, fragmentTracker, keyLoader, "[subtitle-stream-controller]", PlaylistLevelType.SUBTITLE);
      this.levels = [];
      this.currentTrackId = -1;
      this.tracksBuffered = [];
      this.mainDetails = null;
      this._registerListeners();
    }
    onHandlerDestroying() {
      this._unregisterListeners();
      this.mainDetails = null;
    }
    _registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    _unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    }
    startLoad(startPosition) {
      this.stopLoad();
      this.state = State.IDLE;
      this.setInterval(TICK_INTERVAL);
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    }
    onManifestLoading() {
      this.mainDetails = null;
      this.fragmentTracker.removeAllFragments();
    }
    onMediaDetaching() {
      this.tracksBuffered = [];
      super.onMediaDetaching();
    }
    onLevelLoaded(event, data) {
      this.mainDetails = data.details;
    }
    onSubtitleFragProcessed(event, data) {
      const {
        frag,
        success
      } = data;
      this.fragPrevious = frag;
      this.state = State.IDLE;
      if (!success) {
        return;
      }
      const buffered = this.tracksBuffered[this.currentTrackId];
      if (!buffered) {
        return;
      }
      let timeRange;
      const fragStart = frag.start;
      for (let i2 = 0; i2 < buffered.length; i2++) {
        if (fragStart >= buffered[i2].start && fragStart <= buffered[i2].end) {
          timeRange = buffered[i2];
          break;
        }
      }
      const fragEnd = frag.start + frag.duration;
      if (timeRange) {
        timeRange.end = fragEnd;
      } else {
        timeRange = {
          start: fragStart,
          end: fragEnd
        };
        buffered.push(timeRange);
      }
      this.fragmentTracker.fragBuffered(frag);
    }
    onBufferFlushing(event, data) {
      const {
        startOffset,
        endOffset
      } = data;
      if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
        const endOffsetSubtitles = endOffset - 1;
        if (endOffsetSubtitles <= 0) {
          return;
        }
        data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
        this.tracksBuffered.forEach((buffered) => {
          for (let i2 = 0; i2 < buffered.length; ) {
            if (buffered[i2].end <= endOffsetSubtitles) {
              buffered.shift();
              continue;
            } else if (buffered[i2].start < endOffsetSubtitles) {
              buffered[i2].start = endOffsetSubtitles;
            } else {
              break;
            }
            i2++;
          }
        });
        this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);
      }
    }
    onFragBuffered(event, data) {
      if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {
        var _this$media;
        if ((_this$media = this.media) != null && _this$media.buffered.length) {
          this.loadedmetadata = true;
        }
      }
    }
    onError(event, data) {
      const frag = data.frag;
      if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {
        if (this.fragCurrent) {
          this.fragCurrent.abortRequests();
        }
        if (this.state !== State.STOPPED) {
          this.state = State.IDLE;
        }
      }
    }
    onSubtitleTracksUpdated(event, {
      subtitleTracks
    }) {
      if (subtitleOptionsIdentical(this.levels, subtitleTracks)) {
        this.levels = subtitleTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
        return;
      }
      this.tracksBuffered = [];
      this.levels = subtitleTracks.map((mediaPlaylist) => {
        const level = new Level(mediaPlaylist);
        this.tracksBuffered[level.id] = [];
        return level;
      });
      this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);
      this.fragPrevious = null;
      this.mediaBuffer = null;
    }
    onSubtitleTrackSwitch(event, data) {
      this.currentTrackId = data.id;
      if (!this.levels.length || this.currentTrackId === -1) {
        this.clearInterval();
        return;
      }
      const currentTrack = this.levels[this.currentTrackId];
      if (currentTrack != null && currentTrack.details) {
        this.mediaBuffer = this.mediaBufferTimeRanges;
      } else {
        this.mediaBuffer = null;
      }
      if (currentTrack) {
        this.setInterval(TICK_INTERVAL);
      }
    }
    onSubtitleTrackLoaded(event, data) {
      var _track$details;
      const {
        details: newDetails,
        id: trackId
      } = data;
      const {
        currentTrackId,
        levels
      } = this;
      if (!levels.length) {
        return;
      }
      const track = levels[currentTrackId];
      if (trackId >= levels.length || trackId !== currentTrackId || !track) {
        return;
      }
      this.mediaBuffer = this.mediaBufferTimeRanges;
      let sliding = 0;
      if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
        const mainDetails = this.mainDetails;
        if (newDetails.deltaUpdateFailed || !mainDetails) {
          return;
        }
        const mainSlidingStartFragment = mainDetails.fragments[0];
        if (!track.details) {
          if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
            alignMediaPlaylistByPDT(newDetails, mainDetails);
            sliding = newDetails.fragments[0].start;
          } else if (mainSlidingStartFragment) {
            sliding = mainSlidingStartFragment.start;
            addSliding(newDetails, sliding);
          }
        } else {
          sliding = this.alignPlaylists(newDetails, track.details);
          if (sliding === 0 && mainSlidingStartFragment) {
            sliding = mainSlidingStartFragment.start;
            addSliding(newDetails, sliding);
          }
        }
      }
      track.details = newDetails;
      this.levelLastLoaded = trackId;
      if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
        this.setStartPosition(track.details, sliding);
      }
      this.tick();
      if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {
        const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);
        if (!foundFrag) {
          this.warn("Subtitle playlist not aligned with playback");
          track.details = void 0;
        }
      }
    }
    _handleFragmentLoadComplete(fragLoadedData) {
      const {
        frag,
        payload
      } = fragLoadedData;
      const decryptData = frag.decryptdata;
      const hls = this.hls;
      if (this.fragContextChanged(frag)) {
        return;
      }
      if (payload && payload.byteLength > 0 && decryptData && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
        const startTime = performance.now();
        this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err) => {
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_DECRYPT_ERROR,
            fatal: false,
            error: err,
            reason: err.message,
            frag
          });
          throw err;
        }).then((decryptedData) => {
          const endTime = performance.now();
          hls.trigger(Events.FRAG_DECRYPTED, {
            frag,
            payload: decryptedData,
            stats: {
              tstart: startTime,
              tdecrypt: endTime
            }
          });
        }).catch((err) => {
          this.warn(`${err.name}: ${err.message}`);
          this.state = State.IDLE;
        });
      }
    }
    doTick() {
      if (!this.media) {
        this.state = State.IDLE;
        return;
      }
      if (this.state === State.IDLE) {
        const {
          currentTrackId,
          levels
        } = this;
        const track = levels[currentTrackId];
        if (!levels.length || !track || !track.details) {
          return;
        }
        const {
          config
        } = this;
        const currentTime = this.getLoadPosition();
        const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);
        const {
          end: targetBufferTime,
          len: bufferLen
        } = bufferedInfo;
        const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);
        const trackDetails = track.details;
        const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;
        if (bufferLen > maxBufLen) {
          return;
        }
        const fragments = trackDetails.fragments;
        const fragLen = fragments.length;
        const end = trackDetails.edge;
        let foundFrag = null;
        const fragPrevious = this.fragPrevious;
        if (targetBufferTime < end) {
          const tolerance = config.maxFragLookUpTolerance;
          const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;
          foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);
          if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
            foundFrag = fragments[0];
          }
        } else {
          foundFrag = fragments[fragLen - 1];
        }
        if (!foundFrag) {
          return;
        }
        foundFrag = this.mapToInitFragWhenRequired(foundFrag);
        if (foundFrag.sn !== "initSegment") {
          const curSNIdx = foundFrag.sn - trackDetails.startSN;
          const prevFrag = fragments[curSNIdx - 1];
          if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {
            foundFrag = prevFrag;
          }
        }
        if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
          this.loadFragment(foundFrag, track, targetBufferTime);
        }
      }
    }
    getMaxBufferLength(mainBufferLength) {
      const maxConfigBuffer = super.getMaxBufferLength();
      if (!mainBufferLength) {
        return maxConfigBuffer;
      }
      return Math.max(maxConfigBuffer, mainBufferLength);
    }
    loadFragment(frag, level, targetBufferTime) {
      this.fragCurrent = frag;
      if (frag.sn === "initSegment") {
        this._loadInitSegment(frag, level);
      } else {
        this.startFragRequested = true;
        super.loadFragment(frag, level, targetBufferTime);
      }
    }
    get mediaBufferTimeRanges() {
      return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
    }
  };
  var BufferableInstance = class {
    constructor(timeranges) {
      this.buffered = void 0;
      const getRange = (name, index2, length) => {
        index2 = index2 >>> 0;
        if (index2 > length - 1) {
          throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index2}) is greater than the maximum bound (${length})`);
        }
        return timeranges[index2][name];
      };
      this.buffered = {
        get length() {
          return timeranges.length;
        },
        end(index2) {
          return getRange("end", index2, timeranges.length);
        },
        start(index2) {
          return getRange("start", index2, timeranges.length);
        }
      };
    }
  };
  var SubtitleTrackController = class extends BasePlaylistController {
    constructor(hls) {
      super(hls, "[subtitle-track-controller]");
      this.media = null;
      this.tracks = [];
      this.groupId = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.selectDefaultTrack = true;
      this.queuedDefaultTrack = -1;
      this.trackChangeListener = () => this.onTextTracksChanged();
      this.asyncPollTrackChange = () => this.pollTrackChange(0);
      this.useTextTrackPolling = false;
      this.subtitlePollingInterval = -1;
      this._subtitleDisplay = true;
      this.registerListeners();
    }
    destroy() {
      this.unregisterListeners();
      this.tracks.length = 0;
      this.tracksInGroup.length = 0;
      this.trackChangeListener = this.asyncPollTrackChange = null;
      super.destroy();
    }
    get subtitleDisplay() {
      return this._subtitleDisplay;
    }
    set subtitleDisplay(value) {
      this._subtitleDisplay = value;
      if (this.trackId > -1) {
        this.toggleTrackModes(this.trackId);
      }
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
      hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
      hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    onMediaAttached(event, data) {
      this.media = data.media;
      if (!this.media) {
        return;
      }
      if (this.queuedDefaultTrack > -1) {
        this.subtitleTrack = this.queuedDefaultTrack;
        this.queuedDefaultTrack = -1;
      }
      this.useTextTrackPolling = !(this.media.textTracks && "onchange" in this.media.textTracks);
      if (this.useTextTrackPolling) {
        this.pollTrackChange(500);
      } else {
        this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
      }
    }
    pollTrackChange(timeout) {
      self.clearInterval(this.subtitlePollingInterval);
      this.subtitlePollingInterval = self.setInterval(this.trackChangeListener, timeout);
    }
    onMediaDetaching() {
      if (!this.media) {
        return;
      }
      self.clearInterval(this.subtitlePollingInterval);
      if (!this.useTextTrackPolling) {
        this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
      }
      if (this.trackId > -1) {
        this.queuedDefaultTrack = this.trackId;
      }
      const textTracks = filterSubtitleTracks(this.media.textTracks);
      textTracks.forEach((track) => {
        clearCurrentCues(track);
      });
      this.subtitleTrack = -1;
      this.media = null;
    }
    onManifestLoading() {
      this.tracks = [];
      this.groupId = null;
      this.tracksInGroup = [];
      this.trackId = -1;
      this.selectDefaultTrack = true;
    }
    onManifestParsed(event, data) {
      this.tracks = data.subtitleTracks;
    }
    onSubtitleTrackLoaded(event, data) {
      const {
        id,
        details
      } = data;
      const {
        trackId
      } = this;
      const currentTrack = this.tracksInGroup[trackId];
      if (!currentTrack) {
        this.warn(`Invalid subtitle track id ${id}`);
        return;
      }
      const curDetails = currentTrack.details;
      currentTrack.details = data.details;
      this.log(`subtitle track ${id} loaded [${details.startSN}-${details.endSN}]`);
      if (id === this.trackId) {
        this.playlistLoaded(id, data, curDetails);
      }
    }
    onLevelLoading(event, data) {
      this.switchLevel(data.level);
    }
    onLevelSwitching(event, data) {
      this.switchLevel(data.level);
    }
    switchLevel(levelIndex) {
      const levelInfo = this.hls.levels[levelIndex];
      if (!(levelInfo != null && levelInfo.textGroupIds)) {
        return;
      }
      const textGroupId = levelInfo.textGroupIds[levelInfo.urlId];
      const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
      if (this.groupId !== textGroupId) {
        const subtitleTracks = this.tracks.filter((track) => !textGroupId || track.groupId === textGroupId);
        this.tracksInGroup = subtitleTracks;
        const initialTrackId = this.findTrackId(lastTrack == null ? void 0 : lastTrack.name) || this.findTrackId();
        this.groupId = textGroupId || null;
        const subtitleTracksUpdated = {
          subtitleTracks
        };
        this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in "${textGroupId}" group-id`);
        this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
        if (initialTrackId !== -1) {
          this.setSubtitleTrack(initialTrackId, lastTrack);
        }
      } else if (this.shouldReloadPlaylist(lastTrack)) {
        this.setSubtitleTrack(this.trackId, lastTrack);
      }
    }
    findTrackId(name) {
      const textTracks = this.tracksInGroup;
      for (let i2 = 0; i2 < textTracks.length; i2++) {
        const track = textTracks[i2];
        if (!this.selectDefaultTrack || track.default) {
          if (!name || name === track.name) {
            return track.id;
          }
        }
      }
      return -1;
    }
    onError(event, data) {
      if (data.fatal || !data.context) {
        return;
      }
      if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && data.context.groupId === this.groupId) {
        this.checkRetry(data);
      }
    }
    get subtitleTracks() {
      return this.tracksInGroup;
    }
    get subtitleTrack() {
      return this.trackId;
    }
    set subtitleTrack(newId) {
      this.selectDefaultTrack = false;
      const lastTrack = this.tracksInGroup ? this.tracksInGroup[this.trackId] : void 0;
      this.setSubtitleTrack(newId, lastTrack);
    }
    loadPlaylist(hlsUrlParameters) {
      super.loadPlaylist();
      const currentTrack = this.tracksInGroup[this.trackId];
      if (this.shouldLoadPlaylist(currentTrack)) {
        const id = currentTrack.id;
        const groupId = currentTrack.groupId;
        let url = currentTrack.url;
        if (hlsUrlParameters) {
          try {
            url = hlsUrlParameters.addDirectives(url);
          } catch (error) {
            this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
          }
        }
        this.log(`Loading subtitle playlist for id ${id}`);
        this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {
          url,
          id,
          groupId,
          deliveryDirectives: hlsUrlParameters || null
        });
      }
    }
    toggleTrackModes(newId) {
      const {
        media,
        trackId
      } = this;
      if (!media) {
        return;
      }
      const textTracks = filterSubtitleTracks(media.textTracks);
      const groupTracks = textTracks.filter((track) => track.groupId === this.groupId);
      if (newId === -1) {
        [].slice.call(textTracks).forEach((track) => {
          track.mode = "disabled";
        });
      } else {
        const oldTrack = groupTracks[trackId];
        if (oldTrack) {
          oldTrack.mode = "disabled";
        }
      }
      const nextTrack = groupTracks[newId];
      if (nextTrack) {
        nextTrack.mode = this.subtitleDisplay ? "showing" : "hidden";
      }
    }
    setSubtitleTrack(newId, lastTrack) {
      var _tracks$newId;
      const tracks = this.tracksInGroup;
      if (!this.media) {
        this.queuedDefaultTrack = newId;
        return;
      }
      if (this.trackId !== newId) {
        this.toggleTrackModes(newId);
      }
      if (this.trackId === newId && (newId === -1 || (_tracks$newId = tracks[newId]) != null && _tracks$newId.details) || newId < -1 || newId >= tracks.length) {
        return;
      }
      this.clearTimer();
      const track = tracks[newId];
      this.log(`Switching to subtitle-track ${newId}` + (track ? ` "${track.name}" lang:${track.lang} group:${track.groupId}` : ""));
      this.trackId = newId;
      if (track) {
        const {
          id,
          groupId = "",
          name,
          type,
          url
        } = track;
        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
          id,
          groupId,
          name,
          type,
          url
        });
        const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details);
        this.loadPlaylist(hlsUrlParameters);
      } else {
        this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
          id: newId
        });
      }
    }
    onTextTracksChanged() {
      if (!this.useTextTrackPolling) {
        self.clearInterval(this.subtitlePollingInterval);
      }
      if (!this.media || !this.hls.config.renderTextTracksNatively) {
        return;
      }
      let trackId = -1;
      const tracks = filterSubtitleTracks(this.media.textTracks);
      for (let id = 0; id < tracks.length; id++) {
        if (tracks[id].mode === "hidden") {
          trackId = id;
        } else if (tracks[id].mode === "showing") {
          trackId = id;
          break;
        }
      }
      if (this.subtitleTrack !== trackId) {
        this.subtitleTrack = trackId;
      }
    }
  };
  function filterSubtitleTracks(textTrackList) {
    const tracks = [];
    for (let i2 = 0; i2 < textTrackList.length; i2++) {
      const track = textTrackList[i2];
      if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
        tracks.push(textTrackList[i2]);
      }
    }
    return tracks;
  }
  var BufferOperationQueue = class {
    constructor(sourceBufferReference) {
      this.buffers = void 0;
      this.queues = {
        video: [],
        audio: [],
        audiovideo: []
      };
      this.buffers = sourceBufferReference;
    }
    append(operation, type) {
      const queue = this.queues[type];
      queue.push(operation);
      if (queue.length === 1 && this.buffers[type]) {
        this.executeNext(type);
      }
    }
    insertAbort(operation, type) {
      const queue = this.queues[type];
      queue.unshift(operation);
      this.executeNext(type);
    }
    appendBlocker(type) {
      let execute;
      const promise = new Promise((resolve) => {
        execute = resolve;
      });
      const operation = {
        execute,
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: () => {
        }
      };
      this.append(operation, type);
      return promise;
    }
    executeNext(type) {
      const {
        buffers,
        queues
      } = this;
      const sb = buffers[type];
      const queue = queues[type];
      if (queue.length) {
        const operation = queue[0];
        try {
          operation.execute();
        } catch (e3) {
          logger.warn("[buffer-operation-queue]: Unhandled exception executing the current operation");
          operation.onError(e3);
          if (!(sb != null && sb.updating)) {
            queue.shift();
            this.executeNext(type);
          }
        }
      }
    }
    shiftAndExecuteNext(type) {
      this.queues[type].shift();
      this.executeNext(type);
    }
    current(type) {
      return this.queues[type][0];
    }
  };
  var MediaSource = getMediaSource();
  var VIDEO_CODEC_PROFILE_REPACE = /([ha]vc.)(?:\.[^.,]+)+/;
  var BufferController = class {
    constructor(hls) {
      this.details = null;
      this._objectUrl = null;
      this.operationQueue = void 0;
      this.listeners = void 0;
      this.hls = void 0;
      this.bufferCodecEventsExpected = 0;
      this._bufferCodecEventsTotal = 0;
      this.media = null;
      this.mediaSource = null;
      this.lastMpegAudioChunk = null;
      this.appendError = 0;
      this.tracks = {};
      this.pendingTracks = {};
      this.sourceBuffer = void 0;
      this._onMediaSourceOpen = () => {
        const {
          media,
          mediaSource
        } = this;
        logger.log("[buffer-controller]: Media source opened");
        if (media) {
          media.removeEventListener("emptied", this._onMediaEmptied);
          this.updateMediaElementDuration();
          this.hls.trigger(Events.MEDIA_ATTACHED, {
            media
          });
        }
        if (mediaSource) {
          mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
        }
        this.checkPendingTracks();
      };
      this._onMediaSourceClose = () => {
        logger.log("[buffer-controller]: Media source closed");
      };
      this._onMediaSourceEnded = () => {
        logger.log("[buffer-controller]: Media source ended");
      };
      this._onMediaEmptied = () => {
        const {
          media,
          _objectUrl
        } = this;
        if (media && media.src !== _objectUrl) {
          logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${media.src})`);
        }
      };
      this.hls = hls;
      this._initSourceBuffer();
      this.registerListeners();
    }
    hasSourceTypes() {
      return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
    }
    destroy() {
      this.unregisterListeners();
      this.details = null;
      this.lastMpegAudioChunk = null;
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);
      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.on(Events.BUFFER_EOS, this.onBufferEos, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.on(Events.FRAG_PARSED, this.onFragParsed, this);
      hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);
    }
    unregisterListeners() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
      hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);
      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.off(Events.BUFFER_EOS, this.onBufferEos, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
      hls.off(Events.FRAG_PARSED, this.onFragParsed, this);
      hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);
    }
    _initSourceBuffer() {
      this.sourceBuffer = {};
      this.operationQueue = new BufferOperationQueue(this.sourceBuffer);
      this.listeners = {
        audio: [],
        video: [],
        audiovideo: []
      };
      this.lastMpegAudioChunk = null;
    }
    onManifestLoading() {
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;
      this.details = null;
    }
    onManifestParsed(event, data) {
      let codecEvents = 2;
      if (data.audio && !data.video || !data.altAudio || false) {
        codecEvents = 1;
      }
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
      logger.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);
    }
    onMediaAttaching(event, data) {
      const media = this.media = data.media;
      if (media && MediaSource) {
        const ms = this.mediaSource = new MediaSource();
        ms.addEventListener("sourceopen", this._onMediaSourceOpen);
        ms.addEventListener("sourceended", this._onMediaSourceEnded);
        ms.addEventListener("sourceclose", this._onMediaSourceClose);
        media.src = self.URL.createObjectURL(ms);
        this._objectUrl = media.src;
        media.addEventListener("emptied", this._onMediaEmptied);
      }
    }
    onMediaDetaching() {
      const {
        media,
        mediaSource,
        _objectUrl
      } = this;
      if (mediaSource) {
        logger.log("[buffer-controller]: media source detaching");
        if (mediaSource.readyState === "open") {
          try {
            mediaSource.endOfStream();
          } catch (err) {
            logger.warn(`[buffer-controller]: onMediaDetaching: ${err.message} while calling endOfStream`);
          }
        }
        this.onBufferReset();
        mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
        mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
        mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
        if (media) {
          media.removeEventListener("emptied", this._onMediaEmptied);
          if (_objectUrl) {
            self.URL.revokeObjectURL(_objectUrl);
          }
          if (media.src === _objectUrl) {
            media.removeAttribute("src");
            media.load();
          } else {
            logger.warn("[buffer-controller]: media.src was changed by a third party - skip cleanup");
          }
        }
        this.mediaSource = null;
        this.media = null;
        this._objectUrl = null;
        this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
        this.pendingTracks = {};
        this.tracks = {};
      }
      this.hls.trigger(Events.MEDIA_DETACHED, void 0);
    }
    onBufferReset() {
      this.getSourceBufferTypes().forEach((type) => {
        const sb = this.sourceBuffer[type];
        try {
          if (sb) {
            this.removeBufferListeners(type);
            if (this.mediaSource) {
              this.mediaSource.removeSourceBuffer(sb);
            }
            this.sourceBuffer[type] = void 0;
          }
        } catch (err) {
          logger.warn(`[buffer-controller]: Failed to reset the ${type} buffer`, err);
        }
      });
      this._initSourceBuffer();
    }
    onBufferCodecs(event, data) {
      const sourceBufferCount = this.getSourceBufferTypes().length;
      Object.keys(data).forEach((trackName) => {
        if (sourceBufferCount) {
          const track = this.tracks[trackName];
          if (track && typeof track.buffer.changeType === "function") {
            const {
              id,
              codec,
              levelCodec,
              container: container2,
              metadata
            } = data[trackName];
            const currentCodec = (track.levelCodec || track.codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
            const nextCodec = (levelCodec || codec).replace(VIDEO_CODEC_PROFILE_REPACE, "$1");
            if (currentCodec !== nextCodec) {
              const mimeType = `${container2};codecs=${levelCodec || codec}`;
              this.appendChangeType(trackName, mimeType);
              logger.log(`[buffer-controller]: switching codec ${currentCodec} to ${nextCodec}`);
              this.tracks[trackName] = {
                buffer: track.buffer,
                codec,
                container: container2,
                levelCodec,
                metadata,
                id
              };
            }
          }
        } else {
          this.pendingTracks[trackName] = data[trackName];
        }
      });
      if (sourceBufferCount) {
        return;
      }
      this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
      if (this.mediaSource && this.mediaSource.readyState === "open") {
        this.checkPendingTracks();
      }
    }
    appendChangeType(type, mimeType) {
      const {
        operationQueue
      } = this;
      const operation = {
        execute: () => {
          const sb = this.sourceBuffer[type];
          if (sb) {
            logger.log(`[buffer-controller]: changing ${type} sourceBuffer type to ${mimeType}`);
            sb.changeType(mimeType);
          }
          operationQueue.shiftAndExecuteNext(type);
        },
        onStart: () => {
        },
        onComplete: () => {
        },
        onError: (e3) => {
          logger.warn(`[buffer-controller]: Failed to change ${type} SourceBuffer type`, e3);
        }
      };
      operationQueue.append(operation, type);
    }
    onBufferAppending(event, eventData) {
      const {
        hls,
        operationQueue,
        tracks
      } = this;
      const {
        data,
        type,
        frag,
        part,
        chunkMeta
      } = eventData;
      const chunkStats = chunkMeta.buffering[type];
      const bufferAppendingStart = self.performance.now();
      chunkStats.start = bufferAppendingStart;
      const fragBuffering = frag.stats.buffering;
      const partBuffering = part ? part.stats.buffering : null;
      if (fragBuffering.start === 0) {
        fragBuffering.start = bufferAppendingStart;
      }
      if (partBuffering && partBuffering.start === 0) {
        partBuffering.start = bufferAppendingStart;
      }
      const audioTrack = tracks.audio;
      let checkTimestampOffset = false;
      if (type === "audio" && (audioTrack == null ? void 0 : audioTrack.container) === "audio/mpeg") {
        checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
        this.lastMpegAudioChunk = chunkMeta;
      }
      const fragStart = frag.start;
      const operation = {
        execute: () => {
          chunkStats.executeStart = self.performance.now();
          if (checkTimestampOffset) {
            const sb = this.sourceBuffer[type];
            if (sb) {
              const delta = fragStart - sb.timestampOffset;
              if (Math.abs(delta) >= 0.1) {
                logger.log(`[buffer-controller]: Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);
                sb.timestampOffset = fragStart;
              }
            }
          }
          this.appendExecutor(data, type);
        },
        onStart: () => {
        },
        onComplete: () => {
          const end = self.performance.now();
          chunkStats.executeEnd = chunkStats.end = end;
          if (fragBuffering.first === 0) {
            fragBuffering.first = end;
          }
          if (partBuffering && partBuffering.first === 0) {
            partBuffering.first = end;
          }
          const {
            sourceBuffer
          } = this;
          const timeRanges = {};
          for (const type2 in sourceBuffer) {
            timeRanges[type2] = BufferHelper.getBuffered(sourceBuffer[type2]);
          }
          this.appendError = 0;
          this.hls.trigger(Events.BUFFER_APPENDED, {
            type,
            frag,
            part,
            chunkMeta,
            parent: frag.type,
            timeRanges
          });
        },
        onError: (err) => {
          logger.error(`[buffer-controller]: Error encountered while trying to append to the ${type} SourceBuffer`, err);
          const event2 = {
            type: ErrorTypes.MEDIA_ERROR,
            parent: frag.type,
            details: ErrorDetails.BUFFER_APPEND_ERROR,
            frag,
            part,
            chunkMeta,
            error: err,
            err,
            fatal: false
          };
          if (err.code === DOMException.QUOTA_EXCEEDED_ERR) {
            event2.details = ErrorDetails.BUFFER_FULL_ERROR;
          } else {
            this.appendError++;
            event2.details = ErrorDetails.BUFFER_APPEND_ERROR;
            if (this.appendError > hls.config.appendErrorMaxRetry) {
              logger.error(`[buffer-controller]: Failed ${hls.config.appendErrorMaxRetry} times to append segment in sourceBuffer`);
              event2.fatal = true;
            }
          }
          hls.trigger(Events.ERROR, event2);
        }
      };
      operationQueue.append(operation, type);
    }
    onBufferFlushing(event, data) {
      const {
        operationQueue
      } = this;
      const flushOperation = (type) => ({
        execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),
        onStart: () => {
        },
        onComplete: () => {
          this.hls.trigger(Events.BUFFER_FLUSHED, {
            type
          });
        },
        onError: (e3) => {
          logger.warn(`[buffer-controller]: Failed to remove from ${type} SourceBuffer`, e3);
        }
      });
      if (data.type) {
        operationQueue.append(flushOperation(data.type), data.type);
      } else {
        this.getSourceBufferTypes().forEach((type) => {
          operationQueue.append(flushOperation(type), type);
        });
      }
    }
    onFragParsed(event, data) {
      const {
        frag,
        part
      } = data;
      const buffersAppendedTo = [];
      const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
      if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
        buffersAppendedTo.push("audiovideo");
      } else {
        if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
          buffersAppendedTo.push("audio");
        }
        if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
          buffersAppendedTo.push("video");
        }
      }
      const onUnblocked = () => {
        const now2 = self.performance.now();
        frag.stats.buffering.end = now2;
        if (part) {
          part.stats.buffering.end = now2;
        }
        const stats = part ? part.stats : frag.stats;
        this.hls.trigger(Events.FRAG_BUFFERED, {
          frag,
          part,
          stats,
          id: frag.type
        });
      };
      if (buffersAppendedTo.length === 0) {
        logger.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);
      }
      this.blockBuffers(onUnblocked, buffersAppendedTo);
    }
    onFragChanged(event, data) {
      this.flushBackBuffer();
    }
    onBufferEos(event, data) {
      const ended = this.getSourceBufferTypes().reduce((acc, type) => {
        const sb = this.sourceBuffer[type];
        if (sb && (!data.type || data.type === type)) {
          sb.ending = true;
          if (!sb.ended) {
            sb.ended = true;
            logger.log(`[buffer-controller]: ${type} sourceBuffer now EOS`);
          }
        }
        return acc && !!(!sb || sb.ended);
      }, true);
      if (ended) {
        logger.log(`[buffer-controller]: Queueing mediaSource.endOfStream()`);
        this.blockBuffers(() => {
          this.getSourceBufferTypes().forEach((type) => {
            const sb = this.sourceBuffer[type];
            if (sb) {
              sb.ending = false;
            }
          });
          const {
            mediaSource
          } = this;
          if (!mediaSource || mediaSource.readyState !== "open") {
            if (mediaSource) {
              logger.info(`[buffer-controller]: Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);
            }
            return;
          }
          logger.log(`[buffer-controller]: Calling mediaSource.endOfStream()`);
          mediaSource.endOfStream();
        });
      }
    }
    onLevelUpdated(event, {
      details
    }) {
      if (!details.fragments.length) {
        return;
      }
      this.details = details;
      if (this.getSourceBufferTypes().length) {
        this.blockBuffers(this.updateMediaElementDuration.bind(this));
      } else {
        this.updateMediaElementDuration();
      }
    }
    flushBackBuffer() {
      const {
        hls,
        details,
        media,
        sourceBuffer
      } = this;
      if (!media || details === null) {
        return;
      }
      const sourceBufferTypes = this.getSourceBufferTypes();
      if (!sourceBufferTypes.length) {
        return;
      }
      const backBufferLength = details.live && hls.config.liveBackBufferLength !== null ? hls.config.liveBackBufferLength : hls.config.backBufferLength;
      if (!isFiniteNumber(backBufferLength) || backBufferLength < 0) {
        return;
      }
      const currentTime = media.currentTime;
      const targetDuration = details.levelTargetDuration;
      const maxBackBufferLength = Math.max(backBufferLength, targetDuration);
      const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
      sourceBufferTypes.forEach((type) => {
        const sb = sourceBuffer[type];
        if (sb) {
          const buffered = BufferHelper.getBuffered(sb);
          if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
            hls.trigger(Events.BACK_BUFFER_REACHED, {
              bufferEnd: targetBackBufferPosition
            });
            if (details.live) {
              hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {
                bufferEnd: targetBackBufferPosition
              });
            } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {
              logger.info(`[buffer-controller]: Cannot flush ${type} back buffer while SourceBuffer is in ended state`);
              return;
            }
            hls.trigger(Events.BUFFER_FLUSHING, {
              startOffset: 0,
              endOffset: targetBackBufferPosition,
              type
            });
          }
        }
      });
    }
    updateMediaElementDuration() {
      if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") {
        return;
      }
      const {
        details,
        hls,
        media,
        mediaSource
      } = this;
      const levelDuration = details.fragments[0].start + details.totalduration;
      const mediaDuration = media.duration;
      const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
      if (details.live && hls.config.liveDurationInfinity) {
        logger.log("[buffer-controller]: Media Source duration is set to Infinity");
        mediaSource.duration = Infinity;
        this.updateSeekableRange(details);
      } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {
        logger.log(`[buffer-controller]: Updating Media Source duration to ${levelDuration.toFixed(3)}`);
        mediaSource.duration = levelDuration;
      }
    }
    updateSeekableRange(levelDetails) {
      const mediaSource = this.mediaSource;
      const fragments = levelDetails.fragments;
      const len = fragments.length;
      if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {
        const start = Math.max(0, fragments[0].start);
        const end = Math.max(start, start + levelDetails.totalduration);
        mediaSource.setLiveSeekableRange(start, end);
      }
    }
    checkPendingTracks() {
      const {
        bufferCodecEventsExpected,
        operationQueue,
        pendingTracks
      } = this;
      const pendingTracksCount = Object.keys(pendingTracks).length;
      if (pendingTracksCount && !bufferCodecEventsExpected || pendingTracksCount === 2) {
        this.createSourceBuffers(pendingTracks);
        this.pendingTracks = {};
        const buffers = this.getSourceBufferTypes();
        if (buffers.length) {
          this.hls.trigger(Events.BUFFER_CREATED, {
            tracks: this.tracks
          });
          buffers.forEach((type) => {
            operationQueue.executeNext(type);
          });
        } else {
          const error = new Error("could not create source buffer for media codec(s)");
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
            fatal: true,
            error,
            reason: error.message
          });
        }
      }
    }
    createSourceBuffers(tracks) {
      const {
        sourceBuffer,
        mediaSource
      } = this;
      if (!mediaSource) {
        throw Error("createSourceBuffers called when mediaSource was null");
      }
      for (const trackName in tracks) {
        if (!sourceBuffer[trackName]) {
          const track = tracks[trackName];
          if (!track) {
            throw Error(`source buffer exists for track ${trackName}, however track does not`);
          }
          const codec = track.levelCodec || track.codec;
          const mimeType = `${track.container};codecs=${codec}`;
          logger.log(`[buffer-controller]: creating sourceBuffer(${mimeType})`);
          try {
            const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
            const sbName = trackName;
            this.addBufferListener(sbName, "updatestart", this._onSBUpdateStart);
            this.addBufferListener(sbName, "updateend", this._onSBUpdateEnd);
            this.addBufferListener(sbName, "error", this._onSBUpdateError);
            this.tracks[trackName] = {
              buffer: sb,
              codec,
              container: track.container,
              levelCodec: track.levelCodec,
              metadata: track.metadata,
              id: track.id
            };
          } catch (err) {
            logger.error(`[buffer-controller]: error while trying to add sourceBuffer: ${err.message}`);
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
              fatal: false,
              error: err,
              mimeType
            });
          }
        }
      }
    }
    _onSBUpdateStart(type) {
      const {
        operationQueue
      } = this;
      const operation = operationQueue.current(type);
      operation.onStart();
    }
    _onSBUpdateEnd(type) {
      const {
        operationQueue
      } = this;
      const operation = operationQueue.current(type);
      operation.onComplete();
      operationQueue.shiftAndExecuteNext(type);
    }
    _onSBUpdateError(type, event) {
      const error = new Error(`${type} SourceBuffer error`);
      logger.error(`[buffer-controller]: ${error}`, event);
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_APPENDING_ERROR,
        error,
        fatal: false
      });
      const operation = this.operationQueue.current(type);
      if (operation) {
        operation.onError(event);
      }
    }
    removeExecutor(type, startOffset, endOffset) {
      const {
        media,
        mediaSource,
        operationQueue,
        sourceBuffer
      } = this;
      const sb = sourceBuffer[type];
      if (!media || !mediaSource || !sb) {
        logger.warn(`[buffer-controller]: Attempting to remove from the ${type} SourceBuffer, but it does not exist`);
        operationQueue.shiftAndExecuteNext(type);
        return;
      }
      const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;
      const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
      const removeStart = Math.max(0, startOffset);
      const removeEnd = Math.min(endOffset, mediaDuration, msDuration);
      if (removeEnd > removeStart && !sb.ending) {
        sb.ended = false;
        logger.log(`[buffer-controller]: Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);
        sb.remove(removeStart, removeEnd);
      } else {
        operationQueue.shiftAndExecuteNext(type);
      }
    }
    appendExecutor(data, type) {
      const {
        operationQueue,
        sourceBuffer
      } = this;
      const sb = sourceBuffer[type];
      if (!sb) {
        logger.warn(`[buffer-controller]: Attempting to append to the ${type} SourceBuffer, but it does not exist`);
        operationQueue.shiftAndExecuteNext(type);
        return;
      }
      sb.ended = false;
      sb.appendBuffer(data);
    }
    blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {
      if (!buffers.length) {
        logger.log("[buffer-controller]: Blocking operation requested, but no SourceBuffers exist");
        Promise.resolve().then(onUnblocked);
        return;
      }
      const {
        operationQueue
      } = this;
      const blockingOperations = buffers.map((type) => operationQueue.appendBlocker(type));
      Promise.all(blockingOperations).then(() => {
        onUnblocked();
        buffers.forEach((type) => {
          const sb = this.sourceBuffer[type];
          if (!(sb != null && sb.updating)) {
            operationQueue.shiftAndExecuteNext(type);
          }
        });
      });
    }
    getSourceBufferTypes() {
      return Object.keys(this.sourceBuffer);
    }
    addBufferListener(type, event, fn2) {
      const buffer = this.sourceBuffer[type];
      if (!buffer) {
        return;
      }
      const listener = fn2.bind(this, type);
      this.listeners[type].push({
        event,
        listener
      });
      buffer.addEventListener(event, listener);
    }
    removeBufferListeners(type) {
      const buffer = this.sourceBuffer[type];
      if (!buffer) {
        return;
      }
      this.listeners[type].forEach((l2) => {
        buffer.removeEventListener(l2.event, l2.listener);
      });
    }
  };
  var specialCea608CharsCodes = {
    42: 225,
    92: 233,
    94: 237,
    95: 243,
    96: 250,
    123: 231,
    124: 247,
    125: 209,
    126: 241,
    127: 9608,
    128: 174,
    129: 176,
    130: 189,
    131: 191,
    132: 8482,
    133: 162,
    134: 163,
    135: 9834,
    136: 224,
    137: 32,
    138: 232,
    139: 226,
    140: 234,
    141: 238,
    142: 244,
    143: 251,
    144: 193,
    145: 201,
    146: 211,
    147: 218,
    148: 220,
    149: 252,
    150: 8216,
    151: 161,
    152: 42,
    153: 8217,
    154: 9473,
    155: 169,
    156: 8480,
    157: 8226,
    158: 8220,
    159: 8221,
    160: 192,
    161: 194,
    162: 199,
    163: 200,
    164: 202,
    165: 203,
    166: 235,
    167: 206,
    168: 207,
    169: 239,
    170: 212,
    171: 217,
    172: 249,
    173: 219,
    174: 171,
    175: 187,
    176: 195,
    177: 227,
    178: 205,
    179: 204,
    180: 236,
    181: 210,
    182: 242,
    183: 213,
    184: 245,
    185: 123,
    186: 125,
    187: 92,
    188: 94,
    189: 95,
    190: 124,
    191: 8764,
    192: 196,
    193: 228,
    194: 214,
    195: 246,
    196: 223,
    197: 165,
    198: 164,
    199: 9475,
    200: 197,
    201: 229,
    202: 216,
    203: 248,
    204: 9487,
    205: 9491,
    206: 9495,
    207: 9499
  };
  var getCharForByte = function getCharForByte2(byte) {
    let charCode = byte;
    if (specialCea608CharsCodes.hasOwnProperty(byte)) {
      charCode = specialCea608CharsCodes[byte];
    }
    return String.fromCharCode(charCode);
  };
  var NR_ROWS = 15;
  var NR_COLS = 100;
  var rowsLowCh1 = {
    17: 1,
    18: 3,
    21: 5,
    22: 7,
    23: 9,
    16: 11,
    19: 12,
    20: 14
  };
  var rowsHighCh1 = {
    17: 2,
    18: 4,
    21: 6,
    22: 8,
    23: 10,
    19: 13,
    20: 15
  };
  var rowsLowCh2 = {
    25: 1,
    26: 3,
    29: 5,
    30: 7,
    31: 9,
    24: 11,
    27: 12,
    28: 14
  };
  var rowsHighCh2 = {
    25: 2,
    26: 4,
    29: 6,
    30: 8,
    31: 10,
    27: 13,
    28: 15
  };
  var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
  var CaptionsLogger = class {
    constructor() {
      this.time = null;
      this.verboseLevel = 0;
    }
    log(severity, msg) {
      if (this.verboseLevel >= severity) {
        const m2 = typeof msg === "function" ? msg() : msg;
        logger.log(`${this.time} [${severity}] ${m2}`);
      }
    }
  };
  var numArrayToHexArray = function numArrayToHexArray2(numArray) {
    const hexArray = [];
    for (let j3 = 0; j3 < numArray.length; j3++) {
      hexArray.push(numArray[j3].toString(16));
    }
    return hexArray;
  };
  var PenState = class {
    constructor(foreground, underline, italics, background, flash) {
      this.foreground = void 0;
      this.underline = void 0;
      this.italics = void 0;
      this.background = void 0;
      this.flash = void 0;
      this.foreground = foreground || "white";
      this.underline = underline || false;
      this.italics = italics || false;
      this.background = background || "black";
      this.flash = flash || false;
    }
    reset() {
      this.foreground = "white";
      this.underline = false;
      this.italics = false;
      this.background = "black";
      this.flash = false;
    }
    setStyles(styles) {
      const attribs = ["foreground", "underline", "italics", "background", "flash"];
      for (let i2 = 0; i2 < attribs.length; i2++) {
        const style = attribs[i2];
        if (styles.hasOwnProperty(style)) {
          this[style] = styles[style];
        }
      }
    }
    isDefault() {
      return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
    }
    equals(other) {
      return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
    }
    copy(newPenState) {
      this.foreground = newPenState.foreground;
      this.underline = newPenState.underline;
      this.italics = newPenState.italics;
      this.background = newPenState.background;
      this.flash = newPenState.flash;
    }
    toString() {
      return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
    }
  };
  var StyledUnicodeChar = class {
    constructor(uchar, foreground, underline, italics, background, flash) {
      this.uchar = void 0;
      this.penState = void 0;
      this.uchar = uchar || " ";
      this.penState = new PenState(foreground, underline, italics, background, flash);
    }
    reset() {
      this.uchar = " ";
      this.penState.reset();
    }
    setChar(uchar, newPenState) {
      this.uchar = uchar;
      this.penState.copy(newPenState);
    }
    setPenState(newPenState) {
      this.penState.copy(newPenState);
    }
    equals(other) {
      return this.uchar === other.uchar && this.penState.equals(other.penState);
    }
    copy(newChar) {
      this.uchar = newChar.uchar;
      this.penState.copy(newChar.penState);
    }
    isEmpty() {
      return this.uchar === " " && this.penState.isDefault();
    }
  };
  var Row = class {
    constructor(logger2) {
      this.chars = void 0;
      this.pos = void 0;
      this.currPenState = void 0;
      this.cueStartTime = void 0;
      this.logger = void 0;
      this.chars = [];
      for (let i2 = 0; i2 < NR_COLS; i2++) {
        this.chars.push(new StyledUnicodeChar());
      }
      this.logger = logger2;
      this.pos = 0;
      this.currPenState = new PenState();
    }
    equals(other) {
      let equal2 = true;
      for (let i2 = 0; i2 < NR_COLS; i2++) {
        if (!this.chars[i2].equals(other.chars[i2])) {
          equal2 = false;
          break;
        }
      }
      return equal2;
    }
    copy(other) {
      for (let i2 = 0; i2 < NR_COLS; i2++) {
        this.chars[i2].copy(other.chars[i2]);
      }
    }
    isEmpty() {
      let empty = true;
      for (let i2 = 0; i2 < NR_COLS; i2++) {
        if (!this.chars[i2].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
    setCursor(absPos) {
      if (this.pos !== absPos) {
        this.pos = absPos;
      }
      if (this.pos < 0) {
        this.logger.log(3, "Negative cursor position " + this.pos);
        this.pos = 0;
      } else if (this.pos > NR_COLS) {
        this.logger.log(3, "Too large cursor position " + this.pos);
        this.pos = NR_COLS;
      }
    }
    moveCursor(relPos) {
      const newPos = this.pos + relPos;
      if (relPos > 1) {
        for (let i2 = this.pos + 1; i2 < newPos + 1; i2++) {
          this.chars[i2].setPenState(this.currPenState);
        }
      }
      this.setCursor(newPos);
    }
    backSpace() {
      this.moveCursor(-1);
      this.chars[this.pos].setChar(" ", this.currPenState);
    }
    insertChar(byte) {
      if (byte >= 144) {
        this.backSpace();
      }
      const char = getCharForByte(byte);
      if (this.pos >= NR_COLS) {
        this.logger.log(0, () => "Cannot insert " + byte.toString(16) + " (" + char + ") at position " + this.pos + ". Skipping it!");
        return;
      }
      this.chars[this.pos].setChar(char, this.currPenState);
      this.moveCursor(1);
    }
    clearFromPos(startPos) {
      let i2;
      for (i2 = startPos; i2 < NR_COLS; i2++) {
        this.chars[i2].reset();
      }
    }
    clear() {
      this.clearFromPos(0);
      this.pos = 0;
      this.currPenState.reset();
    }
    clearToEndOfRow() {
      this.clearFromPos(this.pos);
    }
    getTextString() {
      const chars = [];
      let empty = true;
      for (let i2 = 0; i2 < NR_COLS; i2++) {
        const char = this.chars[i2].uchar;
        if (char !== " ") {
          empty = false;
        }
        chars.push(char);
      }
      if (empty) {
        return "";
      } else {
        return chars.join("");
      }
    }
    setPenStyles(styles) {
      this.currPenState.setStyles(styles);
      const currChar = this.chars[this.pos];
      currChar.setPenState(this.currPenState);
    }
  };
  var CaptionScreen = class {
    constructor(logger2) {
      this.rows = void 0;
      this.currRow = void 0;
      this.nrRollUpRows = void 0;
      this.lastOutputScreen = void 0;
      this.logger = void 0;
      this.rows = [];
      for (let i2 = 0; i2 < NR_ROWS; i2++) {
        this.rows.push(new Row(logger2));
      }
      this.logger = logger2;
      this.currRow = NR_ROWS - 1;
      this.nrRollUpRows = null;
      this.lastOutputScreen = null;
      this.reset();
    }
    reset() {
      for (let i2 = 0; i2 < NR_ROWS; i2++) {
        this.rows[i2].clear();
      }
      this.currRow = NR_ROWS - 1;
    }
    equals(other) {
      let equal2 = true;
      for (let i2 = 0; i2 < NR_ROWS; i2++) {
        if (!this.rows[i2].equals(other.rows[i2])) {
          equal2 = false;
          break;
        }
      }
      return equal2;
    }
    copy(other) {
      for (let i2 = 0; i2 < NR_ROWS; i2++) {
        this.rows[i2].copy(other.rows[i2]);
      }
    }
    isEmpty() {
      let empty = true;
      for (let i2 = 0; i2 < NR_ROWS; i2++) {
        if (!this.rows[i2].isEmpty()) {
          empty = false;
          break;
        }
      }
      return empty;
    }
    backSpace() {
      const row = this.rows[this.currRow];
      row.backSpace();
    }
    clearToEndOfRow() {
      const row = this.rows[this.currRow];
      row.clearToEndOfRow();
    }
    insertChar(char) {
      const row = this.rows[this.currRow];
      row.insertChar(char);
    }
    setPen(styles) {
      const row = this.rows[this.currRow];
      row.setPenStyles(styles);
    }
    moveCursor(relPos) {
      const row = this.rows[this.currRow];
      row.moveCursor(relPos);
    }
    setCursor(absPos) {
      this.logger.log(2, "setCursor: " + absPos);
      const row = this.rows[this.currRow];
      row.setCursor(absPos);
    }
    setPAC(pacData) {
      this.logger.log(2, () => "pacData = " + JSON.stringify(pacData));
      let newRow = pacData.row - 1;
      if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
        newRow = this.nrRollUpRows - 1;
      }
      if (this.nrRollUpRows && this.currRow !== newRow) {
        for (let i2 = 0; i2 < NR_ROWS; i2++) {
          this.rows[i2].clear();
        }
        const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
        const lastOutputScreen = this.lastOutputScreen;
        if (lastOutputScreen) {
          const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
          const time = this.logger.time;
          if (prevLineTime && time !== null && prevLineTime < time) {
            for (let i2 = 0; i2 < this.nrRollUpRows; i2++) {
              this.rows[newRow - this.nrRollUpRows + i2 + 1].copy(lastOutputScreen.rows[topRowIndex + i2]);
            }
          }
        }
      }
      this.currRow = newRow;
      const row = this.rows[this.currRow];
      if (pacData.indent !== null) {
        const indent = pacData.indent;
        const prevPos = Math.max(indent - 1, 0);
        row.setCursor(pacData.indent);
        pacData.color = row.chars[prevPos].penState.foreground;
      }
      const styles = {
        foreground: pacData.color,
        underline: pacData.underline,
        italics: pacData.italics,
        background: "black",
        flash: false
      };
      this.setPen(styles);
    }
    setBkgData(bkgData) {
      this.logger.log(2, () => "bkgData = " + JSON.stringify(bkgData));
      this.backSpace();
      this.setPen(bkgData);
      this.insertChar(32);
    }
    setRollUpRows(nrRows) {
      this.nrRollUpRows = nrRows;
    }
    rollUp() {
      if (this.nrRollUpRows === null) {
        this.logger.log(3, "roll_up but nrRollUpRows not set yet");
        return;
      }
      this.logger.log(1, () => this.getDisplayText());
      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      const topRow = this.rows.splice(topRowIndex, 1)[0];
      topRow.clear();
      this.rows.splice(this.currRow, 0, topRow);
      this.logger.log(2, "Rolling up");
    }
    getDisplayText(asOneRow) {
      asOneRow = asOneRow || false;
      const displayText = [];
      let text = "";
      let rowNr = -1;
      for (let i2 = 0; i2 < NR_ROWS; i2++) {
        const rowText = this.rows[i2].getTextString();
        if (rowText) {
          rowNr = i2 + 1;
          if (asOneRow) {
            displayText.push("Row " + rowNr + ": '" + rowText + "'");
          } else {
            displayText.push(rowText.trim());
          }
        }
      }
      if (displayText.length > 0) {
        if (asOneRow) {
          text = "[" + displayText.join(" | ") + "]";
        } else {
          text = displayText.join("\n");
        }
      }
      return text;
    }
    getTextAndFormat() {
      return this.rows;
    }
  };
  var Cea608Channel = class {
    constructor(channelNumber, outputFilter, logger2) {
      this.chNr = void 0;
      this.outputFilter = void 0;
      this.mode = void 0;
      this.verbose = void 0;
      this.displayedMemory = void 0;
      this.nonDisplayedMemory = void 0;
      this.lastOutputScreen = void 0;
      this.currRollUpRow = void 0;
      this.writeScreen = void 0;
      this.cueStartTime = void 0;
      this.logger = void 0;
      this.chNr = channelNumber;
      this.outputFilter = outputFilter;
      this.mode = null;
      this.verbose = 0;
      this.displayedMemory = new CaptionScreen(logger2);
      this.nonDisplayedMemory = new CaptionScreen(logger2);
      this.lastOutputScreen = new CaptionScreen(logger2);
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
      this.logger = logger2;
    }
    reset() {
      this.mode = null;
      this.displayedMemory.reset();
      this.nonDisplayedMemory.reset();
      this.lastOutputScreen.reset();
      this.outputFilter.reset();
      this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
      this.writeScreen = this.displayedMemory;
      this.mode = null;
      this.cueStartTime = null;
    }
    getHandler() {
      return this.outputFilter;
    }
    setHandler(newHandler) {
      this.outputFilter = newHandler;
    }
    setPAC(pacData) {
      this.writeScreen.setPAC(pacData);
    }
    setBkgData(bkgData) {
      this.writeScreen.setBkgData(bkgData);
    }
    setMode(newMode) {
      if (newMode === this.mode) {
        return;
      }
      this.mode = newMode;
      this.logger.log(2, () => "MODE=" + newMode);
      if (this.mode === "MODE_POP-ON") {
        this.writeScreen = this.nonDisplayedMemory;
      } else {
        this.writeScreen = this.displayedMemory;
        this.writeScreen.reset();
      }
      if (this.mode !== "MODE_ROLL-UP") {
        this.displayedMemory.nrRollUpRows = null;
        this.nonDisplayedMemory.nrRollUpRows = null;
      }
      this.mode = newMode;
    }
    insertChars(chars) {
      for (let i2 = 0; i2 < chars.length; i2++) {
        this.writeScreen.insertChar(chars[i2]);
      }
      const screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
      this.logger.log(2, () => screen + ": " + this.writeScreen.getDisplayText(true));
      if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
        this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(true));
        this.outputDataUpdate();
      }
    }
    ccRCL() {
      this.logger.log(2, "RCL - Resume Caption Loading");
      this.setMode("MODE_POP-ON");
    }
    ccBS() {
      this.logger.log(2, "BS - BackSpace");
      if (this.mode === "MODE_TEXT") {
        return;
      }
      this.writeScreen.backSpace();
      if (this.writeScreen === this.displayedMemory) {
        this.outputDataUpdate();
      }
    }
    ccAOF() {
    }
    ccAON() {
    }
    ccDER() {
      this.logger.log(2, "DER- Delete to End of Row");
      this.writeScreen.clearToEndOfRow();
      this.outputDataUpdate();
    }
    ccRU(nrRows) {
      this.logger.log(2, "RU(" + nrRows + ") - Roll Up");
      this.writeScreen = this.displayedMemory;
      this.setMode("MODE_ROLL-UP");
      this.writeScreen.setRollUpRows(nrRows);
    }
    ccFON() {
      this.logger.log(2, "FON - Flash On");
      this.writeScreen.setPen({
        flash: true
      });
    }
    ccRDC() {
      this.logger.log(2, "RDC - Resume Direct Captioning");
      this.setMode("MODE_PAINT-ON");
    }
    ccTR() {
      this.logger.log(2, "TR");
      this.setMode("MODE_TEXT");
    }
    ccRTD() {
      this.logger.log(2, "RTD");
      this.setMode("MODE_TEXT");
    }
    ccEDM() {
      this.logger.log(2, "EDM - Erase Displayed Memory");
      this.displayedMemory.reset();
      this.outputDataUpdate(true);
    }
    ccCR() {
      this.logger.log(2, "CR - Carriage Return");
      this.writeScreen.rollUp();
      this.outputDataUpdate(true);
    }
    ccENM() {
      this.logger.log(2, "ENM - Erase Non-displayed Memory");
      this.nonDisplayedMemory.reset();
    }
    ccEOC() {
      this.logger.log(2, "EOC - End Of Caption");
      if (this.mode === "MODE_POP-ON") {
        const tmp = this.displayedMemory;
        this.displayedMemory = this.nonDisplayedMemory;
        this.nonDisplayedMemory = tmp;
        this.writeScreen = this.nonDisplayedMemory;
        this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
      }
      this.outputDataUpdate(true);
    }
    ccTO(nrCols) {
      this.logger.log(2, "TO(" + nrCols + ") - Tab Offset");
      this.writeScreen.moveCursor(nrCols);
    }
    ccMIDROW(secondByte) {
      const styles = {
        flash: false
      };
      styles.underline = secondByte % 2 === 1;
      styles.italics = secondByte >= 46;
      if (!styles.italics) {
        const colorIndex = Math.floor(secondByte / 2) - 16;
        const colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
        styles.foreground = colors[colorIndex];
      } else {
        styles.foreground = "white";
      }
      this.logger.log(2, "MIDROW: " + JSON.stringify(styles));
      this.writeScreen.setPen(styles);
    }
    outputDataUpdate(dispatch = false) {
      const time = this.logger.time;
      if (time === null) {
        return;
      }
      if (this.outputFilter) {
        if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
          this.cueStartTime = time;
        } else {
          if (!this.displayedMemory.equals(this.lastOutputScreen)) {
            this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
            if (dispatch && this.outputFilter.dispatchCue) {
              this.outputFilter.dispatchCue();
            }
            this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
          }
        }
        this.lastOutputScreen.copy(this.displayedMemory);
      }
    }
    cueSplitAtTime(t2) {
      if (this.outputFilter) {
        if (!this.displayedMemory.isEmpty()) {
          if (this.outputFilter.newCue) {
            this.outputFilter.newCue(this.cueStartTime, t2, this.displayedMemory);
          }
          this.cueStartTime = t2;
        }
      }
    }
  };
  var Cea608Parser = class {
    constructor(field, out1, out2) {
      this.channels = void 0;
      this.currentChannel = 0;
      this.cmdHistory = void 0;
      this.logger = void 0;
      const logger2 = new CaptionsLogger();
      this.channels = [null, new Cea608Channel(field, out1, logger2), new Cea608Channel(field + 1, out2, logger2)];
      this.cmdHistory = createCmdHistory();
      this.logger = logger2;
    }
    getHandler(channel) {
      return this.channels[channel].getHandler();
    }
    setHandler(channel, newHandler) {
      this.channels[channel].setHandler(newHandler);
    }
    addData(time, byteList) {
      let cmdFound;
      let a2;
      let b3;
      let charsFound = false;
      this.logger.time = time;
      for (let i2 = 0; i2 < byteList.length; i2 += 2) {
        a2 = byteList[i2] & 127;
        b3 = byteList[i2 + 1] & 127;
        if (a2 === 0 && b3 === 0) {
          continue;
        } else {
          this.logger.log(3, "[" + numArrayToHexArray([byteList[i2], byteList[i2 + 1]]) + "] -> (" + numArrayToHexArray([a2, b3]) + ")");
        }
        cmdFound = this.parseCmd(a2, b3);
        if (!cmdFound) {
          cmdFound = this.parseMidrow(a2, b3);
        }
        if (!cmdFound) {
          cmdFound = this.parsePAC(a2, b3);
        }
        if (!cmdFound) {
          cmdFound = this.parseBackgroundAttributes(a2, b3);
        }
        if (!cmdFound) {
          charsFound = this.parseChars(a2, b3);
          if (charsFound) {
            const currChNr = this.currentChannel;
            if (currChNr && currChNr > 0) {
              const channel = this.channels[currChNr];
              channel.insertChars(charsFound);
            } else {
              this.logger.log(2, "No channel found yet. TEXT-MODE?");
            }
          }
        }
        if (!cmdFound && !charsFound) {
          this.logger.log(2, "Couldn't parse cleaned data " + numArrayToHexArray([a2, b3]) + " orig: " + numArrayToHexArray([byteList[i2], byteList[i2 + 1]]));
        }
      }
    }
    parseCmd(a2, b3) {
      const {
        cmdHistory
      } = this;
      const cond1 = (a2 === 20 || a2 === 28 || a2 === 21 || a2 === 29) && b3 >= 32 && b3 <= 47;
      const cond2 = (a2 === 23 || a2 === 31) && b3 >= 33 && b3 <= 35;
      if (!(cond1 || cond2)) {
        return false;
      }
      if (hasCmdRepeated(a2, b3, cmdHistory)) {
        setLastCmd(null, null, cmdHistory);
        this.logger.log(3, "Repeated command (" + numArrayToHexArray([a2, b3]) + ") is dropped");
        return true;
      }
      const chNr = a2 === 20 || a2 === 21 || a2 === 23 ? 1 : 2;
      const channel = this.channels[chNr];
      if (a2 === 20 || a2 === 21 || a2 === 28 || a2 === 29) {
        if (b3 === 32) {
          channel.ccRCL();
        } else if (b3 === 33) {
          channel.ccBS();
        } else if (b3 === 34) {
          channel.ccAOF();
        } else if (b3 === 35) {
          channel.ccAON();
        } else if (b3 === 36) {
          channel.ccDER();
        } else if (b3 === 37) {
          channel.ccRU(2);
        } else if (b3 === 38) {
          channel.ccRU(3);
        } else if (b3 === 39) {
          channel.ccRU(4);
        } else if (b3 === 40) {
          channel.ccFON();
        } else if (b3 === 41) {
          channel.ccRDC();
        } else if (b3 === 42) {
          channel.ccTR();
        } else if (b3 === 43) {
          channel.ccRTD();
        } else if (b3 === 44) {
          channel.ccEDM();
        } else if (b3 === 45) {
          channel.ccCR();
        } else if (b3 === 46) {
          channel.ccENM();
        } else if (b3 === 47) {
          channel.ccEOC();
        }
      } else {
        channel.ccTO(b3 - 32);
      }
      setLastCmd(a2, b3, cmdHistory);
      this.currentChannel = chNr;
      return true;
    }
    parseMidrow(a2, b3) {
      let chNr = 0;
      if ((a2 === 17 || a2 === 25) && b3 >= 32 && b3 <= 47) {
        if (a2 === 17) {
          chNr = 1;
        } else {
          chNr = 2;
        }
        if (chNr !== this.currentChannel) {
          this.logger.log(0, "Mismatch channel in midrow parsing");
          return false;
        }
        const channel = this.channels[chNr];
        if (!channel) {
          return false;
        }
        channel.ccMIDROW(b3);
        this.logger.log(3, "MIDROW (" + numArrayToHexArray([a2, b3]) + ")");
        return true;
      }
      return false;
    }
    parsePAC(a2, b3) {
      let row;
      const cmdHistory = this.cmdHistory;
      const case1 = (a2 >= 17 && a2 <= 23 || a2 >= 25 && a2 <= 31) && b3 >= 64 && b3 <= 127;
      const case2 = (a2 === 16 || a2 === 24) && b3 >= 64 && b3 <= 95;
      if (!(case1 || case2)) {
        return false;
      }
      if (hasCmdRepeated(a2, b3, cmdHistory)) {
        setLastCmd(null, null, cmdHistory);
        return true;
      }
      const chNr = a2 <= 23 ? 1 : 2;
      if (b3 >= 64 && b3 <= 95) {
        row = chNr === 1 ? rowsLowCh1[a2] : rowsLowCh2[a2];
      } else {
        row = chNr === 1 ? rowsHighCh1[a2] : rowsHighCh2[a2];
      }
      const channel = this.channels[chNr];
      if (!channel) {
        return false;
      }
      channel.setPAC(this.interpretPAC(row, b3));
      setLastCmd(a2, b3, cmdHistory);
      this.currentChannel = chNr;
      return true;
    }
    interpretPAC(row, byte) {
      let pacIndex;
      const pacData = {
        color: null,
        italics: false,
        indent: null,
        underline: false,
        row
      };
      if (byte > 95) {
        pacIndex = byte - 96;
      } else {
        pacIndex = byte - 64;
      }
      pacData.underline = (pacIndex & 1) === 1;
      if (pacIndex <= 13) {
        pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
      } else if (pacIndex <= 15) {
        pacData.italics = true;
        pacData.color = "white";
      } else {
        pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
      }
      return pacData;
    }
    parseChars(a2, b3) {
      let channelNr;
      let charCodes = null;
      let charCode1 = null;
      if (a2 >= 25) {
        channelNr = 2;
        charCode1 = a2 - 8;
      } else {
        channelNr = 1;
        charCode1 = a2;
      }
      if (charCode1 >= 17 && charCode1 <= 19) {
        let oneCode;
        if (charCode1 === 17) {
          oneCode = b3 + 80;
        } else if (charCode1 === 18) {
          oneCode = b3 + 112;
        } else {
          oneCode = b3 + 144;
        }
        this.logger.log(2, "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
        charCodes = [oneCode];
      } else if (a2 >= 32 && a2 <= 127) {
        charCodes = b3 === 0 ? [a2] : [a2, b3];
      }
      if (charCodes) {
        const hexCodes = numArrayToHexArray(charCodes);
        this.logger.log(3, "Char codes =  " + hexCodes.join(","));
        setLastCmd(a2, b3, this.cmdHistory);
      }
      return charCodes;
    }
    parseBackgroundAttributes(a2, b3) {
      const case1 = (a2 === 16 || a2 === 24) && b3 >= 32 && b3 <= 47;
      const case2 = (a2 === 23 || a2 === 31) && b3 >= 45 && b3 <= 47;
      if (!(case1 || case2)) {
        return false;
      }
      let index2;
      const bkgData = {};
      if (a2 === 16 || a2 === 24) {
        index2 = Math.floor((b3 - 32) / 2);
        bkgData.background = backgroundColors[index2];
        if (b3 % 2 === 1) {
          bkgData.background = bkgData.background + "_semi";
        }
      } else if (b3 === 45) {
        bkgData.background = "transparent";
      } else {
        bkgData.foreground = "black";
        if (b3 === 47) {
          bkgData.underline = true;
        }
      }
      const chNr = a2 <= 23 ? 1 : 2;
      const channel = this.channels[chNr];
      channel.setBkgData(bkgData);
      setLastCmd(a2, b3, this.cmdHistory);
      return true;
    }
    reset() {
      for (let i2 = 0; i2 < Object.keys(this.channels).length; i2++) {
        const channel = this.channels[i2];
        if (channel) {
          channel.reset();
        }
      }
      this.cmdHistory = createCmdHistory();
    }
    cueSplitAtTime(t2) {
      for (let i2 = 0; i2 < this.channels.length; i2++) {
        const channel = this.channels[i2];
        if (channel) {
          channel.cueSplitAtTime(t2);
        }
      }
    }
  };
  function setLastCmd(a2, b3, cmdHistory) {
    cmdHistory.a = a2;
    cmdHistory.b = b3;
  }
  function hasCmdRepeated(a2, b3, cmdHistory) {
    return cmdHistory.a === a2 && cmdHistory.b === b3;
  }
  function createCmdHistory() {
    return {
      a: null,
      b: null
    };
  }
  var OutputFilter = class {
    constructor(timelineController, trackName) {
      this.timelineController = void 0;
      this.cueRanges = [];
      this.trackName = void 0;
      this.startTime = null;
      this.endTime = null;
      this.screen = null;
      this.timelineController = timelineController;
      this.trackName = trackName;
    }
    dispatchCue() {
      if (this.startTime === null) {
        return;
      }
      this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
      this.startTime = null;
    }
    newCue(startTime, endTime, screen) {
      if (this.startTime === null || this.startTime > startTime) {
        this.startTime = startTime;
      }
      this.endTime = endTime;
      this.screen = screen;
      this.timelineController.createCaptionsTrack(this.trackName);
    }
    reset() {
      this.cueRanges = [];
      this.startTime = null;
    }
  };
  var VTTCue = function() {
    if (typeof self !== "undefined" && self.VTTCue) {
      return self.VTTCue;
    }
    const AllowedDirections = ["", "lr", "rl"];
    const AllowedAlignments = ["start", "middle", "end", "left", "right"];
    function isAllowedValue(allowed, value) {
      if (typeof value !== "string") {
        return false;
      }
      if (!Array.isArray(allowed)) {
        return false;
      }
      const lcValue = value.toLowerCase();
      if (~allowed.indexOf(lcValue)) {
        return lcValue;
      }
      return false;
    }
    function findDirectionSetting(value) {
      return isAllowedValue(AllowedDirections, value);
    }
    function findAlignSetting(value) {
      return isAllowedValue(AllowedAlignments, value);
    }
    function extend(obj, ...rest) {
      let i2 = 1;
      for (; i2 < arguments.length; i2++) {
        const cobj = arguments[i2];
        for (const p2 in cobj) {
          obj[p2] = cobj[p2];
        }
      }
      return obj;
    }
    function VTTCue2(startTime, endTime, text) {
      const cue = this;
      const baseObj = {
        enumerable: true
      };
      cue.hasBeenReset = false;
      let _id = "";
      let _pauseOnExit = false;
      let _startTime = startTime;
      let _endTime = endTime;
      let _text = text;
      let _region = null;
      let _vertical = "";
      let _snapToLines = true;
      let _line = "auto";
      let _lineAlign = "start";
      let _position = 50;
      let _positionAlign = "middle";
      let _size = 50;
      let _align = "middle";
      Object.defineProperty(cue, "id", extend({}, baseObj, {
        get: function() {
          return _id;
        },
        set: function(value) {
          _id = "" + value;
        }
      }));
      Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
        get: function() {
          return _pauseOnExit;
        },
        set: function(value) {
          _pauseOnExit = !!value;
        }
      }));
      Object.defineProperty(cue, "startTime", extend({}, baseObj, {
        get: function() {
          return _startTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("Start time must be set to a number.");
          }
          _startTime = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "endTime", extend({}, baseObj, {
        get: function() {
          return _endTime;
        },
        set: function(value) {
          if (typeof value !== "number") {
            throw new TypeError("End time must be set to a number.");
          }
          _endTime = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "text", extend({}, baseObj, {
        get: function() {
          return _text;
        },
        set: function(value) {
          _text = "" + value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "region", extend({}, baseObj, {
        get: function() {
          return _region;
        },
        set: function(value) {
          _region = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "vertical", extend({}, baseObj, {
        get: function() {
          return _vertical;
        },
        set: function(value) {
          const setting = findDirectionSetting(value);
          if (setting === false) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _vertical = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
        get: function() {
          return _snapToLines;
        },
        set: function(value) {
          _snapToLines = !!value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "line", extend({}, baseObj, {
        get: function() {
          return _line;
        },
        set: function(value) {
          if (typeof value !== "number" && value !== "auto") {
            throw new SyntaxError("An invalid number or illegal string was specified.");
          }
          _line = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
        get: function() {
          return _lineAlign;
        },
        set: function(value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _lineAlign = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "position", extend({}, baseObj, {
        get: function() {
          return _position;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Position must be between 0 and 100.");
          }
          _position = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
        get: function() {
          return _positionAlign;
        },
        set: function(value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _positionAlign = setting;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "size", extend({}, baseObj, {
        get: function() {
          return _size;
        },
        set: function(value) {
          if (value < 0 || value > 100) {
            throw new Error("Size must be between 0 and 100.");
          }
          _size = value;
          this.hasBeenReset = true;
        }
      }));
      Object.defineProperty(cue, "align", extend({}, baseObj, {
        get: function() {
          return _align;
        },
        set: function(value) {
          const setting = findAlignSetting(value);
          if (!setting) {
            throw new SyntaxError("An invalid or illegal string was specified.");
          }
          _align = setting;
          this.hasBeenReset = true;
        }
      }));
      cue.displayState = void 0;
    }
    VTTCue2.prototype.getCueAsHTML = function() {
      const WebVTT = self.WebVTT;
      return WebVTT.convertCueToDOMTree(self, this.text);
    };
    return VTTCue2;
  }();
  var StringDecoder = class {
    decode(data, options) {
      if (!data) {
        return "";
      }
      if (typeof data !== "string") {
        throw new Error("Error - expected string data.");
      }
      return decodeURIComponent(encodeURIComponent(data));
    }
  };
  function parseTimeStamp(input) {
    function computeSeconds(h2, m3, s2, f2) {
      return (h2 | 0) * 3600 + (m3 | 0) * 60 + (s2 | 0) + parseFloat(f2 || 0);
    }
    const m2 = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
    if (!m2) {
      return null;
    }
    if (parseFloat(m2[2]) > 59) {
      return computeSeconds(m2[2], m2[3], 0, m2[4]);
    }
    return computeSeconds(m2[1], m2[2], m2[3], m2[4]);
  }
  var Settings = class {
    constructor() {
      this.values = /* @__PURE__ */ Object.create(null);
    }
    set(k3, v2) {
      if (!this.get(k3) && v2 !== "") {
        this.values[k3] = v2;
      }
    }
    get(k3, dflt, defaultKey) {
      if (defaultKey) {
        return this.has(k3) ? this.values[k3] : dflt[defaultKey];
      }
      return this.has(k3) ? this.values[k3] : dflt;
    }
    has(k3) {
      return k3 in this.values;
    }
    alt(k3, v2, a2) {
      for (let n2 = 0; n2 < a2.length; ++n2) {
        if (v2 === a2[n2]) {
          this.set(k3, v2);
          break;
        }
      }
    }
    integer(k3, v2) {
      if (/^-?\d+$/.test(v2)) {
        this.set(k3, parseInt(v2, 10));
      }
    }
    percent(k3, v2) {
      if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v2)) {
        const percent = parseFloat(v2);
        if (percent >= 0 && percent <= 100) {
          this.set(k3, percent);
          return true;
        }
      }
      return false;
    }
  };
  function parseOptions(input, callback, keyValueDelim, groupDelim) {
    const groups = groupDelim ? input.split(groupDelim) : [input];
    for (const i2 in groups) {
      if (typeof groups[i2] !== "string") {
        continue;
      }
      const kv = groups[i2].split(keyValueDelim);
      if (kv.length !== 2) {
        continue;
      }
      const k3 = kv[0];
      const v2 = kv[1];
      callback(k3, v2);
    }
  }
  var defaults = new VTTCue(0, 0, "");
  var center = defaults.align === "middle" ? "middle" : "center";
  function parseCue(input, cue, regionList) {
    const oInput = input;
    function consumeTimeStamp() {
      const ts = parseTimeStamp(input);
      if (ts === null) {
        throw new Error("Malformed timestamp: " + oInput);
      }
      input = input.replace(/^[^\sa-zA-Z-]+/, "");
      return ts;
    }
    function consumeCueSettings(input2, cue2) {
      const settings = new Settings();
      parseOptions(input2, function(k3, v2) {
        let vals;
        switch (k3) {
          case "region":
            for (let i2 = regionList.length - 1; i2 >= 0; i2--) {
              if (regionList[i2].id === v2) {
                settings.set(k3, regionList[i2].region);
                break;
              }
            }
            break;
          case "vertical":
            settings.alt(k3, v2, ["rl", "lr"]);
            break;
          case "line":
            vals = v2.split(",");
            settings.integer(k3, vals[0]);
            if (settings.percent(k3, vals[0])) {
              settings.set("snapToLines", false);
            }
            settings.alt(k3, vals[0], ["auto"]);
            if (vals.length === 2) {
              settings.alt("lineAlign", vals[1], ["start", center, "end"]);
            }
            break;
          case "position":
            vals = v2.split(",");
            settings.percent(k3, vals[0]);
            if (vals.length === 2) {
              settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
            }
            break;
          case "size":
            settings.percent(k3, v2);
            break;
          case "align":
            settings.alt(k3, v2, ["start", center, "end", "left", "right"]);
            break;
        }
      }, /:/, /\s/);
      cue2.region = settings.get("region", null);
      cue2.vertical = settings.get("vertical", "");
      let line = settings.get("line", "auto");
      if (line === "auto" && defaults.line === -1) {
        line = -1;
      }
      cue2.line = line;
      cue2.lineAlign = settings.get("lineAlign", "start");
      cue2.snapToLines = settings.get("snapToLines", true);
      cue2.size = settings.get("size", 100);
      cue2.align = settings.get("align", center);
      let position = settings.get("position", "auto");
      if (position === "auto" && defaults.position === 50) {
        position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
      }
      cue2.position = position;
    }
    function skipWhitespace() {
      input = input.replace(/^\s+/, "");
    }
    skipWhitespace();
    cue.startTime = consumeTimeStamp();
    skipWhitespace();
    if (input.slice(0, 3) !== "-->") {
      throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
    }
    input = input.slice(3);
    skipWhitespace();
    cue.endTime = consumeTimeStamp();
    skipWhitespace();
    consumeCueSettings(input, cue);
  }
  function fixLineBreaks(input) {
    return input.replace(/<br(?: \/)?>/gi, "\n");
  }
  var VTTParser = class {
    constructor() {
      this.state = "INITIAL";
      this.buffer = "";
      this.decoder = new StringDecoder();
      this.regionList = [];
      this.cue = null;
      this.oncue = void 0;
      this.onparsingerror = void 0;
      this.onflush = void 0;
    }
    parse(data) {
      const _this = this;
      if (data) {
        _this.buffer += _this.decoder.decode(data, {
          stream: true
        });
      }
      function collectNextLine() {
        let buffer = _this.buffer;
        let pos = 0;
        buffer = fixLineBreaks(buffer);
        while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") {
          ++pos;
        }
        const line = buffer.slice(0, pos);
        if (buffer[pos] === "\r") {
          ++pos;
        }
        if (buffer[pos] === "\n") {
          ++pos;
        }
        _this.buffer = buffer.slice(pos);
        return line;
      }
      function parseHeader2(input) {
        parseOptions(input, function(k3, v2) {
        }, /:/);
      }
      try {
        let line = "";
        if (_this.state === "INITIAL") {
          if (!/\r\n|\n/.test(_this.buffer)) {
            return this;
          }
          line = collectNextLine();
          const m2 = line.match(/^()?WEBVTT([ \t].*)?$/);
          if (!(m2 != null && m2[0])) {
            throw new Error("Malformed WebVTT signature.");
          }
          _this.state = "HEADER";
        }
        let alreadyCollectedLine = false;
        while (_this.buffer) {
          if (!/\r\n|\n/.test(_this.buffer)) {
            return this;
          }
          if (!alreadyCollectedLine) {
            line = collectNextLine();
          } else {
            alreadyCollectedLine = false;
          }
          switch (_this.state) {
            case "HEADER":
              if (/:/.test(line)) {
                parseHeader2(line);
              } else if (!line) {
                _this.state = "ID";
              }
              continue;
            case "NOTE":
              if (!line) {
                _this.state = "ID";
              }
              continue;
            case "ID":
              if (/^NOTE($|[ \t])/.test(line)) {
                _this.state = "NOTE";
                break;
              }
              if (!line) {
                continue;
              }
              _this.cue = new VTTCue(0, 0, "");
              _this.state = "CUE";
              if (line.indexOf("-->") === -1) {
                _this.cue.id = line;
                continue;
              }
            case "CUE":
              if (!_this.cue) {
                _this.state = "BADCUE";
                continue;
              }
              try {
                parseCue(line, _this.cue, _this.regionList);
              } catch (e3) {
                _this.cue = null;
                _this.state = "BADCUE";
                continue;
              }
              _this.state = "CUETEXT";
              continue;
            case "CUETEXT":
              {
                const hasSubstring = line.indexOf("-->") !== -1;
                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                  if (_this.oncue && _this.cue) {
                    _this.oncue(_this.cue);
                  }
                  _this.cue = null;
                  _this.state = "ID";
                  continue;
                }
                if (_this.cue === null) {
                  continue;
                }
                if (_this.cue.text) {
                  _this.cue.text += "\n";
                }
                _this.cue.text += line;
              }
              continue;
            case "BADCUE":
              if (!line) {
                _this.state = "ID";
              }
          }
        }
      } catch (e3) {
        if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
          _this.oncue(_this.cue);
        }
        _this.cue = null;
        _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
      }
      return this;
    }
    flush() {
      const _this = this;
      try {
        if (_this.cue || _this.state === "HEADER") {
          _this.buffer += "\n\n";
          _this.parse();
        }
        if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
          throw new Error("Malformed WebVTT signature.");
        }
      } catch (e3) {
        if (_this.onparsingerror) {
          _this.onparsingerror(e3);
        }
      }
      if (_this.onflush) {
        _this.onflush();
      }
      return this;
    }
  };
  var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
  var startsWith = function startsWith2(inputString, searchString, position = 0) {
    return inputString.slice(position, position + searchString.length) === searchString;
  };
  var cueString2millis = function cueString2millis2(timeString) {
    let ts = parseInt(timeString.slice(-3));
    const secs = parseInt(timeString.slice(-6, -4));
    const mins = parseInt(timeString.slice(-9, -7));
    const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
    if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {
      throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);
    }
    ts += 1e3 * secs;
    ts += 60 * 1e3 * mins;
    ts += 60 * 60 * 1e3 * hours;
    return ts;
  };
  var hash2 = function hash3(text) {
    let _hash = 5381;
    let i2 = text.length;
    while (i2) {
      _hash = _hash * 33 ^ text.charCodeAt(--i2);
    }
    return (_hash >>> 0).toString();
  };
  function generateCueId(startTime, endTime, text) {
    return hash2(startTime.toString()) + hash2(endTime.toString()) + hash2(text);
  }
  var calculateOffset = function calculateOffset2(vttCCs, cc, presentationTime) {
    let currCC = vttCCs[cc];
    let prevCC = vttCCs[currCC.prevCC];
    if (!prevCC || !prevCC.new && currCC.new) {
      vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
      currCC.new = false;
      return;
    }
    while ((_prevCC = prevCC) != null && _prevCC.new) {
      var _prevCC;
      vttCCs.ccOffset += currCC.start - prevCC.start;
      currCC.new = false;
      currCC = prevCC;
      prevCC = vttCCs[currCC.prevCC];
    }
    vttCCs.presentationOffset = presentationTime;
  };
  function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {
    const parser = new VTTParser();
    const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, "\n").split("\n");
    const cues = [];
    const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;
    let cueTime = "00:00.000";
    let timestampMapMPEGTS = 0;
    let timestampMapLOCAL = 0;
    let parsingError;
    let inHeader = true;
    parser.oncue = function(cue) {
      const currCC = vttCCs[cc];
      let cueOffset = vttCCs.ccOffset;
      const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 9e4;
      if (currCC != null && currCC.new) {
        if (timestampMapLOCAL !== void 0) {
          cueOffset = vttCCs.ccOffset = currCC.start;
        } else {
          calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
        }
      }
      if (webVttMpegTsMapOffset) {
        if (!initPTS) {
          parsingError = new Error("Missing initPTS for VTT MPEGTS");
          return;
        }
        cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
      }
      const duration = cue.endTime - cue.startTime;
      const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 9e4, timeOffset * 9e4) / 9e4;
      cue.startTime = Math.max(startTime, 0);
      cue.endTime = Math.max(startTime + duration, 0);
      const text = cue.text.trim();
      cue.text = decodeURIComponent(encodeURIComponent(text));
      if (!cue.id) {
        cue.id = generateCueId(cue.startTime, cue.endTime, text);
      }
      if (cue.endTime > 0) {
        cues.push(cue);
      }
    };
    parser.onparsingerror = function(error) {
      parsingError = error;
    };
    parser.onflush = function() {
      if (parsingError) {
        errorCallBack(parsingError);
        return;
      }
      callBack(cues);
    };
    vttLines.forEach((line) => {
      if (inHeader) {
        if (startsWith(line, "X-TIMESTAMP-MAP=")) {
          inHeader = false;
          line.slice(16).split(",").forEach((timestamp) => {
            if (startsWith(timestamp, "LOCAL:")) {
              cueTime = timestamp.slice(6);
            } else if (startsWith(timestamp, "MPEGTS:")) {
              timestampMapMPEGTS = parseInt(timestamp.slice(7));
            }
          });
          try {
            timestampMapLOCAL = cueString2millis(cueTime) / 1e3;
          } catch (error) {
            parsingError = error;
          }
          return;
        } else if (line === "") {
          inHeader = false;
        }
      }
      parser.parse(line + "\n");
    });
    parser.flush();
  }
  var IMSC1_CODEC = "stpp.ttml.im1t";
  var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
  var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
  var textAlignToLineAlign = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end"
  };
  function parseIMSC1(payload, initPTS, callBack, errorCallBack) {
    const results = findBox(new Uint8Array(payload), ["mdat"]);
    if (results.length === 0) {
      errorCallBack(new Error("Could not parse IMSC1 mdat"));
      return;
    }
    const ttmlList = results.map((mdat) => utf8ArrayToStr(mdat));
    const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);
    try {
      ttmlList.forEach((ttml) => callBack(parseTTML(ttml, syncTime)));
    } catch (error) {
      errorCallBack(error);
    }
  }
  function parseTTML(ttml, syncTime) {
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(ttml, "text/xml");
    const tt2 = xmlDoc.getElementsByTagName("tt")[0];
    if (!tt2) {
      throw new Error("Invalid ttml");
    }
    const defaultRateInfo = {
      frameRate: 30,
      subFrameRate: 1,
      frameRateMultiplier: 0,
      tickRate: 0
    };
    const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {
      result[key] = tt2.getAttribute(`ttp:${key}`) || defaultRateInfo[key];
      return result;
    }, {});
    const trim = tt2.getAttribute("xml:space") !== "preserve";
    const styleElements = collectionToDictionary(getElementCollection(tt2, "styling", "style"));
    const regionElements = collectionToDictionary(getElementCollection(tt2, "layout", "region"));
    const cueElements = getElementCollection(tt2, "body", "[begin]");
    return [].map.call(cueElements, (cueElement) => {
      const cueText = getTextContent(cueElement, trim);
      if (!cueText || !cueElement.hasAttribute("begin")) {
        return null;
      }
      const startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
      const duration = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
      let endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
      if (startTime === null) {
        throw timestampParsingError(cueElement);
      }
      if (endTime === null) {
        if (duration === null) {
          throw timestampParsingError(cueElement);
        }
        endTime = startTime + duration;
      }
      const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);
      cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);
      const region = regionElements[cueElement.getAttribute("region")];
      const style = styleElements[cueElement.getAttribute("style")];
      const styles = getTtmlStyles(region, style, styleElements);
      const {
        textAlign
      } = styles;
      if (textAlign) {
        const lineAlign = textAlignToLineAlign[textAlign];
        if (lineAlign) {
          cue.lineAlign = lineAlign;
        }
        cue.align = textAlign;
      }
      _extends2(cue, styles);
      return cue;
    }).filter((cue) => cue !== null);
  }
  function getElementCollection(fromElement, parentName, childName) {
    const parent = fromElement.getElementsByTagName(parentName)[0];
    if (parent) {
      return [].slice.call(parent.querySelectorAll(childName));
    }
    return [];
  }
  function collectionToDictionary(elementsWithId) {
    return elementsWithId.reduce((dict, element) => {
      const id = element.getAttribute("xml:id");
      if (id) {
        dict[id] = element;
      }
      return dict;
    }, {});
  }
  function getTextContent(element, trim) {
    return [].slice.call(element.childNodes).reduce((str, node, i2) => {
      var _node$childNodes;
      if (node.nodeName === "br" && i2) {
        return str + "\n";
      }
      if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {
        return getTextContent(node, trim);
      } else if (trim) {
        return str + node.textContent.trim().replace(/\s+/g, " ");
      }
      return str + node.textContent;
    }, "");
  }
  function getTtmlStyles(region, style, styleElements) {
    const ttsNs = "http://www.w3.org/ns/ttml#styling";
    let regionStyle = null;
    const styleAttributes = [
      "displayAlign",
      "textAlign",
      "color",
      "backgroundColor",
      "fontSize",
      "fontFamily"
    ];
    const regionStyleName = region != null && region.hasAttribute("style") ? region.getAttribute("style") : null;
    if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
      regionStyle = styleElements[regionStyleName];
    }
    return styleAttributes.reduce((styles, name) => {
      const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
      if (value) {
        styles[name] = value;
      }
      return styles;
    }, {});
  }
  function getAttributeNS(element, ns, name) {
    if (!element) {
      return null;
    }
    return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
  }
  function timestampParsingError(node) {
    return new Error(`Could not parse ttml timestamp ${node}`);
  }
  function parseTtmlTime(timeAttributeValue, rateInfo) {
    if (!timeAttributeValue) {
      return null;
    }
    let seconds = parseTimeStamp(timeAttributeValue);
    if (seconds === null) {
      if (HMSF_REGEX.test(timeAttributeValue)) {
        seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
      } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
        seconds = parseTimeUnits(timeAttributeValue, rateInfo);
      }
    }
    return seconds;
  }
  function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
    const m2 = HMSF_REGEX.exec(timeAttributeValue);
    const frames = (m2[4] | 0) + (m2[5] | 0) / rateInfo.subFrameRate;
    return (m2[1] | 0) * 3600 + (m2[2] | 0) * 60 + (m2[3] | 0) + frames / rateInfo.frameRate;
  }
  function parseTimeUnits(timeAttributeValue, rateInfo) {
    const m2 = TIME_UNIT_REGEX.exec(timeAttributeValue);
    const value = Number(m2[1]);
    const unit = m2[2];
    switch (unit) {
      case "h":
        return value * 3600;
      case "m":
        return value * 60;
      case "ms":
        return value * 1e3;
      case "f":
        return value / rateInfo.frameRate;
      case "t":
        return value / rateInfo.tickRate;
    }
    return value;
  }
  var TimelineController = class {
    constructor(hls) {
      this.hls = void 0;
      this.media = null;
      this.config = void 0;
      this.enabled = true;
      this.Cues = void 0;
      this.textTracks = [];
      this.tracks = [];
      this.initPTS = [];
      this.unparsedVttFrags = [];
      this.captionsTracks = {};
      this.nonNativeCaptionsTracks = {};
      this.cea608Parser1 = void 0;
      this.cea608Parser2 = void 0;
      this.lastSn = -1;
      this.lastPartIndex = -1;
      this.prevCC = -1;
      this.vttCCs = newVTTCCs();
      this.captionsProperties = void 0;
      this.hls = hls;
      this.config = hls.config;
      this.Cues = hls.config.cueHandler;
      this.captionsProperties = {
        textTrack1: {
          label: this.config.captionsTextTrack1Label,
          languageCode: this.config.captionsTextTrack1LanguageCode
        },
        textTrack2: {
          label: this.config.captionsTextTrack2Label,
          languageCode: this.config.captionsTextTrack2LanguageCode
        },
        textTrack3: {
          label: this.config.captionsTextTrack3Label,
          languageCode: this.config.captionsTextTrack3LanguageCode
        },
        textTrack4: {
          label: this.config.captionsTextTrack4Label,
          languageCode: this.config.captionsTextTrack4LanguageCode
        }
      };
      if (this.config.enableCEA708Captions) {
        const channel1 = new OutputFilter(this, "textTrack1");
        const channel2 = new OutputFilter(this, "textTrack2");
        const channel3 = new OutputFilter(this, "textTrack3");
        const channel4 = new OutputFilter(this, "textTrack4");
        this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);
        this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);
      }
      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
      hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
      hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
      hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    }
    destroy() {
      const {
        hls
      } = this;
      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
      hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
      hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
      hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
      hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
      hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
      hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
      hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
      this.hls = this.config = this.cea608Parser1 = this.cea608Parser2 = null;
    }
    addCues(trackName, startTime, endTime, screen, cueRanges) {
      let merged = false;
      for (let i2 = cueRanges.length; i2--; ) {
        const cueRange = cueRanges[i2];
        const overlap = intersection2(cueRange[0], cueRange[1], startTime, endTime);
        if (overlap >= 0) {
          cueRange[0] = Math.min(cueRange[0], startTime);
          cueRange[1] = Math.max(cueRange[1], endTime);
          merged = true;
          if (overlap / (endTime - startTime) > 0.5) {
            return;
          }
        }
      }
      if (!merged) {
        cueRanges.push([startTime, endTime]);
      }
      if (this.config.renderTextTracksNatively) {
        const track = this.captionsTracks[trackName];
        this.Cues.newCue(track, startTime, endTime, screen);
      } else {
        const cues = this.Cues.newCue(null, startTime, endTime, screen);
        this.hls.trigger(Events.CUES_PARSED, {
          type: "captions",
          cues,
          track: trackName
        });
      }
    }
    onInitPtsFound(event, {
      frag,
      id,
      initPTS,
      timescale
    }) {
      const {
        unparsedVttFrags
      } = this;
      if (id === "main") {
        this.initPTS[frag.cc] = {
          baseTime: initPTS,
          timescale
        };
      }
      if (unparsedVttFrags.length) {
        this.unparsedVttFrags = [];
        unparsedVttFrags.forEach((frag2) => {
          this.onFragLoaded(Events.FRAG_LOADED, frag2);
        });
      }
    }
    getExistingTrack(trackName) {
      const {
        media
      } = this;
      if (media) {
        for (let i2 = 0; i2 < media.textTracks.length; i2++) {
          const textTrack = media.textTracks[i2];
          if (textTrack[trackName]) {
            return textTrack;
          }
        }
      }
      return null;
    }
    createCaptionsTrack(trackName) {
      if (this.config.renderTextTracksNatively) {
        this.createNativeTrack(trackName);
      } else {
        this.createNonNativeTrack(trackName);
      }
    }
    createNativeTrack(trackName) {
      if (this.captionsTracks[trackName]) {
        return;
      }
      const {
        captionsProperties,
        captionsTracks,
        media
      } = this;
      const {
        label,
        languageCode
      } = captionsProperties[trackName];
      const existingTrack = this.getExistingTrack(trackName);
      if (!existingTrack) {
        const textTrack = this.createTextTrack("captions", label, languageCode);
        if (textTrack) {
          textTrack[trackName] = true;
          captionsTracks[trackName] = textTrack;
        }
      } else {
        captionsTracks[trackName] = existingTrack;
        clearCurrentCues(captionsTracks[trackName]);
        sendAddTrackEvent(captionsTracks[trackName], media);
      }
    }
    createNonNativeTrack(trackName) {
      if (this.nonNativeCaptionsTracks[trackName]) {
        return;
      }
      const trackProperties = this.captionsProperties[trackName];
      if (!trackProperties) {
        return;
      }
      const label = trackProperties.label;
      const track = {
        _id: trackName,
        label,
        kind: "captions",
        default: trackProperties.media ? !!trackProperties.media.default : false,
        closedCaptions: trackProperties.media
      };
      this.nonNativeCaptionsTracks[trackName] = track;
      this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
        tracks: [track]
      });
    }
    createTextTrack(kind, label, lang) {
      const media = this.media;
      if (!media) {
        return;
      }
      return media.addTextTrack(kind, label, lang);
    }
    onMediaAttaching(event, data) {
      this.media = data.media;
      this._cleanTracks();
    }
    onMediaDetaching() {
      const {
        captionsTracks
      } = this;
      Object.keys(captionsTracks).forEach((trackName) => {
        clearCurrentCues(captionsTracks[trackName]);
        delete captionsTracks[trackName];
      });
      this.nonNativeCaptionsTracks = {};
    }
    onManifestLoading() {
      this.lastSn = -1;
      this.lastPartIndex = -1;
      this.prevCC = -1;
      this.vttCCs = newVTTCCs();
      this._cleanTracks();
      this.tracks = [];
      this.captionsTracks = {};
      this.nonNativeCaptionsTracks = {};
      this.textTracks = [];
      this.unparsedVttFrags = [];
      this.initPTS = [];
      if (this.cea608Parser1 && this.cea608Parser2) {
        this.cea608Parser1.reset();
        this.cea608Parser2.reset();
      }
    }
    _cleanTracks() {
      const {
        media
      } = this;
      if (!media) {
        return;
      }
      const textTracks = media.textTracks;
      if (textTracks) {
        for (let i2 = 0; i2 < textTracks.length; i2++) {
          clearCurrentCues(textTracks[i2]);
        }
      }
    }
    onSubtitleTracksUpdated(event, data) {
      const tracks = data.subtitleTracks || [];
      const hasIMSC1 = tracks.some((track) => track.textCodec === IMSC1_CODEC);
      if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
        const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);
        if (listIsIdentical) {
          this.tracks = tracks;
          return;
        }
        this.textTracks = [];
        this.tracks = tracks;
        if (this.config.renderTextTracksNatively) {
          const inUseTracks = this.media ? this.media.textTracks : null;
          this.tracks.forEach((track, index2) => {
            let textTrack;
            if (inUseTracks && index2 < inUseTracks.length) {
              let inUseTrack = null;
              for (let i2 = 0; i2 < inUseTracks.length; i2++) {
                if (canReuseVttTextTrack(inUseTracks[i2], track)) {
                  inUseTrack = inUseTracks[i2];
                  break;
                }
              }
              if (inUseTrack) {
                textTrack = inUseTrack;
              }
            }
            if (textTrack) {
              clearCurrentCues(textTrack);
            } else {
              const textTrackKind = this._captionsOrSubtitlesFromCharacteristics(track);
              textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);
              if (textTrack) {
                textTrack.mode = "disabled";
              }
            }
            if (textTrack) {
              textTrack.groupId = track.groupId;
              this.textTracks.push(textTrack);
            }
          });
        } else if (this.tracks.length) {
          const tracksList = this.tracks.map((track) => {
            return {
              label: track.name,
              kind: track.type.toLowerCase(),
              default: track.default,
              subtitleTrack: track
            };
          });
          this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: tracksList
          });
        }
      }
    }
    _captionsOrSubtitlesFromCharacteristics(track) {
      if (track.attrs.CHARACTERISTICS) {
        const transcribesSpokenDialog = /transcribes-spoken-dialog/gi.test(track.attrs.CHARACTERISTICS);
        const describesMusicAndSound = /describes-music-and-sound/gi.test(track.attrs.CHARACTERISTICS);
        if (transcribesSpokenDialog && describesMusicAndSound) {
          return "captions";
        }
      }
      return "subtitles";
    }
    onManifestLoaded(event, data) {
      if (this.config.enableCEA708Captions && data.captions) {
        data.captions.forEach((captionsTrack) => {
          const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
          if (!instreamIdMatch) {
            return;
          }
          const trackName = `textTrack${instreamIdMatch[1]}`;
          const trackProperties = this.captionsProperties[trackName];
          if (!trackProperties) {
            return;
          }
          trackProperties.label = captionsTrack.name;
          if (captionsTrack.lang) {
            trackProperties.languageCode = captionsTrack.lang;
          }
          trackProperties.media = captionsTrack;
        });
      }
    }
    closedCaptionsForLevel(frag) {
      const level = this.hls.levels[frag.level];
      return level == null ? void 0 : level.attrs["CLOSED-CAPTIONS"];
    }
    onFragLoading(event, data) {
      const {
        cea608Parser1,
        cea608Parser2,
        lastSn,
        lastPartIndex
      } = this;
      if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
        return;
      }
      if (data.frag.type === PlaylistLevelType.MAIN) {
        var _data$part$index, _data$part;
        const sn2 = data.frag.sn;
        const partIndex = (_data$part$index = data == null ? void 0 : (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;
        if (!(sn2 === lastSn + 1 || sn2 === lastSn && partIndex === lastPartIndex + 1)) {
          cea608Parser1.reset();
          cea608Parser2.reset();
        }
        this.lastSn = sn2;
        this.lastPartIndex = partIndex;
      }
    }
    onFragLoaded(event, data) {
      const {
        frag,
        payload
      } = data;
      if (frag.type === PlaylistLevelType.SUBTITLE) {
        if (payload.byteLength) {
          const decryptData = frag.decryptdata;
          const decrypted = "stats" in data;
          if (decryptData == null || !decryptData.encrypted || decrypted) {
            const trackPlaylistMedia = this.tracks[frag.level];
            const vttCCs = this.vttCCs;
            if (!vttCCs[frag.cc]) {
              vttCCs[frag.cc] = {
                start: frag.start,
                prevCC: this.prevCC,
                new: true
              };
              this.prevCC = frag.cc;
            }
            if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {
              this._parseIMSC1(frag, payload);
            } else {
              this._parseVTTs(data);
            }
          }
        } else {
          this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
            success: false,
            frag,
            error: new Error("Empty subtitle payload")
          });
        }
      }
    }
    _parseIMSC1(frag, payload) {
      const hls = this.hls;
      parseIMSC1(payload, this.initPTS[frag.cc], (cues) => {
        this._appendCues(cues, frag.level);
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: true,
          frag
        });
      }, (error) => {
        logger.log(`Failed to parse IMSC1: ${error}`);
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag,
          error
        });
      });
    }
    _parseVTTs(data) {
      var _frag$initSegment;
      const {
        frag,
        payload
      } = data;
      const {
        initPTS,
        unparsedVttFrags
      } = this;
      const maxAvCC = initPTS.length - 1;
      if (!initPTS[frag.cc] && maxAvCC === -1) {
        unparsedVttFrags.push(data);
        return;
      }
      const hls = this.hls;
      const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;
      parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, (cues) => {
        this._appendCues(cues, frag.level);
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: true,
          frag
        });
      }, (error) => {
        const missingInitPTS = error.message === "Missing initPTS for VTT MPEGTS";
        if (missingInitPTS) {
          unparsedVttFrags.push(data);
        } else {
          this._fallbackToIMSC1(frag, payload);
        }
        logger.log(`Failed to parse VTT cue: ${error}`);
        if (missingInitPTS && maxAvCC > frag.cc) {
          return;
        }
        hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag,
          error
        });
      });
    }
    _fallbackToIMSC1(frag, payload) {
      const trackPlaylistMedia = this.tracks[frag.level];
      if (!trackPlaylistMedia.textCodec) {
        parseIMSC1(payload, this.initPTS[frag.cc], () => {
          trackPlaylistMedia.textCodec = IMSC1_CODEC;
          this._parseIMSC1(frag, payload);
        }, () => {
          trackPlaylistMedia.textCodec = "wvtt";
        });
      }
    }
    _appendCues(cues, fragLevel) {
      const hls = this.hls;
      if (this.config.renderTextTracksNatively) {
        const textTrack = this.textTracks[fragLevel];
        if (!textTrack || textTrack.mode === "disabled") {
          return;
        }
        cues.forEach((cue) => addCueToTrack(textTrack, cue));
      } else {
        const currentTrack = this.tracks[fragLevel];
        if (!currentTrack) {
          return;
        }
        const track = currentTrack.default ? "default" : "subtitles" + fragLevel;
        hls.trigger(Events.CUES_PARSED, {
          type: "subtitles",
          cues,
          track
        });
      }
    }
    onFragDecrypted(event, data) {
      const {
        frag
      } = data;
      if (frag.type === PlaylistLevelType.SUBTITLE) {
        this.onFragLoaded(Events.FRAG_LOADED, data);
      }
    }
    onSubtitleTracksCleared() {
      this.tracks = [];
      this.captionsTracks = {};
    }
    onFragParsingUserdata(event, data) {
      const {
        cea608Parser1,
        cea608Parser2
      } = this;
      if (!this.enabled || !(cea608Parser1 && cea608Parser2)) {
        return;
      }
      const {
        frag,
        samples
      } = data;
      if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
        return;
      }
      for (let i2 = 0; i2 < samples.length; i2++) {
        const ccBytes = samples[i2].bytes;
        if (ccBytes) {
          const ccdatas = this.extractCea608Data(ccBytes);
          cea608Parser1.addData(samples[i2].pts, ccdatas[0]);
          cea608Parser2.addData(samples[i2].pts, ccdatas[1]);
        }
      }
    }
    onBufferFlushing(event, {
      startOffset,
      endOffset,
      endOffsetSubtitles,
      type
    }) {
      const {
        media
      } = this;
      if (!media || media.currentTime < endOffset) {
        return;
      }
      if (!type || type === "video") {
        const {
          captionsTracks
        } = this;
        Object.keys(captionsTracks).forEach((trackName) => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));
      }
      if (this.config.renderTextTracksNatively) {
        if (startOffset === 0 && endOffsetSubtitles !== void 0) {
          const {
            textTracks
          } = this;
          Object.keys(textTracks).forEach((trackName) => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));
        }
      }
    }
    extractCea608Data(byteArray) {
      const actualCCBytes = [[], []];
      const count = byteArray[0] & 31;
      let position = 2;
      for (let j3 = 0; j3 < count; j3++) {
        const tmpByte = byteArray[position++];
        const ccbyte1 = 127 & byteArray[position++];
        const ccbyte2 = 127 & byteArray[position++];
        if (ccbyte1 === 0 && ccbyte2 === 0) {
          continue;
        }
        const ccValid = (4 & tmpByte) !== 0;
        if (ccValid) {
          const ccType = 3 & tmpByte;
          if (0 === ccType || 1 === ccType) {
            actualCCBytes[ccType].push(ccbyte1);
            actualCCBytes[ccType].push(ccbyte2);
          }
        }
      }
      return actualCCBytes;
    }
  };
  function canReuseVttTextTrack(inUseTrack, manifestTrack) {
    return !!inUseTrack && inUseTrack.label === manifestTrack.name && !(inUseTrack.textTrack1 || inUseTrack.textTrack2);
  }
  function intersection2(x1, x2, y1, y2) {
    return Math.min(x2, y2) - Math.max(x1, y1);
  }
  function newVTTCCs() {
    return {
      ccOffset: 0,
      presentationOffset: 0,
      0: {
        start: 0,
        prevCC: -1,
        new: true
      }
    };
  }
  var CapLevelController = class {
    constructor(hls) {
      this.hls = void 0;
      this.autoLevelCapping = void 0;
      this.firstLevel = void 0;
      this.media = void 0;
      this.restrictedLevels = void 0;
      this.timer = void 0;
      this.clientRect = void 0;
      this.streamController = void 0;
      this.hls = hls;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.firstLevel = -1;
      this.media = null;
      this.restrictedLevels = [];
      this.timer = void 0;
      this.clientRect = null;
      this.registerListeners();
    }
    setStreamController(streamController) {
      this.streamController = streamController;
    }
    destroy() {
      this.unregisterListener();
      if (this.hls.config.capLevelToPlayerSize) {
        this.stopCapping();
      }
      this.media = null;
      this.clientRect = null;
      this.hls = this.streamController = null;
    }
    registerListeners() {
      const {
        hls
      } = this;
      hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
      hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    unregisterListener() {
      const {
        hls
      } = this;
      hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
      hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
      hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    }
    onFpsDropLevelCapping(event, data) {
      const level = this.hls.levels[data.droppedLevel];
      if (this.isLevelAllowed(level)) {
        this.restrictedLevels.push({
          bitrate: level.bitrate,
          height: level.height,
          width: level.width
        });
      }
    }
    onMediaAttaching(event, data) {
      this.media = data.media instanceof HTMLVideoElement ? data.media : null;
      this.clientRect = null;
    }
    onManifestParsed(event, data) {
      const hls = this.hls;
      this.restrictedLevels = [];
      this.firstLevel = data.firstLevel;
      if (hls.config.capLevelToPlayerSize && data.video) {
        this.startCapping();
      }
    }
    onBufferCodecs(event, data) {
      const hls = this.hls;
      if (hls.config.capLevelToPlayerSize && data.video) {
        this.startCapping();
      }
    }
    onMediaDetaching() {
      this.stopCapping();
    }
    detectPlayerSize() {
      if (this.media && this.mediaHeight > 0 && this.mediaWidth > 0) {
        const levels = this.hls.levels;
        if (levels.length) {
          const hls = this.hls;
          hls.autoLevelCapping = this.getMaxLevel(levels.length - 1);
          if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
            this.streamController.nextLevelSwitch();
          }
          this.autoLevelCapping = hls.autoLevelCapping;
        }
      }
    }
    getMaxLevel(capLevelIndex) {
      const levels = this.hls.levels;
      if (!levels.length) {
        return -1;
      }
      const validLevels = levels.filter((level, index2) => this.isLevelAllowed(level) && index2 <= capLevelIndex);
      this.clientRect = null;
      return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
    }
    startCapping() {
      if (this.timer) {
        return;
      }
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      this.hls.firstLevel = this.getMaxLevel(this.firstLevel);
      self.clearInterval(this.timer);
      this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3);
      this.detectPlayerSize();
    }
    stopCapping() {
      this.restrictedLevels = [];
      this.firstLevel = -1;
      this.autoLevelCapping = Number.POSITIVE_INFINITY;
      if (this.timer) {
        self.clearInterval(this.timer);
        this.timer = void 0;
      }
    }
    getDimensions() {
      if (this.clientRect) {
        return this.clientRect;
      }
      const media = this.media;
      const boundsRect = {
        width: 0,
        height: 0
      };
      if (media) {
        const clientRect = media.getBoundingClientRect();
        boundsRect.width = clientRect.width;
        boundsRect.height = clientRect.height;
        if (!boundsRect.width && !boundsRect.height) {
          boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
          boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
        }
      }
      this.clientRect = boundsRect;
      return boundsRect;
    }
    get mediaWidth() {
      return this.getDimensions().width * this.contentScaleFactor;
    }
    get mediaHeight() {
      return this.getDimensions().height * this.contentScaleFactor;
    }
    get contentScaleFactor() {
      let pixelRatio = 1;
      if (!this.hls.config.ignoreDevicePixelRatio) {
        try {
          pixelRatio = self.devicePixelRatio;
        } catch (e3) {
        }
      }
      return pixelRatio;
    }
    isLevelAllowed(level) {
      const restrictedLevels = this.restrictedLevels;
      return !restrictedLevels.some((restrictedLevel) => {
        return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
      });
    }
    static getMaxLevelByMediaSize(levels, width, height) {
      if (!(levels != null && levels.length)) {
        return -1;
      }
      const atGreatestBandwidth = (curLevel, nextLevel) => {
        if (!nextLevel) {
          return true;
        }
        return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
      };
      let maxLevelIndex = levels.length - 1;
      for (let i2 = 0; i2 < levels.length; i2 += 1) {
        const level = levels[i2];
        if ((level.width >= width || level.height >= height) && atGreatestBandwidth(level, levels[i2 + 1])) {
          maxLevelIndex = i2;
          break;
        }
      }
      return maxLevelIndex;
    }
  };
  var FPSController = class {
    constructor(hls) {
      this.hls = void 0;
      this.isVideoPlaybackQualityAvailable = false;
      this.timer = void 0;
      this.media = null;
      this.lastTime = void 0;
      this.lastDroppedFrames = 0;
      this.lastDecodedFrames = 0;
      this.streamController = void 0;
      this.hls = hls;
      this.registerListeners();
    }
    setStreamController(streamController) {
      this.streamController = streamController;
    }
    registerListeners() {
      this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    }
    unregisterListeners() {
      this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    }
    destroy() {
      if (this.timer) {
        clearInterval(this.timer);
      }
      this.unregisterListeners();
      this.isVideoPlaybackQualityAvailable = false;
      this.media = null;
    }
    onMediaAttaching(event, data) {
      const config = this.hls.config;
      if (config.capLevelOnFPSDrop) {
        const media = data.media instanceof self.HTMLVideoElement ? data.media : null;
        this.media = media;
        if (media && typeof media.getVideoPlaybackQuality === "function") {
          this.isVideoPlaybackQualityAvailable = true;
        }
        self.clearInterval(this.timer);
        this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
      }
    }
    checkFPS(video, decodedFrames, droppedFrames) {
      const currentTime = performance.now();
      if (decodedFrames) {
        if (this.lastTime) {
          const currentPeriod = currentTime - this.lastTime;
          const currentDropped = droppedFrames - this.lastDroppedFrames;
          const currentDecoded = decodedFrames - this.lastDecodedFrames;
          const droppedFPS = 1e3 * currentDropped / currentPeriod;
          const hls = this.hls;
          hls.trigger(Events.FPS_DROP, {
            currentDropped,
            currentDecoded,
            totalDroppedFrames: droppedFrames
          });
          if (droppedFPS > 0) {
            if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
              let currentLevel = hls.currentLevel;
              logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
              if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                currentLevel = currentLevel - 1;
                hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {
                  level: currentLevel,
                  droppedLevel: hls.currentLevel
                });
                hls.autoLevelCapping = currentLevel;
                this.streamController.nextLevelSwitch();
              }
            }
          }
        }
        this.lastTime = currentTime;
        this.lastDroppedFrames = droppedFrames;
        this.lastDecodedFrames = decodedFrames;
      }
    }
    checkFPSInterval() {
      const video = this.media;
      if (video) {
        if (this.isVideoPlaybackQualityAvailable) {
          const videoPlaybackQuality = video.getVideoPlaybackQuality();
          this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
        } else {
          this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
        }
      }
    }
  };
  var LOGGER_PREFIX = "[eme]";
  var EMEController = class {
    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = null;
      this.keyFormatPromise = null;
      this.keySystemAccessPromises = {};
      this._requestLicenseFailureCount = 0;
      this.mediaKeySessions = [];
      this.keyIdToKeySessionPromise = {};
      this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];
      this.onMediaEncrypted = this._onMediaEncrypted.bind(this);
      this.onWaitingForKey = this._onWaitingForKey.bind(this);
      this.debug = logger.debug.bind(logger, LOGGER_PREFIX);
      this.log = logger.log.bind(logger, LOGGER_PREFIX);
      this.warn = logger.warn.bind(logger, LOGGER_PREFIX);
      this.error = logger.error.bind(logger, LOGGER_PREFIX);
      this.hls = hls;
      this.config = hls.config;
      this.registerListeners();
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetached();
      const config = this.config;
      config.requestMediaKeySystemAccessFunc = null;
      config.licenseXhrSetup = config.licenseResponseCallback = void 0;
      config.drmSystems = config.drmSystemOptions = {};
      this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;
      this.config = null;
    }
    registerListeners() {
      this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    unregisterListeners() {
      this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    }
    getLicenseServerUrl(keySystem) {
      const {
        drmSystems,
        widevineLicenseUrl
      } = this.config;
      const keySystemConfiguration = drmSystems[keySystem];
      if (keySystemConfiguration) {
        return keySystemConfiguration.licenseUrl;
      }
      if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {
        return widevineLicenseUrl;
      }
      throw new Error(`no license server URL configured for key-system "${keySystem}"`);
    }
    getServerCertificateUrl(keySystem) {
      const {
        drmSystems
      } = this.config;
      const keySystemConfiguration = drmSystems[keySystem];
      if (keySystemConfiguration) {
        return keySystemConfiguration.serverCertificateUrl;
      } else {
        this.log(`No Server Certificate in config.drmSystems["${keySystem}"]`);
      }
    }
    attemptKeySystemAccess(keySystemsToAttempt) {
      const levels = this.hls.levels;
      const uniqueCodec = (value, i2, a2) => !!value && a2.indexOf(value) === i2;
      const audioCodecs = levels.map((level) => level.audioCodec).filter(uniqueCodec);
      const videoCodecs = levels.map((level) => level.videoCodec).filter(uniqueCodec);
      if (audioCodecs.length + videoCodecs.length === 0) {
        videoCodecs.push("avc1.42e01e");
      }
      return new Promise((resolve, reject) => {
        const attempt = (keySystems) => {
          const keySystem = keySystems.shift();
          this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then((mediaKeys) => resolve({
            keySystem,
            mediaKeys
          })).catch((error) => {
            if (keySystems.length) {
              attempt(keySystems);
            } else if (error instanceof EMEKeyError) {
              reject(error);
            } else {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                error,
                fatal: true
              }, error.message));
            }
          });
        };
        attempt(keySystemsToAttempt);
      });
    }
    requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
      const {
        requestMediaKeySystemAccessFunc
      } = this.config;
      if (!(typeof requestMediaKeySystemAccessFunc === "function")) {
        let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;
        if (requestMediaKeySystemAccess === null && self.location.protocol === "http:") {
          errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;
        }
        return Promise.reject(new Error(errMessage));
      }
      return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
    }
    getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
      const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);
      const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
      let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;
      if (!keySystemAccess) {
        this.log(`Requesting encrypted media "${keySystem}" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);
        keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
        const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
          keySystemAccess
        };
        keySystemAccess.catch((error) => {
          this.log(`Failed to obtain access to key-system "${keySystem}": ${error}`);
        });
        return keySystemAccess.then((mediaKeySystemAccess) => {
          this.log(`Access for key-system "${mediaKeySystemAccess.keySystem}" obtained`);
          const certificateRequest = this.fetchServerCertificate(keySystem);
          this.log(`Create media-keys for "${keySystem}"`);
          _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then((mediaKeys) => {
            this.log(`Media-keys created for "${keySystem}"`);
            return certificateRequest.then((certificate) => {
              if (certificate) {
                return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);
              }
              return mediaKeys;
            });
          });
          _keySystemAccessPromises.mediaKeys.catch((error) => {
            this.error(`Failed to create media-keys for "${keySystem}"}: ${error}`);
          });
          return _keySystemAccessPromises.mediaKeys;
        });
      }
      return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);
    }
    createMediaKeySessionContext({
      decryptdata,
      keySystem,
      mediaKeys
    }) {
      this.log(`Creating key-system session "${keySystem}" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);
      const mediaKeysSession = mediaKeys.createSession();
      const mediaKeySessionContext = {
        decryptdata,
        keySystem,
        mediaKeys,
        mediaKeysSession,
        keyStatus: "status-pending"
      };
      this.mediaKeySessions.push(mediaKeySessionContext);
      return mediaKeySessionContext;
    }
    renewKeySession(mediaKeySessionContext) {
      const decryptdata = mediaKeySessionContext.decryptdata;
      if (decryptdata.pssh) {
        const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
        const keyId = this.getKeyIdString(decryptdata);
        const scheme = "cenc";
        this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "expired");
      } else {
        this.warn(`Could not renew expired session. Missing pssh initData.`);
      }
      this.removeSession(mediaKeySessionContext);
    }
    getKeyIdString(decryptdata) {
      if (!decryptdata) {
        throw new Error("Could not read keyId of undefined decryptdata");
      }
      if (decryptdata.keyId === null) {
        throw new Error("keyId is null");
      }
      return Hex.hexDump(decryptdata.keyId);
    }
    updateKeySession(mediaKeySessionContext, data) {
      var _mediaKeySessionConte;
      const keySession = mediaKeySessionContext.mediaKeysSession;
      this.log(`Updating key-session "${keySession.sessionId}" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}
      } (data length: ${data ? data.byteLength : data})`);
      return keySession.update(data);
    }
    selectKeySystemFormat(frag) {
      const keyFormats = Object.keys(frag.levelkeys || {});
      if (!this.keyFormatPromise) {
        this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(", ")}`);
        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
      }
      return this.keyFormatPromise;
    }
    getKeyFormatPromise(keyFormats) {
      return new Promise((resolve, reject) => {
        const keySystemsInConfig = getKeySystemsForConfig(this.config);
        const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter((value) => !!value && keySystemsInConfig.indexOf(value) !== -1);
        return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({
          keySystem
        }) => {
          const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);
          if (keySystemFormat) {
            resolve(keySystemFormat);
          } else {
            reject(new Error(`Unable to find format for key-system "${keySystem}"`));
          }
        }).catch(reject);
      });
    }
    loadKey(data) {
      const decryptdata = data.keyInfo.decryptdata;
      const keyId = this.getKeyIdString(decryptdata);
      const keyDetails = `(keyId: ${keyId} format: "${decryptdata.keyFormat}" method: ${decryptdata.method} uri: ${decryptdata.uri})`;
      this.log(`Starting session for key ${keyDetails}`);
      let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];
      if (!keySessionContextPromise) {
        keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({
          keySystem,
          mediaKeys
        }) => {
          this.throwIfDestroyed();
          this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);
          return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
            this.throwIfDestroyed();
            const keySessionContext = this.createMediaKeySessionContext({
              keySystem,
              mediaKeys,
              decryptdata
            });
            const scheme = "cenc";
            return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "playlist-key");
          });
        });
        keySessionContextPromise.catch((error) => this.handleError(error));
      }
      return keySessionContextPromise;
    }
    throwIfDestroyed(message = "Invalid state") {
      if (!this.hls) {
        throw new Error("invalid state");
      }
    }
    handleError(error) {
      if (!this.hls) {
        return;
      }
      this.error(error.message);
      if (error instanceof EMEKeyError) {
        this.hls.trigger(Events.ERROR, error.data);
      } else {
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
          error,
          fatal: true
        });
      }
    }
    getKeySystemForKeyPromise(decryptdata) {
      const keyId = this.getKeyIdString(decryptdata);
      const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
      if (!mediaKeySessionContext) {
        const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);
        const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);
        return this.attemptKeySystemAccess(keySystemsToAttempt);
      }
      return mediaKeySessionContext;
    }
    getKeySystemSelectionPromise(keySystemsToAttempt) {
      if (!keySystemsToAttempt.length) {
        keySystemsToAttempt = getKeySystemsForConfig(this.config);
      }
      if (keySystemsToAttempt.length === 0) {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
          fatal: true
        }, `Missing key-system license configuration options ${JSON.stringify({
          drmSystems: this.config.drmSystems
        })}`);
      }
      return this.attemptKeySystemAccess(keySystemsToAttempt);
    }
    _onMediaEncrypted(event) {
      const {
        initDataType,
        initData
      } = event;
      this.debug(`"${event.type}" event: init data type: "${initDataType}"`);
      if (initData === null) {
        return;
      }
      let keyId;
      let keySystemDomain;
      if (initDataType === "sinf" && this.config.drmSystems[KeySystems.FAIRPLAY]) {
        const json = bin2str(new Uint8Array(initData));
        try {
          const sinf = base64Decode(JSON.parse(json).sinf);
          const tenc = parseSinf(new Uint8Array(sinf));
          if (!tenc) {
            return;
          }
          keyId = tenc.subarray(8, 24);
          keySystemDomain = KeySystems.FAIRPLAY;
        } catch (error) {
          this.warn('Failed to parse sinf "encrypted" event message initData');
          return;
        }
      } else {
        const psshInfo = parsePssh(initData);
        if (psshInfo === null) {
          return;
        }
        if (psshInfo.version === 0 && psshInfo.systemId === KeySystemIds.WIDEVINE && psshInfo.data) {
          keyId = psshInfo.data.subarray(8, 24);
        }
        keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);
      }
      if (!keySystemDomain || !keyId) {
        return;
      }
      const keyIdHex = Hex.hexDump(keyId);
      const {
        keyIdToKeySessionPromise,
        mediaKeySessions
      } = this;
      let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
      for (let i2 = 0; i2 < mediaKeySessions.length; i2++) {
        const keyContext = mediaKeySessions[i2];
        const decryptdata = keyContext.decryptdata;
        if (decryptdata.pssh || !decryptdata.keyId) {
          continue;
        }
        const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);
        if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, "").indexOf(keyIdHex) !== -1) {
          keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
          delete keyIdToKeySessionPromise[oldKeyIdHex];
          decryptdata.pssh = new Uint8Array(initData);
          decryptdata.keyId = keyId;
          keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {
            return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, "encrypted-event-key-match");
          });
          break;
        }
      }
      if (!keySessionContextPromise) {
        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(({
          keySystem,
          mediaKeys
        }) => {
          var _keySystemToKeySystem;
          this.throwIfDestroyed();
          const decryptdata = new LevelKey("ISO-23001-7", keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : "");
          decryptdata.pssh = new Uint8Array(initData);
          decryptdata.keyId = keyId;
          return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
            this.throwIfDestroyed();
            const keySessionContext = this.createMediaKeySessionContext({
              decryptdata,
              keySystem,
              mediaKeys
            });
            return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, "encrypted-event-no-match");
          });
        });
      }
      keySessionContextPromise.catch((error) => this.handleError(error));
    }
    _onWaitingForKey(event) {
      this.log(`"${event.type}" event`);
    }
    attemptSetMediaKeys(keySystem, mediaKeys) {
      const queue = this.setMediaKeysQueue.slice();
      this.log(`Setting media-keys for "${keySystem}"`);
      const setMediaKeysPromise = Promise.all(queue).then(() => {
        if (!this.media) {
          throw new Error("Attempted to set mediaKeys without media element attached");
        }
        return this.media.setMediaKeys(mediaKeys);
      });
      this.setMediaKeysQueue.push(setMediaKeysPromise);
      return setMediaKeysPromise.then(() => {
        this.log(`Media-keys set for "${keySystem}"`);
        queue.push(setMediaKeysPromise);
        this.setMediaKeysQueue = this.setMediaKeysQueue.filter((p2) => queue.indexOf(p2) === -1);
      });
    }
    generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {
      var _this$config$drmSyste, _this$config$drmSyste2;
      const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;
      if (generateRequestFilter) {
        try {
          const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);
          if (!mappedInitData) {
            throw new Error("Invalid response from configured generateRequest filter");
          }
          initDataType = mappedInitData.initDataType;
          initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;
        } catch (error) {
          var _this$hls;
          this.warn(error.message);
          if ((_this$hls = this.hls) != null && _this$hls.config.debug) {
            throw error;
          }
        }
      }
      if (initData === null) {
        this.log(`Skipping key-session request for "${reason}" (no initData)`);
        return Promise.resolve(context);
      }
      const keyId = this.getKeyIdString(context.decryptdata);
      this.log(`Generating key-session request for "${reason}": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);
      const licenseStatus = new EventEmitter();
      context.mediaKeysSession.onmessage = (event) => {
        const keySession = context.mediaKeysSession;
        if (!keySession) {
          licenseStatus.emit("error", new Error("invalid state"));
          return;
        }
        const {
          messageType,
          message
        } = event;
        this.log(`"${messageType}" message event for session "${keySession.sessionId}" message size: ${message.byteLength}`);
        if (messageType === "license-request" || messageType === "license-renewal") {
          this.renewLicense(context, message).catch((error) => {
            this.handleError(error);
            licenseStatus.emit("error", error);
          });
        } else if (messageType === "license-release") {
          if (context.keySystem === KeySystems.FAIRPLAY) {
            this.updateKeySession(context, strToUtf8array("acknowledged"));
            this.removeSession(context);
          }
        } else {
          this.warn(`unhandled media key message type "${messageType}"`);
        }
      };
      context.mediaKeysSession.onkeystatuseschange = (event) => {
        const keySession = context.mediaKeysSession;
        if (!keySession) {
          licenseStatus.emit("error", new Error("invalid state"));
          return;
        }
        this.onKeyStatusChange(context);
        const keyStatus = context.keyStatus;
        licenseStatus.emit("keyStatus", keyStatus);
        if (keyStatus === "expired") {
          this.warn(`${context.keySystem} expired for key ${keyId}`);
          this.renewKeySession(context);
        }
      };
      const keyUsablePromise = new Promise((resolve, reject) => {
        licenseStatus.on("error", reject);
        licenseStatus.on("keyStatus", (keyStatus) => {
          if (keyStatus.startsWith("usable")) {
            resolve();
          } else if (keyStatus === "output-restricted") {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
              fatal: false
            }, "HDCP level output restricted"));
          } else if (keyStatus === "internal-error") {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
              fatal: true
            }, `key status changed to "${keyStatus}"`));
          } else if (keyStatus === "expired") {
            reject(new Error("key expired while generating request"));
          } else {
            this.warn(`unhandled key status change "${keyStatus}"`);
          }
        });
      });
      return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {
        var _context$mediaKeysSes;
        this.log(`Request generated for key-session "${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}" keyId: ${keyId}`);
      }).catch((error) => {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_NO_SESSION,
          error,
          fatal: false
        }, `Error generating key-session request: ${error}`);
      }).then(() => keyUsablePromise).catch((error) => {
        licenseStatus.removeAllListeners();
        this.removeSession(context);
        throw error;
      }).then(() => {
        licenseStatus.removeAllListeners();
        return context;
      });
    }
    onKeyStatusChange(mediaKeySessionContext) {
      mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status2, keyId) => {
        this.log(`key status change "${status2}" for keyStatuses keyId: ${Hex.hexDump("buffer" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);
        mediaKeySessionContext.keyStatus = status2;
      });
    }
    fetchServerCertificate(keySystem) {
      const config = this.config;
      const Loader = config.loader;
      const certLoader = new Loader(config);
      const url = this.getServerCertificateUrl(keySystem);
      if (!url) {
        return Promise.resolve();
      }
      this.log(`Fetching serverCertificate for "${keySystem}"`);
      return new Promise((resolve, reject) => {
        const loaderContext = {
          responseType: "arraybuffer",
          url
        };
        const loadPolicy = config.certLoadPolicy.default;
        const loaderConfig = {
          loadPolicy,
          timeout: loadPolicy.maxLoadTimeMs,
          maxRetry: 0,
          retryDelay: 0,
          maxRetryDelay: 0
        };
        const loaderCallbacks = {
          onSuccess: (response, stats, context, networkDetails) => {
            resolve(response.data);
          },
          onError: (response, contex, networkDetails, stats) => {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: true,
              networkDetails,
              response: _objectSpread22({
                url: loaderContext.url,
                data: void 0
              }, response)
            }, `"${keySystem}" certificate request failed (${url}). Status: ${response.code} (${response.text})`));
          },
          onTimeout: (stats, context, networkDetails) => {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
              fatal: true,
              networkDetails,
              response: {
                url: loaderContext.url,
                data: void 0
              }
            }, `"${keySystem}" certificate request timed out (${url})`));
          },
          onAbort: (stats, context, networkDetails) => {
            reject(new Error("aborted"));
          }
        };
        certLoader.load(loaderContext, loaderConfig, loaderCallbacks);
      });
    }
    setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
      return new Promise((resolve, reject) => {
        mediaKeys.setServerCertificate(cert).then((success) => {
          this.log(`setServerCertificate ${success ? "success" : "not supported by CDM"} (${cert == null ? void 0 : cert.byteLength}) on "${keySystem}"`);
          resolve(mediaKeys);
        }).catch((error) => {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
            error,
            fatal: true
          }, error.message));
        });
      });
    }
    renewLicense(context, keyMessage) {
      return this.requestLicense(context, new Uint8Array(keyMessage)).then((data) => {
        return this.updateKeySession(context, new Uint8Array(data)).catch((error) => {
          throw new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
            error,
            fatal: true
          }, error.message);
        });
      });
    }
    setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {
      const licenseXhrSetup = this.config.licenseXhrSetup;
      if (!licenseXhrSetup) {
        xhr.open("POST", url, true);
        return Promise.resolve({
          xhr,
          licenseChallenge
        });
      }
      return Promise.resolve().then(() => {
        if (!keysListItem.decryptdata) {
          throw new Error("Key removed");
        }
        return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
      }).catch((error) => {
        if (!keysListItem.decryptdata) {
          throw error;
        }
        xhr.open("POST", url, true);
        return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
      }).then((licenseXhrSetupResult) => {
        if (!xhr.readyState) {
          xhr.open("POST", url, true);
        }
        const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
        return {
          xhr,
          licenseChallenge: finalLicenseChallenge
        };
      });
    }
    requestLicense(keySessionContext, licenseChallenge) {
      const keyLoadPolicy = this.config.keyLoadPolicy.default;
      return new Promise((resolve, reject) => {
        const url = this.getLicenseServerUrl(keySessionContext.keySystem);
        this.log(`Sending license request to URL: ${url}`);
        const xhr = new XMLHttpRequest();
        xhr.responseType = "arraybuffer";
        xhr.onreadystatechange = () => {
          if (!this.hls || !keySessionContext.mediaKeysSession) {
            return reject(new Error("invalid state"));
          }
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              this._requestLicenseFailureCount = 0;
              let data = xhr.response;
              this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);
              const licenseResponseCallback = this.config.licenseResponseCallback;
              if (licenseResponseCallback) {
                try {
                  data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);
                } catch (error) {
                  this.error(error);
                }
              }
              resolve(data);
            } else {
              const retryConfig = keyLoadPolicy.errorRetry;
              const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;
              this._requestLicenseFailureCount++;
              if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {
                reject(new EMEKeyError({
                  type: ErrorTypes.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                  fatal: true,
                  networkDetails: xhr,
                  response: {
                    url,
                    data: void 0,
                    code: xhr.status,
                    text: xhr.statusText
                  }
                }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));
              } else {
                const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;
                this.warn(`Retrying license request, ${attemptsLeft} attempts left`);
                this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
              }
            }
          }
        };
        if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
          keySessionContext.licenseXhr.abort();
        }
        keySessionContext.licenseXhr = xhr;
        this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({
          xhr: xhr2,
          licenseChallenge: licenseChallenge2
        }) => {
          xhr2.send(licenseChallenge2);
        });
      });
    }
    onMediaAttached(event, data) {
      if (!this.config.emeEnabled) {
        return;
      }
      const media = data.media;
      this.media = media;
      media.addEventListener("encrypted", this.onMediaEncrypted);
      media.addEventListener("waitingforkey", this.onWaitingForKey);
    }
    onMediaDetached() {
      const media = this.media;
      const mediaKeysList = this.mediaKeySessions;
      if (media) {
        media.removeEventListener("encrypted", this.onMediaEncrypted);
        media.removeEventListener("waitingforkey", this.onWaitingForKey);
        this.media = null;
      }
      this._requestLicenseFailureCount = 0;
      this.setMediaKeysQueue = [];
      this.mediaKeySessions = [];
      this.keyIdToKeySessionPromise = {};
      LevelKey.clearKeyUriToKeyIdMap();
      const keySessionCount = mediaKeysList.length;
      EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map((mediaKeySessionContext) => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch((error) => {
        this.log(`Could not clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);
      }))).then(() => {
        if (keySessionCount) {
          this.log("finished closing key sessions and clearing media keys");
          mediaKeysList.length = 0;
        }
      }).catch((error) => {
        this.log(`Could not close sessions and clear media keys: ${error}. media.src: ${media == null ? void 0 : media.src}`);
      });
    }
    onManifestLoading() {
      this.keyFormatPromise = null;
    }
    onManifestLoaded(event, {
      sessionKeys
    }) {
      if (!sessionKeys || !this.config.emeEnabled) {
        return;
      }
      if (!this.keyFormatPromise) {
        const keyFormats = sessionKeys.reduce((formats, sessionKey) => {
          if (formats.indexOf(sessionKey.keyFormat) === -1) {
            formats.push(sessionKey.keyFormat);
          }
          return formats;
        }, []);
        this.log(`Selecting key-system from session-keys ${keyFormats.join(", ")}`);
        this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
      }
    }
    removeSession(mediaKeySessionContext) {
      const {
        mediaKeysSession,
        licenseXhr
      } = mediaKeySessionContext;
      if (mediaKeysSession) {
        this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);
        mediaKeysSession.onmessage = null;
        mediaKeysSession.onkeystatuseschange = null;
        if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
          licenseXhr.abort();
        }
        mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = void 0;
        const index2 = this.mediaKeySessions.indexOf(mediaKeySessionContext);
        if (index2 > -1) {
          this.mediaKeySessions.splice(index2, 1);
        }
        return mediaKeysSession.remove().catch((error) => {
          this.log(`Could not remove session: ${error}`);
        }).then(() => {
          return mediaKeysSession.close();
        }).catch((error) => {
          this.log(`Could not close session: ${error}`);
        });
      }
    }
  };
  EMEController.CDMCleanupPromise = void 0;
  var EMEKeyError = class extends Error {
    constructor(data, message) {
      super(message);
      this.data = void 0;
      data.error || (data.error = new Error(message));
      this.data = data;
      data.err = data.error;
    }
  };
  var CMCDVersion = 1;
  var CMCDObjectType = {
    MANIFEST: "m",
    AUDIO: "a",
    VIDEO: "v",
    MUXED: "av",
    INIT: "i",
    CAPTION: "c",
    TIMED_TEXT: "tt",
    KEY: "k",
    OTHER: "o"
  };
  var CMCDStreamingFormatHLS = "h";
  var CMCDController = class {
    constructor(hls) {
      this.hls = void 0;
      this.config = void 0;
      this.media = void 0;
      this.sid = void 0;
      this.cid = void 0;
      this.useHeaders = false;
      this.initialized = false;
      this.starved = false;
      this.buffering = true;
      this.audioBuffer = void 0;
      this.videoBuffer = void 0;
      this.onWaiting = () => {
        if (this.initialized) {
          this.starved = true;
        }
        this.buffering = true;
      };
      this.onPlaying = () => {
        if (!this.initialized) {
          this.initialized = true;
        }
        this.buffering = false;
      };
      this.applyPlaylistData = (context) => {
        try {
          this.apply(context, {
            ot: CMCDObjectType.MANIFEST,
            su: !this.initialized
          });
        } catch (error) {
          logger.warn("Could not generate manifest CMCD data.", error);
        }
      };
      this.applyFragmentData = (context) => {
        try {
          const fragment = context.frag;
          const level = this.hls.levels[fragment.level];
          const ot2 = this.getObjectType(fragment);
          const data = {
            d: fragment.duration * 1e3,
            ot: ot2
          };
          if (ot2 === CMCDObjectType.VIDEO || ot2 === CMCDObjectType.AUDIO || ot2 == CMCDObjectType.MUXED) {
            data.br = level.bitrate / 1e3;
            data.tb = this.getTopBandwidth(ot2) / 1e3;
            data.bl = this.getBufferLength(ot2);
          }
          this.apply(context, data);
        } catch (error) {
          logger.warn("Could not generate segment CMCD data.", error);
        }
      };
      this.hls = hls;
      const config = this.config = hls.config;
      const {
        cmcd
      } = config;
      if (cmcd != null) {
        config.pLoader = this.createPlaylistLoader();
        config.fLoader = this.createFragmentLoader();
        this.sid = cmcd.sessionId || CMCDController.uuid();
        this.cid = cmcd.contentId;
        this.useHeaders = cmcd.useHeaders === true;
        this.registerListeners();
      }
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
      hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
      hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
    }
    destroy() {
      this.unregisterListeners();
      this.onMediaDetached();
      this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
    }
    onMediaAttached(event, data) {
      this.media = data.media;
      this.media.addEventListener("waiting", this.onWaiting);
      this.media.addEventListener("playing", this.onPlaying);
    }
    onMediaDetached() {
      if (!this.media) {
        return;
      }
      this.media.removeEventListener("waiting", this.onWaiting);
      this.media.removeEventListener("playing", this.onPlaying);
      this.media = null;
    }
    onBufferCreated(event, data) {
      var _data$tracks$audio, _data$tracks$video;
      this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;
      this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;
    }
    createData() {
      var _this$media;
      return {
        v: CMCDVersion,
        sf: CMCDStreamingFormatHLS,
        sid: this.sid,
        cid: this.cid,
        pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,
        mtp: this.hls.bandwidthEstimate / 1e3
      };
    }
    apply(context, data = {}) {
      _extends2(data, this.createData());
      const isVideo = data.ot === CMCDObjectType.INIT || data.ot === CMCDObjectType.VIDEO || data.ot === CMCDObjectType.MUXED;
      if (this.starved && isVideo) {
        data.bs = true;
        data.su = true;
        this.starved = false;
      }
      if (data.su == null) {
        data.su = this.buffering;
      }
      if (this.useHeaders) {
        const headers = CMCDController.toHeaders(data);
        if (!Object.keys(headers).length) {
          return;
        }
        if (!context.headers) {
          context.headers = {};
        }
        _extends2(context.headers, headers);
      } else {
        const query = CMCDController.toQuery(data);
        if (!query) {
          return;
        }
        context.url = CMCDController.appendQueryToUri(context.url, query);
      }
    }
    getObjectType(fragment) {
      const {
        type
      } = fragment;
      if (type === "subtitle") {
        return CMCDObjectType.TIMED_TEXT;
      }
      if (fragment.sn === "initSegment") {
        return CMCDObjectType.INIT;
      }
      if (type === "audio") {
        return CMCDObjectType.AUDIO;
      }
      if (type === "main") {
        if (!this.hls.audioTracks.length) {
          return CMCDObjectType.MUXED;
        }
        return CMCDObjectType.VIDEO;
      }
      return void 0;
    }
    getTopBandwidth(type) {
      let bitrate = 0;
      let levels;
      const hls = this.hls;
      if (type === CMCDObjectType.AUDIO) {
        levels = hls.audioTracks;
      } else {
        const max2 = hls.maxAutoLevel;
        const len = max2 > -1 ? max2 + 1 : hls.levels.length;
        levels = hls.levels.slice(0, len);
      }
      for (const level of levels) {
        if (level.bitrate > bitrate) {
          bitrate = level.bitrate;
        }
      }
      return bitrate > 0 ? bitrate : NaN;
    }
    getBufferLength(type) {
      const media = this.hls.media;
      const buffer = type === CMCDObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
      if (!buffer || !media) {
        return NaN;
      }
      const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
      return info.len * 1e3;
    }
    createPlaylistLoader() {
      const {
        pLoader
      } = this.config;
      const apply = this.applyPlaylistData;
      const Ctor = pLoader || this.config.loader;
      return class CmcdPlaylistLoader {
        constructor(config) {
          this.loader = void 0;
          this.loader = new Ctor(config);
        }
        get stats() {
          return this.loader.stats;
        }
        get context() {
          return this.loader.context;
        }
        destroy() {
          this.loader.destroy();
        }
        abort() {
          this.loader.abort();
        }
        load(context, config, callbacks) {
          apply(context);
          this.loader.load(context, config, callbacks);
        }
      };
    }
    createFragmentLoader() {
      const {
        fLoader
      } = this.config;
      const apply = this.applyFragmentData;
      const Ctor = fLoader || this.config.loader;
      return class CmcdFragmentLoader {
        constructor(config) {
          this.loader = void 0;
          this.loader = new Ctor(config);
        }
        get stats() {
          return this.loader.stats;
        }
        get context() {
          return this.loader.context;
        }
        destroy() {
          this.loader.destroy();
        }
        abort() {
          this.loader.abort();
        }
        load(context, config, callbacks) {
          apply(context);
          this.loader.load(context, config, callbacks);
        }
      };
    }
    static uuid() {
      const url = URL.createObjectURL(new Blob());
      const uuid = url.toString();
      URL.revokeObjectURL(url);
      return uuid.slice(uuid.lastIndexOf("/") + 1);
    }
    static serialize(data) {
      const results = [];
      const isValid = (value) => !Number.isNaN(value) && value != null && value !== "" && value !== false;
      const toRounded = (value) => Math.round(value);
      const toHundred = (value) => toRounded(value / 100) * 100;
      const toUrlSafe = (value) => encodeURIComponent(value);
      const formatters = {
        br: toRounded,
        d: toRounded,
        bl: toHundred,
        dl: toHundred,
        mtp: toHundred,
        nor: toUrlSafe,
        rtp: toHundred,
        tb: toRounded
      };
      const keys = Object.keys(data || {}).sort();
      for (const key of keys) {
        let value = data[key];
        if (!isValid(value)) {
          continue;
        }
        if (key === "v" && value === 1) {
          continue;
        }
        if (key == "pr" && value === 1) {
          continue;
        }
        const formatter = formatters[key];
        if (formatter) {
          value = formatter(value);
        }
        const type = typeof value;
        let result;
        if (key === "ot" || key === "sf" || key === "st") {
          result = `${key}=${value}`;
        } else if (type === "boolean") {
          result = key;
        } else if (type === "number") {
          result = `${key}=${value}`;
        } else {
          result = `${key}=${JSON.stringify(value)}`;
        }
        results.push(result);
      }
      return results.join(",");
    }
    static toHeaders(data) {
      const keys = Object.keys(data);
      const headers = {};
      const headerNames = ["Object", "Request", "Session", "Status"];
      const headerGroups = [{}, {}, {}, {}];
      const headerMap = {
        br: 0,
        d: 0,
        ot: 0,
        tb: 0,
        bl: 1,
        dl: 1,
        mtp: 1,
        nor: 1,
        nrr: 1,
        su: 1,
        cid: 2,
        pr: 2,
        sf: 2,
        sid: 2,
        st: 2,
        v: 2,
        bs: 3,
        rtp: 3
      };
      for (const key of keys) {
        const index2 = headerMap[key] != null ? headerMap[key] : 1;
        headerGroups[index2][key] = data[key];
      }
      for (let i2 = 0; i2 < headerGroups.length; i2++) {
        const value = CMCDController.serialize(headerGroups[i2]);
        if (value) {
          headers[`CMCD-${headerNames[i2]}`] = value;
        }
      }
      return headers;
    }
    static toQuery(data) {
      return `CMCD=${encodeURIComponent(CMCDController.serialize(data))}`;
    }
    static appendQueryToUri(uri, query) {
      if (!query) {
        return uri;
      }
      const separator = uri.includes("?") ? "&" : "?";
      return `${uri}${separator}${query}`;
    }
  };
  var PATHWAY_PENALTY_DURATION_MS = 3e5;
  var ContentSteeringController = class {
    constructor(hls) {
      this.hls = void 0;
      this.log = void 0;
      this.loader = null;
      this.uri = null;
      this.pathwayId = ".";
      this.pathwayPriority = null;
      this.timeToLoad = 300;
      this.reloadTimer = -1;
      this.updated = 0;
      this.started = false;
      this.enabled = true;
      this.levels = null;
      this.audioTracks = null;
      this.subtitleTracks = null;
      this.penalizedPathways = {};
      this.hls = hls;
      this.log = logger.log.bind(logger, `[content-steering]:`);
      this.registerListeners();
    }
    registerListeners() {
      const hls = this.hls;
      hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.on(Events.ERROR, this.onError, this);
    }
    unregisterListeners() {
      const hls = this.hls;
      if (!hls) {
        return;
      }
      hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
      hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
      hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
      hls.off(Events.ERROR, this.onError, this);
    }
    startLoad() {
      this.started = true;
      self.clearTimeout(this.reloadTimer);
      if (this.enabled && this.uri) {
        if (this.updated) {
          const ttl = Math.max(this.timeToLoad * 1e3 - (performance.now() - this.updated), 0);
          this.scheduleRefresh(this.uri, ttl);
        } else {
          this.loadSteeringManifest(this.uri);
        }
      }
    }
    stopLoad() {
      this.started = false;
      if (this.loader) {
        this.loader.destroy();
        this.loader = null;
      }
      self.clearTimeout(this.reloadTimer);
    }
    destroy() {
      this.unregisterListeners();
      this.stopLoad();
      this.hls = null;
      this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    removeLevel(levelToRemove) {
      const levels = this.levels;
      if (levels) {
        this.levels = levels.filter((level) => level !== levelToRemove);
      }
    }
    onManifestLoading() {
      this.stopLoad();
      this.enabled = true;
      this.timeToLoad = 300;
      this.updated = 0;
      this.uri = null;
      this.pathwayId = ".";
      this.levels = this.audioTracks = this.subtitleTracks = null;
    }
    onManifestLoaded(event, data) {
      const {
        contentSteering
      } = data;
      if (contentSteering === null) {
        return;
      }
      this.pathwayId = contentSteering.pathwayId;
      this.uri = contentSteering.uri;
      if (this.started) {
        this.startLoad();
      }
    }
    onManifestParsed(event, data) {
      this.audioTracks = data.audioTracks;
      this.subtitleTracks = data.subtitleTracks;
    }
    onError(event, data) {
      const {
        errorAction
      } = data;
      if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
        let pathwayPriority = this.pathwayPriority;
        const pathwayId = this.pathwayId;
        if (!this.penalizedPathways[pathwayId]) {
          this.penalizedPathways[pathwayId] = performance.now();
        }
        if (!pathwayPriority && this.levels) {
          pathwayPriority = this.levels.reduce((pathways, level) => {
            if (pathways.indexOf(level.pathwayId) === -1) {
              pathways.push(level.pathwayId);
            }
            return pathways;
          }, []);
        }
        if (pathwayPriority && pathwayPriority.length > 1) {
          this.updatePathwayPriority(pathwayPriority);
          errorAction.resolved = this.pathwayId !== pathwayId;
        }
      }
    }
    filterParsedLevels(levels) {
      this.levels = levels;
      let pathwayLevels = this.getLevelsForPathway(this.pathwayId);
      if (pathwayLevels.length === 0) {
        const pathwayId = levels[0].pathwayId;
        this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${pathwayId}"`);
        pathwayLevels = this.getLevelsForPathway(pathwayId);
        this.pathwayId = pathwayId;
      }
      if (pathwayLevels.length !== levels.length) {
        this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway "${this.pathwayId}"`);
        return pathwayLevels;
      }
      return levels;
    }
    getLevelsForPathway(pathwayId) {
      if (this.levels === null) {
        return [];
      }
      return this.levels.filter((level) => pathwayId === level.pathwayId);
    }
    updatePathwayPriority(pathwayPriority) {
      this.pathwayPriority = pathwayPriority;
      let levels;
      const penalizedPathways = this.penalizedPathways;
      const now2 = performance.now();
      Object.keys(penalizedPathways).forEach((pathwayId) => {
        if (now2 - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {
          delete penalizedPathways[pathwayId];
        }
      });
      for (let i2 = 0; i2 < pathwayPriority.length; i2++) {
        const pathwayId = pathwayPriority[i2];
        if (penalizedPathways[pathwayId]) {
          continue;
        }
        if (pathwayId === this.pathwayId) {
          return;
        }
        const selectedIndex = this.hls.nextLoadLevel;
        const selectedLevel = this.hls.levels[selectedIndex];
        levels = this.getLevelsForPathway(pathwayId);
        if (levels.length > 0) {
          this.log(`Setting Pathway to "${pathwayId}"`);
          this.pathwayId = pathwayId;
          this.hls.trigger(Events.LEVELS_UPDATED, {
            levels
          });
          const levelAfterChange = this.hls.levels[selectedIndex];
          if (selectedLevel && levelAfterChange && this.levels) {
            if (levelAfterChange.attrs["STABLE-VARIANT-ID"] !== selectedLevel.attrs["STABLE-VARIANT-ID"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
              this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);
            }
            this.hls.nextLoadLevel = selectedIndex;
          }
          break;
        }
      }
    }
    clonePathways(pathwayClones) {
      const levels = this.levels;
      if (!levels) {
        return;
      }
      const audioGroupCloneMap = {};
      const subtitleGroupCloneMap = {};
      pathwayClones.forEach((pathwayClone) => {
        const {
          ID: cloneId,
          "BASE-ID": baseId,
          "URI-REPLACEMENT": uriReplacement
        } = pathwayClone;
        if (levels.some((level) => level.pathwayId === cloneId)) {
          return;
        }
        const clonedVariants = this.getLevelsForPathway(baseId).map((baseLevel) => {
          const levelParsed = _extends2({}, baseLevel);
          levelParsed.details = void 0;
          levelParsed.url = performUriReplacement(baseLevel.uri, baseLevel.attrs["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", uriReplacement);
          const attributes = new AttrList(baseLevel.attrs);
          attributes["PATHWAY-ID"] = cloneId;
          const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;
          const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;
          if (clonedAudioGroupId) {
            audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
            attributes.AUDIO = clonedAudioGroupId;
          }
          if (clonedSubtitleGroupId) {
            subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
            attributes.SUBTITLES = clonedSubtitleGroupId;
          }
          levelParsed.attrs = attributes;
          const clonedLevel = new Level(levelParsed);
          addGroupId(clonedLevel, "audio", clonedAudioGroupId);
          addGroupId(clonedLevel, "text", clonedSubtitleGroupId);
          return clonedLevel;
        });
        levels.push(...clonedVariants);
        cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
        cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
      });
    }
    loadSteeringManifest(uri) {
      const config = this.hls.config;
      const Loader = config.loader;
      if (this.loader) {
        this.loader.destroy();
      }
      this.loader = new Loader(config);
      let url;
      try {
        url = new self.URL(uri);
      } catch (error) {
        this.enabled = false;
        this.log(`Failed to parse Steering Manifest URI: ${uri}`);
        return;
      }
      if (url.protocol !== "data:") {
        const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;
        url.searchParams.set("_HLS_pathway", this.pathwayId);
        url.searchParams.set("_HLS_throughput", "" + throughput);
      }
      const context = {
        responseType: "json",
        url: url.href
      };
      const loadPolicy = config.steeringManifestLoadPolicy.default;
      const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
        retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
        maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
      };
      const callbacks = {
        onSuccess: (response, stats, context2, networkDetails) => {
          this.log(`Loaded steering manifest: "${url}"`);
          const steeringData = response.data;
          if (steeringData.VERSION !== 1) {
            this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);
            return;
          }
          this.updated = performance.now();
          this.timeToLoad = steeringData.TTL;
          const {
            "RELOAD-URI": reloadUri,
            "PATHWAY-CLONES": pathwayClones,
            "PATHWAY-PRIORITY": pathwayPriority
          } = steeringData;
          if (reloadUri) {
            try {
              this.uri = new self.URL(reloadUri, url).href;
            } catch (error) {
              this.enabled = false;
              this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);
              return;
            }
          }
          this.scheduleRefresh(this.uri || context2.url);
          if (pathwayClones) {
            this.clonePathways(pathwayClones);
          }
          if (pathwayPriority) {
            this.updatePathwayPriority(pathwayPriority);
          }
        },
        onError: (error, context2, networkDetails, stats) => {
          this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context2.url})`);
          this.stopLoad();
          if (error.code === 410) {
            this.enabled = false;
            this.log(`Steering manifest ${context2.url} no longer available`);
            return;
          }
          let ttl = this.timeToLoad * 1e3;
          if (error.code === 429) {
            const loader = this.loader;
            if (typeof (loader == null ? void 0 : loader.getResponseHeader) === "function") {
              const retryAfter = loader.getResponseHeader("Retry-After");
              if (retryAfter) {
                ttl = parseFloat(retryAfter) * 1e3;
              }
            }
            this.log(`Steering manifest ${context2.url} rate limited`);
            return;
          }
          this.scheduleRefresh(this.uri || context2.url, ttl);
        },
        onTimeout: (stats, context2, networkDetails) => {
          this.log(`Timeout loading steering manifest (${context2.url})`);
          this.scheduleRefresh(this.uri || context2.url);
        }
      };
      this.log(`Requesting steering manifest: ${url}`);
      this.loader.load(context, loaderConfig, callbacks);
    }
    scheduleRefresh(uri, ttlMs = this.timeToLoad * 1e3) {
      self.clearTimeout(this.reloadTimer);
      this.reloadTimer = self.setTimeout(() => {
        this.loadSteeringManifest(uri);
      }, ttlMs);
    }
  };
  function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
    if (!tracks) {
      return;
    }
    Object.keys(groupCloneMap).forEach((audioGroupId) => {
      const clonedTracks = tracks.filter((track) => track.groupId === audioGroupId).map((track) => {
        const clonedTrack = _extends2({}, track);
        clonedTrack.details = void 0;
        clonedTrack.attrs = new AttrList(clonedTrack.attrs);
        clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", uriReplacement);
        clonedTrack.groupId = clonedTrack.attrs["GROUP-ID"] = groupCloneMap[audioGroupId];
        clonedTrack.attrs["PATHWAY-ID"] = cloneId;
        return clonedTrack;
      });
      tracks.push(...clonedTracks);
    });
  }
  function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
    const {
      HOST: host,
      PARAMS: params,
      [perOptionKey]: perOptionUris
    } = uriReplacement;
    let perVariantUri;
    if (stableId) {
      perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];
      if (perVariantUri) {
        uri = perVariantUri;
      }
    }
    const url = new self.URL(uri);
    if (host && !perVariantUri) {
      url.host = host;
    }
    if (params) {
      Object.keys(params).sort().forEach((key) => {
        if (key) {
          url.searchParams.set(key, params[key]);
        }
      });
    }
    return url.href;
  }
  var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;
  var XhrLoader = class {
    constructor(config) {
      this.xhrSetup = void 0;
      this.requestTimeout = void 0;
      this.retryTimeout = void 0;
      this.retryDelay = void 0;
      this.config = null;
      this.callbacks = null;
      this.context = void 0;
      this.loader = null;
      this.stats = void 0;
      this.xhrSetup = config ? config.xhrSetup || null : null;
      this.stats = new LoadStats();
      this.retryDelay = 0;
    }
    destroy() {
      this.callbacks = null;
      this.abortInternal();
      this.loader = null;
      this.config = null;
    }
    abortInternal() {
      const loader = this.loader;
      self.clearTimeout(this.requestTimeout);
      self.clearTimeout(this.retryTimeout);
      if (loader) {
        loader.onreadystatechange = null;
        loader.onprogress = null;
        if (loader.readyState !== 4) {
          this.stats.aborted = true;
          loader.abort();
        }
      }
    }
    abort() {
      var _this$callbacks;
      this.abortInternal();
      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
        this.callbacks.onAbort(this.stats, this.context, this.loader);
      }
    }
    load(context, config, callbacks) {
      if (this.stats.loading.start) {
        throw new Error("Loader can only be used once.");
      }
      this.stats.loading.start = self.performance.now();
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.loadInternal();
    }
    loadInternal() {
      const {
        config,
        context
      } = this;
      if (!config) {
        return;
      }
      const xhr = this.loader = new self.XMLHttpRequest();
      const stats = this.stats;
      stats.loading.first = 0;
      stats.loaded = 0;
      stats.aborted = false;
      const xhrSetup = this.xhrSetup;
      if (xhrSetup) {
        Promise.resolve().then(() => {
          if (this.stats.aborted)
            return;
          return xhrSetup(xhr, context.url);
        }).catch((error) => {
          xhr.open("GET", context.url, true);
          return xhrSetup(xhr, context.url);
        }).then(() => {
          if (this.stats.aborted)
            return;
          this.openAndSendXhr(xhr, context, config);
        }).catch((error) => {
          this.callbacks.onError({
            code: xhr.status,
            text: error.message
          }, context, xhr, stats);
          return;
        });
      } else {
        this.openAndSendXhr(xhr, context, config);
      }
    }
    openAndSendXhr(xhr, context, config) {
      if (!xhr.readyState) {
        xhr.open("GET", context.url, true);
      }
      const headers = this.context.headers;
      const {
        maxTimeToFirstByteMs,
        maxLoadTimeMs
      } = config.loadPolicy;
      if (headers) {
        for (const header in headers) {
          xhr.setRequestHeader(header, headers[header]);
        }
      }
      if (context.rangeEnd) {
        xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
      }
      xhr.onreadystatechange = this.readystatechange.bind(this);
      xhr.onprogress = this.loadprogress.bind(this);
      xhr.responseType = context.responseType;
      self.clearTimeout(this.requestTimeout);
      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
      xhr.send();
    }
    readystatechange() {
      const {
        context,
        loader: xhr,
        stats
      } = this;
      if (!context || !xhr) {
        return;
      }
      const readyState = xhr.readyState;
      const config = this.config;
      if (stats.aborted) {
        return;
      }
      if (readyState >= 2) {
        if (stats.loading.first === 0) {
          stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
          if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {
            self.clearTimeout(this.requestTimeout);
            config.timeout = config.loadPolicy.maxLoadTimeMs;
            this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
          }
        }
        if (readyState === 4) {
          self.clearTimeout(this.requestTimeout);
          xhr.onreadystatechange = null;
          xhr.onprogress = null;
          const status2 = xhr.status;
          const useResponse = xhr.responseType !== "text";
          if (status2 >= 200 && status2 < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {
            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
            const data = useResponse ? xhr.response : xhr.responseText;
            const len = xhr.responseType === "arraybuffer" ? data.byteLength : data.length;
            stats.loaded = stats.total = len;
            stats.bwEstimate = stats.total * 8e3 / (stats.loading.end - stats.loading.first);
            if (!this.callbacks) {
              return;
            }
            const onProgress = this.callbacks.onProgress;
            if (onProgress) {
              onProgress(stats, context, data, xhr);
            }
            if (!this.callbacks) {
              return;
            }
            const response = {
              url: xhr.responseURL,
              data,
              code: status2
            };
            this.callbacks.onSuccess(response, stats, context, xhr);
          } else {
            const retryConfig = config.loadPolicy.errorRetry;
            const retryCount = stats.retry;
            if (shouldRetry(retryConfig, retryCount, false, status2)) {
              this.retry(retryConfig);
            } else {
              logger.error(`${status2} while loading ${context.url}`);
              this.callbacks.onError({
                code: status2,
                text: xhr.statusText
              }, context, xhr, stats);
            }
          }
        }
      }
    }
    loadtimeout() {
      var _this$config;
      const retryConfig = (_this$config = this.config) == null ? void 0 : _this$config.loadPolicy.timeoutRetry;
      const retryCount = this.stats.retry;
      if (shouldRetry(retryConfig, retryCount, true)) {
        this.retry(retryConfig);
      } else {
        logger.warn(`timeout while loading ${this.context.url}`);
        const callbacks = this.callbacks;
        if (callbacks) {
          this.abortInternal();
          callbacks.onTimeout(this.stats, this.context, this.loader);
        }
      }
    }
    retry(retryConfig) {
      const {
        context,
        stats
      } = this;
      this.retryDelay = getRetryDelay(retryConfig, stats.retry);
      stats.retry++;
      logger.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);
      this.abortInternal();
      this.loader = null;
      self.clearTimeout(this.retryTimeout);
      this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
    }
    loadprogress(event) {
      const stats = this.stats;
      stats.loaded = event.loaded;
      if (event.lengthComputable) {
        stats.total = event.total;
      }
    }
    getCacheAge() {
      let result = null;
      if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
        const ageHeader = this.loader.getResponseHeader("age");
        result = ageHeader ? parseFloat(ageHeader) : null;
      }
      return result;
    }
    getResponseHeader(name) {
      if (this.loader && new RegExp(`^${name}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders())) {
        return this.loader.getResponseHeader(name);
      }
      return null;
    }
  };
  function fetchSupported() {
    if (self.fetch && self.AbortController && self.ReadableStream && self.Request) {
      try {
        new self.ReadableStream({});
        return true;
      } catch (e3) {
      }
    }
    return false;
  }
  var BYTERANGE = /(\d+)-(\d+)\/(\d+)/;
  var FetchLoader = class {
    constructor(config) {
      this.fetchSetup = void 0;
      this.requestTimeout = void 0;
      this.request = void 0;
      this.response = void 0;
      this.controller = void 0;
      this.context = void 0;
      this.config = null;
      this.callbacks = null;
      this.stats = void 0;
      this.loader = null;
      this.fetchSetup = config.fetchSetup || getRequest;
      this.controller = new self.AbortController();
      this.stats = new LoadStats();
    }
    destroy() {
      this.loader = this.callbacks = null;
      this.abortInternal();
    }
    abortInternal() {
      const response = this.response;
      if (!(response != null && response.ok)) {
        this.stats.aborted = true;
        this.controller.abort();
      }
    }
    abort() {
      var _this$callbacks;
      this.abortInternal();
      if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
        this.callbacks.onAbort(this.stats, this.context, this.response);
      }
    }
    load(context, config, callbacks) {
      const stats = this.stats;
      if (stats.loading.start) {
        throw new Error("Loader can only be used once.");
      }
      stats.loading.start = self.performance.now();
      const initParams = getRequestParameters(context, this.controller.signal);
      const onProgress = callbacks.onProgress;
      const isArrayBuffer = context.responseType === "arraybuffer";
      const LENGTH = isArrayBuffer ? "byteLength" : "length";
      const {
        maxTimeToFirstByteMs,
        maxLoadTimeMs
      } = config.loadPolicy;
      this.context = context;
      this.config = config;
      this.callbacks = callbacks;
      this.request = this.fetchSetup(context, initParams);
      self.clearTimeout(this.requestTimeout);
      config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(() => {
        this.abortInternal();
        callbacks.onTimeout(stats, context, this.response);
      }, config.timeout);
      self.fetch(this.request).then((response) => {
        this.response = this.loader = response;
        const first = Math.max(self.performance.now(), stats.loading.start);
        self.clearTimeout(this.requestTimeout);
        config.timeout = maxLoadTimeMs;
        this.requestTimeout = self.setTimeout(() => {
          this.abortInternal();
          callbacks.onTimeout(stats, context, this.response);
        }, maxLoadTimeMs - (first - stats.loading.start));
        if (!response.ok) {
          const {
            status: status2,
            statusText
          } = response;
          throw new FetchError(statusText || "fetch, bad network response", status2, response);
        }
        stats.loading.first = first;
        stats.total = getContentLength(response.headers) || stats.total;
        if (onProgress && isFiniteNumber(config.highWaterMark)) {
          return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
        }
        if (isArrayBuffer) {
          return response.arrayBuffer();
        }
        if (context.responseType === "json") {
          return response.json();
        }
        return response.text();
      }).then((responseData) => {
        const {
          response
        } = this;
        self.clearTimeout(this.requestTimeout);
        stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
        const total = responseData[LENGTH];
        if (total) {
          stats.loaded = stats.total = total;
        }
        const loaderResponse = {
          url: response.url,
          data: responseData,
          code: response.status
        };
        if (onProgress && !isFiniteNumber(config.highWaterMark)) {
          onProgress(stats, context, responseData, response);
        }
        callbacks.onSuccess(loaderResponse, stats, context, response);
      }).catch((error) => {
        self.clearTimeout(this.requestTimeout);
        if (stats.aborted) {
          return;
        }
        const code = !error ? 0 : error.code || 0;
        const text = !error ? null : error.message;
        callbacks.onError({
          code,
          text
        }, context, error ? error.details : null, stats);
      });
    }
    getCacheAge() {
      let result = null;
      if (this.response) {
        const ageHeader = this.response.headers.get("age");
        result = ageHeader ? parseFloat(ageHeader) : null;
      }
      return result;
    }
    getResponseHeader(name) {
      return this.response ? this.response.headers.get(name) : null;
    }
    loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {
      const chunkCache = new ChunkCache();
      const reader = response.body.getReader();
      const pump = () => {
        return reader.read().then((data) => {
          if (data.done) {
            if (chunkCache.dataLength) {
              onProgress(stats, context, chunkCache.flush(), response);
            }
            return Promise.resolve(new ArrayBuffer(0));
          }
          const chunk = data.value;
          const len = chunk.length;
          stats.loaded += len;
          if (len < highWaterMark || chunkCache.dataLength) {
            chunkCache.push(chunk);
            if (chunkCache.dataLength >= highWaterMark) {
              onProgress(stats, context, chunkCache.flush(), response);
            }
          } else {
            onProgress(stats, context, chunk, response);
          }
          return pump();
        }).catch(() => {
          return Promise.reject();
        });
      };
      return pump();
    }
  };
  function getRequestParameters(context, signal) {
    const initParams = {
      method: "GET",
      mode: "cors",
      credentials: "same-origin",
      signal,
      headers: new self.Headers(_extends2({}, context.headers))
    };
    if (context.rangeEnd) {
      initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
    }
    return initParams;
  }
  function getByteRangeLength(byteRangeHeader) {
    const result = BYTERANGE.exec(byteRangeHeader);
    if (result) {
      return parseInt(result[2]) - parseInt(result[1]) + 1;
    }
  }
  function getContentLength(headers) {
    const contentRange = headers.get("Content-Range");
    if (contentRange) {
      const byteRangeLength = getByteRangeLength(contentRange);
      if (isFiniteNumber(byteRangeLength)) {
        return byteRangeLength;
      }
    }
    const contentLength = headers.get("Content-Length");
    if (contentLength) {
      return parseInt(contentLength);
    }
  }
  function getRequest(context, initParams) {
    return new self.Request(context.url, initParams);
  }
  var FetchError = class extends Error {
    constructor(message, code, details) {
      super(message);
      this.code = void 0;
      this.details = void 0;
      this.code = code;
      this.details = details;
    }
  };
  var WHITESPACE_CHAR = /\s/;
  var Cues = {
    newCue(track, startTime, endTime, captionScreen) {
      const result = [];
      let row;
      let cue;
      let indenting;
      let indent;
      let text;
      const Cue = self.VTTCue || self.TextTrackCue;
      for (let r2 = 0; r2 < captionScreen.rows.length; r2++) {
        row = captionScreen.rows[r2];
        indenting = true;
        indent = 0;
        text = "";
        if (!row.isEmpty()) {
          var _track$cues;
          for (let c2 = 0; c2 < row.chars.length; c2++) {
            if (WHITESPACE_CHAR.test(row.chars[c2].uchar) && indenting) {
              indent++;
            } else {
              text += row.chars[c2].uchar;
              indenting = false;
            }
          }
          row.cueStartTime = startTime;
          if (startTime === endTime) {
            endTime += 1e-4;
          }
          if (indent >= 16) {
            indent--;
          } else {
            indent++;
          }
          const cueText = fixLineBreaks(text.trim());
          const id = generateCueId(startTime, endTime, cueText);
          if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {
            cue = new Cue(startTime, endTime, cueText);
            cue.id = id;
            cue.line = r2 + 1;
            cue.align = "left";
            cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
            result.push(cue);
          }
        }
      }
      if (track && result.length) {
        result.sort((cueA, cueB) => {
          if (cueA.line === "auto" || cueB.line === "auto") {
            return 0;
          }
          if (cueA.line > 8 && cueB.line > 8) {
            return cueB.line - cueA.line;
          }
          return cueA.line - cueB.line;
        });
        result.forEach((cue2) => addCueToTrack(track, cue2));
      }
      return result;
    }
  };
  var defaultLoadPolicy = {
    maxTimeToFirstByteMs: 8e3,
    maxLoadTimeMs: 2e4,
    timeoutRetry: null,
    errorRetry: null
  };
  var hlsDefaultConfig = _objectSpread22(_objectSpread22({
    autoStartLoad: true,
    startPosition: -1,
    defaultAudioCodec: void 0,
    debug: false,
    capLevelOnFPSDrop: false,
    capLevelToPlayerSize: false,
    ignoreDevicePixelRatio: false,
    initialLiveManifestSize: 1,
    maxBufferLength: 30,
    backBufferLength: Infinity,
    maxBufferSize: 60 * 1e3 * 1e3,
    maxBufferHole: 0.1,
    highBufferWatchdogPeriod: 2,
    nudgeOffset: 0.1,
    nudgeMaxRetry: 3,
    maxFragLookUpTolerance: 0.25,
    liveSyncDurationCount: 3,
    liveMaxLatencyDurationCount: Infinity,
    liveSyncDuration: void 0,
    liveMaxLatencyDuration: void 0,
    maxLiveSyncPlaybackRate: 1,
    liveDurationInfinity: false,
    liveBackBufferLength: null,
    maxMaxBufferLength: 600,
    enableWorker: true,
    workerPath: null,
    enableSoftwareAES: true,
    startLevel: void 0,
    startFragPrefetch: false,
    fpsDroppedMonitoringPeriod: 5e3,
    fpsDroppedMonitoringThreshold: 0.2,
    appendErrorMaxRetry: 3,
    loader: XhrLoader,
    fLoader: void 0,
    pLoader: void 0,
    xhrSetup: void 0,
    licenseXhrSetup: void 0,
    licenseResponseCallback: void 0,
    abrController: AbrController,
    bufferController: BufferController,
    capLevelController: CapLevelController,
    errorController: ErrorController,
    fpsController: FPSController,
    stretchShortVideoTrack: false,
    maxAudioFramesDrift: 1,
    forceKeyFrameOnDiscontinuity: true,
    abrEwmaFastLive: 3,
    abrEwmaSlowLive: 9,
    abrEwmaFastVoD: 3,
    abrEwmaSlowVoD: 9,
    abrEwmaDefaultEstimate: 5e5,
    abrBandWidthFactor: 0.95,
    abrBandWidthUpFactor: 0.7,
    abrMaxWithRealBitrate: false,
    maxStarvationDelay: 4,
    maxLoadingDelay: 4,
    minAutoBitrate: 0,
    emeEnabled: false,
    widevineLicenseUrl: void 0,
    drmSystems: {},
    drmSystemOptions: {},
    requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,
    testBandwidth: true,
    progressive: false,
    lowLatencyMode: true,
    cmcd: void 0,
    enableDateRangeMetadataCues: true,
    enableEmsgMetadataCues: true,
    enableID3MetadataCues: true,
    certLoadPolicy: {
      default: defaultLoadPolicy
    },
    keyLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 8e3,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 2e4,
          backoff: "linear"
        },
        errorRetry: {
          maxNumRetry: 8,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 2e4,
          backoff: "linear"
        }
      }
    },
    manifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: Infinity,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    playlistLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 2,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    fragLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 12e4,
        timeoutRetry: {
          maxNumRetry: 4,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 6,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    steeringManifestLoadPolicy: {
      default: {
        maxTimeToFirstByteMs: 1e4,
        maxLoadTimeMs: 2e4,
        timeoutRetry: {
          maxNumRetry: 2,
          retryDelayMs: 0,
          maxRetryDelayMs: 0
        },
        errorRetry: {
          maxNumRetry: 1,
          retryDelayMs: 1e3,
          maxRetryDelayMs: 8e3
        }
      }
    },
    manifestLoadingTimeOut: 1e4,
    manifestLoadingMaxRetry: 1,
    manifestLoadingRetryDelay: 1e3,
    manifestLoadingMaxRetryTimeout: 64e3,
    levelLoadingTimeOut: 1e4,
    levelLoadingMaxRetry: 4,
    levelLoadingRetryDelay: 1e3,
    levelLoadingMaxRetryTimeout: 64e3,
    fragLoadingTimeOut: 2e4,
    fragLoadingMaxRetry: 6,
    fragLoadingRetryDelay: 1e3,
    fragLoadingMaxRetryTimeout: 64e3
  }, timelineConfig()), {}, {
    subtitleStreamController: SubtitleStreamController,
    subtitleTrackController: SubtitleTrackController,
    timelineController: TimelineController,
    audioStreamController: AudioStreamController,
    audioTrackController: AudioTrackController,
    emeController: EMEController,
    cmcdController: CMCDController,
    contentSteeringController: ContentSteeringController
  });
  function timelineConfig() {
    return {
      cueHandler: Cues,
      enableWebVTT: true,
      enableIMSC1: true,
      enableCEA708Captions: true,
      captionsTextTrack1Label: "English",
      captionsTextTrack1LanguageCode: "en",
      captionsTextTrack2Label: "Spanish",
      captionsTextTrack2LanguageCode: "es",
      captionsTextTrack3Label: "Unknown CC",
      captionsTextTrack3LanguageCode: "",
      captionsTextTrack4Label: "Unknown CC",
      captionsTextTrack4LanguageCode: "",
      renderTextTracksNatively: true
    };
  }
  function mergeConfig(defaultConfig, userConfig) {
    if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
      throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
    }
    if (userConfig.liveMaxLatencyDurationCount !== void 0 && (userConfig.liveSyncDurationCount === void 0 || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
    }
    if (userConfig.liveMaxLatencyDuration !== void 0 && (userConfig.liveSyncDuration === void 0 || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
      throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
    }
    const defaultsCopy = deepCpy(defaultConfig);
    const deprecatedSettingTypes = ["manifest", "level", "frag"];
    const deprecatedSettings = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
    deprecatedSettingTypes.forEach((type) => {
      const policyName = `${type === "level" ? "playlist" : type}LoadPolicy`;
      const policyNotSet = userConfig[policyName] === void 0;
      const report = [];
      deprecatedSettings.forEach((setting) => {
        const deprecatedSetting = `${type}Loading${setting}`;
        const value = userConfig[deprecatedSetting];
        if (value !== void 0 && policyNotSet) {
          report.push(deprecatedSetting);
          const settings = defaultsCopy[policyName].default;
          userConfig[policyName] = {
            default: settings
          };
          switch (setting) {
            case "TimeOut":
              settings.maxLoadTimeMs = value;
              settings.maxTimeToFirstByteMs = value;
              break;
            case "MaxRetry":
              settings.errorRetry.maxNumRetry = value;
              settings.timeoutRetry.maxNumRetry = value;
              break;
            case "RetryDelay":
              settings.errorRetry.retryDelayMs = value;
              settings.timeoutRetry.retryDelayMs = value;
              break;
            case "MaxRetryTimeout":
              settings.errorRetry.maxRetryDelayMs = value;
              settings.timeoutRetry.maxRetryDelayMs = value;
              break;
          }
        }
      });
      if (report.length) {
        logger.warn(`hls.js config: "${report.join('", "')}" setting(s) are deprecated, use "${policyName}": ${JSON.stringify(userConfig[policyName])}`);
      }
    });
    return _objectSpread22(_objectSpread22({}, defaultsCopy), userConfig);
  }
  function deepCpy(obj) {
    if (obj && typeof obj === "object") {
      if (Array.isArray(obj)) {
        return obj.map(deepCpy);
      }
      return Object.keys(obj).reduce((result, key) => {
        result[key] = deepCpy(obj[key]);
        return result;
      }, {});
    }
    return obj;
  }
  function enableStreamingMode(config) {
    const currentLoader = config.loader;
    if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {
      logger.log("[config]: Custom loader detected, cannot enable progressive streaming");
      config.progressive = false;
    } else {
      const canStreamProgressively = fetchSupported();
      if (canStreamProgressively) {
        config.loader = FetchLoader;
        config.progressive = true;
        config.enableSoftwareAES = true;
        logger.log("[config]: Progressive streaming enabled, using FetchLoader");
      }
    }
  }
  var Hls = class {
    static get version() {
      return "1.4.12";
    }
    static isSupported() {
      return isSupported();
    }
    static get Events() {
      return Events;
    }
    static get ErrorTypes() {
      return ErrorTypes;
    }
    static get ErrorDetails() {
      return ErrorDetails;
    }
    static get DefaultConfig() {
      if (!Hls.defaultConfig) {
        return hlsDefaultConfig;
      }
      return Hls.defaultConfig;
    }
    static set DefaultConfig(defaultConfig) {
      Hls.defaultConfig = defaultConfig;
    }
    constructor(userConfig = {}) {
      this.config = void 0;
      this.userConfig = void 0;
      this.coreComponents = void 0;
      this.networkControllers = void 0;
      this._emitter = new EventEmitter();
      this._autoLevelCapping = void 0;
      this._maxHdcpLevel = null;
      this.abrController = void 0;
      this.bufferController = void 0;
      this.capLevelController = void 0;
      this.latencyController = void 0;
      this.levelController = void 0;
      this.streamController = void 0;
      this.audioTrackController = void 0;
      this.subtitleTrackController = void 0;
      this.emeController = void 0;
      this.cmcdController = void 0;
      this._media = null;
      this.url = null;
      enableLogs(userConfig.debug || false, "Hls instance");
      const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);
      this.userConfig = userConfig;
      this._autoLevelCapping = -1;
      if (config.progressive) {
        enableStreamingMode(config);
      }
      const {
        abrController: ConfigAbrController,
        bufferController: ConfigBufferController,
        capLevelController: ConfigCapLevelController,
        errorController: ConfigErrorController,
        fpsController: ConfigFpsController
      } = config;
      const errorController = new ConfigErrorController(this);
      const abrController = this.abrController = new ConfigAbrController(this);
      const bufferController = this.bufferController = new ConfigBufferController(this);
      const capLevelController = this.capLevelController = new ConfigCapLevelController(this);
      const fpsController = new ConfigFpsController(this);
      const playListLoader = new PlaylistLoader(this);
      const id3TrackController = new ID3TrackController(this);
      const ConfigContentSteeringController = config.contentSteeringController;
      const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;
      const levelController = this.levelController = new LevelController(this, contentSteering);
      const fragmentTracker = new FragmentTracker(this);
      const keyLoader = new KeyLoader(this.config);
      const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);
      capLevelController.setStreamController(streamController);
      fpsController.setStreamController(streamController);
      const networkControllers = [playListLoader, levelController, streamController];
      if (contentSteering) {
        networkControllers.splice(1, 0, contentSteering);
      }
      this.networkControllers = networkControllers;
      const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
      this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
      const AudioStreamControllerClass = config.audioStreamController;
      if (AudioStreamControllerClass) {
        networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
      }
      this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
      const SubtitleStreamControllerClass = config.subtitleStreamController;
      if (SubtitleStreamControllerClass) {
        networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
      }
      this.createController(config.timelineController, coreComponents);
      keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
      this.cmcdController = this.createController(config.cmcdController, coreComponents);
      this.latencyController = this.createController(LatencyController, coreComponents);
      this.coreComponents = coreComponents;
      networkControllers.push(errorController);
      const onErrorOut = errorController.onErrorOut;
      if (typeof onErrorOut === "function") {
        this.on(Events.ERROR, onErrorOut, errorController);
      }
    }
    createController(ControllerClass, components) {
      if (ControllerClass) {
        const controllerInstance = new ControllerClass(this);
        if (components) {
          components.push(controllerInstance);
        }
        return controllerInstance;
      }
      return null;
    }
    on(event, listener, context = this) {
      this._emitter.on(event, listener, context);
    }
    once(event, listener, context = this) {
      this._emitter.once(event, listener, context);
    }
    removeAllListeners(event) {
      this._emitter.removeAllListeners(event);
    }
    off(event, listener, context = this, once) {
      this._emitter.off(event, listener, context, once);
    }
    listeners(event) {
      return this._emitter.listeners(event);
    }
    emit(event, name, eventObject) {
      return this._emitter.emit(event, name, eventObject);
    }
    trigger(event, eventObject) {
      if (this.config.debug) {
        return this.emit(event, event, eventObject);
      } else {
        try {
          return this.emit(event, event, eventObject);
        } catch (e3) {
          logger.error("An internal error happened while handling event " + event + '. Error message: "' + e3.message + '". Here is a stacktrace:', e3);
          this.trigger(Events.ERROR, {
            type: ErrorTypes.OTHER_ERROR,
            details: ErrorDetails.INTERNAL_EXCEPTION,
            fatal: false,
            event,
            error: e3
          });
        }
      }
      return false;
    }
    listenerCount(event) {
      return this._emitter.listenerCount(event);
    }
    destroy() {
      logger.log("destroy");
      this.trigger(Events.DESTROYING, void 0);
      this.detachMedia();
      this.removeAllListeners();
      this._autoLevelCapping = -1;
      this.url = null;
      this.networkControllers.forEach((component) => component.destroy());
      this.networkControllers.length = 0;
      this.coreComponents.forEach((component) => component.destroy());
      this.coreComponents.length = 0;
      const config = this.config;
      config.xhrSetup = config.fetchSetup = void 0;
      this.userConfig = null;
    }
    attachMedia(media) {
      logger.log("attachMedia");
      this._media = media;
      this.trigger(Events.MEDIA_ATTACHING, {
        media
      });
    }
    detachMedia() {
      logger.log("detachMedia");
      this.trigger(Events.MEDIA_DETACHING, void 0);
      this._media = null;
    }
    loadSource(url) {
      this.stopLoad();
      const media = this.media;
      const loadedSource = this.url;
      const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {
        alwaysNormalize: true
      });
      logger.log(`loadSource:${loadingSource}`);
      if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
        this.detachMedia();
        this.attachMedia(media);
      }
      this.trigger(Events.MANIFEST_LOADING, {
        url
      });
    }
    startLoad(startPosition = -1) {
      logger.log(`startLoad(${startPosition})`);
      this.networkControllers.forEach((controller) => {
        controller.startLoad(startPosition);
      });
    }
    stopLoad() {
      logger.log("stopLoad");
      this.networkControllers.forEach((controller) => {
        controller.stopLoad();
      });
    }
    swapAudioCodec() {
      logger.log("swapAudioCodec");
      this.streamController.swapAudioCodec();
    }
    recoverMediaError() {
      logger.log("recoverMediaError");
      const media = this._media;
      this.detachMedia();
      if (media) {
        this.attachMedia(media);
      }
    }
    removeLevel(levelIndex, urlId = 0) {
      this.levelController.removeLevel(levelIndex, urlId);
    }
    get levels() {
      const levels = this.levelController.levels;
      return levels ? levels : [];
    }
    get currentLevel() {
      return this.streamController.currentLevel;
    }
    set currentLevel(newLevel) {
      logger.log(`set currentLevel:${newLevel}`);
      this.loadLevel = newLevel;
      this.abrController.clearTimer();
      this.streamController.immediateLevelSwitch();
    }
    get nextLevel() {
      return this.streamController.nextLevel;
    }
    set nextLevel(newLevel) {
      logger.log(`set nextLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
      this.streamController.nextLevelSwitch();
    }
    get loadLevel() {
      return this.levelController.level;
    }
    set loadLevel(newLevel) {
      logger.log(`set loadLevel:${newLevel}`);
      this.levelController.manualLevel = newLevel;
    }
    get nextLoadLevel() {
      return this.levelController.nextLoadLevel;
    }
    set nextLoadLevel(level) {
      this.levelController.nextLoadLevel = level;
    }
    get firstLevel() {
      return Math.max(this.levelController.firstLevel, this.minAutoLevel);
    }
    set firstLevel(newLevel) {
      logger.log(`set firstLevel:${newLevel}`);
      this.levelController.firstLevel = newLevel;
    }
    get startLevel() {
      return this.levelController.startLevel;
    }
    set startLevel(newLevel) {
      logger.log(`set startLevel:${newLevel}`);
      if (newLevel !== -1) {
        newLevel = Math.max(newLevel, this.minAutoLevel);
      }
      this.levelController.startLevel = newLevel;
    }
    get capLevelToPlayerSize() {
      return this.config.capLevelToPlayerSize;
    }
    set capLevelToPlayerSize(shouldStartCapping) {
      const newCapLevelToPlayerSize = !!shouldStartCapping;
      if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
        if (newCapLevelToPlayerSize) {
          this.capLevelController.startCapping();
        } else {
          this.capLevelController.stopCapping();
          this.autoLevelCapping = -1;
          this.streamController.nextLevelSwitch();
        }
        this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
      }
    }
    get autoLevelCapping() {
      return this._autoLevelCapping;
    }
    get bandwidthEstimate() {
      const {
        bwEstimator
      } = this.abrController;
      if (!bwEstimator) {
        return NaN;
      }
      return bwEstimator.getEstimate();
    }
    get ttfbEstimate() {
      const {
        bwEstimator
      } = this.abrController;
      if (!bwEstimator) {
        return NaN;
      }
      return bwEstimator.getEstimateTTFB();
    }
    set autoLevelCapping(newLevel) {
      if (this._autoLevelCapping !== newLevel) {
        logger.log(`set autoLevelCapping:${newLevel}`);
        this._autoLevelCapping = newLevel;
      }
    }
    get maxHdcpLevel() {
      return this._maxHdcpLevel;
    }
    set maxHdcpLevel(value) {
      if (HdcpLevels.indexOf(value) > -1) {
        this._maxHdcpLevel = value;
      }
    }
    get autoLevelEnabled() {
      return this.levelController.manualLevel === -1;
    }
    get manualLevel() {
      return this.levelController.manualLevel;
    }
    get minAutoLevel() {
      const {
        levels,
        config: {
          minAutoBitrate
        }
      } = this;
      if (!levels)
        return 0;
      const len = levels.length;
      for (let i2 = 0; i2 < len; i2++) {
        if (levels[i2].maxBitrate >= minAutoBitrate) {
          return i2;
        }
      }
      return 0;
    }
    get maxAutoLevel() {
      const {
        levels,
        autoLevelCapping,
        maxHdcpLevel
      } = this;
      let maxAutoLevel;
      if (autoLevelCapping === -1 && levels && levels.length) {
        maxAutoLevel = levels.length - 1;
      } else {
        maxAutoLevel = autoLevelCapping;
      }
      if (maxHdcpLevel) {
        for (let i2 = maxAutoLevel; i2--; ) {
          const hdcpLevel = levels[i2].attrs["HDCP-LEVEL"];
          if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
            return i2;
          }
        }
      }
      return maxAutoLevel;
    }
    get nextAutoLevel() {
      return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel);
    }
    set nextAutoLevel(nextLevel) {
      this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, nextLevel);
    }
    get playingDate() {
      return this.streamController.currentProgramDateTime;
    }
    get mainForwardBufferInfo() {
      return this.streamController.getMainFwdBufferInfo();
    }
    get audioTracks() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTracks : [];
    }
    get audioTrack() {
      const audioTrackController = this.audioTrackController;
      return audioTrackController ? audioTrackController.audioTrack : -1;
    }
    set audioTrack(audioTrackId) {
      const audioTrackController = this.audioTrackController;
      if (audioTrackController) {
        audioTrackController.audioTrack = audioTrackId;
      }
    }
    get subtitleTracks() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
    }
    get subtitleTrack() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
    }
    get media() {
      return this._media;
    }
    set subtitleTrack(subtitleTrackId) {
      const subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleTrack = subtitleTrackId;
      }
    }
    get subtitleDisplay() {
      const subtitleTrackController = this.subtitleTrackController;
      return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
    }
    set subtitleDisplay(value) {
      const subtitleTrackController = this.subtitleTrackController;
      if (subtitleTrackController) {
        subtitleTrackController.subtitleDisplay = value;
      }
    }
    get lowLatencyMode() {
      return this.config.lowLatencyMode;
    }
    set lowLatencyMode(mode) {
      this.config.lowLatencyMode = mode;
    }
    get liveSyncPosition() {
      return this.latencyController.liveSyncPosition;
    }
    get latency() {
      return this.latencyController.latency;
    }
    get maxLatency() {
      return this.latencyController.maxLatency;
    }
    get targetLatency() {
      return this.latencyController.targetLatency;
    }
    get drift() {
      return this.latencyController.drift;
    }
    get forceStartLoad() {
      return this.streamController.forceStartLoad;
    }
  };
  Hls.defaultConfig = void 0;

  // node_modules/@samvera/clover-iiif/node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/@samvera/clover-iiif/node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i2 = 0; i2 < 256; ++i2) {
    byteToHex.push((i2 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset2 = 0) {
    return byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]];
  }

  // node_modules/@samvera/clover-iiif/node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // node_modules/@samvera/clover-iiif/node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset2) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (let i2 = 0; i2 < 16; ++i2) {
        buf[offset2 + i2] = rnds[i2];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // node_modules/@radix-ui/react-radio-group/dist/index.mjs
  var import_react84 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/primitive/dist/index.mjs
  function $e42e1063c40fb3ef$export$b9ecd428b558ff105(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react75 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef6(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af6(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef6(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d056(...refs) {
    return (0, import_react75.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af6(...refs), refs);
  }

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react76 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c16(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react76.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react76.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react76.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react76.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react76.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react76.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes6(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes6(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react76.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react78 = __toESM(require_react(), 1);
  var import_react_dom9 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react77 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac13606 = /* @__PURE__ */ (0, import_react77.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react77.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable6);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react77.Children.count(newElement) > 1)
            return import_react77.Children.only(null);
          return /* @__PURE__ */ (0, import_react77.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react77.createElement)($5e63c961fc1ce211$var$SlotClone6, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react77.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react77.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react77.createElement)($5e63c961fc1ce211$var$SlotClone6, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13606.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone6 = /* @__PURE__ */ (0, import_react77.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react77.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react77.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps6(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af6(forwardedRef, children.ref) : children.ref
      });
    return import_react77.Children.count(children) > 1 ? import_react77.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone6.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d456 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react77.createElement)(import_react77.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable6(child) {
    return /* @__PURE__ */ (0, import_react77.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d456;
  }
  function $5e63c961fc1ce211$var$mergeProps6(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES5 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0345 = $8927f6f2acc4f386$var$NODES5.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react78.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac13606 : node;
      (0, import_react78.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react78.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var import_react80 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react79 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a5(callback) {
    const callbackRef = (0, import_react79.useRef)(callback);
    (0, import_react79.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react79.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-radio-group/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  function $71cd76cc60e0454e$export$6f32135080cb4c35({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState5({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a5(onChange);
    const setValue = (0, import_react80.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState5({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react80.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react80.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a5(onChange);
    (0, import_react80.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-use-size/dist/index.mjs
  var import_react82 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-use-size/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var import_react81 = __toESM(require_react(), 1);
  var $9f79659886946c16$export$e5c5a5f917a5871c5 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react81.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-use-size/dist/index.mjs
  function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
    const [size2, setSize] = (0, import_react82.useState)(void 0);
    $9f79659886946c16$export$e5c5a5f917a5871c5(() => {
      if (element) {
        setSize({
          width: element.offsetWidth,
          height: element.offsetHeight
        });
        const resizeObserver = new ResizeObserver((entries) => {
          if (!Array.isArray(entries))
            return;
          if (!entries.length)
            return;
          const entry = entries[0];
          let width;
          let height;
          if ("borderBoxSize" in entry) {
            const borderSizeEntry = entry["borderBoxSize"];
            const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
            width = borderSize["inlineSize"];
            height = borderSize["blockSize"];
          } else {
            width = element.offsetWidth;
            height = element.offsetHeight;
          }
          setSize({
            width,
            height
          });
        });
        resizeObserver.observe(element, {
          box: "border-box"
        });
        return () => resizeObserver.unobserve(element);
      } else
        setSize(void 0);
    }, [
      element
    ]);
    return size2;
  }

  // node_modules/@radix-ui/react-use-previous/dist/index.mjs
  var import_react83 = __toESM(require_react(), 1);
  function $010c2913dbd2fe3d$export$5cae361ad82dce8b(value) {
    const ref = (0, import_react83.useRef)({
      value,
      previous: value
    });
    return (0, import_react83.useMemo)(() => {
      if (ref.current.value !== value) {
        ref.current.previous = ref.current.value;
        ref.current.value = value;
      }
      return ref.current.previous;
    }, [
      value
    ]);
  }

  // node_modules/@radix-ui/react-radio-group/dist/index.mjs
  var $ce77a8961b41be9e$var$RADIO_NAME = "Radio";
  var [$ce77a8961b41be9e$var$createRadioContext, $ce77a8961b41be9e$export$67d2296460f1b002] = $c512c27ab02ef895$export$50c7b4e9d9f19c16($ce77a8961b41be9e$var$RADIO_NAME);
  var [$ce77a8961b41be9e$var$RadioProvider, $ce77a8961b41be9e$var$useRadioContext] = $ce77a8961b41be9e$var$createRadioContext($ce77a8961b41be9e$var$RADIO_NAME);
  var $ce77a8961b41be9e$export$d7b12c4107be0d61 = /* @__PURE__ */ (0, import_react84.forwardRef)((props, forwardedRef) => {
    const { __scopeRadio, name, checked = false, required, disabled, value = "on", onCheck, ...radioProps } = props;
    const [button, setButton] = (0, import_react84.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d056(
      forwardedRef,
      (node) => setButton(node)
    );
    const hasConsumerStoppedPropagationRef = (0, import_react84.useRef)(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    return /* @__PURE__ */ (0, import_react84.createElement)($ce77a8961b41be9e$var$RadioProvider, {
      scope: __scopeRadio,
      checked,
      disabled
    }, /* @__PURE__ */ (0, import_react84.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0345.button, _extends({
      type: "button",
      role: "radio",
      "aria-checked": checked,
      "data-state": $ce77a8961b41be9e$var$getState(checked),
      "data-disabled": disabled ? "" : void 0,
      disabled,
      value
    }, radioProps, {
      ref: composedRefs,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff105(props.onClick, (event) => {
        if (!checked)
          onCheck === null || onCheck === void 0 || onCheck();
        if (isFormControl) {
          hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
          if (!hasConsumerStoppedPropagationRef.current)
            event.stopPropagation();
        }
      })
    })), isFormControl && /* @__PURE__ */ (0, import_react84.createElement)($ce77a8961b41be9e$var$BubbleInput, {
      control: button,
      bubbles: !hasConsumerStoppedPropagationRef.current,
      name,
      value,
      checked,
      required,
      disabled,
      style: {
        transform: "translateX(-100%)"
      }
    }));
  });
  var $ce77a8961b41be9e$var$BubbleInput = (props) => {
    const { control, checked, bubbles = true, ...inputProps } = props;
    const ref = (0, import_react84.useRef)(null);
    const prevChecked = $010c2913dbd2fe3d$export$5cae361ad82dce8b(checked);
    const controlSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(control);
    (0, import_react84.useEffect)(() => {
      const input = ref.current;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", {
          bubbles
        });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [
      prevChecked,
      checked,
      bubbles
    ]);
    return /* @__PURE__ */ (0, import_react84.createElement)("input", _extends({
      type: "radio",
      "aria-hidden": true,
      defaultChecked: checked
    }, inputProps, {
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }));
  };
  function $ce77a8961b41be9e$var$getState(checked) {
    return checked ? "checked" : "unchecked";
  }
  var $f99a8c78507165f7$var$ARROW_KEYS = [
    "ArrowUp",
    "ArrowDown",
    "ArrowLeft",
    "ArrowRight"
  ];
  var $f99a8c78507165f7$var$RADIO_GROUP_NAME = "RadioGroup";
  var [$f99a8c78507165f7$var$createRadioGroupContext, $f99a8c78507165f7$export$c547093f11b76da2] = $c512c27ab02ef895$export$50c7b4e9d9f19c16($f99a8c78507165f7$var$RADIO_GROUP_NAME, [
    $d7bdfb9eb0fdf311$export$c7109489551a4f4,
    $ce77a8961b41be9e$export$67d2296460f1b002
  ]);
  var $f99a8c78507165f7$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
  var $f99a8c78507165f7$var$useRadioScope = $ce77a8961b41be9e$export$67d2296460f1b002();
  var [$f99a8c78507165f7$var$RadioGroupProvider, $f99a8c78507165f7$var$useRadioGroupContext] = $f99a8c78507165f7$var$createRadioGroupContext($f99a8c78507165f7$var$RADIO_GROUP_NAME);
  var $f99a8c78507165f7$export$a98f0dcb43a68a25 = /* @__PURE__ */ (0, import_react84.forwardRef)((props, forwardedRef) => {
    const { __scopeRadioGroup, name, defaultValue, value: valueProp, required = false, disabled = false, orientation, dir, loop = true, onValueChange, ...groupProps } = props;
    const rovingFocusGroupScope = $f99a8c78507165f7$var$useRovingFocusGroupScope(__scopeRadioGroup);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c35({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    return /* @__PURE__ */ (0, import_react84.createElement)($f99a8c78507165f7$var$RadioGroupProvider, {
      scope: __scopeRadioGroup,
      name,
      required,
      disabled,
      value,
      onValueChange: setValue
    }, /* @__PURE__ */ (0, import_react84.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
      asChild: true
    }, rovingFocusGroupScope, {
      orientation,
      dir: direction,
      loop
    }), /* @__PURE__ */ (0, import_react84.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0345.div, _extends({
      role: "radiogroup",
      "aria-required": required,
      "aria-orientation": orientation,
      "data-disabled": disabled ? "" : void 0,
      dir: direction
    }, groupProps, {
      ref: forwardedRef
    }))));
  });
  var $f99a8c78507165f7$var$ITEM_NAME = "RadioGroupItem";
  var $f99a8c78507165f7$export$9f866c100ef519e4 = /* @__PURE__ */ (0, import_react84.forwardRef)((props, forwardedRef) => {
    const { __scopeRadioGroup, disabled, ...itemProps } = props;
    const context = $f99a8c78507165f7$var$useRadioGroupContext($f99a8c78507165f7$var$ITEM_NAME, __scopeRadioGroup);
    const isDisabled = context.disabled || disabled;
    const rovingFocusGroupScope = $f99a8c78507165f7$var$useRovingFocusGroupScope(__scopeRadioGroup);
    const radioScope = $f99a8c78507165f7$var$useRadioScope(__scopeRadioGroup);
    const ref = (0, import_react84.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d056(forwardedRef, ref);
    const checked = context.value === itemProps.value;
    const isArrowKeyPressedRef = (0, import_react84.useRef)(false);
    (0, import_react84.useEffect)(() => {
      const handleKeyDown = (event) => {
        if ($f99a8c78507165f7$var$ARROW_KEYS.includes(event.key))
          isArrowKeyPressedRef.current = true;
      };
      const handleKeyUp = () => isArrowKeyPressedRef.current = false;
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
      };
    }, []);
    return /* @__PURE__ */ (0, import_react84.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
      asChild: true
    }, rovingFocusGroupScope, {
      focusable: !isDisabled,
      active: checked
    }), /* @__PURE__ */ (0, import_react84.createElement)($ce77a8961b41be9e$export$d7b12c4107be0d61, _extends({
      disabled: isDisabled,
      required: context.required,
      checked
    }, radioScope, itemProps, {
      name: context.name,
      ref: composedRefs,
      onCheck: () => context.onValueChange(itemProps.value),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff105((event) => {
        if (event.key === "Enter")
          event.preventDefault();
      }),
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff105(itemProps.onFocus, () => {
        var _ref$current;
        if (isArrowKeyPressedRef.current)
          (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.click();
      })
    })));
  });
  var $f99a8c78507165f7$export$be92b6f5f03c0fe9 = $f99a8c78507165f7$export$a98f0dcb43a68a25;
  var $f99a8c78507165f7$export$6d08773d2e66f8f2 = $f99a8c78507165f7$export$9f866c100ef519e4;

  // node_modules/@samvera/clover-iiif/dist/viewer/index.mjs
  var import_node_webvtt = __toESM(require_node_webvtt(), 1);

  // node_modules/@radix-ui/react-popover/dist/index.mjs
  var import_react109 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/primitive/dist/index.mjs
  function $e42e1063c40fb3ef$export$b9ecd428b558ff106(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react85 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef7(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af7(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef7(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d057(...refs) {
    return (0, import_react85.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af7(...refs), refs);
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react86 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c17(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react86.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react86.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react86.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react86.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react86.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react86.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes7(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes7(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react86.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var import_react91 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react88 = __toESM(require_react(), 1);
  var import_react_dom10 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react87 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac13607 = /* @__PURE__ */ (0, import_react87.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react87.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable7);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react87.Children.count(newElement) > 1)
            return import_react87.Children.only(null);
          return /* @__PURE__ */ (0, import_react87.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react87.createElement)($5e63c961fc1ce211$var$SlotClone7, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react87.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react87.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react87.createElement)($5e63c961fc1ce211$var$SlotClone7, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13607.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone7 = /* @__PURE__ */ (0, import_react87.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react87.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react87.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps7(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af7(forwardedRef, children.ref) : children.ref
      });
    return import_react87.Children.count(children) > 1 ? import_react87.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone7.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d457 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react87.createElement)(import_react87.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable7(child) {
    return /* @__PURE__ */ (0, import_react87.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d457;
  }
  function $5e63c961fc1ce211$var$mergeProps7(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES6 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0346 = $8927f6f2acc4f386$var$NODES6.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react88.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac13607 : node;
      (0, import_react88.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react88.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});
  function $8927f6f2acc4f386$export$6d1a0317bde7de7f2(target, event) {
    if (target)
      (0, import_react_dom10.flushSync)(
        () => target.dispatchEvent(event)
      );
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react89 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(callback) {
    const callbackRef = (0, import_react89.useRef)(callback);
    (0, import_react89.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react89.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
  var import_react90 = __toESM(require_react(), 1);
  function $addc16e1bbe58fd0$export$3a72a57244d6e7652(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(onEscapeKeyDownProp);
    (0, import_react90.useEffect)(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape")
          onEscapeKeyDown(event);
      };
      ownerDocument.addEventListener("keydown", handleKeyDown);
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
    }, [
      onEscapeKeyDown,
      ownerDocument
    ]);
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var $5cb92bef7577960e$var$CONTEXT_UPDATE2 = "dismissableLayer.update";
  var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE2 = "dismissableLayer.pointerDownOutside";
  var $5cb92bef7577960e$var$FOCUS_OUTSIDE2 = "dismissableLayer.focusOutside";
  var $5cb92bef7577960e$var$originalBodyPointerEvents2;
  var $5cb92bef7577960e$var$DismissableLayerContext2 = /* @__PURE__ */ (0, import_react91.createContext)({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var $5cb92bef7577960e$export$177fb62ff3ec1f222 = /* @__PURE__ */ (0, import_react91.forwardRef)((props, forwardedRef) => {
    var _node$ownerDocument;
    const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
    const context = (0, import_react91.useContext)($5cb92bef7577960e$var$DismissableLayerContext2);
    const [node1, setNode] = (0, import_react91.useState)(null);
    const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
    const [, force] = (0, import_react91.useState)({});
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d057(
      forwardedRef,
      (node) => setNode(node)
    );
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [
      ...context.layersWithOutsidePointerEventsDisabled
    ].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node1 ? layers.indexOf(node1) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside2((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    }, ownerDocument);
    const focusOutside = $5cb92bef7577960e$var$useFocusOutside2((event) => {
      const target = event.target;
      const isFocusInBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (isFocusInBranch)
        return;
      onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    }, ownerDocument);
    $addc16e1bbe58fd0$export$3a72a57244d6e7652((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    (0, import_react91.useEffect)(() => {
      if (!node1)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          $5cb92bef7577960e$var$originalBodyPointerEvents2 = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node1);
      }
      context.layers.add(node1);
      $5cb92bef7577960e$var$dispatchUpdate2();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
          ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents2;
      };
    }, [
      node1,
      ownerDocument,
      disableOutsidePointerEvents,
      context
    ]);
    (0, import_react91.useEffect)(() => {
      return () => {
        if (!node1)
          return;
        context.layers.delete(node1);
        context.layersWithOutsidePointerEventsDisabled.delete(node1);
        $5cb92bef7577960e$var$dispatchUpdate2();
      };
    }, [
      node1,
      context
    ]);
    (0, import_react91.useEffect)(() => {
      const handleUpdate = () => force({});
      document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE2, handleUpdate);
      return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE2, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_react91.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0346.div, _extends({}, layerProps, {
      ref: composedRefs,
      style: {
        pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
        ...props.style
      },
      onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff106(props.onFocusCapture, focusOutside.onFocusCapture),
      onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff106(props.onBlurCapture, focusOutside.onBlurCapture),
      onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff106(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
    }));
  });
  function $5cb92bef7577960e$var$usePointerDownOutside2(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(onPointerDownOutside);
    const isPointerInsideReactTreeRef = (0, import_react91.useRef)(false);
    const handleClickRef = (0, import_react91.useRef)(() => {
    });
    (0, import_react91.useEffect)(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent = function() {
            $5cb92bef7577960e$var$handleAndDispatchCustomEvent2($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE2, handlePointerDownOutside, eventDetail, {
              discrete: true
            });
          };
          const eventDetail = {
            originalEvent: event
          };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
            ownerDocument.addEventListener("click", handleClickRef.current, {
              once: true
            });
          } else
            handleAndDispatchPointerDownOutsideEvent();
        } else
          ownerDocument.removeEventListener("click", handleClickRef.current);
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [
      ownerDocument,
      handlePointerDownOutside
    ]);
    return {
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function $5cb92bef7577960e$var$useFocusOutside2(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(onFocusOutside);
    const isFocusInsideReactTreeRef = (0, import_react91.useRef)(false);
    (0, import_react91.useEffect)(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = {
            originalEvent: event
          };
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent2($5cb92bef7577960e$var$FOCUS_OUTSIDE2, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [
      ownerDocument,
      handleFocusOutside
    ]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function $5cb92bef7577960e$var$dispatchUpdate2() {
    const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE2);
    document.dispatchEvent(event);
  }
  function $5cb92bef7577960e$var$handleAndDispatchCustomEvent2(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, {
      bubbles: false,
      cancelable: true,
      detail
    });
    if (handler)
      target.addEventListener(name, handler, {
        once: true
      });
    if (discrete)
      $8927f6f2acc4f386$export$6d1a0317bde7de7f2(target, event);
    else
      target.dispatchEvent(event);
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-focus-guards/dist/index.mjs
  var import_react92 = __toESM(require_react(), 1);
  var $3db38b7d1fb3fe6a$var$count2 = 0;
  function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c2() {
    (0, import_react92.useEffect)(() => {
      var _edgeGuards$, _edgeGuards$2;
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard2());
      document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard2());
      $3db38b7d1fb3fe6a$var$count2++;
      return () => {
        if ($3db38b7d1fb3fe6a$var$count2 === 1)
          document.querySelectorAll("[data-radix-focus-guard]").forEach(
            (node) => node.remove()
          );
        $3db38b7d1fb3fe6a$var$count2--;
      };
    }, []);
  }
  function $3db38b7d1fb3fe6a$var$createFocusGuard2() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
    return element;
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-focus-scope/dist/index.mjs
  var import_react93 = __toESM(require_react(), 1);
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT2 = "focusScope.autoFocusOnMount";
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT2 = "focusScope.autoFocusOnUnmount";
  var $d3863c46a17e8a28$var$EVENT_OPTIONS2 = {
    bubbles: false,
    cancelable: true
  };
  var $d3863c46a17e8a28$export$20e40289641fbbb62 = /* @__PURE__ */ (0, import_react93.forwardRef)((props, forwardedRef) => {
    const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
    const [container1, setContainer] = (0, import_react93.useState)(null);
    const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(onMountAutoFocusProp);
    const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(onUnmountAutoFocusProp);
    const lastFocusedElementRef = (0, import_react93.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d057(
      forwardedRef,
      (node) => setContainer(node)
    );
    const focusScope = (0, import_react93.useRef)({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    (0, import_react93.useEffect)(() => {
      if (trapped) {
        let handleFocusIn = function(event) {
          if (focusScope.paused || !container1)
            return;
          const target = event.target;
          if (container1.contains(target))
            lastFocusedElementRef.current = target;
          else
            $d3863c46a17e8a28$var$focus2(lastFocusedElementRef.current, {
              select: true
            });
        }, handleFocusOut = function(event) {
          if (focusScope.paused || !container1)
            return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null)
            return;
          if (!container1.contains(relatedTarget))
            $d3863c46a17e8a28$var$focus2(lastFocusedElementRef.current, {
              select: true
            });
        }, handleMutations = function(mutations) {
          const focusedElement = document.activeElement;
          if (focusedElement !== document.body)
            return;
          for (const mutation of mutations)
            if (mutation.removedNodes.length > 0)
              $d3863c46a17e8a28$var$focus2(container1);
        };
        document.addEventListener("focusin", handleFocusIn);
        document.addEventListener("focusout", handleFocusOut);
        const mutationObserver = new MutationObserver(handleMutations);
        if (container1)
          mutationObserver.observe(container1, {
            childList: true,
            subtree: true
          });
        return () => {
          document.removeEventListener("focusin", handleFocusIn);
          document.removeEventListener("focusout", handleFocusOut);
          mutationObserver.disconnect();
        };
      }
    }, [
      trapped,
      container1,
      focusScope.paused
    ]);
    (0, import_react93.useEffect)(() => {
      if (container1) {
        $d3863c46a17e8a28$var$focusScopesStack2.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT2, $d3863c46a17e8a28$var$EVENT_OPTIONS2);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT2, onMountAutoFocus);
          container1.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            $d3863c46a17e8a28$var$focusFirst2($d3863c46a17e8a28$var$removeLinks2($d3863c46a17e8a28$var$getTabbableCandidates2(container1)), {
              select: true
            });
            if (document.activeElement === previouslyFocusedElement)
              $d3863c46a17e8a28$var$focus2(container1);
          }
        }
        return () => {
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT2, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT2, $d3863c46a17e8a28$var$EVENT_OPTIONS2);
            container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT2, onUnmountAutoFocus);
            container1.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented)
              $d3863c46a17e8a28$var$focus2(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
                select: true
              });
            container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT2, onUnmountAutoFocus);
            $d3863c46a17e8a28$var$focusScopesStack2.remove(focusScope);
          }, 0);
        };
      }
    }, [
      container1,
      onMountAutoFocus,
      onUnmountAutoFocus,
      focusScope
    ]);
    const handleKeyDown = (0, import_react93.useCallback)((event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges2(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus2(first, {
                select: true
              });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus2(last, {
                select: true
              });
          }
        }
      }
    }, [
      loop,
      trapped,
      focusScope.paused
    ]);
    return /* @__PURE__ */ (0, import_react93.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0346.div, _extends({
      tabIndex: -1
    }, scopeProps, {
      ref: composedRefs,
      onKeyDown: handleKeyDown
    }));
  });
  function $d3863c46a17e8a28$var$focusFirst2(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      $d3863c46a17e8a28$var$focus2(candidate, {
        select
      });
      if (document.activeElement !== previouslyFocusedElement)
        return;
    }
  }
  function $d3863c46a17e8a28$var$getTabbableEdges2(container2) {
    const candidates = $d3863c46a17e8a28$var$getTabbableCandidates2(container2);
    const first = $d3863c46a17e8a28$var$findVisible2(candidates, container2);
    const last = $d3863c46a17e8a28$var$findVisible2(candidates.reverse(), container2);
    return [
      first,
      last
    ];
  }
  function $d3863c46a17e8a28$var$getTabbableCandidates2(container2) {
    const nodes = [];
    const walker = document.createTreeWalker(container2, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  }
  function $d3863c46a17e8a28$var$findVisible2(elements, container2) {
    for (const element of elements) {
      if (!$d3863c46a17e8a28$var$isHidden2(element, {
        upTo: container2
      }))
        return element;
    }
  }
  function $d3863c46a17e8a28$var$isHidden2(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden")
      return true;
    while (node) {
      if (upTo !== void 0 && node === upTo)
        return false;
      if (getComputedStyle(node).display === "none")
        return true;
      node = node.parentElement;
    }
    return false;
  }
  function $d3863c46a17e8a28$var$isSelectableInput2(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function $d3863c46a17e8a28$var$focus2(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({
        preventScroll: true
      });
      if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput2(element) && select)
        element.select();
    }
  }
  var $d3863c46a17e8a28$var$focusScopesStack2 = $d3863c46a17e8a28$var$createFocusScopesStack2();
  function $d3863c46a17e8a28$var$createFocusScopesStack2() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope)
          activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
        stack = $d3863c46a17e8a28$var$arrayRemove2(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        var _stack$;
        stack = $d3863c46a17e8a28$var$arrayRemove2(stack, focusScope);
        (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
      }
    };
  }
  function $d3863c46a17e8a28$var$arrayRemove2(array, item) {
    const updatedArray = [
      ...array
    ];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1)
      updatedArray.splice(index2, 1);
    return updatedArray;
  }
  function $d3863c46a17e8a28$var$removeLinks2(items) {
    return items.filter(
      (item) => item.tagName !== "A"
    );
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-id/dist/index.mjs
  var $2AODx$react5 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var import_react94 = __toESM(require_react(), 1);
  var $9f79659886946c16$export$e5c5a5f917a5871c6 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react94.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-id/dist/index.mjs
  var $1746a345f3d73bb7$var$useReactId5 = $2AODx$react5["useId".toString()] || (() => void 0);
  var $1746a345f3d73bb7$var$count5 = 0;
  function $1746a345f3d73bb7$export$f680877a34711e375(deterministicId) {
    const [id, setId] = $2AODx$react5.useState($1746a345f3d73bb7$var$useReactId5());
    $9f79659886946c16$export$e5c5a5f917a5871c6(() => {
      if (!deterministicId)
        setId(
          (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count5++)
        );
    }, [
      deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : "");
  }

  // node_modules/@radix-ui/react-popper/dist/index.mjs
  var import_react106 = __toESM(require_react(), 1);

  // node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
  var sides = ["top", "right", "bottom", "left"];
  var min = Math.min;
  var max = Math.max;
  var round = Math.round;
  var floor = Math.floor;
  var createCoords = (v2) => ({
    x: v2,
    y: v2
  });
  var oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  var oppositeAlignmentMap = {
    start: "end",
    end: "start"
  };
  function clamp(start, value, end) {
    return max(start, min(value, end));
  }
  function evaluate(value, param) {
    return typeof value === "function" ? value(param) : value;
  }
  function getSide(placement) {
    return placement.split("-")[0];
  }
  function getAlignment(placement) {
    return placement.split("-")[1];
  }
  function getOppositeAxis(axis) {
    return axis === "x" ? "y" : "x";
  }
  function getAxisLength(axis) {
    return axis === "y" ? "height" : "width";
  }
  function getSideAxis(placement) {
    return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
  }
  function getAlignmentAxis(placement) {
    return getOppositeAxis(getSideAxis(placement));
  }
  function getAlignmentSides(placement, rects, rtl) {
    if (rtl === void 0) {
      rtl = false;
    }
    const alignment = getAlignment(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const length = getAxisLength(alignmentAxis);
    let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
    if (rects.reference[length] > rects.floating[length]) {
      mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
    }
    return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
  }
  function getExpandedPlacements(placement) {
    const oppositePlacement = getOppositePlacement(placement);
    return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
  }
  function getOppositeAlignmentPlacement(placement) {
    return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
  }
  function getSideList(side, isStart, rtl) {
    const lr2 = ["left", "right"];
    const rl = ["right", "left"];
    const tb = ["top", "bottom"];
    const bt2 = ["bottom", "top"];
    switch (side) {
      case "top":
      case "bottom":
        if (rtl)
          return isStart ? rl : lr2;
        return isStart ? lr2 : rl;
      case "left":
      case "right":
        return isStart ? tb : bt2;
      default:
        return [];
    }
  }
  function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
    const alignment = getAlignment(placement);
    let list = getSideList(getSide(placement), direction === "start", rtl);
    if (alignment) {
      list = list.map((side) => side + "-" + alignment);
      if (flipAlignment) {
        list = list.concat(list.map(getOppositeAlignmentPlacement));
      }
    }
    return list;
  }
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
  }
  function expandPaddingObject(padding) {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...padding
    };
  }
  function getPaddingObject(padding) {
    return typeof padding !== "number" ? expandPaddingObject(padding) : {
      top: padding,
      right: padding,
      bottom: padding,
      left: padding
    };
  }
  function rectToClientRect(rect) {
    return {
      ...rect,
      top: rect.y,
      left: rect.x,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    };
  }

  // node_modules/@floating-ui/core/dist/floating-ui.core.mjs
  function computeCoordsFromPlacement(_ref, placement, rtl) {
    let {
      reference,
      floating
    } = _ref;
    const sideAxis = getSideAxis(placement);
    const alignmentAxis = getAlignmentAxis(placement);
    const alignLength = getAxisLength(alignmentAxis);
    const side = getSide(placement);
    const isVertical = sideAxis === "y";
    const commonX = reference.x + reference.width / 2 - floating.width / 2;
    const commonY = reference.y + reference.height / 2 - floating.height / 2;
    const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
    let coords;
    switch (side) {
      case "top":
        coords = {
          x: commonX,
          y: reference.y - floating.height
        };
        break;
      case "bottom":
        coords = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;
      case "right":
        coords = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;
      case "left":
        coords = {
          x: reference.x - floating.width,
          y: commonY
        };
        break;
      default:
        coords = {
          x: reference.x,
          y: reference.y
        };
    }
    switch (getAlignment(placement)) {
      case "start":
        coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
        break;
      case "end":
        coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
        break;
    }
    return coords;
  }
  var computePosition = async (reference, floating, config) => {
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2
    } = config;
    const validMiddleware = middleware.filter(Boolean);
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
    let rects = await platform2.getElementRects({
      reference,
      floating,
      strategy
    });
    let {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, placement, rtl);
    let statefulPlacement = placement;
    let middlewareData = {};
    let resetCount = 0;
    for (let i2 = 0; i2 < validMiddleware.length; i2++) {
      const {
        name,
        fn: fn2
      } = validMiddleware[i2];
      const {
        x: nextX,
        y: nextY,
        data,
        reset
      } = await fn2({
        x: x2,
        y: y2,
        initialPlacement: placement,
        placement: statefulPlacement,
        strategy,
        middlewareData,
        rects,
        platform: platform2,
        elements: {
          reference,
          floating
        }
      });
      x2 = nextX != null ? nextX : x2;
      y2 = nextY != null ? nextY : y2;
      middlewareData = {
        ...middlewareData,
        [name]: {
          ...middlewareData[name],
          ...data
        }
      };
      if (reset && resetCount <= 50) {
        resetCount++;
        if (typeof reset === "object") {
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (reset.rects) {
            rects = reset.rects === true ? await platform2.getElementRects({
              reference,
              floating,
              strategy
            }) : reset.rects;
          }
          ({
            x: x2,
            y: y2
          } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
        }
        i2 = -1;
        continue;
      }
    }
    return {
      x: x2,
      y: y2,
      placement: statefulPlacement,
      strategy,
      middlewareData
    };
  };
  async function detectOverflow(state, options) {
    var _await$platform$isEle;
    if (options === void 0) {
      options = {};
    }
    const {
      x: x2,
      y: y2,
      platform: platform2,
      rects,
      elements,
      strategy
    } = state;
    const {
      boundary = "clippingAncestors",
      rootBoundary = "viewport",
      elementContext = "floating",
      altBoundary = false,
      padding = 0
    } = evaluate(options, state);
    const paddingObject = getPaddingObject(padding);
    const altContext = elementContext === "floating" ? "reference" : "floating";
    const element = elements[altBoundary ? altContext : elementContext];
    const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
      element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
      boundary,
      rootBoundary,
      strategy
    }));
    const rect = elementContext === "floating" ? {
      ...rects.floating,
      x: x2,
      y: y2
    } : rects.reference;
    const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
    const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
      x: 1,
      y: 1
    } : {
      x: 1,
      y: 1
    };
    const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
      rect,
      offsetParent,
      strategy
    }) : rect);
    return {
      top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
      bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
      left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
      right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
    };
  }
  var arrow = (options) => ({
    name: "arrow",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        platform: platform2,
        elements,
        middlewareData
      } = state;
      const {
        element,
        padding = 0
      } = evaluate(options, state) || {};
      if (element == null) {
        return {};
      }
      const paddingObject = getPaddingObject(padding);
      const coords = {
        x: x2,
        y: y2
      };
      const axis = getAlignmentAxis(placement);
      const length = getAxisLength(axis);
      const arrowDimensions = await platform2.getDimensions(element);
      const isYAxis = axis === "y";
      const minProp = isYAxis ? "top" : "left";
      const maxProp = isYAxis ? "bottom" : "right";
      const clientProp = isYAxis ? "clientHeight" : "clientWidth";
      const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
      const startDiff = coords[axis] - rects.reference[axis];
      const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
      let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
      if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
        clientSize = elements.floating[clientProp] || rects.floating[length];
      }
      const centerToReference = endDiff / 2 - startDiff / 2;
      const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
      const minPadding = min(paddingObject[minProp], largestPossiblePadding);
      const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
      const min$1 = minPadding;
      const max2 = clientSize - arrowDimensions[length] - maxPadding;
      const center2 = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
      const offset2 = clamp(min$1, center2, max2);
      const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center2 != offset2 && rects.reference[length] / 2 - (center2 < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
      const alignmentOffset = shouldAddOffset ? center2 < min$1 ? center2 - min$1 : center2 - max2 : 0;
      return {
        [axis]: coords[axis] + alignmentOffset,
        data: {
          [axis]: offset2,
          centerOffset: center2 - offset2 - alignmentOffset,
          ...shouldAddOffset && {
            alignmentOffset
          }
        },
        reset: shouldAddOffset
      };
    }
  });
  var flip = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "flip",
      options,
      async fn(state) {
        var _middlewareData$arrow, _middlewareData$flip;
        const {
          placement,
          middlewareData,
          rects,
          initialPlacement,
          platform: platform2,
          elements
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true,
          fallbackPlacements: specifiedFallbackPlacements,
          fallbackStrategy = "bestFit",
          fallbackAxisSideDirection = "none",
          flipAlignment = true,
          ...detectOverflowOptions
        } = evaluate(options, state);
        if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
          return {};
        }
        const side = getSide(placement);
        const isBasePlacement = getSide(initialPlacement) === initialPlacement;
        const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
        const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
        if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
          fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
        }
        const placements2 = [initialPlacement, ...fallbackPlacements];
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const overflows = [];
        let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
        if (checkMainAxis) {
          overflows.push(overflow[side]);
        }
        if (checkCrossAxis) {
          const sides2 = getAlignmentSides(placement, rects, rtl);
          overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
        }
        overflowsData = [...overflowsData, {
          placement,
          overflows
        }];
        if (!overflows.every((side2) => side2 <= 0)) {
          var _middlewareData$flip2, _overflowsData$filter;
          const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
          const nextPlacement = placements2[nextIndex];
          if (nextPlacement) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
          let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a2, b3) => a2.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
          if (!resetPlacement) {
            switch (fallbackStrategy) {
              case "bestFit": {
                var _overflowsData$map$so;
                const placement2 = (_overflowsData$map$so = overflowsData.map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b3) => a2[1] - b3[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
                if (placement2) {
                  resetPlacement = placement2;
                }
                break;
              }
              case "initialPlacement":
                resetPlacement = initialPlacement;
                break;
            }
          }
          if (placement !== resetPlacement) {
            return {
              reset: {
                placement: resetPlacement
              }
            };
          }
        }
        return {};
      }
    };
  };
  function getSideOffsets(overflow, rect) {
    return {
      top: overflow.top - rect.height,
      right: overflow.right - rect.width,
      bottom: overflow.bottom - rect.height,
      left: overflow.left - rect.width
    };
  }
  function isAnySideFullyClipped(overflow) {
    return sides.some((side) => overflow[side] >= 0);
  }
  var hide = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "hide",
      options,
      async fn(state) {
        const {
          rects
        } = state;
        const {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = evaluate(options, state);
        switch (strategy) {
          case "referenceHidden": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              elementContext: "reference"
            });
            const offsets = getSideOffsets(overflow, rects.reference);
            return {
              data: {
                referenceHiddenOffsets: offsets,
                referenceHidden: isAnySideFullyClipped(offsets)
              }
            };
          }
          case "escaped": {
            const overflow = await detectOverflow(state, {
              ...detectOverflowOptions,
              altBoundary: true
            });
            const offsets = getSideOffsets(overflow, rects.floating);
            return {
              data: {
                escapedOffsets: offsets,
                escaped: isAnySideFullyClipped(offsets)
              }
            };
          }
          default: {
            return {};
          }
        }
      }
    };
  };
  async function convertValueToCoords(state, options) {
    const {
      placement,
      platform: platform2,
      elements
    } = state;
    const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
    const side = getSide(placement);
    const alignment = getAlignment(placement);
    const isVertical = getSideAxis(placement) === "y";
    const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
    const crossAxisMulti = rtl && isVertical ? -1 : 1;
    const rawValue = evaluate(options, state);
    let {
      mainAxis,
      crossAxis,
      alignmentAxis
    } = typeof rawValue === "number" ? {
      mainAxis: rawValue,
      crossAxis: 0,
      alignmentAxis: null
    } : {
      mainAxis: 0,
      crossAxis: 0,
      alignmentAxis: null,
      ...rawValue
    };
    if (alignment && typeof alignmentAxis === "number") {
      crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
    }
    return isVertical ? {
      x: crossAxis * crossAxisMulti,
      y: mainAxis * mainAxisMulti
    } : {
      x: mainAxis * mainAxisMulti,
      y: crossAxis * crossAxisMulti
    };
  }
  var offset = function(options) {
    if (options === void 0) {
      options = 0;
    }
    return {
      name: "offset",
      options,
      async fn(state) {
        const {
          x: x2,
          y: y2
        } = state;
        const diffCoords = await convertValueToCoords(state, options);
        return {
          x: x2 + diffCoords.x,
          y: y2 + diffCoords.y,
          data: diffCoords
        };
      }
    };
  };
  var shift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "shift",
      options,
      async fn(state) {
        const {
          x: x2,
          y: y2,
          placement
        } = state;
        const {
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = false,
          limiter = {
            fn: (_ref) => {
              let {
                x: x3,
                y: y3
              } = _ref;
              return {
                x: x3,
                y: y3
              };
            }
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const coords = {
          x: x2,
          y: y2
        };
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const crossAxis = getSideAxis(getSide(placement));
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        if (checkMainAxis) {
          const minSide = mainAxis === "y" ? "top" : "left";
          const maxSide = mainAxis === "y" ? "bottom" : "right";
          const min2 = mainAxisCoord + overflow[minSide];
          const max2 = mainAxisCoord - overflow[maxSide];
          mainAxisCoord = clamp(min2, mainAxisCoord, max2);
        }
        if (checkCrossAxis) {
          const minSide = crossAxis === "y" ? "top" : "left";
          const maxSide = crossAxis === "y" ? "bottom" : "right";
          const min2 = crossAxisCoord + overflow[minSide];
          const max2 = crossAxisCoord - overflow[maxSide];
          crossAxisCoord = clamp(min2, crossAxisCoord, max2);
        }
        const limitedCoords = limiter.fn({
          ...state,
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        });
        return {
          ...limitedCoords,
          data: {
            x: limitedCoords.x - x2,
            y: limitedCoords.y - y2
          }
        };
      }
    };
  };
  var limitShift = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      options,
      fn(state) {
        const {
          x: x2,
          y: y2,
          placement,
          rects,
          middlewareData
        } = state;
        const {
          offset: offset2 = 0,
          mainAxis: checkMainAxis = true,
          crossAxis: checkCrossAxis = true
        } = evaluate(options, state);
        const coords = {
          x: x2,
          y: y2
        };
        const crossAxis = getSideAxis(placement);
        const mainAxis = getOppositeAxis(crossAxis);
        let mainAxisCoord = coords[mainAxis];
        let crossAxisCoord = coords[crossAxis];
        const rawOffset = evaluate(offset2, state);
        const computedOffset = typeof rawOffset === "number" ? {
          mainAxis: rawOffset,
          crossAxis: 0
        } : {
          mainAxis: 0,
          crossAxis: 0,
          ...rawOffset
        };
        if (checkMainAxis) {
          const len = mainAxis === "y" ? "height" : "width";
          const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
          const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
          if (mainAxisCoord < limitMin) {
            mainAxisCoord = limitMin;
          } else if (mainAxisCoord > limitMax) {
            mainAxisCoord = limitMax;
          }
        }
        if (checkCrossAxis) {
          var _middlewareData$offse, _middlewareData$offse2;
          const len = mainAxis === "y" ? "width" : "height";
          const isOriginSide = ["top", "left"].includes(getSide(placement));
          const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
          const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
          if (crossAxisCoord < limitMin) {
            crossAxisCoord = limitMin;
          } else if (crossAxisCoord > limitMax) {
            crossAxisCoord = limitMax;
          }
        }
        return {
          [mainAxis]: mainAxisCoord,
          [crossAxis]: crossAxisCoord
        };
      }
    };
  };
  var size = function(options) {
    if (options === void 0) {
      options = {};
    }
    return {
      name: "size",
      options,
      async fn(state) {
        const {
          placement,
          rects,
          platform: platform2,
          elements
        } = state;
        const {
          apply = () => {
          },
          ...detectOverflowOptions
        } = evaluate(options, state);
        const overflow = await detectOverflow(state, detectOverflowOptions);
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isYAxis = getSideAxis(placement) === "y";
        const {
          width,
          height
        } = rects.floating;
        let heightSide;
        let widthSide;
        if (side === "top" || side === "bottom") {
          heightSide = side;
          widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
        } else {
          widthSide = side;
          heightSide = alignment === "end" ? "top" : "bottom";
        }
        const overflowAvailableHeight = height - overflow[heightSide];
        const overflowAvailableWidth = width - overflow[widthSide];
        const noShift = !state.middlewareData.shift;
        let availableHeight = overflowAvailableHeight;
        let availableWidth = overflowAvailableWidth;
        if (isYAxis) {
          const maximumClippingWidth = width - overflow.left - overflow.right;
          availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
        } else {
          const maximumClippingHeight = height - overflow.top - overflow.bottom;
          availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
        }
        if (noShift && !alignment) {
          const xMin = max(overflow.left, 0);
          const xMax = max(overflow.right, 0);
          const yMin = max(overflow.top, 0);
          const yMax = max(overflow.bottom, 0);
          if (isYAxis) {
            availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
          } else {
            availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
          }
        }
        await apply({
          ...state,
          availableWidth,
          availableHeight
        });
        const nextDimensions = await platform2.getDimensions(elements.floating);
        if (width !== nextDimensions.width || height !== nextDimensions.height) {
          return {
            reset: {
              rects: true
            }
          };
        }
        return {};
      }
    };
  };

  // node_modules/@floating-ui/utils/dom/dist/floating-ui.utils.dom.mjs
  function getNodeName(node) {
    if (isNode(node)) {
      return (node.nodeName || "").toLowerCase();
    }
    return "#document";
  }
  function getWindow(node) {
    var _node$ownerDocument;
    return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
  }
  function getDocumentElement(node) {
    var _ref;
    return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
  }
  function isNode(value) {
    return value instanceof Node || value instanceof getWindow(value).Node;
  }
  function isElement(value) {
    return value instanceof Element || value instanceof getWindow(value).Element;
  }
  function isHTMLElement(value) {
    return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
  }
  function isShadowRoot(value) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
  }
  function isOverflowElement(element) {
    const {
      overflow,
      overflowX,
      overflowY,
      display
    } = getComputedStyle2(element);
    return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
  }
  function isTableElement(element) {
    return ["table", "td", "th"].includes(getNodeName(element));
  }
  function isContainingBlock(element) {
    const webkit = isWebKit();
    const css2 = getComputedStyle2(element);
    return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
  }
  function getContainingBlock(element) {
    let currentNode = getParentNode(element);
    while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
      if (isContainingBlock(currentNode)) {
        return currentNode;
      } else {
        currentNode = getParentNode(currentNode);
      }
    }
    return null;
  }
  function isWebKit() {
    if (typeof CSS === "undefined" || !CSS.supports)
      return false;
    return CSS.supports("-webkit-backdrop-filter", "none");
  }
  function isLastTraversableNode(node) {
    return ["html", "body", "#document"].includes(getNodeName(node));
  }
  function getComputedStyle2(element) {
    return getWindow(element).getComputedStyle(element);
  }
  function getNodeScroll(element) {
    if (isElement(element)) {
      return {
        scrollLeft: element.scrollLeft,
        scrollTop: element.scrollTop
      };
    }
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  function getParentNode(node) {
    if (getNodeName(node) === "html") {
      return node;
    }
    const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);
    return isShadowRoot(result) ? result.host : result;
  }
  function getNearestOverflowAncestor(node) {
    const parentNode = getParentNode(node);
    if (isLastTraversableNode(parentNode)) {
      return node.ownerDocument ? node.ownerDocument.body : node.body;
    }
    if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
      return parentNode;
    }
    return getNearestOverflowAncestor(parentNode);
  }
  function getOverflowAncestors(node, list, traverseIframes) {
    var _node$ownerDocument2;
    if (list === void 0) {
      list = [];
    }
    if (traverseIframes === void 0) {
      traverseIframes = true;
    }
    const scrollableAncestor = getNearestOverflowAncestor(node);
    const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
    const win = getWindow(scrollableAncestor);
    if (isBody) {
      return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
    }
    return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
  }

  // node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
  function getCssDimensions(element) {
    const css2 = getComputedStyle2(element);
    let width = parseFloat(css2.width) || 0;
    let height = parseFloat(css2.height) || 0;
    const hasOffset = isHTMLElement(element);
    const offsetWidth = hasOffset ? element.offsetWidth : width;
    const offsetHeight = hasOffset ? element.offsetHeight : height;
    const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
    if (shouldFallback) {
      width = offsetWidth;
      height = offsetHeight;
    }
    return {
      width,
      height,
      $: shouldFallback
    };
  }
  function unwrapElement(element) {
    return !isElement(element) ? element.contextElement : element;
  }
  function getScale(element) {
    const domElement = unwrapElement(element);
    if (!isHTMLElement(domElement)) {
      return createCoords(1);
    }
    const rect = domElement.getBoundingClientRect();
    const {
      width,
      height,
      $: $3
    } = getCssDimensions(domElement);
    let x2 = ($3 ? round(rect.width) : rect.width) / width;
    let y2 = ($3 ? round(rect.height) : rect.height) / height;
    if (!x2 || !Number.isFinite(x2)) {
      x2 = 1;
    }
    if (!y2 || !Number.isFinite(y2)) {
      y2 = 1;
    }
    return {
      x: x2,
      y: y2
    };
  }
  var noOffsets = /* @__PURE__ */ createCoords(0);
  function getVisualOffsets(element) {
    const win = getWindow(element);
    if (!isWebKit() || !win.visualViewport) {
      return noOffsets;
    }
    return {
      x: win.visualViewport.offsetLeft,
      y: win.visualViewport.offsetTop
    };
  }
  function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
      return false;
    }
    return isFixed;
  }
  function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    const clientRect = element.getBoundingClientRect();
    const domElement = unwrapElement(element);
    let scale = createCoords(1);
    if (includeScale) {
      if (offsetParent) {
        if (isElement(offsetParent)) {
          scale = getScale(offsetParent);
        }
      } else {
        scale = getScale(element);
      }
    }
    const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
    let x2 = (clientRect.left + visualOffsets.x) / scale.x;
    let y2 = (clientRect.top + visualOffsets.y) / scale.y;
    let width = clientRect.width / scale.x;
    let height = clientRect.height / scale.y;
    if (domElement) {
      const win = getWindow(domElement);
      const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
      let currentIFrame = win.frameElement;
      while (currentIFrame && offsetParent && offsetWin !== win) {
        const iframeScale = getScale(currentIFrame);
        const iframeRect = currentIFrame.getBoundingClientRect();
        const css2 = getComputedStyle2(currentIFrame);
        const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
        const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
        x2 *= iframeScale.x;
        y2 *= iframeScale.y;
        width *= iframeScale.x;
        height *= iframeScale.y;
        x2 += left;
        y2 += top;
        currentIFrame = getWindow(currentIFrame).frameElement;
      }
    }
    return rectToClientRect({
      width,
      height,
      x: x2,
      y: y2
    });
  }
  function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
    let {
      rect,
      offsetParent,
      strategy
    } = _ref;
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    if (offsetParent === documentElement) {
      return rect;
    }
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    let scale = createCoords(1);
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        const offsetRect = getBoundingClientRect(offsetParent);
        scale = getScale(offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      }
    }
    return {
      width: rect.width * scale.x,
      height: rect.height * scale.y,
      x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
      y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
    };
  }
  function getClientRects(element) {
    return Array.from(element.getClientRects());
  }
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
  }
  function getDocumentRect(element) {
    const html = getDocumentElement(element);
    const scroll = getNodeScroll(element);
    const body = element.ownerDocument.body;
    const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
    const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
    let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
    const y2 = -scroll.scrollTop;
    if (getComputedStyle2(body).direction === "rtl") {
      x2 += max(html.clientWidth, body.clientWidth) - width;
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getViewportRect(element, strategy) {
    const win = getWindow(element);
    const html = getDocumentElement(element);
    const visualViewport = win.visualViewport;
    let width = html.clientWidth;
    let height = html.clientHeight;
    let x2 = 0;
    let y2 = 0;
    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      const visualViewportBased = isWebKit();
      if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
        x2 = visualViewport.offsetLeft;
        y2 = visualViewport.offsetTop;
      }
    }
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getInnerBoundingClientRect(element, strategy) {
    const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
    const top = clientRect.top + element.clientTop;
    const left = clientRect.left + element.clientLeft;
    const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
    const width = element.clientWidth * scale.x;
    const height = element.clientHeight * scale.y;
    const x2 = left * scale.x;
    const y2 = top * scale.y;
    return {
      width,
      height,
      x: x2,
      y: y2
    };
  }
  function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
    let rect;
    if (clippingAncestor === "viewport") {
      rect = getViewportRect(element, strategy);
    } else if (clippingAncestor === "document") {
      rect = getDocumentRect(getDocumentElement(element));
    } else if (isElement(clippingAncestor)) {
      rect = getInnerBoundingClientRect(clippingAncestor, strategy);
    } else {
      const visualOffsets = getVisualOffsets(element);
      rect = {
        ...clippingAncestor,
        x: clippingAncestor.x - visualOffsets.x,
        y: clippingAncestor.y - visualOffsets.y
      };
    }
    return rectToClientRect(rect);
  }
  function hasFixedPositionAncestor(element, stopNode) {
    const parentNode = getParentNode(element);
    if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
      return false;
    }
    return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
  }
  function getClippingElementAncestors(element, cache) {
    const cachedResult = cache.get(element);
    if (cachedResult) {
      return cachedResult;
    }
    let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
    let currentContainingBlockComputedStyle = null;
    const elementIsFixed = getComputedStyle2(element).position === "fixed";
    let currentNode = elementIsFixed ? getParentNode(element) : element;
    while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
      const computedStyle = getComputedStyle2(currentNode);
      const currentNodeIsContaining = isContainingBlock(currentNode);
      if (!currentNodeIsContaining && computedStyle.position === "fixed") {
        currentContainingBlockComputedStyle = null;
      }
      const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
      if (shouldDropCurrentNode) {
        result = result.filter((ancestor) => ancestor !== currentNode);
      } else {
        currentContainingBlockComputedStyle = computedStyle;
      }
      currentNode = getParentNode(currentNode);
    }
    cache.set(element, result);
    return result;
  }
  function getClippingRect(_ref) {
    let {
      element,
      boundary,
      rootBoundary,
      strategy
    } = _ref;
    const elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
    const clippingAncestors = [...elementClippingAncestors, rootBoundary];
    const firstClippingAncestor = clippingAncestors[0];
    const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
      const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
    return {
      width: clippingRect.right - clippingRect.left,
      height: clippingRect.bottom - clippingRect.top,
      x: clippingRect.left,
      y: clippingRect.top
    };
  }
  function getDimensions(element) {
    return getCssDimensions(element);
  }
  function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
    const isOffsetParentAnElement = isHTMLElement(offsetParent);
    const documentElement = getDocumentElement(offsetParent);
    const isFixed = strategy === "fixed";
    const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
    let scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    const offsets = createCoords(0);
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isOffsetParentAnElement) {
        const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
        offsets.x = offsetRect.x + offsetParent.clientLeft;
        offsets.y = offsetRect.y + offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }
  function getTrueOffsetParent(element, polyfill) {
    if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
      return null;
    }
    if (polyfill) {
      return polyfill(element);
    }
    return element.offsetParent;
  }
  function getOffsetParent2(element, polyfill) {
    const window2 = getWindow(element);
    if (!isHTMLElement(element)) {
      return window2;
    }
    let offsetParent = getTrueOffsetParent(element, polyfill);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent, polyfill);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }
  var getElementRects = async function(_ref) {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    const getOffsetParentFn = this.getOffsetParent || getOffsetParent2;
    const getDimensionsFn = this.getDimensions;
    return {
      reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),
      floating: {
        x: 0,
        y: 0,
        ...await getDimensionsFn(floating)
      }
    };
  };
  function isRTL(element) {
    return getComputedStyle2(element).direction === "rtl";
  }
  var platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent: getOffsetParent2,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement,
    isRTL
  };
  function observeMove(element, onMove) {
    let io = null;
    let timeoutId;
    const root2 = getDocumentElement(element);
    function cleanup() {
      clearTimeout(timeoutId);
      io && io.disconnect();
      io = null;
    }
    function refresh(skip, threshold) {
      if (skip === void 0) {
        skip = false;
      }
      if (threshold === void 0) {
        threshold = 1;
      }
      cleanup();
      const {
        left,
        top,
        width,
        height
      } = element.getBoundingClientRect();
      if (!skip) {
        onMove();
      }
      if (!width || !height) {
        return;
      }
      const insetTop = floor(top);
      const insetRight = floor(root2.clientWidth - (left + width));
      const insetBottom = floor(root2.clientHeight - (top + height));
      const insetLeft = floor(left);
      const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
      const options = {
        rootMargin,
        threshold: max(0, min(1, threshold)) || 1
      };
      let isFirstUpdate = true;
      function handleObserve(entries) {
        const ratio = entries[0].intersectionRatio;
        if (ratio !== threshold) {
          if (!isFirstUpdate) {
            return refresh();
          }
          if (!ratio) {
            timeoutId = setTimeout(() => {
              refresh(false, 1e-7);
            }, 100);
          } else {
            refresh(false, ratio);
          }
        }
        isFirstUpdate = false;
      }
      try {
        io = new IntersectionObserver(handleObserve, {
          ...options,
          root: root2.ownerDocument
        });
      } catch (e3) {
        io = new IntersectionObserver(handleObserve, options);
      }
      io.observe(element);
    }
    refresh(true);
    return cleanup;
  }
  function autoUpdate(reference, floating, update, options) {
    if (options === void 0) {
      options = {};
    }
    const {
      ancestorScroll = true,
      ancestorResize = true,
      elementResize = typeof ResizeObserver === "function",
      layoutShift = typeof IntersectionObserver === "function",
      animationFrame = false
    } = options;
    const referenceEl = unwrapElement(reference);
    const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.addEventListener("scroll", update, {
        passive: true
      });
      ancestorResize && ancestor.addEventListener("resize", update);
    });
    const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
    let reobserveFrame = -1;
    let resizeObserver = null;
    if (elementResize) {
      resizeObserver = new ResizeObserver((_ref) => {
        let [firstEntry] = _ref;
        if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
          resizeObserver.unobserve(floating);
          cancelAnimationFrame(reobserveFrame);
          reobserveFrame = requestAnimationFrame(() => {
            resizeObserver && resizeObserver.observe(floating);
          });
        }
        update();
      });
      if (referenceEl && !animationFrame) {
        resizeObserver.observe(referenceEl);
      }
      resizeObserver.observe(floating);
    }
    let frameId;
    let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
    if (animationFrame) {
      frameLoop();
    }
    function frameLoop() {
      const nextRefRect = getBoundingClientRect(reference);
      if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
        update();
      }
      prevRefRect = nextRefRect;
      frameId = requestAnimationFrame(frameLoop);
    }
    update();
    return () => {
      ancestors.forEach((ancestor) => {
        ancestorScroll && ancestor.removeEventListener("scroll", update);
        ancestorResize && ancestor.removeEventListener("resize", update);
      });
      cleanupIo && cleanupIo();
      resizeObserver && resizeObserver.disconnect();
      resizeObserver = null;
      if (animationFrame) {
        cancelAnimationFrame(frameId);
      }
    };
  }
  var computePosition2 = (reference, floating, options) => {
    const cache = /* @__PURE__ */ new Map();
    const mergedOptions = {
      platform,
      ...options
    };
    const platformWithCache = {
      ...mergedOptions.platform,
      _c: cache
    };
    return computePosition(reference, floating, {
      ...mergedOptions,
      platform: platformWithCache
    });
  };

  // node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
  var React16 = __toESM(require_react(), 1);
  var import_react95 = __toESM(require_react(), 1);
  var ReactDOM = __toESM(require_react_dom(), 1);
  var arrow2 = (options) => {
    function isRef2(value) {
      return {}.hasOwnProperty.call(value, "current");
    }
    return {
      name: "arrow",
      options,
      fn(state) {
        const {
          element,
          padding
        } = typeof options === "function" ? options(state) : options;
        if (element && isRef2(element)) {
          if (element.current != null) {
            return arrow({
              element: element.current,
              padding
            }).fn(state);
          }
          return {};
        } else if (element) {
          return arrow({
            element,
            padding
          }).fn(state);
        }
        return {};
      }
    };
  };
  var index = typeof document !== "undefined" ? import_react95.useLayoutEffect : import_react95.useEffect;
  function deepEqual(a2, b3) {
    if (a2 === b3) {
      return true;
    }
    if (typeof a2 !== typeof b3) {
      return false;
    }
    if (typeof a2 === "function" && a2.toString() === b3.toString()) {
      return true;
    }
    let length, i2, keys;
    if (a2 && b3 && typeof a2 == "object") {
      if (Array.isArray(a2)) {
        length = a2.length;
        if (length != b3.length)
          return false;
        for (i2 = length; i2-- !== 0; ) {
          if (!deepEqual(a2[i2], b3[i2])) {
            return false;
          }
        }
        return true;
      }
      keys = Object.keys(a2);
      length = keys.length;
      if (length !== Object.keys(b3).length) {
        return false;
      }
      for (i2 = length; i2-- !== 0; ) {
        if (!{}.hasOwnProperty.call(b3, keys[i2])) {
          return false;
        }
      }
      for (i2 = length; i2-- !== 0; ) {
        const key = keys[i2];
        if (key === "_owner" && a2.$$typeof) {
          continue;
        }
        if (!deepEqual(a2[key], b3[key])) {
          return false;
        }
      }
      return true;
    }
    return a2 !== a2 && b3 !== b3;
  }
  function getDPR(element) {
    if (typeof window === "undefined") {
      return 1;
    }
    const win = element.ownerDocument.defaultView || window;
    return win.devicePixelRatio || 1;
  }
  function roundByDPR(element, value) {
    const dpr = getDPR(element);
    return Math.round(value * dpr) / dpr;
  }
  function useLatestRef(value) {
    const ref = React16.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }
  function useFloating(options) {
    if (options === void 0) {
      options = {};
    }
    const {
      placement = "bottom",
      strategy = "absolute",
      middleware = [],
      platform: platform2,
      elements: {
        reference: externalReference,
        floating: externalFloating
      } = {},
      transform = true,
      whileElementsMounted,
      open
    } = options;
    const [data, setData] = React16.useState({
      x: 0,
      y: 0,
      strategy,
      placement,
      middlewareData: {},
      isPositioned: false
    });
    const [latestMiddleware, setLatestMiddleware] = React16.useState(middleware);
    if (!deepEqual(latestMiddleware, middleware)) {
      setLatestMiddleware(middleware);
    }
    const [_reference, _setReference] = React16.useState(null);
    const [_floating, _setFloating] = React16.useState(null);
    const setReference = React16.useCallback((node) => {
      if (node != referenceRef.current) {
        referenceRef.current = node;
        _setReference(node);
      }
    }, [_setReference]);
    const setFloating = React16.useCallback((node) => {
      if (node !== floatingRef.current) {
        floatingRef.current = node;
        _setFloating(node);
      }
    }, [_setFloating]);
    const referenceEl = externalReference || _reference;
    const floatingEl = externalFloating || _floating;
    const referenceRef = React16.useRef(null);
    const floatingRef = React16.useRef(null);
    const dataRef = React16.useRef(data);
    const whileElementsMountedRef = useLatestRef(whileElementsMounted);
    const platformRef = useLatestRef(platform2);
    const update = React16.useCallback(() => {
      if (!referenceRef.current || !floatingRef.current) {
        return;
      }
      const config = {
        placement,
        strategy,
        middleware: latestMiddleware
      };
      if (platformRef.current) {
        config.platform = platformRef.current;
      }
      computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
        const fullData = {
          ...data2,
          isPositioned: true
        };
        if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
          dataRef.current = fullData;
          ReactDOM.flushSync(() => {
            setData(fullData);
          });
        }
      });
    }, [latestMiddleware, placement, strategy, platformRef]);
    index(() => {
      if (open === false && dataRef.current.isPositioned) {
        dataRef.current.isPositioned = false;
        setData((data2) => ({
          ...data2,
          isPositioned: false
        }));
      }
    }, [open]);
    const isMountedRef = React16.useRef(false);
    index(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    index(() => {
      if (referenceEl)
        referenceRef.current = referenceEl;
      if (floatingEl)
        floatingRef.current = floatingEl;
      if (referenceEl && floatingEl) {
        if (whileElementsMountedRef.current) {
          return whileElementsMountedRef.current(referenceEl, floatingEl, update);
        } else {
          update();
        }
      }
    }, [referenceEl, floatingEl, update, whileElementsMountedRef]);
    const refs = React16.useMemo(() => ({
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    }), [setReference, setFloating]);
    const elements = React16.useMemo(() => ({
      reference: referenceEl,
      floating: floatingEl
    }), [referenceEl, floatingEl]);
    const floatingStyles = React16.useMemo(() => {
      const initialStyles = {
        position: strategy,
        left: 0,
        top: 0
      };
      if (!elements.floating) {
        return initialStyles;
      }
      const x2 = roundByDPR(elements.floating, data.x);
      const y2 = roundByDPR(elements.floating, data.y);
      if (transform) {
        return {
          ...initialStyles,
          transform: "translate(" + x2 + "px, " + y2 + "px)",
          ...getDPR(elements.floating) >= 1.5 && {
            willChange: "transform"
          }
        };
      }
      return {
        position: strategy,
        left: x2,
        top: y2
      };
    }, [strategy, transform, elements.floating, data.x, data.y]);
    return React16.useMemo(() => ({
      ...data,
      update,
      refs,
      elements,
      floatingStyles
    }), [data, update, refs, elements, floatingStyles]);
  }

  // node_modules/@radix-ui/react-arrow/dist/index.mjs
  var import_react99 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react98 = __toESM(require_react(), 1);
  var import_react_dom11 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react97 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react96 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef8(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af8(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef8(ref, node)
    );
  }

  // node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-slot/dist/index.mjs
  var $5e63c961fc1ce211$export$8c6ed5c666ac13608 = /* @__PURE__ */ (0, import_react97.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react97.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable8);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react97.Children.count(newElement) > 1)
            return import_react97.Children.only(null);
          return /* @__PURE__ */ (0, import_react97.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react97.createElement)($5e63c961fc1ce211$var$SlotClone8, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react97.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react97.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react97.createElement)($5e63c961fc1ce211$var$SlotClone8, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13608.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone8 = /* @__PURE__ */ (0, import_react97.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react97.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react97.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps8(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af8(forwardedRef, children.ref) : children.ref
      });
    return import_react97.Children.count(children) > 1 ? import_react97.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone8.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d458 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react97.createElement)(import_react97.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable8(child) {
    return /* @__PURE__ */ (0, import_react97.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d458;
  }
  function $5e63c961fc1ce211$var$mergeProps8(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-arrow/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES7 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0347 = $8927f6f2acc4f386$var$NODES7.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react98.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac13608 : node;
      (0, import_react98.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react98.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-arrow/dist/index.mjs
  var $7e8f5cd07187803e$export$21b07c8f274aebd5 = /* @__PURE__ */ (0, import_react99.forwardRef)((props, forwardedRef) => {
    const { children, width = 10, height = 5, ...arrowProps } = props;
    return /* @__PURE__ */ (0, import_react99.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0347.svg, _extends({}, arrowProps, {
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none"
    }), props.asChild ? children : /* @__PURE__ */ (0, import_react99.createElement)("polygon", {
      points: "0,0 30,0 15,10"
    }));
  });
  var $7e8f5cd07187803e$export$be92b6f5f03c0fe9 = $7e8f5cd07187803e$export$21b07c8f274aebd5;

  // node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react100 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef9(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af9(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef9(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d058(...refs) {
    return (0, import_react100.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af9(...refs), refs);
  }

  // node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react101 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c18(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react101.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react101.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react101.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react101.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react101.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react101.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes8(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes8(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react101.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react103 = __toESM(require_react(), 1);
  var import_react_dom12 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react102 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac13609 = /* @__PURE__ */ (0, import_react102.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react102.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable9);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react102.Children.count(newElement) > 1)
            return import_react102.Children.only(null);
          return /* @__PURE__ */ (0, import_react102.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react102.createElement)($5e63c961fc1ce211$var$SlotClone9, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react102.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react102.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react102.createElement)($5e63c961fc1ce211$var$SlotClone9, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac13609.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone9 = /* @__PURE__ */ (0, import_react102.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react102.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react102.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps9(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af9(forwardedRef, children.ref) : children.ref
      });
    return import_react102.Children.count(children) > 1 ? import_react102.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone9.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d459 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react102.createElement)(import_react102.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable9(child) {
    return /* @__PURE__ */ (0, import_react102.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d459;
  }
  function $5e63c961fc1ce211$var$mergeProps9(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES8 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0348 = $8927f6f2acc4f386$var$NODES8.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac13609 : node;
      (0, import_react103.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react103.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react104 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a7(callback) {
    const callbackRef = (0, import_react104.useRef)(callback);
    (0, import_react104.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react104.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-popper/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var import_react105 = __toESM(require_react(), 1);
  var $9f79659886946c16$export$e5c5a5f917a5871c7 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react105.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-popper/dist/index.mjs
  var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
  var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c18($cf1ac5d9fe0e8206$var$POPPER_NAME);
  var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
  var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = (0, import_react106.useState)(null);
    return /* @__PURE__ */ (0, import_react106.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
      scope: __scopePopper,
      anchor,
      onAnchorChange: setAnchor
    }, children);
  };
  var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
  var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react106.forwardRef)((props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
    const ref = (0, import_react106.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d058(forwardedRef, ref);
    (0, import_react106.useEffect)(() => {
      context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ (0, import_react106.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0348.div, _extends({}, anchorProps, {
      ref: composedRefs
    }));
  });
  var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
  var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
  var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react106.forwardRef)((props, forwardedRef) => {
    var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
    const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, avoidCollisions = true, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, updatePositionStrategy = "optimized", onPlaced, ...contentProps } = props;
    const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
    const [content, setContent] = (0, import_react106.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d058(
      forwardedRef,
      (node) => setContent(node)
    );
    const [arrow3, setArrow] = (0, import_react106.useState)(null);
    const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow3);
    const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
    const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...collisionPaddingProp
    };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
      collisionBoundary
    ];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({
          mainAxis: sideOffset + arrowHeight,
          alignmentAxis: alignOffset
        }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({
          ...detectOverflowOptions
        }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow3 && arrow2({
          element: arrow3,
          padding: arrowPadding
        }),
        $cf1ac5d9fe0e8206$var$transformOrigin({
          arrowWidth,
          arrowHeight
        }),
        hideWhenDetached && hide({
          strategy: "referenceHidden",
          ...detectOverflowOptions
        })
      ]
    });
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a7(onPlaced);
    $9f79659886946c16$export$e5c5a5f917a5871c7(() => {
      if (isPositioned)
        handlePlaced === null || handlePlaced === void 0 || handlePlaced();
    }, [
      isPositioned,
      handlePlaced
    ]);
    const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
    const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
    const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = (0, import_react106.useState)();
    $9f79659886946c16$export$e5c5a5f917a5871c7(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [
      content
    ]);
    return /* @__PURE__ */ (0, import_react106.createElement)("div", {
      ref: refs.setFloating,
      "data-radix-popper-content-wrapper": "",
      style: {
        ...floatingStyles,
        transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: contentZIndex,
        ["--radix-popper-transform-origin"]: [
          (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
          (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
        ].join(" ")
      },
      dir: props.dir
    }, /* @__PURE__ */ (0, import_react106.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
      scope: __scopePopper,
      placedSide,
      onArrowChange: setArrow,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    }, /* @__PURE__ */ (0, import_react106.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0348.div, _extends({
      "data-side": placedSide,
      "data-align": placedAlign
    }, contentProps, {
      ref: composedRefs,
      style: {
        ...contentProps.style,
        animation: !isPositioned ? "none" : void 0,
        opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
      }
    }))));
  });
  var $cf1ac5d9fe0e8206$var$ARROW_NAME = "PopperArrow";
  var $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
  };
  var $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0 = /* @__PURE__ */ (0, import_react106.forwardRef)(function $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd02(props, forwardedRef) {
    const { __scopePopper, ...arrowProps } = props;
    const contentContext = $cf1ac5d9fe0e8206$var$useContentContext($cf1ac5d9fe0e8206$var$ARROW_NAME, __scopePopper);
    const baseSide = $cf1ac5d9fe0e8206$var$OPPOSITE_SIDE[contentContext.placedSide];
    return /* @__PURE__ */ (0, import_react106.createElement)("span", {
      ref: contentContext.onArrowChange,
      style: {
        position: "absolute",
        left: contentContext.arrowX,
        top: contentContext.arrowY,
        [baseSide]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[contentContext.placedSide],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: `rotate(180deg)`,
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[contentContext.placedSide],
        visibility: contentContext.shouldHideArrow ? "hidden" : void 0
      }
    }, /* @__PURE__ */ (0, import_react106.createElement)($7e8f5cd07187803e$export$be92b6f5f03c0fe9, _extends({}, arrowProps, {
      ref: forwardedRef,
      style: {
        ...arrowProps.style,
        display: "block"
      }
    })));
  });
  function $cf1ac5d9fe0e8206$var$isNotNull(value) {
    return value !== null;
  }
  var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
    name: "transformOrigin",
    options,
    fn(data) {
      var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
      const noArrowAlign = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[placedAlign];
      const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
      const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
      let x2 = "";
      let y2 = "";
      if (placedSide === "bottom") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x2 = `${-arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x2 = `${rects.floating.width + arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return {
        data: {
          x: x2,
          y: y2
        }
      };
    }
  });
  function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
    const [side, align = "center"] = placement.split("-");
    return [
      side,
      align
    ];
  }
  var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
  var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
  var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;
  var $cf1ac5d9fe0e8206$export$21b07c8f274aebd5 = $cf1ac5d9fe0e8206$export$79d62cd4e10a3fd0;

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-presence/dist/index.mjs
  var import_react107 = __toESM(require_react(), 1);
  var import_react_dom14 = __toESM(require_react_dom(), 1);
  function $fe963b355347cc68$export$3e6543de14f8614f4(initialState3, machine) {
    return (0, import_react107.useReducer)((state, event) => {
      const nextState = machine[state][event];
      return nextState !== null && nextState !== void 0 ? nextState : state;
    }, initialState3);
  }
  var $921a889cee6df7e8$export$99c2b779aa4e8b8b4 = (props) => {
    const { present, children } = props;
    const presence = $921a889cee6df7e8$var$usePresence4(present);
    const child = typeof children === "function" ? children({
      present: presence.isPresent
    }) : import_react107.Children.only(children);
    const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d057(presence.ref, child.ref);
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react107.cloneElement)(child, {
      ref
    }) : null;
  };
  $921a889cee6df7e8$export$99c2b779aa4e8b8b4.displayName = "Presence";
  function $921a889cee6df7e8$var$usePresence4(present) {
    const [node1, setNode] = (0, import_react107.useState)();
    const stylesRef = (0, import_react107.useRef)({});
    const prevPresentRef = (0, import_react107.useRef)(present);
    const prevAnimationNameRef = (0, import_react107.useRef)("none");
    const initialState3 = present ? "mounted" : "unmounted";
    const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f4(initialState3, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    (0, import_react107.useEffect)(() => {
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName4(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [
      state
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c6(() => {
      const styles = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName4(styles);
        if (present)
          send("MOUNT");
        else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
          send("UNMOUNT");
        else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating)
            send("ANIMATION_OUT");
          else
            send("UNMOUNT");
        }
        prevPresentRef.current = present;
      }
    }, [
      present,
      send
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c6(() => {
      if (node1) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = $921a889cee6df7e8$var$getAnimationName4(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node1 && isCurrentAnimation)
            (0, import_react_dom14.flushSync)(
              () => send("ANIMATION_END")
            );
        };
        const handleAnimationStart = (event) => {
          if (event.target === node1)
            prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName4(stylesRef.current);
        };
        node1.addEventListener("animationstart", handleAnimationStart);
        node1.addEventListener("animationcancel", handleAnimationEnd);
        node1.addEventListener("animationend", handleAnimationEnd);
        return () => {
          node1.removeEventListener("animationstart", handleAnimationStart);
          node1.removeEventListener("animationcancel", handleAnimationEnd);
          node1.removeEventListener("animationend", handleAnimationEnd);
        };
      } else
        send("ANIMATION_END");
    }, [
      node1,
      send
    ]);
    return {
      isPresent: [
        "mounted",
        "unmountSuspended"
      ].includes(state),
      ref: (0, import_react107.useCallback)((node) => {
        if (node)
          stylesRef.current = getComputedStyle(node);
        setNode(node);
      }, [])
    };
  }
  function $921a889cee6df7e8$var$getAnimationName4(styles) {
    return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
  }

  // node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var import_react108 = __toESM(require_react(), 1);
  function $71cd76cc60e0454e$export$6f32135080cb4c36({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState6({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(onChange);
    const setValue = (0, import_react108.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState6({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react108.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react108.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a6(onChange);
    (0, import_react108.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/Combination.js
  var React19 = __toESM(require_react());

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/UI.js
  var React17 = __toESM(require_react());

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/medium.js
  var effectCar2 = createSidecarMedium();

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/UI.js
  var nothing2 = function() {
    return;
  };
  var RemoveScroll2 = React17.forwardRef(function(props, parentRef) {
    var ref = React17.useRef(null);
    var _a = React17.useState({
      onScrollCapture: nothing2,
      onWheelCapture: nothing2,
      onTouchMoveCapture: nothing2
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return React17.createElement(
      React17.Fragment,
      null,
      enabled && React17.createElement(SideCar2, { sideCar: effectCar2, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
      forwardProps ? React17.cloneElement(React17.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React17.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll2.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll2.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var React18 = __toESM(require_react());

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
  var passiveSupported2 = false;
  if (typeof window !== "undefined") {
    try {
      options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported2 = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported2 = false;
    }
  }
  var options;
  var nonPassive2 = passiveSupported2 ? { passive: false } : false;

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
  var alwaysContainsScroll = function(node) {
    return node.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled = function(node, overflow) {
    var styles = window.getComputedStyle(node);
    return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible");
  };
  var elementCouldBeVScrolled2 = function(node) {
    return elementCanBeScrolled(node, "overflowY");
  };
  var elementCouldBeHScrolled2 = function(node) {
    return elementCanBeScrolled(node, "overflowX");
  };
  var locationCouldBeScrolled2 = function(axis, node) {
    var current = node;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled2(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables2(axis, current), s2 = _a[1], d3 = _a[2];
        if (s2 > d3) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== document.body);
    return false;
  };
  var getVScrollVariables2 = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables2 = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled2 = function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled2(node) : elementCouldBeHScrolled2(node);
  };
  var getScrollVariables2 = function(axis, node) {
    return axis === "v" ? getVScrollVariables2(node) : getHScrollVariables2(node);
  };
  var getDirectionFactor2 = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll2 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor2(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      var _a = getScrollVariables2(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled2(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      target = target.parentNode;
    } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
    if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var getTouchXY2 = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY2 = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef2 = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare2 = function(x2, y2) {
    return x2[0] === y2[0] && x2[1] === y2[1];
  };
  var generateStyle2 = function(id) {
    return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
  };
  var idCounter2 = 0;
  var lockStack2 = [];
  function RemoveScrollSideCar2(props) {
    var shouldPreventQueue = React18.useRef([]);
    var touchStartRef = React18.useRef([0, 0]);
    var activeAxis = React18.useRef();
    var id = React18.useState(idCounter2++)[0];
    var Style2 = React18.useState(function() {
      return styleSingleton();
    })[0];
    var lastProps = React18.useRef(props);
    React18.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    React18.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef2), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React18.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY2(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled2(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled2(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll2(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React18.useCallback(function(_event) {
      var event = _event;
      if (!lockStack2.length || lockStack2[lockStack2.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY2(event) : getTouchXY2(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
        return e3.name === event.type && e3.target === event.target && deltaCompare2(e3.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef2).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = React18.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
          return e3 !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = React18.useCallback(function(event) {
      touchStartRef.current = getTouchXY2(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = React18.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY2(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React18.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY2(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React18.useEffect(function() {
      lockStack2.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive2);
      document.addEventListener("touchmove", shouldPrevent, nonPassive2);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive2);
      return function() {
        lockStack2 = lockStack2.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive2);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive2);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive2);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return React18.createElement(
      React18.Fragment,
      null,
      inert ? React18.createElement(Style2, { styles: generateStyle2(id) }) : null,
      removeScrollBar ? React18.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
    );
  }

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/sidecar.js
  var sidecar_default2 = exportSidecar(effectCar2, RemoveScrollSideCar2);

  // node_modules/@radix-ui/react-popover/node_modules/react-remove-scroll/dist/es2015/Combination.js
  var ReactRemoveScroll2 = React19.forwardRef(function(props, ref) {
    return React19.createElement(RemoveScroll2, __assign({}, props, { ref, sideCar: sidecar_default2 }));
  });
  ReactRemoveScroll2.classNames = RemoveScroll2.classNames;
  var Combination_default2 = ReactRemoveScroll2;

  // node_modules/@radix-ui/react-popover/dist/index.mjs
  var $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
  var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c17($cb5cc270b50c6fcd$var$POPOVER_NAME, [
    $cf1ac5d9fe0e8206$export$722aac194ae923
  ]);
  var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
  var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
  var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
    const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
    const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
    const triggerRef = (0, import_react109.useRef)(null);
    const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react109.useState)(false);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c36({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react109.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react109.createElement)($cb5cc270b50c6fcd$var$PopoverProvider, {
      scope: __scopePopover,
      contentId: $1746a345f3d73bb7$export$f680877a34711e375(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: (0, import_react109.useCallback)(
        () => setOpen(
          (prevOpen) => !prevOpen
        ),
        [
          setOpen
        ]
      ),
      hasCustomAnchor,
      onCustomAnchorAdd: (0, import_react109.useCallback)(
        () => setHasCustomAnchor(true),
        []
      ),
      onCustomAnchorRemove: (0, import_react109.useCallback)(
        () => setHasCustomAnchor(false),
        []
      ),
      modal
    }, children));
  };
  var $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
  var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ (0, import_react109.forwardRef)((props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
    const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
    const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d057(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ (0, import_react109.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0346.button, _extends({
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": context.open,
      "aria-controls": context.contentId,
      "data-state": $cb5cc270b50c6fcd$var$getState(context.open)
    }, triggerProps, {
      ref: composedTriggerRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff106(props.onClick, context.onOpenToggle)
    }));
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ (0, import_react109.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({
      asChild: true
    }, popperScope), trigger);
  });
  var $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
  var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
    forceMount: void 0
  });
  var $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
  var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ (0, import_react109.forwardRef)((props, forwardedRef) => {
    const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    return /* @__PURE__ */ (0, import_react109.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b4, {
      present: forceMount || context.open
    }, context.modal ? /* @__PURE__ */ (0, import_react109.createElement)($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
      ref: forwardedRef
    })) : /* @__PURE__ */ (0, import_react109.createElement)($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
      ref: forwardedRef
    })));
  });
  var $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ (0, import_react109.forwardRef)((props, forwardedRef) => {
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    const contentRef = (0, import_react109.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d057(forwardedRef, contentRef);
    const isRightClickOutsideRef = (0, import_react109.useRef)(false);
    (0, import_react109.useEffect)(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_react109.createElement)(Combination_default2, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac13607,
      allowPinchZoom: true
    }, /* @__PURE__ */ (0, import_react109.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
      ref: composedRefs,
      trapFocus: context.open,
      disableOutsidePointerEvents: true,
      onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff106(props.onCloseAutoFocus, (event) => {
        var _context$triggerRef$c;
        event.preventDefault();
        if (!isRightClickOutsideRef.current)
          (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      }),
      onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff106(props.onPointerDownOutside, (event) => {
        const originalEvent = event.detail.originalEvent;
        const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
        const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
        isRightClickOutsideRef.current = isRightClick;
      }, {
        checkForDefaultPrevented: false
      }),
      onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff106(
        props.onFocusOutside,
        (event) => event.preventDefault(),
        {
          checkForDefaultPrevented: false
        }
      )
    })));
  });
  var $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ (0, import_react109.forwardRef)((props, forwardedRef) => {
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    const hasInteractedOutsideRef = (0, import_react109.useRef)(false);
    const hasPointerDownOutsideRef = (0, import_react109.useRef)(false);
    return /* @__PURE__ */ (0, import_react109.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      onCloseAutoFocus: (event) => {
        var _props$onCloseAutoFoc;
        (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
        if (!event.defaultPrevented) {
          var _context$triggerRef$c2;
          if (!hasInteractedOutsideRef.current)
            (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
          event.preventDefault();
        }
        hasInteractedOutsideRef.current = false;
        hasPointerDownOutsideRef.current = false;
      },
      onInteractOutside: (event) => {
        var _props$onInteractOuts, _context$triggerRef$c3;
        (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
        if (!event.defaultPrevented) {
          hasInteractedOutsideRef.current = true;
          if (event.detail.originalEvent.type === "pointerdown")
            hasPointerDownOutsideRef.current = true;
        }
        const target = event.target;
        const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
        if (targetIsTrigger)
          event.preventDefault();
        if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
          event.preventDefault();
      }
    }));
  });
  var $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ (0, import_react109.forwardRef)((props, forwardedRef) => {
    const { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, ...contentProps } = props;
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
    const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c2();
    return /* @__PURE__ */ (0, import_react109.createElement)($d3863c46a17e8a28$export$20e40289641fbbb62, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus
    }, /* @__PURE__ */ (0, import_react109.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f222, {
      asChild: true,
      disableOutsidePointerEvents,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onDismiss: () => context.onOpenChange(false)
    }, /* @__PURE__ */ (0, import_react109.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
      "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
      role: "dialog",
      id: context.contentId
    }, popperScope, contentProps, {
      ref: forwardedRef,
      style: {
        ...contentProps.style,
        "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
        "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
        "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }))));
  });
  var $cb5cc270b50c6fcd$var$CLOSE_NAME = "PopoverClose";
  var $cb5cc270b50c6fcd$export$d6ac43ebaa40d53e = /* @__PURE__ */ (0, import_react109.forwardRef)((props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ (0, import_react109.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0346.button, _extends({
      type: "button"
    }, closeProps, {
      ref: forwardedRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff106(
        props.onClick,
        () => context.onOpenChange(false)
      )
    }));
  });
  var $cb5cc270b50c6fcd$export$3152841115e061b2 = /* @__PURE__ */ (0, import_react109.forwardRef)((props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
    return /* @__PURE__ */ (0, import_react109.createElement)($cf1ac5d9fe0e8206$export$21b07c8f274aebd5, _extends({}, popperScope, arrowProps, {
      ref: forwardedRef
    }));
  });
  function $cb5cc270b50c6fcd$var$getState(open) {
    return open ? "open" : "closed";
  }
  var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
  var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
  var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;
  var $cb5cc270b50c6fcd$export$f39c2d165cd861fe = $cb5cc270b50c6fcd$export$d6ac43ebaa40d53e;
  var $cb5cc270b50c6fcd$export$21b07c8f274aebd5 = $cb5cc270b50c6fcd$export$3152841115e061b2;

  // node_modules/@samvera/clover-iiif/dist/viewer/index.mjs
  var import_openseadragon = __toESM(require_openseadragon(), 1);

  // node_modules/@radix-ui/react-select/dist/index.mjs
  var import_react126 = __toESM(require_react(), 1);
  var import_react_dom18 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/number/dist/index.mjs
  function $ae6933e535247d3d$export$7d15b64cf5a3a4c4(value, [min2, max2]) {
    return Math.min(max2, Math.max(min2, value));
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/primitive/dist/index.mjs
  function $e42e1063c40fb3ef$export$b9ecd428b558ff107(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react110 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef10(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af10(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef10(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d059(...refs) {
    return (0, import_react110.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af10(...refs), refs);
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react111 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c19(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react111.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react111.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react111.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react111.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react111.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react111.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes9(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes9(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react111.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var import_react116 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react113 = __toESM(require_react(), 1);
  var import_react_dom15 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react112 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac136010 = /* @__PURE__ */ (0, import_react112.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react112.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable10);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react112.Children.count(newElement) > 1)
            return import_react112.Children.only(null);
          return /* @__PURE__ */ (0, import_react112.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react112.createElement)($5e63c961fc1ce211$var$SlotClone10, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react112.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react112.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react112.createElement)($5e63c961fc1ce211$var$SlotClone10, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac136010.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone10 = /* @__PURE__ */ (0, import_react112.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react112.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react112.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps10(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af10(forwardedRef, children.ref) : children.ref
      });
    return import_react112.Children.count(children) > 1 ? import_react112.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone10.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d4510 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react112.createElement)(import_react112.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable10(child) {
    return /* @__PURE__ */ (0, import_react112.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d4510;
  }
  function $5e63c961fc1ce211$var$mergeProps10(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES9 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d0349 = $8927f6f2acc4f386$var$NODES9.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react113.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac136010 : node;
      (0, import_react113.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react113.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});
  function $8927f6f2acc4f386$export$6d1a0317bde7de7f3(target, event) {
    if (target)
      (0, import_react_dom15.flushSync)(
        () => target.dispatchEvent(event)
      );
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react114 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(callback) {
    const callbackRef = (0, import_react114.useRef)(callback);
    (0, import_react114.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react114.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
  var import_react115 = __toESM(require_react(), 1);
  function $addc16e1bbe58fd0$export$3a72a57244d6e7653(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onEscapeKeyDownProp);
    (0, import_react115.useEffect)(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape")
          onEscapeKeyDown(event);
      };
      ownerDocument.addEventListener("keydown", handleKeyDown);
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
    }, [
      onEscapeKeyDown,
      ownerDocument
    ]);
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
  var $5cb92bef7577960e$var$CONTEXT_UPDATE3 = "dismissableLayer.update";
  var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE3 = "dismissableLayer.pointerDownOutside";
  var $5cb92bef7577960e$var$FOCUS_OUTSIDE3 = "dismissableLayer.focusOutside";
  var $5cb92bef7577960e$var$originalBodyPointerEvents3;
  var $5cb92bef7577960e$var$DismissableLayerContext3 = /* @__PURE__ */ (0, import_react116.createContext)({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var $5cb92bef7577960e$export$177fb62ff3ec1f223 = /* @__PURE__ */ (0, import_react116.forwardRef)((props, forwardedRef) => {
    var _node$ownerDocument;
    const { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, ...layerProps } = props;
    const context = (0, import_react116.useContext)($5cb92bef7577960e$var$DismissableLayerContext3);
    const [node1, setNode] = (0, import_react116.useState)(null);
    const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
    const [, force] = (0, import_react116.useState)({});
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(
      forwardedRef,
      (node) => setNode(node)
    );
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [
      ...context.layersWithOutsidePointerEventsDisabled
    ].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node1 ? layers.indexOf(node1) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside3((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    }, ownerDocument);
    const focusOutside = $5cb92bef7577960e$var$useFocusOutside3((event) => {
      const target = event.target;
      const isFocusInBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (isFocusInBranch)
        return;
      onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    }, ownerDocument);
    $addc16e1bbe58fd0$export$3a72a57244d6e7653((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    (0, import_react116.useEffect)(() => {
      if (!node1)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          $5cb92bef7577960e$var$originalBodyPointerEvents3 = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node1);
      }
      context.layers.add(node1);
      $5cb92bef7577960e$var$dispatchUpdate3();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
          ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents3;
      };
    }, [
      node1,
      ownerDocument,
      disableOutsidePointerEvents,
      context
    ]);
    (0, import_react116.useEffect)(() => {
      return () => {
        if (!node1)
          return;
        context.layers.delete(node1);
        context.layersWithOutsidePointerEventsDisabled.delete(node1);
        $5cb92bef7577960e$var$dispatchUpdate3();
      };
    }, [
      node1,
      context
    ]);
    (0, import_react116.useEffect)(() => {
      const handleUpdate = () => force({});
      document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE3, handleUpdate);
      return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE3, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_react116.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({}, layerProps, {
      ref: composedRefs,
      style: {
        pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
        ...props.style
      },
      onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff107(props.onFocusCapture, focusOutside.onFocusCapture),
      onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff107(props.onBlurCapture, focusOutside.onBlurCapture),
      onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff107(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
    }));
  });
  function $5cb92bef7577960e$var$usePointerDownOutside3(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onPointerDownOutside);
    const isPointerInsideReactTreeRef = (0, import_react116.useRef)(false);
    const handleClickRef = (0, import_react116.useRef)(() => {
    });
    (0, import_react116.useEffect)(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent = function() {
            $5cb92bef7577960e$var$handleAndDispatchCustomEvent3($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE3, handlePointerDownOutside, eventDetail, {
              discrete: true
            });
          };
          const eventDetail = {
            originalEvent: event
          };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
            ownerDocument.addEventListener("click", handleClickRef.current, {
              once: true
            });
          } else
            handleAndDispatchPointerDownOutsideEvent();
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [
      ownerDocument,
      handlePointerDownOutside
    ]);
    return {
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function $5cb92bef7577960e$var$useFocusOutside3(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onFocusOutside);
    const isFocusInsideReactTreeRef = (0, import_react116.useRef)(false);
    (0, import_react116.useEffect)(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = {
            originalEvent: event
          };
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent3($5cb92bef7577960e$var$FOCUS_OUTSIDE3, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [
      ownerDocument,
      handleFocusOutside
    ]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function $5cb92bef7577960e$var$dispatchUpdate3() {
    const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE3);
    document.dispatchEvent(event);
  }
  function $5cb92bef7577960e$var$handleAndDispatchCustomEvent3(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, {
      bubbles: false,
      cancelable: true,
      detail
    });
    if (handler)
      target.addEventListener(name, handler, {
        once: true
      });
    if (discrete)
      $8927f6f2acc4f386$export$6d1a0317bde7de7f3(target, event);
    else
      target.dispatchEvent(event);
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-focus-guards/dist/index.mjs
  var import_react117 = __toESM(require_react(), 1);
  var $3db38b7d1fb3fe6a$var$count3 = 0;
  function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c3() {
    (0, import_react117.useEffect)(() => {
      var _edgeGuards$, _edgeGuards$2;
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard3());
      document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard3());
      $3db38b7d1fb3fe6a$var$count3++;
      return () => {
        if ($3db38b7d1fb3fe6a$var$count3 === 1)
          document.querySelectorAll("[data-radix-focus-guard]").forEach(
            (node) => node.remove()
          );
        $3db38b7d1fb3fe6a$var$count3--;
      };
    }, []);
  }
  function $3db38b7d1fb3fe6a$var$createFocusGuard3() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
    return element;
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-focus-scope/dist/index.mjs
  var import_react118 = __toESM(require_react(), 1);
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT3 = "focusScope.autoFocusOnMount";
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT3 = "focusScope.autoFocusOnUnmount";
  var $d3863c46a17e8a28$var$EVENT_OPTIONS3 = {
    bubbles: false,
    cancelable: true
  };
  var $d3863c46a17e8a28$export$20e40289641fbbb63 = /* @__PURE__ */ (0, import_react118.forwardRef)((props, forwardedRef) => {
    const { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp, ...scopeProps } = props;
    const [container1, setContainer] = (0, import_react118.useState)(null);
    const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onMountAutoFocusProp);
    const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onUnmountAutoFocusProp);
    const lastFocusedElementRef = (0, import_react118.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(
      forwardedRef,
      (node) => setContainer(node)
    );
    const focusScope = (0, import_react118.useRef)({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    (0, import_react118.useEffect)(() => {
      if (trapped) {
        let handleFocusIn = function(event) {
          if (focusScope.paused || !container1)
            return;
          const target = event.target;
          if (container1.contains(target))
            lastFocusedElementRef.current = target;
          else
            $d3863c46a17e8a28$var$focus3(lastFocusedElementRef.current, {
              select: true
            });
        }, handleFocusOut = function(event) {
          if (focusScope.paused || !container1)
            return;
          const relatedTarget = event.relatedTarget;
          if (relatedTarget === null)
            return;
          if (!container1.contains(relatedTarget))
            $d3863c46a17e8a28$var$focus3(lastFocusedElementRef.current, {
              select: true
            });
        }, handleMutations = function(mutations) {
          const focusedElement = document.activeElement;
          for (const mutation of mutations) {
            if (mutation.removedNodes.length > 0) {
              if (!(container1 !== null && container1 !== void 0 && container1.contains(focusedElement)))
                $d3863c46a17e8a28$var$focus3(container1);
            }
          }
        };
        document.addEventListener("focusin", handleFocusIn);
        document.addEventListener("focusout", handleFocusOut);
        const mutationObserver = new MutationObserver(handleMutations);
        if (container1)
          mutationObserver.observe(container1, {
            childList: true,
            subtree: true
          });
        return () => {
          document.removeEventListener("focusin", handleFocusIn);
          document.removeEventListener("focusout", handleFocusOut);
          mutationObserver.disconnect();
        };
      }
    }, [
      trapped,
      container1,
      focusScope.paused
    ]);
    (0, import_react118.useEffect)(() => {
      if (container1) {
        $d3863c46a17e8a28$var$focusScopesStack3.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT3, $d3863c46a17e8a28$var$EVENT_OPTIONS3);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT3, onMountAutoFocus);
          container1.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            $d3863c46a17e8a28$var$focusFirst3($d3863c46a17e8a28$var$removeLinks3($d3863c46a17e8a28$var$getTabbableCandidates3(container1)), {
              select: true
            });
            if (document.activeElement === previouslyFocusedElement)
              $d3863c46a17e8a28$var$focus3(container1);
          }
        }
        return () => {
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT3, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT3, $d3863c46a17e8a28$var$EVENT_OPTIONS3);
            container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT3, onUnmountAutoFocus);
            container1.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented)
              $d3863c46a17e8a28$var$focus3(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
                select: true
              });
            container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT3, onUnmountAutoFocus);
            $d3863c46a17e8a28$var$focusScopesStack3.remove(focusScope);
          }, 0);
        };
      }
    }, [
      container1,
      onMountAutoFocus,
      onUnmountAutoFocus,
      focusScope
    ]);
    const handleKeyDown = (0, import_react118.useCallback)((event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges3(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus3(first, {
                select: true
              });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus3(last, {
                select: true
              });
          }
        }
      }
    }, [
      loop,
      trapped,
      focusScope.paused
    ]);
    return /* @__PURE__ */ (0, import_react118.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({
      tabIndex: -1
    }, scopeProps, {
      ref: composedRefs,
      onKeyDown: handleKeyDown
    }));
  });
  function $d3863c46a17e8a28$var$focusFirst3(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      $d3863c46a17e8a28$var$focus3(candidate, {
        select
      });
      if (document.activeElement !== previouslyFocusedElement)
        return;
    }
  }
  function $d3863c46a17e8a28$var$getTabbableEdges3(container2) {
    const candidates = $d3863c46a17e8a28$var$getTabbableCandidates3(container2);
    const first = $d3863c46a17e8a28$var$findVisible3(candidates, container2);
    const last = $d3863c46a17e8a28$var$findVisible3(candidates.reverse(), container2);
    return [
      first,
      last
    ];
  }
  function $d3863c46a17e8a28$var$getTabbableCandidates3(container2) {
    const nodes = [];
    const walker = document.createTreeWalker(container2, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  }
  function $d3863c46a17e8a28$var$findVisible3(elements, container2) {
    for (const element of elements) {
      if (!$d3863c46a17e8a28$var$isHidden3(element, {
        upTo: container2
      }))
        return element;
    }
  }
  function $d3863c46a17e8a28$var$isHidden3(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden")
      return true;
    while (node) {
      if (upTo !== void 0 && node === upTo)
        return false;
      if (getComputedStyle(node).display === "none")
        return true;
      node = node.parentElement;
    }
    return false;
  }
  function $d3863c46a17e8a28$var$isSelectableInput3(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function $d3863c46a17e8a28$var$focus3(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({
        preventScroll: true
      });
      if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput3(element) && select)
        element.select();
    }
  }
  var $d3863c46a17e8a28$var$focusScopesStack3 = $d3863c46a17e8a28$var$createFocusScopesStack3();
  function $d3863c46a17e8a28$var$createFocusScopesStack3() {
    let stack = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack[0];
        if (focusScope !== activeFocusScope)
          activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
        stack = $d3863c46a17e8a28$var$arrayRemove3(stack, focusScope);
        stack.unshift(focusScope);
      },
      remove(focusScope) {
        var _stack$;
        stack = $d3863c46a17e8a28$var$arrayRemove3(stack, focusScope);
        (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();
      }
    };
  }
  function $d3863c46a17e8a28$var$arrayRemove3(array, item) {
    const updatedArray = [
      ...array
    ];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1)
      updatedArray.splice(index2, 1);
    return updatedArray;
  }
  function $d3863c46a17e8a28$var$removeLinks3(items) {
    return items.filter(
      (item) => item.tagName !== "A"
    );
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-id/dist/index.mjs
  var $2AODx$react6 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
  var import_react119 = __toESM(require_react(), 1);
  var $9f79659886946c16$export$e5c5a5f917a5871c8 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react119.useLayoutEffect : () => {
  };

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-id/dist/index.mjs
  var $1746a345f3d73bb7$var$useReactId6 = $2AODx$react6["useId".toString()] || (() => void 0);
  var $1746a345f3d73bb7$var$count6 = 0;
  function $1746a345f3d73bb7$export$f680877a34711e376(deterministicId) {
    const [id, setId] = $2AODx$react6.useState($1746a345f3d73bb7$var$useReactId6());
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      if (!deterministicId)
        setId(
          (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count6++)
        );
    }, [
      deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : "");
  }

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-popper/dist/index.mjs
  var import_react120 = __toESM(require_react(), 1);
  var $cf1ac5d9fe0e8206$var$POPPER_NAME2 = "Popper";
  var [$cf1ac5d9fe0e8206$var$createPopperContext2, $cf1ac5d9fe0e8206$export$722aac194ae9232] = $c512c27ab02ef895$export$50c7b4e9d9f19c19($cf1ac5d9fe0e8206$var$POPPER_NAME2);
  var [$cf1ac5d9fe0e8206$var$PopperProvider2, $cf1ac5d9fe0e8206$var$usePopperContext2] = $cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$POPPER_NAME2);
  var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf92 = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = (0, import_react120.useState)(null);
    return /* @__PURE__ */ (0, import_react120.createElement)($cf1ac5d9fe0e8206$var$PopperProvider2, {
      scope: __scopePopper,
      anchor,
      onAnchorChange: setAnchor
    }, children);
  };
  var $cf1ac5d9fe0e8206$var$ANCHOR_NAME2 = "PopperAnchor";
  var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d2 = /* @__PURE__ */ (0, import_react120.forwardRef)((props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = $cf1ac5d9fe0e8206$var$usePopperContext2($cf1ac5d9fe0e8206$var$ANCHOR_NAME2, __scopePopper);
    const ref = (0, import_react120.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, ref);
    (0, import_react120.useEffect)(() => {
      context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ (0, import_react120.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({}, anchorProps, {
      ref: composedRefs
    }));
  });
  var $cf1ac5d9fe0e8206$var$CONTENT_NAME2 = "PopperContent";
  var [$cf1ac5d9fe0e8206$var$PopperContentProvider2, $cf1ac5d9fe0e8206$var$useContentContext2] = $cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2);
  var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc2 = /* @__PURE__ */ (0, import_react120.forwardRef)((props, forwardedRef) => {
    var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$trans, _middlewareData$trans2, _middlewareData$hide;
    const { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced, ...contentProps } = props;
    const context = $cf1ac5d9fe0e8206$var$usePopperContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2, __scopePopper);
    const [content, setContent] = (0, import_react120.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(
      forwardedRef,
      (node) => setContent(node)
    );
    const [arrow3, setArrow] = (0, import_react120.useState)(null);
    const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow3);
    const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
    const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...collisionPaddingProp
    };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
      collisionBoundary
    ];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull2),
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: autoUpdate,
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({
          mainAxis: sideOffset + arrowHeight,
          alignmentAxis: alignOffset
        }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({
          ...detectOverflowOptions
        }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow3 && arrow2({
          element: arrow3,
          padding: arrowPadding
        }),
        $cf1ac5d9fe0e8206$var$transformOrigin2({
          arrowWidth,
          arrowHeight
        }),
        hideWhenDetached && hide({
          strategy: "referenceHidden"
        })
      ]
    });
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement);
    const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onPlaced);
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      if (isPositioned)
        handlePlaced === null || handlePlaced === void 0 || handlePlaced();
    }, [
      isPositioned,
      handlePlaced
    ]);
    const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
    const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
    const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = (0, import_react120.useState)();
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [
      content
    ]);
    return /* @__PURE__ */ (0, import_react120.createElement)("div", {
      ref: refs.setFloating,
      "data-radix-popper-content-wrapper": "",
      style: {
        ...floatingStyles,
        transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
        minWidth: "max-content",
        zIndex: contentZIndex,
        ["--radix-popper-transform-origin"]: [
          (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
          (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
        ].join(" ")
      },
      dir: props.dir
    }, /* @__PURE__ */ (0, import_react120.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider2, {
      scope: __scopePopper,
      placedSide,
      onArrowChange: setArrow,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    }, /* @__PURE__ */ (0, import_react120.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({
      "data-side": placedSide,
      "data-align": placedAlign
    }, contentProps, {
      ref: composedRefs,
      style: {
        ...contentProps.style,
        animation: !isPositioned ? "none" : void 0,
        opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
      }
    }))));
  });
  function $cf1ac5d9fe0e8206$var$isNotNull2(value) {
    return value !== null;
  }
  var $cf1ac5d9fe0e8206$var$transformOrigin2 = (options) => ({
    name: "transformOrigin",
    options,
    fn(data) {
      var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement);
      const noArrowAlign = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[placedAlign];
      const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
      const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
      let x2 = "";
      let y2 = "";
      if (placedSide === "bottom") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y2 = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x2 = `${-arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x2 = `${rects.floating.width + arrowHeight}px`;
        y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return {
        data: {
          x: x2,
          y: y2
        }
      };
    }
  });
  function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement) {
    const [side, align = "center"] = placement.split("-");
    return [
      side,
      align
    ];
  }
  var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe92 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf92;
  var $cf1ac5d9fe0e8206$export$b688253958b8dfe72 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d2;
  var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d22 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc2;

  // node_modules/@radix-ui/react-select/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var import_react121 = __toESM(require_react(), 1);
  function $71cd76cc60e0454e$export$6f32135080cb4c37({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState7({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onChange);
    const setValue = (0, import_react121.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState7({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react121.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react121.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onChange);
    (0, import_react121.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
  var import_react125 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react124 = __toESM(require_react(), 1);
  var import_react_dom17 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react123 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react122 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef11(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af11(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef11(ref, node)
    );
  }

  // node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-slot/dist/index.mjs
  var $5e63c961fc1ce211$export$8c6ed5c666ac136011 = /* @__PURE__ */ (0, import_react123.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react123.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable11);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react123.Children.count(newElement) > 1)
            return import_react123.Children.only(null);
          return /* @__PURE__ */ (0, import_react123.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react123.createElement)($5e63c961fc1ce211$var$SlotClone11, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react123.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react123.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react123.createElement)($5e63c961fc1ce211$var$SlotClone11, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac136011.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone11 = /* @__PURE__ */ (0, import_react123.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react123.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react123.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps11(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af11(forwardedRef, children.ref) : children.ref
      });
    return import_react123.Children.count(children) > 1 ? import_react123.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone11.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d4511 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react123.createElement)(import_react123.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable11(child) {
    return /* @__PURE__ */ (0, import_react123.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d4511;
  }
  function $5e63c961fc1ce211$var$mergeProps11(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-visually-hidden/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES10 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d03410 = $8927f6f2acc4f386$var$NODES10.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react124.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac136011 : node;
      (0, import_react124.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react124.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
  var $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ (0, import_react125.forwardRef)((props, forwardedRef) => {
    return /* @__PURE__ */ (0, import_react125.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d03410.span, _extends({}, props, {
      ref: forwardedRef,
      style: {
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...props.style
      }
    }));
  });

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/Combination.js
  var React22 = __toESM(require_react());

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/UI.js
  var React20 = __toESM(require_react());

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/medium.js
  var effectCar3 = createSidecarMedium();

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/UI.js
  var nothing3 = function() {
    return;
  };
  var RemoveScroll3 = React20.forwardRef(function(props, parentRef) {
    var ref = React20.useRef(null);
    var _a = React20.useState({
      onScrollCapture: nothing3,
      onWheelCapture: nothing3,
      onTouchMoveCapture: nothing3
    }), callbacks = _a[0], setCallbacks = _a[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return React20.createElement(
      React20.Fragment,
      null,
      enabled && React20.createElement(SideCar2, { sideCar: effectCar3, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
      forwardProps ? React20.cloneElement(React20.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React20.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll3.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll3.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var React21 = __toESM(require_react());

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
  var passiveSupported3 = false;
  if (typeof window !== "undefined") {
    try {
      options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported3 = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported3 = false;
    }
  }
  var options;
  var nonPassive3 = passiveSupported3 ? { passive: false } : false;

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/handleScroll.js
  var alwaysContainsScroll2 = function(node) {
    return node.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled2 = function(node, overflow) {
    var styles = window.getComputedStyle(node);
    return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll2(node) && styles[overflow] === "visible");
  };
  var elementCouldBeVScrolled3 = function(node) {
    return elementCanBeScrolled2(node, "overflowY");
  };
  var elementCouldBeHScrolled3 = function(node) {
    return elementCanBeScrolled2(node, "overflowX");
  };
  var locationCouldBeScrolled3 = function(axis, node) {
    var current = node;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled3(axis, current);
      if (isScrollable) {
        var _a = getScrollVariables3(axis, current), s2 = _a[1], d3 = _a[2];
        if (s2 > d3) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== document.body);
    return false;
  };
  var getVScrollVariables3 = function(_a) {
    var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables3 = function(_a) {
    var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled3 = function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled3(node) : elementCouldBeHScrolled3(node);
  };
  var getScrollVariables3 = function(axis, node) {
    return axis === "v" ? getVScrollVariables3(node) : getHScrollVariables3(node);
  };
  var getDirectionFactor3 = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll3 = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor3(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      var _a = getScrollVariables3(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled3(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      target = target.parentNode;
    } while (!targetInLock && target !== document.body || targetInLock && (endTarget.contains(target) || endTarget === target));
    if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var getTouchXY3 = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY3 = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef3 = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare3 = function(x2, y2) {
    return x2[0] === y2[0] && x2[1] === y2[1];
  };
  var generateStyle3 = function(id) {
    return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
  };
  var idCounter3 = 0;
  var lockStack3 = [];
  function RemoveScrollSideCar3(props) {
    var shouldPreventQueue = React21.useRef([]);
    var touchStartRef = React21.useRef([0, 0]);
    var activeAxis = React21.useRef();
    var id = React21.useState(idCounter3++)[0];
    var Style2 = React21.useState(function() {
      return styleSingleton();
    })[0];
    var lastProps = React21.useRef(props);
    React21.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    React21.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef3), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React21.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY3(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled3(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled3(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll3(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React21.useCallback(function(_event) {
      var event = _event;
      if (!lockStack3.length || lockStack3[lockStack3.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY3(event) : getTouchXY3(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
        return e3.name === event.type && e3.target === event.target && deltaCompare3(e3.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef3).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = React21.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
          return e3 !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = React21.useCallback(function(event) {
      touchStartRef.current = getTouchXY3(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = React21.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY3(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React21.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY3(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React21.useEffect(function() {
      lockStack3.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive3);
      document.addEventListener("touchmove", shouldPrevent, nonPassive3);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive3);
      return function() {
        lockStack3 = lockStack3.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive3);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive3);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive3);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return React21.createElement(
      React21.Fragment,
      null,
      inert ? React21.createElement(Style2, { styles: generateStyle3(id) }) : null,
      removeScrollBar ? React21.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
    );
  }

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/sidecar.js
  var sidecar_default3 = exportSidecar(effectCar3, RemoveScrollSideCar3);

  // node_modules/@radix-ui/react-select/node_modules/react-remove-scroll/dist/es2015/Combination.js
  var ReactRemoveScroll3 = React22.forwardRef(function(props, ref) {
    return React22.createElement(RemoveScroll3, __assign({}, props, { ref, sideCar: sidecar_default3 }));
  });
  ReactRemoveScroll3.classNames = RemoveScroll3.classNames;
  var Combination_default3 = ReactRemoveScroll3;

  // node_modules/@radix-ui/react-select/dist/index.mjs
  var $cc7e05a45900e73f$var$OPEN_KEYS = [
    " ",
    "Enter",
    "ArrowUp",
    "ArrowDown"
  ];
  var $cc7e05a45900e73f$var$SELECTION_KEYS = [
    " ",
    "Enter"
  ];
  var $cc7e05a45900e73f$var$SELECT_NAME = "Select";
  var [$cc7e05a45900e73f$var$Collection, $cc7e05a45900e73f$var$useCollection, $cc7e05a45900e73f$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($cc7e05a45900e73f$var$SELECT_NAME);
  var [$cc7e05a45900e73f$var$createSelectContext, $cc7e05a45900e73f$export$286727a75dc039bd] = $c512c27ab02ef895$export$50c7b4e9d9f19c19($cc7e05a45900e73f$var$SELECT_NAME, [
    $cc7e05a45900e73f$var$createCollectionScope,
    $cf1ac5d9fe0e8206$export$722aac194ae9232
  ]);
  var $cc7e05a45900e73f$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae9232();
  var [$cc7e05a45900e73f$var$SelectProvider, $cc7e05a45900e73f$var$useSelectContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$SELECT_NAME);
  var [$cc7e05a45900e73f$var$SelectNativeOptionsProvider, $cc7e05a45900e73f$var$useSelectNativeOptionsContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$SELECT_NAME);
  var $cc7e05a45900e73f$export$ef9b1a59e592288f = (props) => {
    const { __scopeSelect, children, open: openProp, defaultOpen, onOpenChange, value: valueProp, defaultValue, onValueChange, dir, name, autoComplete, disabled, required } = props;
    const popperScope = $cc7e05a45900e73f$var$usePopperScope(__scopeSelect);
    const [trigger, setTrigger] = (0, import_react126.useState)(null);
    const [valueNode, setValueNode] = (0, import_react126.useState)(null);
    const [valueNodeHasChildren, setValueNodeHasChildren] = (0, import_react126.useState)(false);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c37({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c37({
      prop: valueProp,
      defaultProp: defaultValue,
      onChange: onValueChange
    });
    const triggerPointerDownPosRef = (0, import_react126.useRef)(null);
    const isFormControl = trigger ? Boolean(trigger.closest("form")) : true;
    const [nativeOptionsSet, setNativeOptionsSet] = (0, import_react126.useState)(/* @__PURE__ */ new Set());
    const nativeSelectKey = Array.from(nativeOptionsSet).map(
      (option) => option.props.value
    ).join(";");
    return /* @__PURE__ */ (0, import_react126.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe92, popperScope, /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectProvider, {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: $1746a345f3d73bb7$export$f680877a34711e376(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled
    }, /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$Collection.Provider, {
      scope: __scopeSelect
    }, /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectNativeOptionsProvider, {
      scope: props.__scopeSelect,
      onNativeOptionAdd: (0, import_react126.useCallback)((option) => {
        setNativeOptionsSet(
          (prev) => new Set(prev).add(option)
        );
      }, []),
      onNativeOptionRemove: (0, import_react126.useCallback)((option) => {
        setNativeOptionsSet((prev) => {
          const optionsSet = new Set(prev);
          optionsSet.delete(option);
          return optionsSet;
        });
      }, [])
    }, children)), isFormControl ? /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$BubbleSelect, {
      key: nativeSelectKey,
      "aria-hidden": true,
      required,
      tabIndex: -1,
      name,
      autoComplete,
      value,
      onChange: (event) => setValue(event.target.value),
      disabled
    }, value === void 0 ? /* @__PURE__ */ (0, import_react126.createElement)("option", {
      value: ""
    }) : null, Array.from(nativeOptionsSet)) : null));
  };
  var $cc7e05a45900e73f$var$TRIGGER_NAME = "SelectTrigger";
  var $cc7e05a45900e73f$export$3ac1e88a1c0b9f1 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = $cc7e05a45900e73f$var$usePopperScope(__scopeSelect);
    const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$TRIGGER_NAME, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, context.onTriggerChange);
    const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = $cc7e05a45900e73f$var$useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter(
        (item) => !item.disabled
      );
      const currentItem = enabledItems.find(
        (item) => item.value === context.value
      );
      const nextItem = $cc7e05a45900e73f$var$findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0)
        context.onValueChange(nextItem.value);
    });
    const handleOpen = () => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
    };
    return /* @__PURE__ */ (0, import_react126.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe72, _extends({
      asChild: true
    }, popperScope), /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.button, _extends({
      type: "button",
      role: "combobox",
      "aria-controls": context.contentId,
      "aria-expanded": context.open,
      "aria-required": context.required,
      "aria-autocomplete": "none",
      dir: context.dir,
      "data-state": context.open ? "open" : "closed",
      disabled: isDisabled,
      "data-disabled": isDisabled ? "" : void 0,
      "data-placeholder": context.value === void 0 ? "" : void 0
    }, triggerProps, {
      ref: composedRefs,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff107(triggerProps.onClick, (event) => {
        event.currentTarget.focus();
      }),
      onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff107(triggerProps.onPointerDown, (event) => {
        const target = event.target;
        if (target.hasPointerCapture(event.pointerId))
          target.releasePointerCapture(event.pointerId);
        if (event.button === 0 && event.ctrlKey === false) {
          handleOpen();
          context.triggerPointerDownPosRef.current = {
            x: Math.round(event.pageX),
            y: Math.round(event.pageY)
          };
          event.preventDefault();
        }
      }),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff107(triggerProps.onKeyDown, (event) => {
        const isTypingAhead = searchRef.current !== "";
        const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
        if (!isModifierKey && event.key.length === 1)
          handleTypeaheadSearch(event.key);
        if (isTypingAhead && event.key === " ")
          return;
        if ($cc7e05a45900e73f$var$OPEN_KEYS.includes(event.key)) {
          handleOpen();
          event.preventDefault();
        }
      })
    })));
  });
  var $cc7e05a45900e73f$var$VALUE_NAME = "SelectValue";
  var $cc7e05a45900e73f$export$e288731fd71264f0 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder, ...valueProps } = props;
    const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, context.onValueNodeChange);
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [
      onValueNodeHasChildrenChange,
      hasChildren
    ]);
    return /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.span, _extends({}, valueProps, {
      ref: composedRefs,
      style: {
        pointerEvents: "none"
      }
    }), context.value === void 0 && placeholder !== void 0 ? placeholder : children);
  });
  var $cc7e05a45900e73f$export$99b400cabb58c515 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.span, _extends({
      "aria-hidden": true
    }, iconProps, {
      ref: forwardedRef
    }), children || "\u25BC");
  });
  var $cc7e05a45900e73f$var$CONTENT_NAME = "SelectContent";
  var $cc7e05a45900e73f$export$c973a4b3cb86a03d = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, props.__scopeSelect);
    const [fragment, setFragment] = (0, import_react126.useState)();
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? /* @__PURE__ */ (0, import_react_dom18.createPortal)(/* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectContentProvider, {
        scope: props.__scopeSelect
      }, /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$Collection.Slot, {
        scope: props.__scopeSelect
      }, /* @__PURE__ */ (0, import_react126.createElement)("div", null, props.children))), frag) : null;
    }
    return /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectContentImpl, _extends({}, props, {
      ref: forwardedRef
    }));
  });
  var $cc7e05a45900e73f$var$CONTENT_MARGIN = 10;
  var [$cc7e05a45900e73f$var$SelectContentProvider, $cc7e05a45900e73f$var$useSelectContentContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$CONTENT_NAME);
  var $cc7e05a45900e73f$var$SelectContentImpl = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      ...contentProps
    } = props;
    const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, __scopeSelect);
    const [content, setContent] = (0, import_react126.useState)(null);
    const [viewport, setViewport] = (0, import_react126.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(
      forwardedRef,
      (node) => setContent(node)
    );
    const [selectedItem, setSelectedItem] = (0, import_react126.useState)(null);
    const [selectedItemText, setSelectedItemText] = (0, import_react126.useState)(null);
    const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
    const [isPositioned, setIsPositioned] = (0, import_react126.useState)(false);
    const firstValidItemFoundRef = (0, import_react126.useRef)(false);
    (0, import_react126.useEffect)(() => {
      if (content)
        return hideOthers(content);
    }, [
      content
    ]);
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c3();
    const focusFirst = (0, import_react126.useCallback)((candidates) => {
      const [firstItem, ...restItems] = getItems().map(
        (item) => item.ref.current
      );
      const [lastItem] = restItems.slice(-1);
      const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
      for (const candidate of candidates) {
        if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
          return;
        candidate === null || candidate === void 0 || candidate.scrollIntoView({
          block: "nearest"
        });
        if (candidate === firstItem && viewport)
          viewport.scrollTop = 0;
        if (candidate === lastItem && viewport)
          viewport.scrollTop = viewport.scrollHeight;
        candidate === null || candidate === void 0 || candidate.focus();
        if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
          return;
      }
    }, [
      getItems,
      viewport
    ]);
    const focusSelectedItem = (0, import_react126.useCallback)(
      () => focusFirst([
        selectedItem,
        content
      ]),
      [
        focusFirst,
        selectedItem,
        content
      ]
    );
    (0, import_react126.useEffect)(() => {
      if (isPositioned)
        focusSelectedItem();
    }, [
      isPositioned,
      focusSelectedItem
    ]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    (0, import_react126.useEffect)(() => {
      if (content) {
        let pointerMoveDelta = {
          x: 0,
          y: 0
        };
        const handlePointerMove = (event) => {
          var _triggerPointerDownPo, _triggerPointerDownPo2, _triggerPointerDownPo3, _triggerPointerDownPo4;
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - ((_triggerPointerDownPo = (_triggerPointerDownPo2 = triggerPointerDownPosRef.current) === null || _triggerPointerDownPo2 === void 0 ? void 0 : _triggerPointerDownPo2.x) !== null && _triggerPointerDownPo !== void 0 ? _triggerPointerDownPo : 0)),
            y: Math.abs(Math.round(event.pageY) - ((_triggerPointerDownPo3 = (_triggerPointerDownPo4 = triggerPointerDownPosRef.current) === null || _triggerPointerDownPo4 === void 0 ? void 0 : _triggerPointerDownPo4.y) !== null && _triggerPointerDownPo3 !== void 0 ? _triggerPointerDownPo3 : 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10)
            event.preventDefault();
          else if (!content.contains(event.target))
            onOpenChange(false);
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, {
            capture: true,
            once: true
          });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, {
            capture: true
          });
        };
      }
    }, [
      content,
      onOpenChange,
      triggerPointerDownPosRef
    ]);
    (0, import_react126.useEffect)(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [
      onOpenChange
    ]);
    const [searchRef, handleTypeaheadSearch] = $cc7e05a45900e73f$var$useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter(
        (item) => !item.disabled
      );
      const currentItem = enabledItems.find(
        (item) => item.ref.current === document.activeElement
      );
      const nextItem = $cc7e05a45900e73f$var$findNextItem(enabledItems, search, currentItem);
      if (nextItem)
        setTimeout(
          () => nextItem.ref.current.focus()
        );
    });
    const itemRefCallback = (0, import_react126.useCallback)((node, value, disabled) => {
      const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
      const isSelectedItem = context.value !== void 0 && context.value === value;
      if (isSelectedItem || isFirstValidItem) {
        setSelectedItem(node);
        if (isFirstValidItem)
          firstValidItemFoundRef.current = true;
      }
    }, [
      context.value
    ]);
    const handleItemLeave = (0, import_react126.useCallback)(
      () => content === null || content === void 0 ? void 0 : content.focus(),
      [
        content
      ]
    );
    const itemTextRefCallback = (0, import_react126.useCallback)((node, value, disabled) => {
      const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
      const isSelectedItem = context.value !== void 0 && context.value === value;
      if (isSelectedItem || isFirstValidItem)
        setSelectedItemText(node);
    }, [
      context.value
    ]);
    const SelectPosition = position === "popper" ? $cc7e05a45900e73f$var$SelectPopperPosition : $cc7e05a45900e73f$var$SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === $cc7e05a45900e73f$var$SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectContentProvider, {
      scope: __scopeSelect,
      content,
      viewport,
      onViewportChange: setViewport,
      itemRefCallback,
      selectedItem,
      onItemLeave: handleItemLeave,
      itemTextRefCallback,
      focusSelectedItem,
      selectedItemText,
      position,
      isPositioned,
      searchRef
    }, /* @__PURE__ */ (0, import_react126.createElement)(Combination_default3, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac136010,
      allowPinchZoom: true
    }, /* @__PURE__ */ (0, import_react126.createElement)($d3863c46a17e8a28$export$20e40289641fbbb63, {
      asChild: true,
      trapped: context.open,
      onMountAutoFocus: (event) => {
        event.preventDefault();
      },
      onUnmountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff107(onCloseAutoFocus, (event) => {
        var _context$trigger;
        (_context$trigger = context.trigger) === null || _context$trigger === void 0 || _context$trigger.focus({
          preventScroll: true
        });
        event.preventDefault();
      })
    }, /* @__PURE__ */ (0, import_react126.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f223, {
      asChild: true,
      disableOutsidePointerEvents: true,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside: (event) => event.preventDefault(),
      onDismiss: () => context.onOpenChange(false)
    }, /* @__PURE__ */ (0, import_react126.createElement)(SelectPosition, _extends({
      role: "listbox",
      id: context.contentId,
      "data-state": context.open ? "open" : "closed",
      dir: context.dir,
      onContextMenu: (event) => event.preventDefault()
    }, contentProps, popperContentProps, {
      onPlaced: () => setIsPositioned(true),
      ref: composedRefs,
      style: {
        display: "flex",
        flexDirection: "column",
        outline: "none",
        ...contentProps.style
      },
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff107(contentProps.onKeyDown, (event) => {
        const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
        if (event.key === "Tab")
          event.preventDefault();
        if (!isModifierKey && event.key.length === 1)
          handleTypeaheadSearch(event.key);
        if ([
          "ArrowUp",
          "ArrowDown",
          "Home",
          "End"
        ].includes(event.key)) {
          const items = getItems().filter(
            (item) => !item.disabled
          );
          let candidateNodes = items.map(
            (item) => item.ref.current
          );
          if ([
            "ArrowUp",
            "End"
          ].includes(event.key))
            candidateNodes = candidateNodes.slice().reverse();
          if ([
            "ArrowUp",
            "ArrowDown"
          ].includes(event.key)) {
            const currentElement = event.target;
            const currentIndex = candidateNodes.indexOf(currentElement);
            candidateNodes = candidateNodes.slice(currentIndex + 1);
          }
          setTimeout(
            () => focusFirst(candidateNodes)
          );
          event.preventDefault();
        }
      })
    }))))));
  });
  var $cc7e05a45900e73f$var$SelectItemAlignedPosition = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, onPlaced, ...popperProps } = props;
    const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, __scopeSelect);
    const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$CONTENT_NAME, __scopeSelect);
    const [contentWrapper, setContentWrapper] = (0, import_react126.useState)(null);
    const [content, setContent] = (0, import_react126.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(
      forwardedRef,
      (node) => setContent(node)
    );
    const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
    const shouldExpandOnScrollRef = (0, import_react126.useRef)(false);
    const shouldRepositionRef = (0, import_react126.useRef)(true);
    const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
    const position = (0, import_react126.useCallback)(() => {
      if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
        const triggerRect = context.trigger.getBoundingClientRect();
        const contentRect = content.getBoundingClientRect();
        const valueNodeRect = context.valueNode.getBoundingClientRect();
        const itemTextRect = selectedItemText.getBoundingClientRect();
        if (context.dir !== "rtl") {
          const itemTextOffset = itemTextRect.left - contentRect.left;
          const left = valueNodeRect.left - itemTextOffset;
          const leftDelta = triggerRect.left - left;
          const minContentWidth = triggerRect.width + leftDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const rightEdge = window.innerWidth - $cc7e05a45900e73f$var$CONTENT_MARGIN;
          const clampedLeft = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(left, [
            $cc7e05a45900e73f$var$CONTENT_MARGIN,
            rightEdge - contentWidth
          ]);
          contentWrapper.style.minWidth = minContentWidth + "px";
          contentWrapper.style.left = clampedLeft + "px";
        } else {
          const itemTextOffset = contentRect.right - itemTextRect.right;
          const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
          const rightDelta = window.innerWidth - triggerRect.right - right;
          const minContentWidth = triggerRect.width + rightDelta;
          const contentWidth = Math.max(minContentWidth, contentRect.width);
          const leftEdge = window.innerWidth - $cc7e05a45900e73f$var$CONTENT_MARGIN;
          const clampedRight = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(right, [
            $cc7e05a45900e73f$var$CONTENT_MARGIN,
            leftEdge - contentWidth
          ]);
          contentWrapper.style.minWidth = minContentWidth + "px";
          contentWrapper.style.right = clampedRight + "px";
        }
        const items = getItems();
        const availableHeight = window.innerHeight - $cc7e05a45900e73f$var$CONTENT_MARGIN * 2;
        const itemsHeight = viewport.scrollHeight;
        const contentStyles = window.getComputedStyle(content);
        const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
        const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
        const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
        const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
        const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
        const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
        const viewportStyles = window.getComputedStyle(viewport);
        const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
        const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
        const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - $cc7e05a45900e73f$var$CONTENT_MARGIN;
        const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
        const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
        const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
        const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
        const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
        const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
        if (willAlignWithoutTopOverflow) {
          const isLastItem = selectedItem === items[items.length - 1].ref.current;
          contentWrapper.style.bottom = "0px";
          const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
          const clampedTriggerMiddleToBottomEdge = Math.max(triggerMiddleToBottomEdge, selectedItemHalfHeight + (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth);
          const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
          contentWrapper.style.height = height + "px";
        } else {
          const isFirstItem = selectedItem === items[0].ref.current;
          contentWrapper.style.top = "0px";
          const clampedTopEdgeToTriggerMiddle = Math.max(topEdgeToTriggerMiddle, contentBorderTopWidth + viewport.offsetTop + (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight);
          const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
          contentWrapper.style.height = height + "px";
          viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
        }
        contentWrapper.style.margin = `${$cc7e05a45900e73f$var$CONTENT_MARGIN}px 0`;
        contentWrapper.style.minHeight = minContentHeight + "px";
        contentWrapper.style.maxHeight = availableHeight + "px";
        onPlaced === null || onPlaced === void 0 || onPlaced();
        requestAnimationFrame(
          () => shouldExpandOnScrollRef.current = true
        );
      }
    }, [
      getItems,
      context.trigger,
      context.valueNode,
      contentWrapper,
      content,
      viewport,
      selectedItem,
      selectedItemText,
      context.dir,
      onPlaced
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c8(
      () => position(),
      [
        position
      ]
    );
    const [contentZIndex, setContentZIndex] = (0, import_react126.useState)();
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [
      content
    ]);
    const handleScrollButtonChange = (0, import_react126.useCallback)((node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem === null || focusSelectedItem === void 0 || focusSelectedItem();
        shouldRepositionRef.current = false;
      }
    }, [
      position,
      focusSelectedItem
    ]);
    return /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectViewportProvider, {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange
    }, /* @__PURE__ */ (0, import_react126.createElement)("div", {
      ref: setContentWrapper,
      style: {
        display: "flex",
        flexDirection: "column",
        position: "fixed",
        zIndex: contentZIndex
      }
    }, /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({}, popperProps, {
      ref: composedRefs,
      style: {
        boxSizing: "border-box",
        maxHeight: "100%",
        ...popperProps.style
      }
    }))));
  });
  var $cc7e05a45900e73f$var$SelectPopperPosition = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, align = "start", collisionPadding = $cc7e05a45900e73f$var$CONTENT_MARGIN, ...popperProps } = props;
    const popperScope = $cc7e05a45900e73f$var$usePopperScope(__scopeSelect);
    return /* @__PURE__ */ (0, import_react126.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d22, _extends({}, popperScope, popperProps, {
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        boxSizing: "border-box",
        ...popperProps.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }));
  });
  var [$cc7e05a45900e73f$var$SelectViewportProvider, $cc7e05a45900e73f$var$useSelectViewportContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$CONTENT_NAME, {});
  var $cc7e05a45900e73f$var$VIEWPORT_NAME = "SelectViewport";
  var $cc7e05a45900e73f$export$9ed6e7b40248d36d = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, ...viewportProps } = props;
    const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$VIEWPORT_NAME, __scopeSelect);
    const viewportContext = $cc7e05a45900e73f$var$useSelectViewportContext($cc7e05a45900e73f$var$VIEWPORT_NAME, __scopeSelect);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = (0, import_react126.useRef)(0);
    return /* @__PURE__ */ (0, import_react126.createElement)(import_react126.Fragment, null, /* @__PURE__ */ (0, import_react126.createElement)("style", {
      dangerouslySetInnerHTML: {
        __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
      }
    }), /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$Collection.Slot, {
      scope: __scopeSelect
    }, /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({
      "data-radix-select-viewport": "",
      role: "presentation"
    }, viewportProps, {
      ref: composedRefs,
      style: {
        position: "relative",
        flex: 1,
        overflow: "auto",
        ...viewportProps.style
      },
      onScroll: $e42e1063c40fb3ef$export$b9ecd428b558ff107(viewportProps.onScroll, (event) => {
        const viewport = event.currentTarget;
        const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
        if (shouldExpandOnScrollRef !== null && shouldExpandOnScrollRef !== void 0 && shouldExpandOnScrollRef.current && contentWrapper) {
          const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
          if (scrolledBy > 0) {
            const availableHeight = window.innerHeight - $cc7e05a45900e73f$var$CONTENT_MARGIN * 2;
            const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
            const cssHeight = parseFloat(contentWrapper.style.height);
            const prevHeight = Math.max(cssMinHeight, cssHeight);
            if (prevHeight < availableHeight) {
              const nextHeight = prevHeight + scrolledBy;
              const clampedNextHeight = Math.min(availableHeight, nextHeight);
              const heightDiff = nextHeight - clampedNextHeight;
              contentWrapper.style.height = clampedNextHeight + "px";
              if (contentWrapper.style.bottom === "0px") {
                viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                contentWrapper.style.justifyContent = "flex-end";
              }
            }
          }
        }
        prevScrollTopRef.current = viewport.scrollTop;
      })
    }))));
  });
  var $cc7e05a45900e73f$var$GROUP_NAME = "SelectGroup";
  var [$cc7e05a45900e73f$var$SelectGroupContextProvider, $cc7e05a45900e73f$var$useSelectGroupContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$GROUP_NAME);
  var $cc7e05a45900e73f$export$ee25a334c55de1f4 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = $1746a345f3d73bb7$export$f680877a34711e376();
    return /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectGroupContextProvider, {
      scope: __scopeSelect,
      id: groupId
    }, /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({
      role: "group",
      "aria-labelledby": groupId
    }, groupProps, {
      ref: forwardedRef
    })));
  });
  var $cc7e05a45900e73f$var$LABEL_NAME = "SelectLabel";
  var $cc7e05a45900e73f$export$f67338d29bd972f8 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = $cc7e05a45900e73f$var$useSelectGroupContext($cc7e05a45900e73f$var$LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({
      id: groupContext.id
    }, labelProps, {
      ref: forwardedRef
    }));
  });
  var $cc7e05a45900e73f$var$ITEM_NAME = "SelectItem";
  var [$cc7e05a45900e73f$var$SelectItemContextProvider, $cc7e05a45900e73f$var$useSelectItemContext] = $cc7e05a45900e73f$var$createSelectContext($cc7e05a45900e73f$var$ITEM_NAME);
  var $cc7e05a45900e73f$export$13ef48a934230896 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, value, disabled = false, textValue: textValueProp, ...itemProps } = props;
    const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$ITEM_NAME, __scopeSelect);
    const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = (0, import_react126.useState)(textValueProp !== null && textValueProp !== void 0 ? textValueProp : "");
    const [isFocused, setIsFocused] = (0, import_react126.useState)(false);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, (node) => {
      var _contentContext$itemR;
      return (_contentContext$itemR = contentContext.itemRefCallback) === null || _contentContext$itemR === void 0 ? void 0 : _contentContext$itemR.call(contentContext, node, value, disabled);
    });
    const textId = $1746a345f3d73bb7$export$f680877a34711e376();
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    return /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectItemContextProvider, {
      scope: __scopeSelect,
      value,
      disabled,
      textId,
      isSelected,
      onItemTextChange: (0, import_react126.useCallback)((node) => {
        setTextValue((prevTextValue) => {
          var _node$textContent;
          return prevTextValue || ((_node$textContent = node === null || node === void 0 ? void 0 : node.textContent) !== null && _node$textContent !== void 0 ? _node$textContent : "").trim();
        });
      }, [])
    }, /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$Collection.ItemSlot, {
      scope: __scopeSelect,
      value,
      disabled,
      textValue
    }, /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({
      role: "option",
      "aria-labelledby": textId,
      "data-highlighted": isFocused ? "" : void 0,
      "aria-selected": isSelected && isFocused,
      "data-state": isSelected ? "checked" : "unchecked",
      "aria-disabled": disabled || void 0,
      "data-disabled": disabled ? "" : void 0,
      tabIndex: disabled ? void 0 : -1
    }, itemProps, {
      ref: composedRefs,
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff107(
        itemProps.onFocus,
        () => setIsFocused(true)
      ),
      onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff107(
        itemProps.onBlur,
        () => setIsFocused(false)
      ),
      onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff107(itemProps.onPointerUp, handleSelect),
      onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff107(itemProps.onPointerMove, (event) => {
        if (disabled) {
          var _contentContext$onIte;
          (_contentContext$onIte = contentContext.onItemLeave) === null || _contentContext$onIte === void 0 || _contentContext$onIte.call(contentContext);
        } else
          event.currentTarget.focus({
            preventScroll: true
          });
      }),
      onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff107(itemProps.onPointerLeave, (event) => {
        if (event.currentTarget === document.activeElement) {
          var _contentContext$onIte2;
          (_contentContext$onIte2 = contentContext.onItemLeave) === null || _contentContext$onIte2 === void 0 || _contentContext$onIte2.call(contentContext);
        }
      }),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff107(itemProps.onKeyDown, (event) => {
        var _contentContext$searc;
        const isTypingAhead = ((_contentContext$searc = contentContext.searchRef) === null || _contentContext$searc === void 0 ? void 0 : _contentContext$searc.current) !== "";
        if (isTypingAhead && event.key === " ")
          return;
        if ($cc7e05a45900e73f$var$SELECTION_KEYS.includes(event.key))
          handleSelect();
        if (event.key === " ")
          event.preventDefault();
      })
    }))));
  });
  var $cc7e05a45900e73f$var$ITEM_TEXT_NAME = "SelectItemText";
  var $cc7e05a45900e73f$export$3572fb0fb821ff49 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = $cc7e05a45900e73f$var$useSelectContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = $cc7e05a45900e73f$var$useSelectItemContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = $cc7e05a45900e73f$var$useSelectNativeOptionsContext($cc7e05a45900e73f$var$ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = (0, import_react126.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => {
        var _contentContext$itemT;
        return (_contentContext$itemT = contentContext.itemTextRefCallback) === null || _contentContext$itemT === void 0 ? void 0 : _contentContext$itemT.call(contentContext, node, itemContext.value, itemContext.disabled);
      }
    );
    const textContent = itemTextNode === null || itemTextNode === void 0 ? void 0 : itemTextNode.textContent;
    const nativeOption = (0, import_react126.useMemo)(
      () => /* @__PURE__ */ (0, import_react126.createElement)("option", {
        key: itemContext.value,
        value: itemContext.value,
        disabled: itemContext.disabled
      }, textContent),
      [
        itemContext.disabled,
        itemContext.value,
        textContent
      ]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [
      onNativeOptionAdd,
      onNativeOptionRemove,
      nativeOption
    ]);
    return /* @__PURE__ */ (0, import_react126.createElement)(import_react126.Fragment, null, /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.span, _extends({
      id: itemContext.textId
    }, itemTextProps, {
      ref: composedRefs
    })), itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? /* @__PURE__ */ (0, import_react_dom18.createPortal)(itemTextProps.children, context.valueNode) : null);
  });
  var $cc7e05a45900e73f$var$ITEM_INDICATOR_NAME = "SelectItemIndicator";
  var $cc7e05a45900e73f$export$6b9198de19accfe6 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = $cc7e05a45900e73f$var$useSelectItemContext($cc7e05a45900e73f$var$ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.span, _extends({
      "aria-hidden": true
    }, itemIndicatorProps, {
      ref: forwardedRef
    })) : null;
  });
  var $cc7e05a45900e73f$var$SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
  var $cc7e05a45900e73f$export$d8117927658af6d7 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = $cc7e05a45900e73f$var$useSelectViewportContext($cc7e05a45900e73f$var$SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
    const [canScrollUp1, setCanScrollUp] = (0, import_react126.useState)(false);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, viewportContext.onScrollButtonChange);
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll4 = function() {
          const canScrollUp = viewport.scrollTop > 0;
          setCanScrollUp(canScrollUp);
        };
        const viewport = contentContext.viewport;
        handleScroll4();
        viewport.addEventListener("scroll", handleScroll4);
        return () => viewport.removeEventListener("scroll", handleScroll4);
      }
    }, [
      contentContext.viewport,
      contentContext.isPositioned
    ]);
    return canScrollUp1 ? /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectScrollButtonImpl, _extends({}, props, {
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem)
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
      }
    })) : null;
  });
  var $cc7e05a45900e73f$var$SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
  var $cc7e05a45900e73f$export$ff951e476c12189 = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const contentContext = $cc7e05a45900e73f$var$useSelectContentContext($cc7e05a45900e73f$var$SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const viewportContext = $cc7e05a45900e73f$var$useSelectViewportContext($cc7e05a45900e73f$var$SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
    const [canScrollDown1, setCanScrollDown] = (0, import_react126.useState)(false);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, viewportContext.onScrollButtonChange);
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      if (contentContext.viewport && contentContext.isPositioned) {
        let handleScroll4 = function() {
          const maxScroll = viewport.scrollHeight - viewport.clientHeight;
          const canScrollDown = Math.ceil(viewport.scrollTop) < maxScroll;
          setCanScrollDown(canScrollDown);
        };
        const viewport = contentContext.viewport;
        handleScroll4();
        viewport.addEventListener("scroll", handleScroll4);
        return () => viewport.removeEventListener("scroll", handleScroll4);
      }
    }, [
      contentContext.viewport,
      contentContext.isPositioned
    ]);
    return canScrollDown1 ? /* @__PURE__ */ (0, import_react126.createElement)($cc7e05a45900e73f$var$SelectScrollButtonImpl, _extends({}, props, {
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem)
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
      }
    })) : null;
  });
  var $cc7e05a45900e73f$var$SelectScrollButtonImpl = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
    const contentContext = $cc7e05a45900e73f$var$useSelectContentContext("SelectScrollButton", __scopeSelect);
    const autoScrollTimerRef = (0, import_react126.useRef)(null);
    const getItems = $cc7e05a45900e73f$var$useCollection(__scopeSelect);
    const clearAutoScrollTimer = (0, import_react126.useCallback)(() => {
      if (autoScrollTimerRef.current !== null) {
        window.clearInterval(autoScrollTimerRef.current);
        autoScrollTimerRef.current = null;
      }
    }, []);
    (0, import_react126.useEffect)(() => {
      return () => clearAutoScrollTimer();
    }, [
      clearAutoScrollTimer
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c8(() => {
      var _activeItem$ref$curre;
      const activeItem = getItems().find(
        (item) => item.ref.current === document.activeElement
      );
      activeItem === null || activeItem === void 0 || (_activeItem$ref$curre = activeItem.ref.current) === null || _activeItem$ref$curre === void 0 || _activeItem$ref$curre.scrollIntoView({
        block: "nearest"
      });
    }, [
      getItems
    ]);
    return /* @__PURE__ */ (0, import_react126.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d0349.div, _extends({
      "aria-hidden": true
    }, scrollIndicatorProps, {
      ref: forwardedRef,
      style: {
        flexShrink: 0,
        ...scrollIndicatorProps.style
      },
      onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff107(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null)
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
      }),
      onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff107(scrollIndicatorProps.onPointerMove, () => {
        var _contentContext$onIte3;
        (_contentContext$onIte3 = contentContext.onItemLeave) === null || _contentContext$onIte3 === void 0 || _contentContext$onIte3.call(contentContext);
        if (autoScrollTimerRef.current === null)
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
      }),
      onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff107(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }));
  });
  var $cc7e05a45900e73f$var$BubbleSelect = /* @__PURE__ */ (0, import_react126.forwardRef)((props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = (0, import_react126.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d059(forwardedRef, ref);
    const prevValue = $010c2913dbd2fe3d$export$5cae361ad82dce8b(value);
    (0, import_react126.useEffect)(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(selectProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", {
          bubbles: true
        });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [
      prevValue,
      value
    ]);
    return /* @__PURE__ */ (0, import_react126.createElement)($ea1ef594cf570d83$export$439d29a4e110a164, {
      asChild: true
    }, /* @__PURE__ */ (0, import_react126.createElement)("select", _extends({}, selectProps, {
      ref: composedRefs,
      defaultValue: value
    })));
  });
  $cc7e05a45900e73f$var$BubbleSelect.displayName = "BubbleSelect";
  function $cc7e05a45900e73f$var$useTypeaheadSearch(onSearchChange) {
    const handleSearchChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a8(onSearchChange);
    const searchRef = (0, import_react126.useRef)("");
    const timerRef = (0, import_react126.useRef)(0);
    const handleTypeaheadSearch = (0, import_react126.useCallback)((key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(
            () => updateSearch(""),
            1e3
          );
      })(search);
    }, [
      handleSearchChange
    ]);
    const resetTypeahead = (0, import_react126.useCallback)(() => {
      searchRef.current = "";
      window.clearTimeout(timerRef.current);
    }, []);
    (0, import_react126.useEffect)(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    return [
      searchRef,
      handleTypeaheadSearch,
      resetTypeahead
    ];
  }
  function $cc7e05a45900e73f$var$findNextItem(items, search, currentItem) {
    const isRepeated = search.length > 1 && Array.from(search).every(
      (char) => char === search[0]
    );
    const normalizedSearch = isRepeated ? search[0] : search;
    const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
    let wrappedItems = $cc7e05a45900e73f$var$wrapArray(items, Math.max(currentItemIndex, 0));
    const excludeCurrentItem = normalizedSearch.length === 1;
    if (excludeCurrentItem)
      wrappedItems = wrappedItems.filter(
        (v2) => v2 !== currentItem
      );
    const nextItem = wrappedItems.find(
      (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
    );
    return nextItem !== currentItem ? nextItem : void 0;
  }
  function $cc7e05a45900e73f$var$wrapArray(array, startIndex) {
    return array.map(
      (_, index2) => array[(startIndex + index2) % array.length]
    );
  }
  var $cc7e05a45900e73f$export$be92b6f5f03c0fe9 = $cc7e05a45900e73f$export$ef9b1a59e592288f;
  var $cc7e05a45900e73f$export$41fb9f06171c75f4 = $cc7e05a45900e73f$export$3ac1e88a1c0b9f1;
  var $cc7e05a45900e73f$export$4c8d1a57a761ef94 = $cc7e05a45900e73f$export$e288731fd71264f0;
  var $cc7e05a45900e73f$export$f04a61298a47a40f = $cc7e05a45900e73f$export$99b400cabb58c515;
  var $cc7e05a45900e73f$export$7c6e2c02157bb7d2 = $cc7e05a45900e73f$export$c973a4b3cb86a03d;
  var $cc7e05a45900e73f$export$d5c6c08dc2d3ca7 = $cc7e05a45900e73f$export$9ed6e7b40248d36d;
  var $cc7e05a45900e73f$export$eb2fcfdbd7ba97d4 = $cc7e05a45900e73f$export$ee25a334c55de1f4;
  var $cc7e05a45900e73f$export$b04be29aa201d4f5 = $cc7e05a45900e73f$export$f67338d29bd972f8;
  var $cc7e05a45900e73f$export$6d08773d2e66f8f2 = $cc7e05a45900e73f$export$13ef48a934230896;
  var $cc7e05a45900e73f$export$d6e5bf9c43ea9319 = $cc7e05a45900e73f$export$3572fb0fb821ff49;
  var $cc7e05a45900e73f$export$c3468e2714d175fa = $cc7e05a45900e73f$export$6b9198de19accfe6;
  var $cc7e05a45900e73f$export$2f60d3ec9ad468f2 = $cc7e05a45900e73f$export$d8117927658af6d7;
  var $cc7e05a45900e73f$export$bf1aedc3039c8d63 = $cc7e05a45900e73f$export$ff951e476c12189;

  // node_modules/@radix-ui/react-switch/dist/index.mjs
  var import_react133 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/primitive/dist/index.mjs
  function $e42e1063c40fb3ef$export$b9ecd428b558ff108(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-compose-refs/dist/index.mjs
  var import_react127 = __toESM(require_react(), 1);
  function $6ed0406888f73fc4$var$setRef12(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af12(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef12(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d0510(...refs) {
    return (0, import_react127.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af12(...refs), refs);
  }

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-context/dist/index.mjs
  var import_react128 = __toESM(require_react(), 1);
  function $c512c27ab02ef895$export$50c7b4e9d9f19c110(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react128.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const { scope: scope2, children, ...context } = props;
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const value = (0, import_react128.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react128.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext2(consumerName, scope2) {
        const Context = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName][index2]) || BaseContext;
        const context = (0, import_react128.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext2
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react128.createContext)(defaultContext);
      });
      return function useScope(scope2) {
        const contexts = (scope2 === null || scope2 === void 0 ? void 0 : scope2[scopeName]) || scopeContexts;
        return (0, import_react128.useMemo)(
          () => ({
            [`__scope${scopeName}`]: {
              ...scope2,
              [scopeName]: contexts
            }
          }),
          [
            scope2,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes10(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes10(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return {
            ...nextScopes,
            ...currentScope
          };
        }, {});
        return (0, import_react128.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  var import_react130 = __toESM(require_react(), 1);

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
  var import_react129 = __toESM(require_react(), 1);
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a9(callback) {
    const callbackRef = (0, import_react129.useRef)(callback);
    (0, import_react129.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react129.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
  function $71cd76cc60e0454e$export$6f32135080cb4c38({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState8({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a9(onChange);
    const setValue = (0, import_react130.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState8({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react130.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react130.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a9(onChange);
    (0, import_react130.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var import_react132 = __toESM(require_react(), 1);
  var import_react_dom19 = __toESM(require_react_dom(), 1);

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-slot/dist/index.mjs
  var import_react131 = __toESM(require_react(), 1);
  var $5e63c961fc1ce211$export$8c6ed5c666ac136012 = /* @__PURE__ */ (0, import_react131.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = import_react131.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable12);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react131.Children.count(newElement) > 1)
            return import_react131.Children.only(null);
          return /* @__PURE__ */ (0, import_react131.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react131.createElement)($5e63c961fc1ce211$var$SlotClone12, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react131.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react131.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react131.createElement)($5e63c961fc1ce211$var$SlotClone12, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac136012.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone12 = /* @__PURE__ */ (0, import_react131.forwardRef)((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (/* @__PURE__ */ (0, import_react131.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react131.cloneElement)(children, {
        ...$5e63c961fc1ce211$var$mergeProps12(slotProps, children.props),
        ref: forwardedRef ? $6ed0406888f73fc4$export$43e446d32b3d21af12(forwardedRef, children.ref) : children.ref
      });
    return import_react131.Children.count(children) > 1 ? import_react131.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone12.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d4512 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react131.createElement)(import_react131.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable12(child) {
    return /* @__PURE__ */ (0, import_react131.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d4512;
  }
  function $5e63c961fc1ce211$var$mergeProps12(slotProps, childProps) {
    const overrideProps = {
      ...childProps
    };
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = {
          ...slotPropValue,
          ...childPropValue
        };
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return {
      ...slotProps,
      ...overrideProps
    };
  }

  // node_modules/@radix-ui/react-switch/node_modules/@radix-ui/react-primitive/dist/index.mjs
  var $8927f6f2acc4f386$var$NODES11 = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d03411 = $8927f6f2acc4f386$var$NODES11.reduce((primitive, node) => {
    const Node2 = /* @__PURE__ */ (0, import_react132.forwardRef)((props, forwardedRef) => {
      const { asChild, ...primitiveProps } = props;
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac136012 : node;
      (0, import_react132.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react132.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node2.displayName = `Primitive.${node}`;
    return {
      ...primitive,
      [node]: Node2
    };
  }, {});

  // node_modules/@radix-ui/react-switch/dist/index.mjs
  var $6be4966fd9bbc698$var$SWITCH_NAME = "Switch";
  var [$6be4966fd9bbc698$var$createSwitchContext, $6be4966fd9bbc698$export$cf7f5f17f69cbd43] = $c512c27ab02ef895$export$50c7b4e9d9f19c110($6be4966fd9bbc698$var$SWITCH_NAME);
  var [$6be4966fd9bbc698$var$SwitchProvider, $6be4966fd9bbc698$var$useSwitchContext] = $6be4966fd9bbc698$var$createSwitchContext($6be4966fd9bbc698$var$SWITCH_NAME);
  var $6be4966fd9bbc698$export$b5d5cf8927ab7262 = /* @__PURE__ */ (0, import_react133.forwardRef)((props, forwardedRef) => {
    const { __scopeSwitch, name, checked: checkedProp, defaultChecked, required, disabled, value = "on", onCheckedChange, ...switchProps } = props;
    const [button, setButton] = (0, import_react133.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d0510(
      forwardedRef,
      (node) => setButton(node)
    );
    const hasConsumerStoppedPropagationRef = (0, import_react133.useRef)(false);
    const isFormControl = button ? Boolean(button.closest("form")) : true;
    const [checked = false, setChecked] = $71cd76cc60e0454e$export$6f32135080cb4c38({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    return /* @__PURE__ */ (0, import_react133.createElement)($6be4966fd9bbc698$var$SwitchProvider, {
      scope: __scopeSwitch,
      checked,
      disabled
    }, /* @__PURE__ */ (0, import_react133.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d03411.button, _extends({
      type: "button",
      role: "switch",
      "aria-checked": checked,
      "aria-required": required,
      "data-state": $6be4966fd9bbc698$var$getState(checked),
      "data-disabled": disabled ? "" : void 0,
      disabled,
      value
    }, switchProps, {
      ref: composedRefs,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff108(props.onClick, (event) => {
        setChecked(
          (prevChecked) => !prevChecked
        );
        if (isFormControl) {
          hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
          if (!hasConsumerStoppedPropagationRef.current)
            event.stopPropagation();
        }
      })
    })), isFormControl && /* @__PURE__ */ (0, import_react133.createElement)($6be4966fd9bbc698$var$BubbleInput, {
      control: button,
      bubbles: !hasConsumerStoppedPropagationRef.current,
      name,
      value,
      checked,
      required,
      disabled,
      style: {
        transform: "translateX(-100%)"
      }
    }));
  });
  var $6be4966fd9bbc698$var$THUMB_NAME = "SwitchThumb";
  var $6be4966fd9bbc698$export$4d07bf653ea69106 = /* @__PURE__ */ (0, import_react133.forwardRef)((props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = $6be4966fd9bbc698$var$useSwitchContext($6be4966fd9bbc698$var$THUMB_NAME, __scopeSwitch);
    return /* @__PURE__ */ (0, import_react133.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d03411.span, _extends({
      "data-state": $6be4966fd9bbc698$var$getState(context.checked),
      "data-disabled": context.disabled ? "" : void 0
    }, thumbProps, {
      ref: forwardedRef
    }));
  });
  var $6be4966fd9bbc698$var$BubbleInput = (props) => {
    const { control, checked, bubbles = true, ...inputProps } = props;
    const ref = (0, import_react133.useRef)(null);
    const prevChecked = $010c2913dbd2fe3d$export$5cae361ad82dce8b(checked);
    const controlSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(control);
    (0, import_react133.useEffect)(() => {
      const input = ref.current;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", {
          bubbles
        });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [
      prevChecked,
      checked,
      bubbles
    ]);
    return /* @__PURE__ */ (0, import_react133.createElement)("input", _extends({
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: checked
    }, inputProps, {
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }));
  };
  function $6be4966fd9bbc698$var$getState(checked) {
    return checked ? "checked" : "unchecked";
  }
  var $6be4966fd9bbc698$export$be92b6f5f03c0fe9 = $6be4966fd9bbc698$export$b5d5cf8927ab7262;
  var $6be4966fd9bbc698$export$6521433ed15a34db = $6be4966fd9bbc698$export$4d07bf653ea69106;

  // node_modules/@samvera/clover-iiif/dist/viewer/index.mjs
  var Je = (t2) => {
    var n2 = t2.toString().split(":"), r2 = Math.ceil(parseInt(n2[0])), o2 = Math.ceil(parseInt(n2[1])), i2 = Qe(Math.ceil(parseInt(n2[2])), 2);
    let l2 = `${r2 !== 0 && o2 < 10 ? (o2 + "").padStart(2, "0") : o2}:${i2}`;
    return r2 !== 0 && (l2 = `${r2}:${l2}`), l2;
  };
  var pe = (t2) => {
    const n2 = new Date(t2 * 1e3).toISOString().substr(11, 8);
    return Je(n2);
  };
  var ge = (t2, n2) => {
    if (typeof t2 != "object" || t2 === null)
      return n2;
    for (const r2 in n2)
      typeof n2[r2] == "object" && n2[r2] !== null && !Array.isArray(n2[r2]) ? (t2[r2] || (t2[r2] = {}), t2[r2] = ge(t2[r2], n2[r2])) : t2[r2] = n2[r2];
    return t2;
  };
  var fe = (t2, n2) => Object.hasOwn(t2, n2) ? t2[n2].toString() : void 0;
  var Qe = (t2, n2) => String(t2).padStart(n2, "0");
  var H2 = {
    background: "transparent",
    canvasBackgroundColor: "#6662",
    canvasHeight: "61.8vh",
    ignoreCaptionLabels: [],
    informationPanel: {
      open: true,
      renderAbout: true,
      renderSupplementing: true,
      renderToggle: true
    },
    openSeadragon: {},
    requestHeaders: { "Content-Type": "application/json" },
    showIIIFBadge: true,
    showTitle: true,
    withCredentials: false
  };
  var ce;
  var W2 = {
    activeCanvas: "",
    activeManifest: "",
    collection: {},
    configOptions: H2,
    informationOpen: (ce = H2 == null ? void 0 : H2.informationPanel) == null ? void 0 : ce.open,
    isLoaded: false,
    vault: new Vault()
  };
  var he = import_react134.default.createContext(W2);
  var xe = import_react134.default.createContext(W2);
  function et(t2, n2) {
    switch (n2.type) {
      case "updateActiveCanvas":
        return n2.canvasId || (n2.canvasId = ""), {
          ...t2,
          activeCanvas: n2.canvasId
        };
      case "updateActiveManifest":
        return {
          ...t2,
          activeManifest: n2.manifestId
        };
      case "updateCollection":
        return {
          ...t2,
          collection: n2.collection
        };
      case "updateConfigOptions":
        return {
          ...t2,
          configOptions: ge(t2.configOptions, n2.configOptions)
        };
      case "updateInformationOpen":
        return {
          ...t2,
          informationOpen: n2.informationOpen
        };
      case "updateIsLoaded":
        return {
          ...t2,
          isLoaded: n2.isLoaded
        };
      default:
        throw new Error(`Unhandled action type: ${n2.type}`);
    }
  }
  var tt = ({
    initialState: t2 = W2,
    children: n2
  }) => {
    const [r2, o2] = (0, import_react134.useReducer)(et, t2);
    return /* @__PURE__ */ import_react134.default.createElement(he.Provider, { value: r2 }, /* @__PURE__ */ import_react134.default.createElement(
      xe.Provider,
      {
        value: o2
      },
      n2
    ));
  };
  function k2() {
    const t2 = import_react134.default.useContext(he);
    if (t2 === void 0)
      throw new Error("useViewerState must be used within a ViewerProvider");
    return t2;
  }
  function F2() {
    const t2 = import_react134.default.useContext(xe);
    if (t2 === void 0)
      throw new Error("useViewerDispatch must be used within a ViewerProvider");
    return t2;
  }
  var ve = (t2, n2, r2, o2) => {
    var l2, s2;
    const i2 = {
      canvas: void 0,
      accompanyingCanvas: void 0,
      annotationPage: void 0,
      annotations: []
    }, a2 = (c2) => {
      if (c2) {
        if (!c2.body || !c2.motivation) {
          console.error(
            "Invalid annotation after Hyperion parsing: missing either 'body' or 'motivation'",
            c2
          );
          return;
        }
        let m2 = c2.body;
        Array.isArray(m2) && (m2 = m2[0]);
        const u2 = t2.get(m2.id);
        if (!u2)
          return;
        switch (r2) {
          case "painting":
            return c2.target === n2.id && c2.motivation && c2.motivation[0] === "painting" && o2.includes(u2.type) && (c2.body = u2), !!c2;
          case "supplementing":
            return;
          default:
            throw new Error("Invalid annotation motivation.");
        }
      }
    };
    return i2.canvas = t2.get(n2), i2.canvas && (i2.annotationPage = t2.get(i2.canvas.items[0]), i2.accompanyingCanvas = (l2 = i2.canvas) != null && l2.accompanyingCanvas ? t2.get((s2 = i2.canvas) == null ? void 0 : s2.accompanyingCanvas) : void 0), i2.annotationPage && (i2.annotations = t2.get(i2.annotationPage.items).filter(a2)), i2;
  };
  var P2 = (t2, n2 = "en") => {
    if (!t2)
      return "";
    if (!t2[n2]) {
      const r2 = Object.getOwnPropertyNames(t2);
      if (r2.length > 0)
        return t2[r2[0]];
    }
    return t2[n2];
  };
  var B2 = (t2, n2) => {
    const r2 = ve(
      t2,
      { id: n2, type: "Canvas" },
      "painting",
      ["Image", "Sound", "Video"]
    );
    if (r2.annotations.length !== 0 && r2.annotations[0] && r2.annotations[0].body)
      return r2.annotations[0].body;
  };
  var nt = (t2, n2, r2) => {
    const o2 = t2.get({
      id: n2,
      type: "Canvas"
    });
    if (!(o2 != null && o2.annotations) || !o2.annotations[0])
      return [];
    const i2 = t2.get(o2.annotations[0]), a2 = t2.get(i2.items);
    return Array.isArray(a2) ? a2.filter((l2) => {
      var s2;
      if (l2.body && (s2 = l2.motivation) != null && s2.includes("supplementing")) {
        let c2 = l2.body;
        Array.isArray(c2) && (c2 = c2[0]);
        const m2 = t2.get(c2.id);
        if (m2.format === r2)
          return l2.body = m2, l2;
      }
    }).map((l2) => l2.body) : [];
  };
  var rt = (t2, n2, r2, o2) => {
    let i2 = [];
    if (n2.canvas && n2.canvas.thumbnail.length > 0) {
      const s2 = t2.get(
        n2.canvas.thumbnail[0]
      );
      i2.push(s2);
    }
    if (n2.annotations[0]) {
      if (n2.annotations[0].thumbnail && n2.annotations[0].thumbnail.length > 0) {
        const c2 = t2.get(
          n2.annotations[0].thumbnail[0]
        );
        i2.push(c2);
      }
      if (!n2.annotations[0].body)
        return;
      const s2 = n2.annotations[0].body;
      s2.type === "Image" && i2.push(s2);
    }
    return i2.length === 0 ? void 0 : {
      id: i2[0].id,
      format: i2[0].format,
      type: i2[0].type,
      width: r2,
      height: o2
    };
  };
  var j2 = 209;
  var ot = {
    colors: {
      primary: "#1a1d1e",
      primaryMuted: "#26292b",
      primaryAlt: "#151718",
      accent: `hsl(${j2} 100% 38.2%)`,
      accentMuted: `hsl(${j2} 80% 61.8%)`,
      accentAlt: `hsl(${j2} 80% 30%)`,
      secondary: "#FFFFFF",
      secondaryMuted: "#e6e8eb",
      secondaryAlt: "#c1c8cd"
    },
    fontSizes: {
      1: "12px",
      2: "13px",
      3: "15px",
      4: "17px",
      5: "19px",
      6: "21px",
      7: "27px",
      8: "35px",
      9: "59px"
    },
    lineHeights: {
      1: "12px",
      2: "13px",
      3: "15px",
      4: "17px",
      5: "19px",
      6: "21px",
      7: "27px",
      8: "35px",
      9: "59px"
    },
    sizes: {
      1: "5px",
      2: "10px",
      3: "15px",
      4: "20px",
      5: "25px",
      6: "35px",
      7: "45px",
      8: "65px",
      9: "80px"
    },
    space: {
      1: "5px",
      2: "10px",
      3: "15px",
      4: "20px",
      5: "25px",
      6: "35px",
      7: "45px",
      8: "65px",
      9: "80px"
    },
    radii: {
      1: "4px",
      2: "6px",
      3: "8px",
      4: "12px",
      round: "50%",
      pill: "9999px"
    },
    transitions: {
      all: "all 300ms cubic-bezier(0.16, 1, 0.3, 1)"
    },
    zIndices: {
      1: "100",
      2: "200",
      3: "300",
      4: "400",
      max: "999"
    }
  };
  var Z2 = {
    xxs: "(max-width: 349px)",
    xs: "(max-width: 575px)",
    sm: "(max-width: 767px)",
    md: "(max-width: 991px)",
    lg: "(max-width: 90rem)",
    xl: "(min-width: calc(90rem + 1px))"
  };
  var { styled: d2, css: Hr, keyframes: X2, createTheme: Br } = q({
    theme: ot,
    media: Z2
  });
  var at = d2("div", {
    display: "flex",
    flexDirection: "column",
    alignItems: "center"
  });
  var it = d2("p", {
    fontWeight: "bold",
    fontSize: "x-large"
  });
  var lt = d2("span", {
    fontSize: "medium"
  });
  var st = ({ error: t2 }) => {
    const { message: n2 } = t2;
    return /* @__PURE__ */ import_react134.default.createElement(at, { role: "alert" }, /* @__PURE__ */ import_react134.default.createElement(it, { "data-testid": "headline" }, "Something went wrong"), n2 && /* @__PURE__ */ import_react134.default.createElement(lt, null, `Error message: ${n2}`, " "));
  };
  var be = d2("div", {
    position: "relative",
    zIndex: "0"
  });
  var ye = d2("div", {
    display: "flex",
    flexDirection: "row",
    overflow: "hidden",
    "@sm": {
      flexDirection: "column"
    }
  });
  var Ee = d2("div", {
    display: "flex",
    flexDirection: "column",
    flexGrow: "1",
    flexShrink: "1",
    width: "61.8%",
    "@sm": {
      width: "100%"
    }
  });
  var we = d2($409067139f391064$export$41fb9f06171c75f4, {
    display: "none",
    border: "none",
    padding: "0",
    transition: "$all",
    opacity: "1",
    background: "#6663",
    margin: "1rem 0",
    borderRadius: "6px",
    "&[data-information-panel='false']": {
      opacity: "0",
      marginTop: "-59px"
    },
    "@sm": {
      display: "flex",
      "> span": {
        display: "flex",
        flexGrow: "1",
        fontSize: "0.8333em",
        justifyContent: "center",
        padding: "0.5rem",
        fontFamily: "inherit"
      }
    }
  });
  var Ce = d2($409067139f391064$export$7c6e2c02157bb7d2, {
    width: "100%",
    display: "flex"
  });
  var ct = d2("aside", {
    display: "flex",
    flexGrow: "1",
    flexShrink: "0",
    width: "38.2%",
    maxHeight: "100%",
    "@sm": {
      width: "100%"
    }
  });
  var dt = d2("div", {
    display: "flex",
    flexDirection: "column",
    fontSmooth: "auto",
    webkitFontSmoothing: "antialiased",
    "> div": {
      display: "flex",
      flexDirection: "column",
      flexGrow: "1",
      justifyContent: "flex-start",
      "@sm": {
        [`& ${ye}`]: {
          flexGrow: "1"
        },
        [`& ${Ee}`]: {
          flexGrow: "0"
        }
      }
    },
    "@sm": {
      padding: "0"
    },
    "&[data-information-panel-open='true']": {
      "@sm": {
        position: "fixed",
        height: "100%",
        width: "100%",
        top: "0",
        left: "0",
        zIndex: "2500000000",
        [`& ${be}`]: {
          display: "none"
        },
        [`& ${we}`]: {
          margin: "1rem"
        },
        [`& ${Ce}`]: {
          height: "100%"
        }
      }
    }
  });
  var mt = d2($69cb30bb0017df05$export$be92b6f5f03c0fe9, {
    display: "flex",
    flexDirection: "column",
    width: "100%",
    height: "100%",
    flexGrow: "1",
    flexShrink: "0",
    position: "relative",
    zIndex: "1",
    maskImage: "linear-gradient(180deg, rgba(0, 0, 0, 1) calc(100% - 2rem), transparent 100%)",
    "@sm": {
      marginTop: "0.5rem",
      boxShadow: "none"
    }
  });
  var ut = d2($69cb30bb0017df05$export$54c2e3dc7acea9f5, {
    display: "flex",
    flexGrow: "0",
    margin: "0 1.618rem",
    borderBottom: "4px solid #6663",
    "@sm": {
      margin: "0 1rem"
    }
  });
  var ee = d2($69cb30bb0017df05$export$41fb9f06171c75f4, {
    display: "flex",
    position: "relative",
    padding: "0.5rem 1rem",
    background: "none",
    backgroundColor: "transparent",
    fontFamily: "inherit",
    border: "none",
    opacity: "0.7",
    fontSize: "1rem",
    marginRight: "1rem",
    lineHeight: "1rem",
    whiteSpace: "nowrap",
    cursor: "pointer",
    fontWeight: 400,
    transition: "$all",
    "&::after": {
      width: "0",
      height: "4px",
      content: "",
      position: "absolute",
      bottom: "-4px",
      left: "0",
      transition: "$all"
    },
    "&[data-state='active']": {
      opacity: "1",
      fontWeight: 700,
      "&::after": {
        width: "100%",
        backgroundColor: "$accent"
      }
    }
  });
  var te = d2($69cb30bb0017df05$export$7c6e2c02157bb7d2, {
    display: "flex",
    flexGrow: "1",
    flexShrink: "0",
    position: "absolute",
    top: "0",
    left: "0",
    "&[data-state='active']": {
      width: "100%",
      height: "calc(100% - 2rem)",
      padding: "1.618rem 0"
    }
  });
  var pt = d2("div", {
    position: "relative",
    height: "100%",
    width: "100%",
    overflowY: "scroll"
  });
  var gt = d2("div", {
    padding: " 0 1.618rem 2rem",
    display: "flex",
    flexDirection: "column",
    overflow: "scroll",
    position: "absolute",
    fontWeight: "400",
    fontSize: "1rem",
    zIndex: "0",
    img: {
      maxWidth: "100px",
      maxHeight: "100px",
      objectFit: "contain",
      color: "transparent",
      margin: "0 0 1rem",
      borderRadius: "3px",
      backgroundColor: "$secondaryMuted"
    },
    video: {
      display: "none"
    },
    "a, a:visited": {
      color: "$accent"
    },
    p: {
      fontSize: "1rem",
      lineHeight: "1.45em",
      margin: "0"
    },
    dl: {
      margin: "0",
      dt: {
        fontWeight: "700",
        margin: "1rem 0 0.25rem"
      },
      dd: {
        margin: "0"
      }
    },
    ".manifest-property-title": {
      fontWeight: "700",
      margin: "1rem 0 0.25rem"
    },
    "ul, ol": {
      padding: "0",
      margin: "0",
      li: {
        fontSize: "1rem",
        lineHeight: "1.45em",
        listStyle: "none",
        margin: "0.25rem 0 0.25rem"
      }
    }
  });
  var ft = d2("div", {
    position: "relative",
    width: "100%",
    height: "100%",
    zIndex: "0"
  });
  var Se = (t2, n2 = "none") => {
    if (!t2)
      return null;
    if (typeof t2 == "string")
      return [t2];
    if (!t2[n2]) {
      const r2 = Object.getOwnPropertyNames(t2);
      if (r2.length > 0)
        return t2[r2[0]];
    }
    return !t2[n2] || !Array.isArray(t2[n2]) ? null : t2[n2];
  };
  var M2 = (t2, n2 = "none", r2 = ", ") => {
    const o2 = Se(t2, n2);
    return Array.isArray(o2) ? o2.join(`${r2}`) : o2;
  };
  function ht(t2) {
    return { __html: xt(t2) };
  }
  function A2(t2, n2) {
    const r2 = Object.keys(t2).filter(
      (i2) => n2.includes(i2) ? null : i2
    );
    let o2 = new Object();
    return r2.forEach((i2) => {
      o2[i2] = t2[i2];
    }), o2;
  }
  function xt(t2) {
    return (0, import_sanitize_html.default)(t2, {
      allowedAttributes: {
        a: ["href"],
        img: ["alt", "src", "height", "width"]
      },
      allowedSchemes: ["http", "https", "mailto"],
      allowedTags: [
        "a",
        "b",
        "br",
        "i",
        "img",
        "p",
        "small",
        "span",
        "sub",
        "sup"
      ]
    });
  }
  var vt = d2("span", {});
  var z2 = (t2) => {
    const { as: n2, label: r2 } = t2;
    let i2 = A2(t2, ["as", "label"]);
    return /* @__PURE__ */ import_react134.default.createElement(vt, { as: n2, ...i2 }, M2(r2, i2.lang));
  };
  var bt = (t2, n2 = "200,", r2 = "full") => {
    Array.isArray(t2) && (t2 = t2[0]);
    const { id: o2, service: i2 } = t2;
    let a2;
    if (!i2)
      return o2;
    if (Array.isArray(t2.service) && t2.service.length > 0 && (a2 = i2[0]), a2) {
      if (a2["@id"])
        return `${a2["@id"]}/${r2}/${n2}/0/default.jpg`;
      if (a2.id)
        return `${a2.id}/${r2}/${n2}/0/default.jpg`;
    }
  };
  var ne = d2("img", { objectFit: "cover" });
  var yt = (t2) => {
    const n2 = (0, import_react134.useRef)(null), { contentResource: r2, altAsLabel: o2, region: i2 = "full" } = t2;
    let a2;
    o2 && (a2 = M2(o2));
    const s2 = A2(t2, ["contentResource", "altAsLabel"]), {
      type: c2,
      id: m2,
      width: u2 = 200,
      height: f2 = 200,
      format: v2,
      duration: h2
    } = r2;
    (0, import_react134.useEffect)(() => {
      if (!m2 && !n2.current || ["Image"].includes(c2) || !m2.includes("m3u8"))
        return;
      const p2 = new Hls();
      return n2.current && (p2.attachMedia(n2.current), p2.on(Hls.Events.MEDIA_ATTACHED, function() {
        p2.loadSource(m2);
      })), p2.on(Hls.Events.ERROR, function(w2, g2) {
        if (g2.fatal)
          switch (g2.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              console.error(
                `fatal ${w2} network error encountered, try to recover`
              ), p2.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              console.error(
                `fatal ${w2} media error encountered, try to recover`
              ), p2.recoverMediaError();
              break;
            default:
              p2.destroy();
              break;
          }
      }), () => {
        p2 && (p2.detachMedia(), p2.destroy());
      };
    }, []), (0, import_react134.useEffect)(() => x2(), []);
    const x2 = () => {
      if (!n2.current)
        return;
      let p2 = 0, w2 = 30;
      if (h2 && (w2 = h2), !m2.split("#t=") && h2 && (p2 = h2 * 0.1), m2.split("#t=").pop()) {
        const y2 = m2.split("#t=").pop();
        y2 && (p2 = parseInt(y2.split(",")[0]));
      }
      const g2 = n2.current;
      g2.autoplay = true, g2.currentTime = p2, setTimeout(() => x2(), w2 * 1e3);
    };
    switch (c2) {
      case "Image":
        const p2 = bt(
          r2,
          `${u2},${f2}`,
          i2
        );
        return /* @__PURE__ */ import_react134.default.createElement(
          ne,
          {
            as: "img",
            alt: a2,
            css: { width: u2, height: f2 },
            key: m2,
            src: p2,
            ...s2
          }
        );
      case "Video":
        return /* @__PURE__ */ import_react134.default.createElement(
          ne,
          {
            as: "video",
            css: { width: u2, height: f2 },
            disablePictureInPicture: true,
            key: m2,
            loop: true,
            muted: true,
            onPause: x2,
            ref: n2,
            src: m2
          }
        );
      default:
        return console.warn(
          `Resource type: ${c2} is not valid or not yet supported in Primitives.`
        ), /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
    }
  };
  var Et = d2("a", {});
  var wt = (t2) => {
    const { children: n2, homepage: r2 } = t2, i2 = A2(t2, ["children", "homepage"]);
    return /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, r2 && r2.map((a2) => {
      const l2 = M2(
        a2.label,
        i2.lang
      );
      return /* @__PURE__ */ import_react134.default.createElement(
        Et,
        {
          "aria-label": n2 ? l2 : void 0,
          href: a2.id,
          key: a2.id,
          ...i2
        },
        n2 || l2
      );
    }));
  };
  var Ct = {
    delimiter: ", "
  };
  var Y2 = (0, import_react134.createContext)(void 0);
  var ke = () => {
    const t2 = (0, import_react134.useContext)(Y2);
    if (t2 === void 0)
      throw new Error(
        "usePrimitivesContext must be used with a PrimitivesProvider"
      );
    return t2;
  };
  var K2 = ({
    children: t2,
    initialState: n2 = Ct
  }) => {
    const r2 = St(n2, "delimiter");
    return /* @__PURE__ */ import_react134.default.createElement(Y2.Provider, { value: { delimiter: r2 } }, t2);
  };
  var St = (t2, n2) => Object.hasOwn(t2, n2) ? t2[n2].toString() : void 0;
  var kt = d2("span", {});
  var re2 = (t2) => {
    const { as: n2, markup: r2 } = t2, { delimiter: o2 } = ke();
    if (!r2)
      return /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
    let a2 = A2(t2, ["as", "markup"]);
    const l2 = ht(
      M2(r2, a2.lang, o2)
    );
    return /* @__PURE__ */ import_react134.default.createElement(kt, { as: n2, ...a2, dangerouslySetInnerHTML: l2 });
  };
  var Ie = (t2) => import_react134.default.useContext(Y2) ? /* @__PURE__ */ import_react134.default.createElement(re2, { ...t2 }) : /* @__PURE__ */ import_react134.default.createElement(K2, null, /* @__PURE__ */ import_react134.default.createElement(re2, { ...t2 }));
  var It = ({ as: t2 = "dd", lang: n2, value: r2 }) => /* @__PURE__ */ import_react134.default.createElement(Ie, { markup: r2, as: t2, lang: n2 });
  var $t = d2("span", {});
  var Tt = ({
    as: t2 = "dd",
    customValueContent: n2,
    lang: r2,
    value: o2
  }) => {
    var l2;
    const { delimiter: i2 } = ke(), a2 = (l2 = Se(o2, r2)) == null ? void 0 : l2.map((s2) => (0, import_react134.cloneElement)(n2, {
      value: s2
    }));
    return /* @__PURE__ */ import_react134.default.createElement($t, { as: t2, lang: r2 }, a2 == null ? void 0 : a2.map((s2, c2) => [
      c2 > 0 && `${i2}`,
      /* @__PURE__ */ import_react134.default.createElement(import_react134.Fragment, { key: c2 }, s2)
    ]));
  };
  var $e = (t2) => {
    var s2;
    const { item: n2, lang: r2, customValueContent: o2 } = t2, { label: i2, value: a2 } = n2, l2 = (s2 = M2(i2)) == null ? void 0 : s2.replace(" ", "-").toLowerCase();
    return /* @__PURE__ */ import_react134.default.createElement("div", { role: "group", "data-label": l2 }, /* @__PURE__ */ import_react134.default.createElement(z2, { as: "dt", label: i2, lang: r2 }), o2 ? /* @__PURE__ */ import_react134.default.createElement(
      Tt,
      {
        as: "dd",
        customValueContent: o2,
        value: a2,
        lang: r2
      }
    ) : /* @__PURE__ */ import_react134.default.createElement(It, { as: "dd", value: a2, lang: r2 }));
  };
  function At(t2, n2) {
    const r2 = n2.filter((o2) => {
      const { matchingLabel: i2 } = o2, a2 = Object.keys(o2.matchingLabel)[0], l2 = M2(i2, a2);
      if (M2(t2, a2) === l2)
        return true;
    }).map((o2) => o2.Content);
    if (Array.isArray(r2))
      return r2[0];
  }
  var Mt = d2("dl", {});
  var Rt = (t2) => {
    const { as: n2, customValueContent: r2, metadata: o2 } = t2;
    if (!Array.isArray(o2))
      return /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
    const i2 = fe(t2, "customValueDelimiter");
    let l2 = A2(t2, [
      "as",
      "customValueContent",
      "customValueDelimiter",
      "metadata"
    ]);
    return /* @__PURE__ */ import_react134.default.createElement(
      K2,
      {
        ...typeof i2 == "string" ? { initialState: { delimiter: i2 } } : void 0
      },
      o2.length > 0 && /* @__PURE__ */ import_react134.default.createElement(Mt, { as: n2, ...l2 }, o2.map((s2, c2) => {
        const m2 = r2 ? At(s2.label, r2) : void 0;
        return /* @__PURE__ */ import_react134.default.createElement(
          $e,
          {
            customValueContent: m2,
            item: s2,
            key: c2,
            lang: l2 == null ? void 0 : l2.lang
          }
        );
      }))
    );
  };
  d2("li", {});
  d2("ul", {});
  var zt = d2("dl", {});
  var Lt = (t2) => {
    const { as: n2, requiredStatement: r2 } = t2;
    if (!r2)
      return /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
    const o2 = fe(t2, "customValueDelimiter");
    let a2 = A2(t2, ["as", "customValueDelimiter", "requiredStatement"]);
    return /* @__PURE__ */ import_react134.default.createElement(
      K2,
      {
        ...typeof o2 == "string" ? { initialState: { delimiter: o2 } } : void 0
      },
      /* @__PURE__ */ import_react134.default.createElement(zt, { as: n2, ...a2 }, /* @__PURE__ */ import_react134.default.createElement($e, { item: r2, lang: a2.lang }))
    );
  };
  var Ft = d2("li", {});
  var Pt = d2("ul", {});
  var Vt = (t2) => {
    const { as: n2, seeAlso: r2 } = t2, i2 = A2(t2, ["as", "seeAlso"]);
    return /* @__PURE__ */ import_react134.default.createElement(Pt, { as: n2 }, r2 && r2.map((a2) => {
      const l2 = M2(
        a2.label,
        i2.lang
      );
      return /* @__PURE__ */ import_react134.default.createElement(Ft, { key: a2.id }, /* @__PURE__ */ import_react134.default.createElement("a", { href: a2.id, ...i2 }, l2 || a2.id));
    }));
  };
  var Ht = (t2) => {
    const { as: n2, summary: r2 } = t2;
    let i2 = A2(t2, ["as", "customValueDelimiter", "summary"]);
    return /* @__PURE__ */ import_react134.default.createElement(Ie, { as: n2, markup: r2, ...i2 });
  };
  var Te = (t2) => {
    const { thumbnail: n2, region: r2 } = t2, i2 = A2(t2, ["thumbnail"]);
    return /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, n2 && n2.map((a2) => /* @__PURE__ */ import_react134.default.createElement(
      yt,
      {
        contentResource: a2,
        key: a2.id,
        region: r2,
        ...i2
      }
    )));
  };
  var Bt = ({
    homepage: t2
  }) => (t2 == null ? void 0 : t2.length) === 0 ? /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement("span", { className: "manifest-property-title" }, "Homepage"), /* @__PURE__ */ import_react134.default.createElement(wt, { homepage: t2 }));
  var Ot = ({
    id: t2,
    htmlLabel: n2,
    parent: r2 = "manifest"
  }) => /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement("span", { className: "manifest-property-title" }, n2), /* @__PURE__ */ import_react134.default.createElement("a", { href: t2, target: "_blank", id: `iiif-${r2}-id` }, t2));
  var Dt = ({
    metadata: t2,
    parent: n2 = "manifest"
  }) => t2 ? /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(Rt, { metadata: t2, id: `iiif-${n2}-metadata` })) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
  var Wt = ({
    requiredStatement: t2,
    parent: n2 = "manifest"
  }) => t2 ? /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(
    Lt,
    {
      requiredStatement: t2,
      id: `iiif-${n2}-required-statement`
    }
  )) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
  var jt = ({ rights: t2 }) => t2 ? /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement("span", { className: "manifest-property-title" }, "Rights"), /* @__PURE__ */ import_react134.default.createElement("a", { href: t2, target: "_blank" }, t2)) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
  var Nt = ({ seeAlso: t2 }) => (t2 == null ? void 0 : t2.length) === 0 ? /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement("span", { className: "manifest-property-title" }, "See Also"), /* @__PURE__ */ import_react134.default.createElement(Vt, { seeAlso: t2 }));
  var Gt = ({
    summary: t2,
    parent: n2 = "manifest"
  }) => t2 ? /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(Ht, { summary: t2, as: "p", id: `iiif-${n2}-summary` })) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
  var qt = ({
    label: t2,
    thumbnail: n2
  }) => (n2 == null ? void 0 : n2.length) === 0 ? /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(
    Te,
    {
      altAsLabel: t2 || { none: ["resource"] },
      thumbnail: n2,
      style: { backgroundColor: "#6663", objectFit: "cover" }
    }
  ));
  var Ut = () => {
    const t2 = k2(), { activeManifest: n2, vault: r2 } = t2, [o2, i2] = (0, import_react134.useState)(), [a2, l2] = (0, import_react134.useState)([]), [s2, c2] = (0, import_react134.useState)([]), [m2, u2] = (0, import_react134.useState)([]);
    return (0, import_react134.useEffect)(() => {
      var v2, h2, x2;
      const f2 = r2.get(n2);
      i2(f2), ((v2 = f2.homepage) == null ? void 0 : v2.length) > 0 && l2(r2.get(f2.homepage)), ((h2 = f2.seeAlso) == null ? void 0 : h2.length) > 0 && c2(r2.get(f2.seeAlso)), ((x2 = f2.thumbnail) == null ? void 0 : x2.length) > 0 && u2(r2.get(f2.thumbnail));
    }, [n2, r2]), o2 ? /* @__PURE__ */ import_react134.default.createElement(ft, null, /* @__PURE__ */ import_react134.default.createElement(gt, null, /* @__PURE__ */ import_react134.default.createElement(qt, { thumbnail: m2, label: o2.label }), /* @__PURE__ */ import_react134.default.createElement(Gt, { summary: o2.summary }), /* @__PURE__ */ import_react134.default.createElement(Dt, { metadata: o2.metadata }), /* @__PURE__ */ import_react134.default.createElement(Wt, { requiredStatement: o2.requiredStatement }), /* @__PURE__ */ import_react134.default.createElement(jt, { rights: o2.rights }), /* @__PURE__ */ import_react134.default.createElement(
      Bt,
      {
        homepage: a2
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      Nt,
      {
        seeAlso: s2
      }
    ), /* @__PURE__ */ import_react134.default.createElement(Ot, { id: o2.id, htmlLabel: "IIIF Manifest" }))) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
  };
  var _t = () => {
    function t2(i2) {
      return i2.map((a2) => {
        const l2 = a2.identifier || v4_default();
        return { ...a2, identifier: l2 };
      });
    }
    function n2(i2) {
      var c2;
      const a2 = [], l2 = [], s2 = t2(i2);
      for (const m2 of s2) {
        for (; l2.length > 0 && l2[l2.length - 1].end <= m2.start; )
          l2.pop();
        l2.length > 0 ? (l2[l2.length - 1].children || (l2[l2.length - 1].children = []), (c2 = l2[l2.length - 1].children) == null || c2.push(m2), l2.push(m2)) : (a2.push(m2), l2.push(m2));
      }
      return a2;
    }
    function r2(i2, a2 = []) {
      return a2.some(
        (l2) => i2.start >= l2.start && i2.end <= l2.end
      );
    }
    function o2(i2 = []) {
      return i2.sort((a2, l2) => a2.start - l2.start);
    }
    return {
      addIdentifiersToParsedCues: t2,
      createNestedCues: n2,
      isChild: r2,
      orderCuesByTime: o2
    };
  };
  var oe = X2({
    from: { transform: "rotate(360deg)" },
    to: { transform: "rotate(0deg)" }
  });
  var Zt = d2($f99a8c78507165f7$export$be92b6f5f03c0fe9, {
    display: "flex",
    flexDirection: "column",
    width: "100%"
  });
  var Ae = d2($f99a8c78507165f7$export$6d08773d2e66f8f2, {
    position: "relative",
    cursor: "pointer",
    display: "flex",
    width: "100%",
    justifyContent: "space-between",
    textAlign: "left",
    margin: "0",
    padding: "0.5rem 1.618rem",
    fontFamily: "inherit",
    lineHeight: "1.25em",
    fontSize: "1rem",
    color: "inherit",
    border: "none",
    background: "none",
    "@sm": {
      padding: "0.5rem 1rem",
      fontSize: "0.8333rem"
    },
    "&::before": {
      content: "",
      width: "12px",
      height: "12px",
      borderRadius: "12px",
      position: "absolute",
      backgroundColor: "$primaryMuted",
      opacity: "0",
      left: "8px",
      marginTop: "3px",
      boxSizing: "content-box",
      "@sm": {
        content: "unset"
      }
    },
    "&::after": {
      content: "",
      width: "4px",
      height: "6px",
      position: "absolute",
      backgroundColor: "$secondary",
      opacity: "0",
      clipPath: "polygon(100% 50%, 0 100%, 0 0)",
      left: "13px",
      marginTop: "6px",
      boxSizing: "content-box",
      "@sm": {
        content: "unset"
      }
    },
    strong: {
      marginLeft: "1rem"
    },
    "&:hover": {
      color: "$accent",
      "&::before": {
        backgroundColor: "$accent",
        opacity: "1"
      },
      "&::after": {
        content: "",
        width: "4px",
        height: "6px",
        position: "absolute",
        backgroundColor: "$secondary",
        clipPath: "polygon(100% 50%, 0 100%, 0 0)",
        opacity: "1"
      }
    },
    "&[aria-checked='true']": {
      backgroundColor: "#6663",
      "&::before": {
        content: "",
        width: "6px",
        height: "6px",
        position: "absolute",
        backgroundColor: "transparent",
        border: "3px solid $accentMuted",
        borderRadius: "12px",
        left: "8px",
        marginTop: "4px",
        opacity: "1",
        animation: "1s linear infinite",
        animationName: oe,
        boxSizing: "content-box",
        "@sm": {
          content: "unset"
        }
      },
      "&::after": {
        content: "",
        width: "6px",
        height: "6px",
        position: "absolute",
        backgroundColor: "transparent",
        border: "3px solid $accent",
        clipPath: "polygon(100% 0, 100% 100%, 0 0)",
        borderRadius: "12px",
        left: "8px",
        marginTop: "4px",
        opacity: "1",
        animation: "1.5s linear infinite",
        animationName: oe,
        boxSizing: "content-box",
        "@sm": {
          content: "unset"
        }
      }
    }
  });
  var Xt = ({ label: t2, start: n2, end: r2 }) => {
    const [o2, i2] = (0, import_react134.useState)(false), a2 = document.getElementById(
      "clover-iiif-video"
    );
    (0, import_react134.useEffect)(() => (a2 == null || a2.addEventListener("timeupdate", () => {
      const { currentTime: s2 } = a2;
      i2(n2 <= s2 && s2 < r2);
    }), () => document.removeEventListener("timeupdate", () => {
    })), [a2]);
    const l2 = () => {
      a2 && (a2.pause(), a2.currentTime = n2, a2.play());
    };
    return /* @__PURE__ */ import_react134.default.createElement(
      Ae,
      {
        "aria-checked": o2,
        "data-testid": "information-panel-cue",
        onClick: l2,
        value: t2
      },
      t2,
      /* @__PURE__ */ import_react134.default.createElement("strong", null, pe(n2))
    );
  };
  var Yt = d2("ul", {
    listStyle: "none",
    paddingLeft: "1rem",
    position: "relative",
    "&&:first-child": {
      paddingLeft: "0"
    },
    "& li ul": {
      [`& ${Ae}`]: {
        backgroundColor: "unset",
        "&::before": {
          content: "none"
        },
        "&::after": {
          content: "none"
        }
      }
    },
    "&:first-child": {
      margin: "0 0 1.618rem"
    }
  });
  var Me = ({ items: t2 }) => /* @__PURE__ */ import_react134.default.createElement(Yt, null, t2.map((n2) => {
    const { text: r2, start: o2, end: i2, children: a2, identifier: l2 } = n2;
    return /* @__PURE__ */ import_react134.default.createElement("li", { key: l2 }, /* @__PURE__ */ import_react134.default.createElement(Xt, { label: r2, start: o2, end: i2 }), a2 && /* @__PURE__ */ import_react134.default.createElement(Me, { items: a2 }));
  }));
  var Kt = ({ resource: t2 }) => {
    const [n2, r2] = import_react134.default.useState([]), { id: o2, label: i2 } = t2, { createNestedCues: a2, orderCuesByTime: l2 } = _t();
    return (0, import_react134.useEffect)(() => {
      o2 && fetch(o2, {
        headers: {
          "Content-Type": "text/plain",
          Accept: "application/json"
        }
      }).then((s2) => s2.text()).then((s2) => {
        const c2 = (0, import_node_webvtt.parse)(s2).cues, m2 = l2(c2), u2 = a2(m2);
        r2(u2);
      }).catch((s2) => console.error(o2, s2.toString()));
    }, [o2]), /* @__PURE__ */ import_react134.default.createElement(
      Zt,
      {
        "aria-label": `navigate ${P2(i2, "en")}`
      },
      /* @__PURE__ */ import_react134.default.createElement(Me, { items: n2 })
    );
  };
  var Jt = ({
    activeCanvas: t2,
    resources: n2
  }) => {
    const r2 = k2(), { configOptions: o2 } = r2, { informationPanel: i2 } = o2, [a2, l2] = (0, import_react134.useState)(), s2 = (i2 == null ? void 0 : i2.renderAbout) || (o2 == null ? void 0 : o2.renderAbout), c2 = i2 == null ? void 0 : i2.renderSupplementing;
    (0, import_react134.useEffect)(() => {
      s2 ? l2("manifest-about") : n2 && (n2 == null ? void 0 : n2.length) > 0 && !s2 && l2(n2[0].id);
    }, [t2, n2]);
    const m2 = (u2) => {
      l2(u2);
    };
    return n2 ? /* @__PURE__ */ import_react134.default.createElement(
      mt,
      {
        "data-testid": "information-panel",
        defaultValue: a2,
        onValueChange: m2,
        orientation: "horizontal",
        value: a2
      },
      /* @__PURE__ */ import_react134.default.createElement(ut, { "aria-label": "select chapter", "data-testid": "information-panel-list" }, s2 && /* @__PURE__ */ import_react134.default.createElement(ee, { value: "manifest-about" }, "About"), c2 && n2 && n2.map(({ id: u2, label: f2 }) => /* @__PURE__ */ import_react134.default.createElement(ee, { key: u2, value: u2 }, /* @__PURE__ */ import_react134.default.createElement(z2, { label: f2 })))),
      /* @__PURE__ */ import_react134.default.createElement(pt, null, s2 && /* @__PURE__ */ import_react134.default.createElement(te, { value: "manifest-about" }, /* @__PURE__ */ import_react134.default.createElement(Ut, null)), c2 && n2 && n2.map((u2) => /* @__PURE__ */ import_react134.default.createElement(te, { key: u2.id, value: u2.id }, /* @__PURE__ */ import_react134.default.createElement(Kt, { resource: u2 }))))
    ) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null);
  };
  var Qt = d2($f99a8c78507165f7$export$be92b6f5f03c0fe9, {
    display: "flex",
    flexDirection: "row",
    flexGrow: "1",
    padding: "1.618rem",
    overflowX: "scroll",
    position: "relative",
    zIndex: "0"
  });
  var en = () => /* @__PURE__ */ import_react134.default.createElement(
    "path",
    {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: "32",
      d: "M256 112v288M400 256H112"
    }
  );
  var tn = () => /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement("path", { d: "M232 416a23.88 23.88 0 01-14.2-4.68 8.27 8.27 0 01-.66-.51L125.76 336H56a24 24 0 01-24-24V200a24 24 0 0124-24h69.75l91.37-74.81a8.27 8.27 0 01.66-.51A24 24 0 01256 120v272a24 24 0 01-24 24zm-106.18-80zm-.27-159.86zM320 336a16 16 0 01-14.29-23.19c9.49-18.87 14.3-38 14.3-56.81 0-19.38-4.66-37.94-14.25-56.73a16 16 0 0128.5-14.54C346.19 208.12 352 231.44 352 256c0 23.86-6 47.81-17.7 71.19A16 16 0 01320 336z" }), /* @__PURE__ */ import_react134.default.createElement("path", { d: "M368 384a16 16 0 01-13.86-24C373.05 327.09 384 299.51 384 256c0-44.17-10.93-71.56-29.82-103.94a16 16 0 0127.64-16.12C402.92 172.11 416 204.81 416 256c0 50.43-13.06 83.29-34.13 120a16 16 0 01-13.87 8z" }), /* @__PURE__ */ import_react134.default.createElement("path", { d: "M416 432a16 16 0 01-13.39-24.74C429.85 365.47 448 323.76 448 256c0-66.5-18.18-108.62-45.49-151.39a16 16 0 1127-17.22C459.81 134.89 480 181.74 480 256c0 64.75-14.66 113.63-50.6 168.74A16 16 0 01416 432z" }));
  var nn = () => /* @__PURE__ */ import_react134.default.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" });
  var rn = () => /* @__PURE__ */ import_react134.default.createElement("path", { d: "M416 64H96a64.07 64.07 0 00-64 64v256a64.07 64.07 0 0064 64h320a64.07 64.07 0 0064-64V128a64.07 64.07 0 00-64-64zm-80 64a48 48 0 11-48 48 48.05 48.05 0 0148-48zM96 416a32 32 0 01-32-32v-67.63l94.84-84.3a48.06 48.06 0 0165.8 1.9l64.95 64.81L172.37 416zm352-32a32 32 0 01-32 32H217.63l121.42-121.42a47.72 47.72 0 0161.64-.16L448 333.84z" });
  var on = () => /* @__PURE__ */ import_react134.default.createElement("path", { d: "M464 384.39a32 32 0 01-13-2.77 15.77 15.77 0 01-2.71-1.54l-82.71-58.22A32 32 0 01352 295.7v-79.4a32 32 0 0113.58-26.16l82.71-58.22a15.77 15.77 0 012.71-1.54 32 32 0 0145 29.24v192.76a32 32 0 01-32 32zM268 400H84a68.07 68.07 0 01-68-68V180a68.07 68.07 0 0168-68h184.48A67.6 67.6 0 01336 179.52V332a68.07 68.07 0 01-68 68z" });
  var Re = d2("svg", {
    display: "inline-flex",
    variants: {
      isLarge: {
        true: {
          height: "4rem",
          width: "4rem"
        }
      },
      isMedium: {
        true: {
          height: "2rem",
          width: "2rem"
        }
      },
      isSmall: {
        true: {
          height: "1rem",
          width: "1rem"
        }
      }
    }
  });
  var an = ({ children: t2 }) => /* @__PURE__ */ import_react134.default.createElement("title", null, t2);
  var S2 = (t2) => /* @__PURE__ */ import_react134.default.createElement(
    Re,
    {
      ...t2,
      "data-testid": "icon-svg",
      role: "img",
      viewBox: "0 0 512 512",
      xmlns: "http://www.w3.org/2000/svg"
    },
    t2.children
  );
  S2.Title = an;
  S2.Add = en;
  S2.Audio = tn;
  S2.Close = nn;
  S2.Image = rn;
  S2.Video = on;
  var ln = X2({
    "0%": { opacity: 0, transform: "translateY(1rem)" },
    "100%": { opacity: 1, transform: "translateY(0)" }
  });
  var sn = X2({
    "0%": { opacity: 0, transform: "translateY(1rem)" },
    "100%": { opacity: 1, transform: "translateY(0)" }
  });
  var ze = d2($cb5cc270b50c6fcd$export$21b07c8f274aebd5, {
    fill: "$secondaryAlt"
  });
  var cn = d2($cb5cc270b50c6fcd$export$f39c2d165cd861fe, {
    position: "absolute",
    right: "0",
    top: "0",
    padding: "0.5rem",
    margin: "0",
    cursor: "pointer",
    border: "none",
    background: "none",
    fill: "inherit",
    "&:hover": {
      opacity: "0.75"
    }
  });
  var dn = d2($cb5cc270b50c6fcd$export$7c6e2c02157bb7d2, {
    border: "none",
    backgroundColor: "white",
    fill: "inhrerit",
    padding: "1rem 2rem 1rem 1rem",
    width: "auto",
    minWidth: "200px",
    maxWidth: "350px",
    borderRadius: "3px",
    boxShadow: "5px 5px 13px #0002",
    animationDuration: "0.3s",
    animationTimingFunction: "cubic-bezier(0.16, 1, 0.3, 1)",
    '&[data-side="top"]': { animationName: sn },
    '&[data-side="bottom"]': { animationName: ln },
    '&[data-align="end"]': {
      [`& ${ze}`]: {
        margin: "0 0.7rem"
      }
    }
  });
  var mn = d2($cb5cc270b50c6fcd$export$41fb9f06171c75f4, {
    display: "inline-flex",
    padding: "0.5rem 0",
    margin: "0 0.5rem 0 0",
    cursor: "pointer",
    border: "none",
    background: "none",
    "> button, > span": {
      margin: "0"
    }
  });
  var un = d2($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, {
    boxSizing: "content-box"
  });
  var pn = (t2) => /* @__PURE__ */ import_react134.default.createElement(mn, { ...t2 }, t2.children);
  var gn = (t2) => /* @__PURE__ */ import_react134.default.createElement(dn, { ...t2 }, /* @__PURE__ */ import_react134.default.createElement(ze, null), /* @__PURE__ */ import_react134.default.createElement(cn, null, /* @__PURE__ */ import_react134.default.createElement(S2, { isSmall: true }, /* @__PURE__ */ import_react134.default.createElement(S2.Close, null))), t2.children);
  var V2 = ({ children: t2 }) => /* @__PURE__ */ import_react134.default.createElement(un, null, t2);
  V2.Trigger = pn;
  V2.Content = gn;
  var q2 = d2("div", {
    boxSizing: "border-box",
    display: "inline-flex",
    alignItems: "center",
    borderRadius: "5px",
    padding: "$1",
    marginBottom: "$2",
    marginRight: "$2",
    backgroundColor: "$lightGrey",
    color: "$richBlack50",
    textTransform: "uppercase",
    fontSize: "$2",
    objectFit: "contain",
    lineHeight: "1em !important",
    "&:last-child": {
      marginRight: "0"
    },
    [`${Re}`]: {
      position: "absolute",
      left: "$1",
      height: "$3",
      width: "$3"
    },
    variants: {
      isIcon: {
        true: { position: "relative", paddingLeft: "$5" }
      }
    }
  });
  var U2 = d2("span", {
    display: "flex"
  });
  var fn = d2("span", {
    display: "flex",
    width: "1.2111rem",
    height: "0.7222rem"
  });
  var hn = d2("span", {
    display: "inline-flex",
    marginLeft: "5px",
    marginBottom: "-1px"
  });
  var xn = d2($f99a8c78507165f7$export$6d08773d2e66f8f2, {
    display: "flex",
    flexShrink: "0",
    margin: "0 1.618rem 0 0",
    padding: "0",
    cursor: "pointer",
    background: "none",
    border: "none",
    fontFamily: "inherit",
    lineHeight: "1.25em",
    fontSize: "1rem",
    textAlign: "left",
    "&:last-child": {
      marginRight: "1rem"
    },
    figure: {
      margin: "0",
      width: "161.8px",
      "> div": {
        position: "relative",
        display: "flex",
        backgroundColor: "$secondaryAlt",
        width: "inherit",
        height: "100px",
        overflow: "hidden",
        borderRadius: "3px",
        transition: "$all",
        img: {
          width: "100%",
          height: "100%",
          objectFit: "cover",
          filter: "blur(0)",
          transform: "scale3d(1, 1, 1)",
          transition: "$all",
          color: "transparent"
        },
        [`& ${U2}`]: {
          position: "absolute",
          right: "0",
          bottom: "0",
          [`& ${q2}`]: {
            margin: "0",
            paddingLeft: "0",
            fontSize: "0.7222rem",
            backgroundColor: "#000d",
            color: "$secondary",
            fill: "$secondary",
            borderBottomLeftRadius: "0",
            borderTopRightRadius: "0"
          }
        }
      },
      figcaption: {
        marginTop: "0.5rem",
        fontWeight: "400",
        fontSize: "0.8333rem",
        display: "-webkit-box",
        overflow: "hidden",
        MozBoxOrient: "vertical",
        WebkitBoxOrient: "vertical",
        WebkitLineClamp: "5",
        "@sm": {
          fontSize: "0.8333rem"
        }
      }
    },
    "&[aria-checked='true']": {
      figure: {
        "> div": {
          backgroundColor: "$primaryAlt",
          "&::before": {
            position: "absolute",
            zIndex: "1",
            color: "$secondaryMuted",
            content: "Active Item",
            textTransform: "uppercase",
            fontWeight: "700",
            fontSize: "0.6111rem",
            letterSpacing: "0.03rem",
            display: "flex",
            width: "100%",
            height: "100%",
            flexDirection: "column",
            justifyContent: "center",
            textAlign: "center",
            textShadow: "5px 5px 5px #0003"
          },
          img: {
            opacity: "0.3",
            transform: "scale3d(1.1, 1.1, 1.1)",
            filter: "blur(2px)"
          },
          [`& ${U2}`]: {
            [`& ${q2}`]: {
              backgroundColor: "$accent"
            }
          }
        }
      },
      figcaption: {
        fontWeight: "700"
      }
    }
  });
  var vn = ({ type: t2 }) => {
    switch (t2) {
      case "Sound":
        return /* @__PURE__ */ import_react134.default.createElement(S2.Audio, null);
      case "Image":
        return /* @__PURE__ */ import_react134.default.createElement(S2.Image, null);
      case "Video":
        return /* @__PURE__ */ import_react134.default.createElement(S2.Video, null);
      default:
        return /* @__PURE__ */ import_react134.default.createElement(S2.Image, null);
    }
  };
  var bn = ({
    canvas: t2,
    canvasIndex: n2,
    isActive: r2,
    thumbnail: o2,
    type: i2,
    handleChange: a2
  }) => /* @__PURE__ */ import_react134.default.createElement(
    xn,
    {
      "aria-checked": r2,
      "data-testid": "media-thumbnail",
      "data-canvas": n2,
      onClick: () => a2(t2.id),
      value: t2.id
    },
    /* @__PURE__ */ import_react134.default.createElement("figure", null, /* @__PURE__ */ import_react134.default.createElement("div", null, (o2 == null ? void 0 : o2.id) && /* @__PURE__ */ import_react134.default.createElement(
      "img",
      {
        src: o2.id,
        alt: t2 != null && t2.label ? P2(t2.label) : ""
      }
    ), /* @__PURE__ */ import_react134.default.createElement(U2, null, /* @__PURE__ */ import_react134.default.createElement(q2, { isIcon: true, "data-testid": "thumbnail-tag" }, /* @__PURE__ */ import_react134.default.createElement(fn, null), /* @__PURE__ */ import_react134.default.createElement(S2, { "aria-label": i2 }, /* @__PURE__ */ import_react134.default.createElement(vn, { type: i2 })), ["Video", "Sound"].includes(i2) && /* @__PURE__ */ import_react134.default.createElement(hn, null, pe(t2.duration))))), (t2 == null ? void 0 : t2.label) && /* @__PURE__ */ import_react134.default.createElement("figcaption", { "data-testid": "fig-caption" }, /* @__PURE__ */ import_react134.default.createElement(z2, { label: t2.label })))
  );
  var yn = (t2) => t2.body ? t2.body.type : "Image";
  var Le = d2("div", {
    position: "absolute",
    right: "1rem",
    top: "1rem",
    display: "flex",
    justifyContent: "flex-end",
    zIndex: "1"
  });
  var En = d2("input", {
    flexGrow: "1",
    border: "none",
    backgroundColor: "$secondaryMuted",
    color: "$primary",
    marginRight: "1rem",
    height: "2rem",
    padding: "0 1rem",
    borderRadius: "2rem",
    fontFamily: "inherit",
    fontSize: "1rem",
    lineHeight: "1rem",
    boxShadow: "inset 1px 1px 2px #0003",
    "&::placeholder": {
      color: "$primaryMuted"
    }
  });
  var N2 = d2("button", {
    display: "flex",
    background: "none",
    border: "none",
    width: "2rem !important",
    height: "2rem !important",
    padding: "0",
    margin: "0",
    fontWeight: "700",
    borderRadius: "2rem",
    backgroundColor: "$accent",
    color: "$secondary",
    cursor: "pointer",
    boxSizing: "content-box !important",
    transition: "$all",
    svg: {
      height: "60%",
      width: "60%",
      padding: "20%",
      fill: "$secondary",
      stroke: "$secondary",
      opacity: "1",
      filter: "drop-shadow(5px 5px 5px #000D)",
      boxSizing: "inherit",
      transition: "$all"
    },
    "&:disabled": {
      backgroundColor: "transparent",
      boxShadow: "none",
      svg: { opacity: "0.25" }
    }
  });
  var wn = d2("div", {
    display: "flex",
    marginRight: "0.618rem",
    backgroundColor: "$accentAlt",
    borderRadius: "2rem",
    boxShadow: "5px 5px 5px #0003",
    color: "$secondary",
    alignItems: "center",
    "> span": {
      display: "flex",
      margin: "0 0.5rem",
      fontSize: "0.7222rem"
    }
  });
  var Cn = d2("div", {
    display: "flex",
    position: "relative",
    zIndex: "1",
    width: "100%",
    padding: "0",
    transition: "$all",
    variants: {
      isToggle: {
        true: {
          paddingTop: "2.618rem",
          [`& ${Le}`]: {
            width: "calc(100% - 2rem)",
            "@sm": {
              width: "calc(100% - 2rem)"
            }
          }
        }
      }
    }
  });
  var Sn = (t2, n2) => {
    (0, import_react134.useEffect)(() => {
      function r2(o2) {
        o2.key === t2 && n2();
      }
      return window.addEventListener("keyup", r2), () => window.removeEventListener("keyup", r2);
    }, []);
  };
  var kn = () => /* @__PURE__ */ import_react134.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ import_react134.default.createElement("title", null, "Arrow Back"), /* @__PURE__ */ import_react134.default.createElement(
    "path",
    {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeMiterlimit: "10",
      strokeWidth: "45",
      d: "M244 400L100 256l144-144M120 256h292"
    }
  ));
  var In = () => /* @__PURE__ */ import_react134.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ import_react134.default.createElement("title", null, "Arrow Forward"), /* @__PURE__ */ import_react134.default.createElement(
    "path",
    {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeMiterlimit: "10",
      strokeWidth: "45",
      d: "M268 112l144 144-144 144M392 256H100"
    }
  ));
  var $n = () => /* @__PURE__ */ import_react134.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ import_react134.default.createElement("title", null, "Close"), /* @__PURE__ */ import_react134.default.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" }));
  var Tn = () => /* @__PURE__ */ import_react134.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" }, /* @__PURE__ */ import_react134.default.createElement("title", null, "Search"), /* @__PURE__ */ import_react134.default.createElement("path", { d: "M456.69 421.39L362.6 327.3a173.81 173.81 0 0034.84-104.58C397.44 126.38 319.06 48 222.72 48S48 126.38 48 222.72s78.38 174.72 174.72 174.72A173.81 173.81 0 00327.3 362.6l94.09 94.09a25 25 0 0035.3-35.3zM97.92 222.72a124.8 124.8 0 11124.8 124.8 124.95 124.95 0 01-124.8-124.8z" }));
  var An = ({
    handleCanvasToggle: t2,
    handleFilter: n2,
    activeIndex: r2,
    canvasLength: o2
  }) => {
    const [i2, a2] = (0, import_react134.useState)(false), [l2, s2] = (0, import_react134.useState)(false), [c2, m2] = (0, import_react134.useState)(false);
    (0, import_react134.useEffect)(() => {
      m2(r2 === 0), r2 === o2 - 1 ? s2(true) : s2(false);
    }, [r2]), Sn("Escape", () => {
      a2(false), n2("");
    });
    const u2 = () => {
      a2((v2) => !v2), n2("");
    }, f2 = (v2) => n2(v2.target.value);
    return /* @__PURE__ */ import_react134.default.createElement(Cn, { isToggle: i2 }, /* @__PURE__ */ import_react134.default.createElement(Le, null, i2 && /* @__PURE__ */ import_react134.default.createElement(En, { autoFocus: true, onChange: f2, placeholder: "Search" }), !i2 && /* @__PURE__ */ import_react134.default.createElement(wn, null, /* @__PURE__ */ import_react134.default.createElement(
      N2,
      {
        onClick: () => t2(-1),
        disabled: c2,
        type: "button"
      },
      /* @__PURE__ */ import_react134.default.createElement(kn, null)
    ), /* @__PURE__ */ import_react134.default.createElement("span", null, r2 + 1, " of ", o2), /* @__PURE__ */ import_react134.default.createElement(
      N2,
      {
        onClick: () => t2(1),
        disabled: l2,
        type: "button"
      },
      /* @__PURE__ */ import_react134.default.createElement(In, null)
    )), /* @__PURE__ */ import_react134.default.createElement(N2, { onClick: u2, type: "button" }, i2 ? /* @__PURE__ */ import_react134.default.createElement($n, null) : /* @__PURE__ */ import_react134.default.createElement(Tn, null))));
  };
  var Mn = ({ items: t2 }) => {
    const n2 = F2(), r2 = k2(), { activeCanvas: o2, vault: i2 } = r2, [a2, l2] = (0, import_react134.useState)(""), [s2, c2] = (0, import_react134.useState)([]), [m2, u2] = (0, import_react134.useState)(0), f2 = import_react134.default.useRef(null), v2 = "painting", h2 = ["Image", "Sound", "Video"], x2 = (g2) => {
      o2 !== g2 && n2({
        type: "updateActiveCanvas",
        canvasId: g2
      });
    };
    (0, import_react134.useEffect)(() => {
      if (!s2.length) {
        const g2 = t2.map(
          (y2) => ve(i2, y2, v2, h2)
        ).filter((y2) => y2.annotations.length > 0);
        c2(g2);
      }
    }, []), (0, import_react134.useEffect)(() => {
      s2.forEach((g2, y2) => {
        g2 != null && g2.canvas && g2.canvas.id === o2 && u2(y2);
      });
    }, [o2]), (0, import_react134.useEffect)(() => {
      const g2 = document.querySelector(
        `[data-canvas="${m2}"]`
      );
      if (g2 instanceof HTMLElement && f2.current) {
        const y2 = g2.offsetLeft - f2.current.offsetWidth / 2 + g2.offsetWidth / 2;
        f2.current.scrollTo({ left: y2, behavior: "smooth" });
      }
    }, [m2]);
    const p2 = (g2) => l2(g2), w2 = (g2) => {
      const y2 = s2[m2 + g2];
      y2 != null && y2.canvas && x2(y2.canvas.id);
    };
    return /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(
      An,
      {
        handleFilter: p2,
        handleCanvasToggle: w2,
        activeIndex: m2,
        canvasLength: s2.length
      }
    ), /* @__PURE__ */ import_react134.default.createElement(Qt, { "aria-label": "select item", "data-testid": "media", ref: f2 }, s2.filter((g2) => {
      var y2;
      if ((y2 = g2.canvas) != null && y2.label) {
        const I2 = P2(g2.canvas.label);
        if (Array.isArray(I2))
          return I2[0].toLowerCase().includes(a2.toLowerCase());
      }
    }).map((g2, y2) => {
      var I2, $3;
      return /* @__PURE__ */ import_react134.default.createElement(
        bn,
        {
          canvas: g2.canvas,
          canvasIndex: y2,
          handleChange: x2,
          isActive: o2 === ((I2 = g2 == null ? void 0 : g2.canvas) == null ? void 0 : I2.id),
          key: ($3 = g2 == null ? void 0 : g2.canvas) == null ? void 0 : $3.id,
          thumbnail: rt(i2, g2, 200, 200),
          type: yn(g2.annotations[0])
        }
      );
    })));
  };
  var Rn = d2("div", {
    position: "absolute !important",
    zIndex: "1",
    top: "1rem",
    left: "1rem",
    width: "161.8px",
    height: "100px",
    backgroundColor: "#000D",
    boxShadow: "5px 5px 5px #0002",
    borderRadius: "3px",
    ".displayregion": {
      border: " 3px solid $accent !important",
      boxShadow: "0 0 3px #0006"
    },
    "@sm": {
      width: "123px",
      height: "76px"
    },
    "@xs": {
      width: "100px",
      height: "61.8px"
    }
  });
  var zn = d2("div", {
    position: "relative",
    width: "100%",
    height: "100%",
    zIndex: "0"
  });
  var Ln = d2("div", {
    width: "100%",
    height: "61.8vh",
    maxHeight: "100vh",
    background: "black",
    backgroundSize: "contain",
    color: "white",
    position: "relative",
    zIndex: "1",
    overflow: "hidden"
  });
  var Fe = d2("button", {
    display: "flex",
    height: "2rem",
    width: "2rem",
    borderRadius: "2rem",
    padding: "0",
    margin: "0",
    fontFamily: "inherit",
    background: "none",
    border: "none",
    color: "white",
    cursor: "pointer",
    marginLeft: "0.618rem",
    backgroundColor: "$primary",
    filter: "drop-shadow(2px 2px 5px #0003)",
    transition: "$all",
    boxSizing: "content-box !important",
    "&:first-child": {
      marginLeft: "0"
    },
    "@xs": {
      marginBottom: "0.618rem",
      marginLeft: "0",
      "&:last-child": {
        marginBottom: "0"
      }
    },
    svg: {
      height: "60%",
      width: "60%",
      padding: "20%",
      fill: "$secondary",
      stroke: "$secondary",
      filter: "drop-shadow(2px 2px 5px #0003)",
      transition: "$all",
      boxSizing: "inherit"
    },
    "&:hover, &:focus": {
      backgroundColor: "$accent"
    },
    "&#rotateRight": {
      "&:hover, &:focus": {
        svg: {
          rotate: "45deg"
        }
      }
    },
    "&#rotateLeft": {
      transform: "scaleX(-1)",
      "&:hover, &:focus": {
        svg: {
          rotate: "45deg"
        }
      }
    },
    "&#reset": {
      "&:hover, &:focus": {
        svg: {
          rotate: "-15deg"
        }
      }
    }
  });
  var R2 = ({ id: t2, label: n2, children: r2 }) => /* @__PURE__ */ import_react134.default.createElement(Fe, { id: t2, "data-testid": "openseadragon-button" }, /* @__PURE__ */ import_react134.default.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      "aria-labelledby": `${t2}-svg-title`,
      "data-testid": "openseadragon-button-svg",
      focusable: "false",
      viewBox: "0 0 512 512",
      role: "img"
    },
    /* @__PURE__ */ import_react134.default.createElement("title", { id: `${t2}-svg-title` }, n2),
    r2
  ));
  var Fn = d2("div", {
    position: "absolute",
    zIndex: "1",
    top: "1rem",
    display: "flex",
    "@xs": {
      flexDirection: "column",
      zIndex: "2"
    },
    variants: {
      hasPlaceholder: {
        true: {
          right: "3.618rem",
          "@xs": {
            top: "3.618rem",
            right: "1rem"
          }
        },
        false: {
          right: "1rem",
          "@xs": {
            top: "1rem",
            right: "1rem"
          }
        }
      }
    }
  });
  var Pn = () => /* @__PURE__ */ import_react134.default.createElement(
    "path",
    {
      strokeLinecap: "round",
      strokeMiterlimit: "10",
      strokeWidth: "45",
      d: "M256 112v288M400 256H112"
    }
  );
  var Vn = () => /* @__PURE__ */ import_react134.default.createElement(
    "path",
    {
      strokeLinecap: "round",
      strokeMiterlimit: "10",
      strokeWidth: "45",
      d: "M400 256H112"
    }
  );
  var Hn = () => /* @__PURE__ */ import_react134.default.createElement(
    "path",
    {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: "32",
      d: "M432 320v112H320M421.8 421.77L304 304M80 192V80h112M90.2 90.23L208 208M320 80h112v112M421.77 90.2L304 208M192 432H80V320M90.23 421.8L208 304"
    }
  );
  var Bn = () => /* @__PURE__ */ import_react134.default.createElement("path", { d: "M448 440a16 16 0 01-12.61-6.15c-22.86-29.27-44.07-51.86-73.32-67C335 352.88 301 345.59 256 344.23V424a16 16 0 01-27 11.57l-176-168a16 16 0 010-23.14l176-168A16 16 0 01256 88v80.36c74.14 3.41 129.38 30.91 164.35 81.87C449.32 292.44 464 350.9 464 424a16 16 0 01-16 16z" });
  var ae = () => /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(
    "path",
    {
      fill: "none",
      strokeLinecap: "round",
      strokeMiterlimit: "10",
      strokeWidth: "45",
      d: "M400 148l-21.12-24.57A191.43 191.43 0 00240 64C134 64 48 150 48 256s86 192 192 192a192.09 192.09 0 00181.07-128"
    }
  ), /* @__PURE__ */ import_react134.default.createElement("path", { d: "M464 97.42V208a16 16 0 01-16 16H337.42c-14.26 0-21.4-17.23-11.32-27.31L436.69 86.1C446.77 76 464 83.16 464 97.42z" }));
  var On = ({
    hasPlaceholder: t2,
    options: n2
  }) => /* @__PURE__ */ import_react134.default.createElement(
    Fn,
    {
      "data-testid": "openseadragon-controls",
      hasPlaceholder: t2,
      id: "openseadragon-controls"
    },
    n2.showZoomControl && /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(R2, { id: "zoomIn", label: "zoom in" }, /* @__PURE__ */ import_react134.default.createElement(Pn, null)), /* @__PURE__ */ import_react134.default.createElement(R2, { id: "zoomOut", label: "zoom out" }, /* @__PURE__ */ import_react134.default.createElement(Vn, null))),
    n2.showFullPageControl && /* @__PURE__ */ import_react134.default.createElement(R2, { id: "fullPage", label: "full page" }, /* @__PURE__ */ import_react134.default.createElement(Hn, null)),
    n2.showRotationControl && /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement(R2, { id: "rotateRight", label: "rotate right" }, /* @__PURE__ */ import_react134.default.createElement(ae, null)), /* @__PURE__ */ import_react134.default.createElement(R2, { id: "rotateLeft", label: "rotate left" }, /* @__PURE__ */ import_react134.default.createElement(ae, null))),
    n2.showHomeControl && /* @__PURE__ */ import_react134.default.createElement(R2, { id: "reset", label: "reset" }, /* @__PURE__ */ import_react134.default.createElement(Bn, null))
  );
  var Dn = (t2) => fetch(`${t2.replace(/\/$/, "")}/info.json`).then((n2) => n2.json()).then((n2) => n2).catch((n2) => {
    console.error(
      `The IIIF tilesource ${t2.replace(
        /\/$/,
        ""
      )}/info.json failed to load: ${n2}`
    );
  });
  var Wn = (t2) => {
    let n2, r2;
    if (Array.isArray(t2) && (n2 = t2[0], n2)) {
      let o2;
      "@id" in n2 ? o2 = n2["@id"] : o2 = n2.id, r2 = o2;
    }
    return r2;
  };
  var jn = ({ uri: t2, imageType: n2, hasPlaceholder: r2 }) => {
    const [o2, i2] = (0, import_react134.useState)(), a2 = k2(), { configOptions: l2 } = a2, s2 = v4_default(), c2 = {
      id: `openseadragon-viewport-${s2}`,
      loadTilesWithAjax: true,
      fullPageButton: "fullPage",
      homeButton: "reset",
      rotateLeftButton: "rotateLeft",
      rotateRightButton: "rotateRight",
      zoomInButton: "zoomIn",
      zoomOutButton: "zoomOut",
      showNavigator: true,
      showFullPageControl: true,
      showHomeControl: true,
      showRotationControl: true,
      showZoomControl: true,
      navigatorBorderColor: "transparent",
      navigatorId: `openseadragon-navigator-${s2}`,
      gestureSettingsMouse: {
        clickToZoom: true,
        dblClickToZoom: true,
        pinchToZoom: true,
        scrollToZoom: true
      },
      ...l2.openSeadragon,
      ajaxWithCredentials: l2.withCredentials
    };
    return (0, import_react134.useEffect)(() => {
      t2 !== o2 && i2(t2);
    }, []), (0, import_react134.useEffect)(() => {
      if (o2)
        switch (n2) {
          case "simpleImage":
            (0, import_openseadragon.default)(c2).addSimpleImage({
              url: o2
            });
            break;
          case "tiledImage":
            Dn(o2).then(
              (m2) => (0, import_openseadragon.default)(c2).addTiledImage({
                tileSource: m2
              })
            );
            break;
          default:
            console.warn(
              `Unable to render ${o2} in OpenSeadragon as type: "${n2}"`
            );
            break;
        }
    }, [o2]), /* @__PURE__ */ import_react134.default.createElement(
      Ln,
      {
        css: {
          backgroundColor: l2.canvasBackgroundColor,
          height: l2.canvasHeight
        }
      },
      /* @__PURE__ */ import_react134.default.createElement(On, { options: c2, hasPlaceholder: r2 }),
      /* @__PURE__ */ import_react134.default.createElement(Rn, { id: `openseadragon-navigator-${s2}` }),
      /* @__PURE__ */ import_react134.default.createElement(zn, { id: `openseadragon-viewport-${s2}` })
    );
  };
  var Nn = ({ body: t2, hasPlaceholder: n2 }) => {
    const [r2, o2] = (0, import_react134.useState)(), [i2, a2] = (0, import_react134.useState)();
    return (0, import_react134.useEffect)(() => {
      Array.isArray(t2.service) && t2.service.length > 0 ? (o2("tiledImage"), a2(Wn(t2.service))) : (o2("simpleImage"), a2(t2.id));
    }, [t2]), /* @__PURE__ */ import_react134.default.createElement(
      jn,
      {
        uri: i2,
        key: i2,
        imageType: r2,
        hasPlaceholder: n2
      }
    );
  };
  var Pe = d2("button", {
    background: "none",
    border: "none",
    cursor: "zoom-in",
    width: "100%",
    height: "100%",
    margin: "0",
    padding: "0",
    display: "flex",
    transition: "$all",
    "& img": {
      width: "100%",
      height: "100%",
      objectFit: "contain",
      color: "transparent",
      transition: "$all"
    },
    variants: {
      isMedia: {
        true: {
          cursor: "pointer"
        }
      }
    }
  });
  var Gn = ({
    isMedia: t2,
    label: n2,
    placeholderCanvas: r2,
    setIsInteractive: o2
  }) => {
    const { vault: i2 } = k2(), a2 = B2(i2, r2), l2 = n2 ? P2(n2) : ["placeholder image"];
    return /* @__PURE__ */ import_react134.default.createElement(Pe, { onClick: () => o2(true), isMedia: t2 }, /* @__PURE__ */ import_react134.default.createElement(
      "img",
      {
        src: (a2 == null ? void 0 : a2.id) || "",
        alt: l2.join(),
        height: a2 == null ? void 0 : a2.height,
        width: a2 == null ? void 0 : a2.width
      }
    ));
  };
  var Ve = d2(Fe, {
    position: "absolute",
    width: "2rem",
    top: "1rem",
    right: "1rem",
    zIndex: 100,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    textAlign: "center",
    transition: "$all",
    borderRadius: "50%",
    backgroundColor: "$accent",
    cursor: "pointer",
    "&:hover, &:focus": {
      backgroundColor: "$accent !important"
    },
    variants: {
      isInteractive: {
        true: {
          "&:hover": {
            opacity: "1"
          }
        },
        false: {}
      },
      isMedia: {
        true: {
          cursor: "pointer !important"
        }
      }
    },
    compoundVariants: [
      {
        isInteractive: false,
        isMedia: true,
        css: {
          top: "50%",
          right: "50%",
          width: "4rem",
          height: "4rem",
          transform: "translate(50%,-50%)"
        }
      }
    ]
  });
  var qn = d2("div", {
    position: "relative",
    zIndex: "0",
    "&:hover": {
      [`${Ve}`]: {
        backgroundColor: "$accent"
      },
      [`${Pe}`]: {
        backgroundColor: "#6662",
        img: {
          filter: "brightness(0.85)"
        }
      }
    }
  });
  var Un = d2("div", {
    position: "relative",
    backgroundColor: "$primaryAlt",
    display: "flex",
    flexGrow: "0",
    flexShrink: "1",
    maxHeight: "500px",
    zIndex: "1",
    video: {
      backgroundColor: "transparent",
      objectFit: "contain",
      width: "100%",
      height: "100%",
      position: "relative",
      zIndex: "1"
    }
  });
  var _n = d2("canvas", {
    position: "absolute",
    width: "100%",
    height: "100%",
    zIndex: "0"
  });
  var Zn = import_react134.default.forwardRef((t2, n2) => {
    const r2 = import_react134.default.useRef(null);
    import_react134.default.useEffect(() => {
      n2 && (n2.current.onplay = o2);
    }, [n2]);
    function o2() {
      const a2 = n2.current, l2 = new AudioContext(), s2 = l2.createMediaElementSource(a2);
      let c2 = l2.createAnalyser();
      const m2 = r2.current;
      if (!m2)
        return;
      m2.width = a2.offsetWidth, m2.height = a2.offsetHeight;
      const u2 = m2.getContext("2d");
      s2.connect(c2), c2.connect(l2.destination), c2.fftSize = 256;
      const f2 = c2.frequencyBinCount, v2 = new Uint8Array(f2);
      setInterval(function() {
        i2(
          c2,
          u2,
          f2,
          v2,
          m2.width,
          m2.height
        );
      }, 20);
    }
    function i2(a2, l2, s2, c2, m2, u2) {
      let f2 = m2 / s2 * 2.6, v2, h2 = 0;
      a2.getByteFrequencyData(c2), l2.fillStyle = "#000000", l2.fillRect(0, 0, m2, u2);
      for (let x2 = 0; x2 < s2; x2++)
        v2 = c2[x2] * 2, l2.fillStyle = "rgba(78, 42, 132, 1)", l2.fillRect(h2, u2 - v2, f2, v2), h2 += f2 + 6;
    }
    return /* @__PURE__ */ import_react134.default.createElement(_n, { ref: r2 });
  });
  var Xn = ({ resource: t2, ignoreCaptionLabels: n2 }) => {
    const r2 = P2(t2.label, "en");
    return r2.some(
      (i2) => n2.includes(i2)
    ) ? null : /* @__PURE__ */ import_react134.default.createElement(
      "track",
      {
        key: t2.id,
        src: t2.id,
        label: r2,
        srcLang: "en",
        "data-testid": "player-track"
      }
    );
  };
  var Yn = ({ resources: t2, painting: n2 }) => {
    var v2;
    const [r2, o2] = import_react134.default.useState(0), [i2, a2] = import_react134.default.useState(), l2 = import_react134.default.useRef(null), s2 = (v2 = n2 == null ? void 0 : n2.format) == null ? void 0 : v2.includes("audio/"), c2 = k2(), { activeCanvas: m2, configOptions: u2, vault: f2 } = c2;
    return (0, import_react134.useEffect)(() => {
      if (!n2.id || !l2.current || n2.id.split(".").pop() !== "m3u8")
        return;
      const h2 = {
        xhrSetup: function(p2, w2) {
          p2.withCredentials = u2.withCredentials;
        }
      }, x2 = new Hls(h2);
      return x2.attachMedia(l2.current), x2.on(Hls.Events.MEDIA_ATTACHED, function() {
        x2.loadSource(n2.id);
      }), x2.on(Hls.Events.ERROR, function(p2, w2) {
        if (w2.fatal)
          switch (w2.type) {
            case Hls.ErrorTypes.NETWORK_ERROR:
              console.error(
                `fatal ${p2} network error encountered, try to recover`
              ), x2.startLoad();
              break;
            case Hls.ErrorTypes.MEDIA_ERROR:
              console.error(
                `fatal ${p2} media error encountered, try to recover`
              ), x2.recoverMediaError();
              break;
            default:
              x2.destroy();
              break;
          }
      }), () => {
        if (x2 && l2.current) {
          const p2 = l2.current;
          x2.detachMedia(), x2.destroy(), p2.currentTime = 0;
        }
      };
    }, [n2.id]), (0, import_react134.useEffect)(() => {
      var g2, y2, I2, $3;
      const h2 = f2.get(m2), x2 = (g2 = h2.accompanyingCanvas) != null && g2.id ? B2(f2, (y2 = h2.accompanyingCanvas) == null ? void 0 : y2.id) : null, p2 = (I2 = h2.placeholderCanvas) != null && I2.id ? B2(f2, ($3 = h2.placeholderCanvas) == null ? void 0 : $3.id) : null;
      !!(x2 && p2) ? a2(r2 === 0 ? p2.id : x2.id) : (x2 && a2(x2.id), p2 && a2(p2.id));
    }, [m2, r2]), (0, import_react134.useEffect)(() => {
      if (l2 != null && l2.current) {
        const h2 = l2.current;
        return h2 == null || h2.addEventListener(
          "timeupdate",
          () => o2(h2.currentTime)
        ), () => document.removeEventListener("timeupdate", () => {
        });
      }
    }, [l2 == null ? void 0 : l2.current]), /* @__PURE__ */ import_react134.default.createElement(
      Un,
      {
        css: {
          backgroundColor: u2.canvasBackgroundColor,
          maxHeight: u2.canvasHeight
        }
      },
      /* @__PURE__ */ import_react134.default.createElement(
        "video",
        {
          id: "clover-iiif-video",
          key: n2.id,
          ref: l2,
          controls: true,
          height: n2.height,
          width: n2.width,
          crossOrigin: "anonymous",
          poster: i2,
          style: {
            maxHeight: u2.canvasHeight
          }
        },
        /* @__PURE__ */ import_react134.default.createElement("source", { src: n2.id, type: n2.format }),
        t2.length > 0 && t2.map((h2) => /* @__PURE__ */ import_react134.default.createElement(
          Xn,
          {
            resource: h2,
            ignoreCaptionLabels: u2.ignoreCaptionLabels,
            key: h2.id
          }
        )),
        "Sorry, your browser doesn't support embedded videos."
      ),
      s2 && /* @__PURE__ */ import_react134.default.createElement(Zn, { ref: l2 })
    );
  };
  var Kn = () => /* @__PURE__ */ import_react134.default.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      "aria-labelledby": "close-svg-title",
      focusable: "false",
      viewBox: "0 0 512 512",
      role: "img"
    },
    /* @__PURE__ */ import_react134.default.createElement("title", { id: "close-svg-title" }, "close"),
    /* @__PURE__ */ import_react134.default.createElement("path", { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" })
  );
  var Jn = ({ isMedia: t2 }) => /* @__PURE__ */ import_react134.default.createElement(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      "aria-labelledby": "open-svg-title",
      focusable: "false",
      viewBox: "0 0 512 512",
      role: "img"
    },
    /* @__PURE__ */ import_react134.default.createElement("title", { id: "open-svg-title" }, "open"),
    t2 ? /* @__PURE__ */ import_react134.default.createElement("path", { d: "M133 440a35.37 35.37 0 01-17.5-4.67c-12-6.8-19.46-20-19.46-34.33V111c0-14.37 7.46-27.53 19.46-34.33a35.13 35.13 0 0135.77.45l247.85 148.36a36 36 0 010 61l-247.89 148.4A35.5 35.5 0 01133 440z" }) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, /* @__PURE__ */ import_react134.default.createElement("path", { d: "m456.69,421.39l-94.09-94.09c22.65-30.16,34.88-66.86,34.84-104.58,0-96.34-78.38-174.72-174.72-174.72S48,126.38,48,222.72s78.38,174.72,174.72,174.72c37.72.04,74.42-12.19,104.58-34.84l94.09,94.09c10.29,9.2,26.1,8.32,35.3-1.98,8.48-9.49,8.48-23.83,0-33.32Zm-233.97-73.87c-68.89-.08-124.72-55.91-124.8-124.8h0c0-68.93,55.87-124.8,124.8-124.8s124.8,55.87,124.8,124.8-55.87,124.8-124.8,124.8Z" }), /* @__PURE__ */ import_react134.default.createElement("path", { d: "m279.5,197.76h-3.35s-28.47,0-28.47,0v-31.82c-.77-13.79-12.57-24.33-26.36-23.56-12.71.71-22.85,10.86-23.56,23.56v3.35h0v28.47h-31.82c-13.79.77-24.33,12.57-23.56,26.36.71,12.71,10.86,22.85,23.56,23.56h3.35s28.47,0,28.47,0v31.82c.77,13.79,12.57,24.33,26.36,23.56,12.71-.71,22.85-10.86,23.56-23.56v-3.35h0v-28.47h31.82c13.79-.77,24.33-12.57,23.56-26.36-.71-12.71-10.86-22.85-23.56-23.56Z" }))
  );
  var Qn = ({
    handleToggle: t2,
    isInteractive: n2,
    isMedia: r2
  }) => /* @__PURE__ */ import_react134.default.createElement(
    Ve,
    {
      onClick: t2,
      isInteractive: n2,
      isMedia: r2
    },
    n2 ? /* @__PURE__ */ import_react134.default.createElement(Kn, null) : /* @__PURE__ */ import_react134.default.createElement(Jn, { isMedia: r2 })
  );
  var er = ({
    activeCanvas: t2,
    isMedia: n2,
    painting: r2,
    resources: o2
  }) => {
    var h2;
    const [i2, a2] = import_react134.default.useState(false), { configOptions: l2, vault: s2 } = k2(), c2 = s2.get(t2), m2 = (h2 = c2 == null ? void 0 : c2.placeholderCanvas) == null ? void 0 : h2.id, u2 = !!m2, f2 = m2 && !i2 && !n2, v2 = () => a2(!i2);
    return /* @__PURE__ */ import_react134.default.createElement(
      qn,
      {
        css: {
          maxHeight: l2.canvasHeight,
          backgroundColor: l2.canvasBackgroundColor
        }
      },
      m2 && !n2 && /* @__PURE__ */ import_react134.default.createElement(
        Qn,
        {
          handleToggle: v2,
          isInteractive: i2,
          isMedia: n2
        }
      ),
      f2 && !n2 && /* @__PURE__ */ import_react134.default.createElement(
        Gn,
        {
          isMedia: n2,
          label: c2 == null ? void 0 : c2.label,
          placeholderCanvas: m2,
          setIsInteractive: a2
        }
      ),
      !f2 && /* @__PURE__ */ import_react134.default.createElement("div", null, n2 ? /* @__PURE__ */ import_react134.default.createElement(
        Yn,
        {
          painting: r2,
          resources: o2
        }
      ) : r2 && /* @__PURE__ */ import_react134.default.createElement(
        Nn,
        {
          body: r2,
          hasPlaceholder: u2,
          key: t2
        }
      ))
    );
  };
  var tr = ({
    activeCanvas: t2,
    painting: n2,
    resources: r2,
    items: o2,
    isAudioVideo: i2
  }) => {
    const { informationOpen: a2, configOptions: l2 } = k2(), { informationPanel: s2 } = l2, c2 = (s2 == null ? void 0 : s2.renderAbout) || (s2 == null ? void 0 : s2.renderSupplementing) && r2.length > 0;
    return /* @__PURE__ */ import_react134.default.createElement(ye, { className: "clover-content" }, /* @__PURE__ */ import_react134.default.createElement(Ee, null, /* @__PURE__ */ import_react134.default.createElement(
      er,
      {
        activeCanvas: t2,
        isMedia: i2,
        painting: n2,
        resources: r2
      }
    ), c2 && /* @__PURE__ */ import_react134.default.createElement(we, null, /* @__PURE__ */ import_react134.default.createElement("span", null, a2 ? "View Items" : "More Information")), o2.length > 1 && /* @__PURE__ */ import_react134.default.createElement(be, { className: "clover-canvases" }, /* @__PURE__ */ import_react134.default.createElement(Mn, { items: o2, activeItem: 0 }))), a2 && c2 && /* @__PURE__ */ import_react134.default.createElement(ct, null, /* @__PURE__ */ import_react134.default.createElement(Ce, null, /* @__PURE__ */ import_react134.default.createElement(
      Jt,
      {
        activeCanvas: t2,
        resources: r2
      }
    ))));
  };
  var nr = d2("svg", {
    height: "19px",
    color: "$accent",
    fill: "$accent",
    stroke: "$accent",
    display: "flex",
    margin: "0.25rem 0.85rem"
  });
  var rr = d2($cc7e05a45900e73f$export$41fb9f06171c75f4, {
    fontSize: "1.25rem",
    fontWeight: "400",
    fontFamily: "inherit",
    alignSelf: "flex-start",
    flexGrow: "1",
    backgroundColor: "$secondary",
    cursor: "pointer",
    transition: "$all",
    border: "1px solid $secondaryMuted",
    boxShadow: "2px 2px 5px #0001",
    borderRadius: "3px",
    display: "flex",
    alignItems: "center",
    paddingLeft: "0.5rem",
    "@sm": {
      fontSize: "1rem"
    }
  });
  var or = d2($cc7e05a45900e73f$export$7c6e2c02157bb7d2, {
    borderRadius: "3px",
    boxShadow: "3px 3px 8px #0003",
    backgroundColor: "$secondary",
    marginTop: "2.25rem",
    marginLeft: "6px",
    paddingBottom: "0.25rem",
    maxHeight: "calc(61.8vh - 2.5rem) !important",
    borderTopLeftRadius: "0",
    border: "1px solid $secondaryMuted",
    maxWidth: "90vw"
  });
  var ar = d2($cc7e05a45900e73f$export$6d08773d2e66f8f2, {
    display: "flex",
    alignItems: "center",
    fontFamily: "inherit",
    padding: "0.25rem 0.5rem",
    color: "$primary",
    fontWeight: "400",
    fontSize: "0.8333rem",
    cursor: "pointer",
    backgroundColor: "$secondary",
    width: "calc(100% - 1rem)",
    "> span": {
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      overflow: "hidden"
    },
    '&[data-state="checked"]': {
      fontWeight: "700",
      color: "$primary !important"
    },
    "&:hover": {
      color: "$accent"
    },
    img: {
      width: "31px",
      height: "31px",
      marginRight: "0.5rem",
      borderRadius: "3px"
    }
  });
  var ir = d2($cc7e05a45900e73f$export$b04be29aa201d4f5, {
    color: "$primaryMuted",
    fontFamily: "inherit",
    fontSize: "0.85rem",
    padding: "0.5rem 1rem 0.5rem 0.5rem",
    display: "flex",
    alignItems: "center",
    marginBottom: "0.25rem",
    borderRadius: "3px",
    borderTopLeftRadius: "0",
    borderBottomLeftRadius: "0",
    borderBottomRightRadius: "0",
    backgroundColor: "$secondaryMuted"
  });
  var He = d2("div", {
    position: "relative",
    zIndex: "5"
  });
  var lr = d2(V2.Trigger, {
    width: "30px",
    padding: "5px"
  });
  var sr = d2(V2.Content, {
    display: "flex",
    flexDirection: "column",
    fontSize: "0.8333rem",
    border: "none",
    boxShadow: "2px 2px 5px #0003",
    zIndex: "2",
    button: {
      display: "flex",
      textDecoration: "none",
      marginBottom: "0.5em",
      color: "$accentAlt",
      cursor: "pointer",
      background: "$secondary",
      border: "none",
      "&:last-child": {
        marginBottom: "0"
      }
    }
  });
  var cr = d2("span", {
    fontSize: "1.33rem",
    alignSelf: "flex-start",
    flexGrow: "0",
    flexShrink: "1",
    padding: "1rem",
    "@sm": {
      fontSize: "1rem"
    },
    "&.visually-hidden": {
      position: "absolute",
      width: "1px",
      height: "1px",
      padding: "0",
      margin: "-1px",
      overflow: "hidden",
      clip: "rect(0, 0, 0, 0)",
      whiteSpace: "nowrap",
      border: "0"
    }
  });
  var dr = d2("header", {
    display: "flex",
    backgroundColor: "transparent !important",
    justifyContent: "space-between",
    alignItems: "flex-start",
    width: "100%",
    [`> ${He}`]: {
      flexGrow: "1",
      flexShrink: "0"
    },
    form: {
      flexGrow: "0",
      flexShrink: "1"
    }
  });
  var mr = d2("div", {
    display: "flex",
    alignItems: "flex-end",
    justifyContent: "flex-end",
    padding: "1rem",
    flexShrink: "0",
    flexGrow: "1"
  });
  var G2 = ({ direction: t2, title: n2 }) => {
    const r2 = () => /* @__PURE__ */ import_react134.default.createElement("path", { d: "M414 321.94L274.22 158.82a24 24 0 00-36.44 0L98 321.94c-13.34 15.57-2.28 39.62 18.22 39.62h279.6c20.5 0 31.56-24.05 18.18-39.62z" }), o2 = () => /* @__PURE__ */ import_react134.default.createElement("path", { d: "M98 190.06l139.78 163.12a24 24 0 0036.44 0L414 190.06c13.34-15.57 2.28-39.62-18.22-39.62h-279.6c-20.5 0-31.56 24.05-18.18 39.62z" });
    return /* @__PURE__ */ import_react134.default.createElement(
      nr,
      {
        xmlns: "http://www.w3.org/2000/svg",
        focusable: "false",
        viewBox: "0 0 512 512",
        role: "img"
      },
      /* @__PURE__ */ import_react134.default.createElement("title", null, n2),
      t2 === "up" && /* @__PURE__ */ import_react134.default.createElement(r2, null),
      t2 === "down" && /* @__PURE__ */ import_react134.default.createElement(o2, null)
    );
  };
  var ur = () => {
    const t2 = F2(), n2 = k2(), { activeManifest: r2, collection: o2, configOptions: i2, vault: a2 } = n2, l2 = i2 == null ? void 0 : i2.canvasHeight, s2 = (c2) => {
      t2({
        type: "updateActiveManifest",
        manifestId: c2
      });
    };
    return /* @__PURE__ */ import_react134.default.createElement(He, null, /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$be92b6f5f03c0fe9, { value: r2, onValueChange: s2 }, /* @__PURE__ */ import_react134.default.createElement(rr, null, /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$4c8d1a57a761ef94, null), /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$f04a61298a47a40f, null, /* @__PURE__ */ import_react134.default.createElement(G2, { direction: "down", title: "select from collection" }))), /* @__PURE__ */ import_react134.default.createElement(or, { css: { maxHeight: `${l2} !important` } }, /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$2f60d3ec9ad468f2, null, /* @__PURE__ */ import_react134.default.createElement(G2, { direction: "up", title: "scroll up for more" })), /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$d5c6c08dc2d3ca7, null, /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$eb2fcfdbd7ba97d4, null, /* @__PURE__ */ import_react134.default.createElement(ir, null, /* @__PURE__ */ import_react134.default.createElement(z2, { label: o2.label })), o2.items.map((c2) => /* @__PURE__ */ import_react134.default.createElement(ar, { value: c2.id, key: c2.id }, (c2 == null ? void 0 : c2.thumbnail) && /* @__PURE__ */ import_react134.default.createElement(Te, { thumbnail: a2.get(c2 == null ? void 0 : c2.thumbnail) }), /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$d6e5bf9c43ea9319, null, /* @__PURE__ */ import_react134.default.createElement(z2, { label: c2.label })), /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$c3468e2714d175fa, null))))), /* @__PURE__ */ import_react134.default.createElement($cc7e05a45900e73f$export$bf1aedc3039c8d63, null, /* @__PURE__ */ import_react134.default.createElement(G2, { direction: "down", title: "scroll down for more" })))));
  };
  var pr = (t2, n2 = 2500) => {
    const [r2, o2] = (0, import_react134.useState)(), i2 = (0, import_react134.useCallback)(() => {
      navigator.clipboard.writeText(t2).then(
        () => o2("copied"),
        () => o2("failed")
      );
    }, [t2]);
    return (0, import_react134.useEffect)(() => {
      if (!r2)
        return;
      const a2 = setTimeout(() => o2(void 0), n2);
      return () => clearTimeout(a2);
    }, [r2]), [r2, i2];
  };
  var gr = d2("span", {
    display: "flex",
    alignContent: "center",
    alignItems: "center",
    padding: "0.125rem 0.25rem 0",
    marginTop: "-0.125rem",
    marginLeft: "0.5rem",
    backgroundColor: "$accent",
    color: "$secondary",
    borderRadius: "3px",
    fontSize: "0.6111rem",
    textTransform: "uppercase",
    lineHeight: "1em"
  });
  var fr = ({ status: t2 }) => t2 ? /* @__PURE__ */ import_react134.default.createElement(gr, { "data-copy-status": t2 }, t2) : null;
  var ie = ({
    textPrompt: t2,
    textToCopy: n2
  }) => {
    const [r2, o2] = pr(n2);
    return /* @__PURE__ */ import_react134.default.createElement("button", { onClick: o2 }, t2, " ", /* @__PURE__ */ import_react134.default.createElement(fr, { status: r2 }));
  };
  var hr = () => {
    const t2 = "#ed1d33", n2 = "#2873ab";
    return /* @__PURE__ */ import_react134.default.createElement("svg", { viewBox: "0 0 493.35999 441.33334", id: "iiif-logo", version: "1.1" }, /* @__PURE__ */ import_react134.default.createElement("title", null, "IIIF Manifest Options"), /* @__PURE__ */ import_react134.default.createElement("g", { transform: "matrix(1.3333333,0,0,-1.3333333,0,441.33333)" }, /* @__PURE__ */ import_react134.default.createElement("g", { transform: "scale(0.1)" }, /* @__PURE__ */ import_react134.default.createElement(
      "path",
      {
        style: { fill: n2 },
        d: "M 65.2422,2178.75 775.242,1915 773.992,15 65.2422,276.25 v 1902.5"
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      "path",
      {
        style: { fill: n2 },
        d: "m 804.145,2640.09 c 81.441,-240.91 -26.473,-436.2 -241.04,-436.2 -214.558,0 -454.511,195.29 -535.9527,436.2 -81.4335,240.89 26.4805,436.18 241.0387,436.18 214.567,0 454.512,-195.29 535.954,-436.18"
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      "path",
      {
        style: { fill: t2 },
        d: "M 1678.58,2178.75 968.578,1915 969.828,15 1678.58,276.25 v 1902.5"
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      "path",
      {
        style: { fill: t2 },
        d: "m 935.082,2640.09 c -81.437,-240.91 26.477,-436.2 241.038,-436.2 214.56,0 454.51,195.29 535.96,436.2 81.43,240.89 -26.48,436.18 -241.04,436.18 -214.57,0 -454.52,-195.29 -535.958,-436.18"
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      "path",
      {
        style: { fill: n2 },
        d: "m 1860.24,2178.75 710,-263.75 -1.25,-1900 -708.75,261.25 v 1902.5"
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      "path",
      {
        style: { fill: n2 },
        d: "m 2603.74,2640.09 c 81.45,-240.91 -26.47,-436.2 -241.03,-436.2 -214.58,0 -454.52,195.29 -535.96,436.2 -81.44,240.89 26.48,436.18 241.03,436.18 214.57,0 454.51,-195.29 535.96,-436.18"
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      "path",
      {
        style: { fill: t2 },
        d: "m 3700.24,3310 v -652.5 c 0,0 -230,90 -257.5,-142.5 -2.5,-247.5 0,-336.25 0,-336.25 l 257.5,83.75 V 1690 l -258.61,-92.5 V 262.5 L 2735.24,0 v 2360 c 0,0 -15,850 965,950"
      }
    ))));
  };
  var xr = d2($6be4966fd9bbc698$export$be92b6f5f03c0fe9, {
    all: "unset",
    height: "2rem",
    width: "3.236rem",
    backgroundColor: "#6663",
    borderRadius: "9999px",
    position: "relative",
    WebkitTapHighlightColor: "transparent",
    cursor: "pointer",
    "&:focus": {
      boxShadow: "0 0 0 2px $secondaryAlt"
    },
    '&[data-state="checked"]': {
      backgroundColor: "$accent",
      boxShadow: "inset 2px 2px 5px #0003"
    }
  });
  var vr = d2($6be4966fd9bbc698$export$6521433ed15a34db, {
    display: "block",
    height: "calc(2rem - 12px)",
    width: "calc(2rem - 12px)",
    backgroundColor: "$secondary",
    borderRadius: "100%",
    boxShadow: "2px 2px 5px #0001",
    transition: "$all",
    transform: "translateX(6px)",
    willChange: "transform",
    '&[data-state="checked"]': {
      transform: "translateX(calc(1.236rem + 6px))"
    }
  });
  var br = d2("label", {
    fontSize: "0.8333rem",
    fontWeight: "400",
    lineHeight: "1em",
    userSelect: "none",
    cursor: "pointer",
    paddingRight: "0.618rem"
  });
  var yr = d2("form", {
    display: "flex",
    flexShrink: "0",
    flexGrow: "1",
    alignItems: "center",
    marginLeft: "1.618rem"
  });
  var Er = () => {
    var i2;
    const { configOptions: t2 } = k2(), n2 = F2(), [r2, o2] = (0, import_react134.useState)((i2 = t2 == null ? void 0 : t2.informationPanel) == null ? void 0 : i2.open);
    return (0, import_react134.useEffect)(() => {
      n2({
        type: "updateInformationOpen",
        informationOpen: r2
      });
    }, [r2]), /* @__PURE__ */ import_react134.default.createElement(yr, null, /* @__PURE__ */ import_react134.default.createElement(br, { htmlFor: "information-toggle", css: r2 ? { opacity: "1" } : {} }, "More Information"), /* @__PURE__ */ import_react134.default.createElement(
      xr,
      {
        checked: r2,
        onCheckedChange: () => o2(!r2),
        id: "information-toggle",
        "aria-label": "information panel toggle",
        name: "toggled?"
      },
      /* @__PURE__ */ import_react134.default.createElement(vr, null)
    ));
  };
  var Be = (t2) => {
    const n2 = () => window.matchMedia ? window.matchMedia(t2).matches : false, [r2, o2] = (0, import_react134.useState)(n2);
    return (0, import_react134.useEffect)(() => {
      const i2 = () => o2(n2);
      return window.addEventListener("resize", i2), () => window.removeEventListener("resize", i2);
    }), r2;
  };
  var wr = ({ manifestId: t2, manifestLabel: n2 }) => {
    const r2 = k2(), { collection: o2, configOptions: i2 } = r2, { showTitle: a2, showIIIFBadge: l2, informationPanel: s2 } = i2, c2 = l2 || (s2 == null ? void 0 : s2.renderToggle), m2 = Be(Z2.sm);
    return /* @__PURE__ */ import_react134.default.createElement(dr, { className: "clover-header" }, o2 != null && o2.items ? /* @__PURE__ */ import_react134.default.createElement(ur, null) : /* @__PURE__ */ import_react134.default.createElement(cr, { className: a2 ? "" : "visually-hidden" }, a2 && /* @__PURE__ */ import_react134.default.createElement(z2, { label: n2 })), c2 && /* @__PURE__ */ import_react134.default.createElement(mr, null, l2 && /* @__PURE__ */ import_react134.default.createElement(V2, null, /* @__PURE__ */ import_react134.default.createElement(lr, null, /* @__PURE__ */ import_react134.default.createElement(hr, null)), /* @__PURE__ */ import_react134.default.createElement(sr, null, (o2 == null ? void 0 : o2.items) && /* @__PURE__ */ import_react134.default.createElement(
      "button",
      {
        onClick: (u2) => {
          u2.preventDefault(), window.open(o2.id, "_blank");
        }
      },
      "View Collection"
    ), /* @__PURE__ */ import_react134.default.createElement(
      "button",
      {
        onClick: (u2) => {
          u2.preventDefault(), window.open(t2, "_blank");
        }
      },
      "View Manifest"
    ), " ", (o2 == null ? void 0 : o2.items) && /* @__PURE__ */ import_react134.default.createElement(
      ie,
      {
        textPrompt: "Copy Collection URL",
        textToCopy: o2.id
      }
    ), /* @__PURE__ */ import_react134.default.createElement(
      ie,
      {
        textPrompt: "Copy Manifest URL",
        textToCopy: t2
      }
    ))), s2.renderToggle && !m2 && /* @__PURE__ */ import_react134.default.createElement(Er, null)));
  };
  var Cr = (t2 = false) => {
    const [n2, r2] = (0, import_react134.useState)(t2);
    return (0, import_react134.useLayoutEffect)(() => {
      if (!n2)
        return;
      const o2 = document.documentElement.style.overflow;
      return document.documentElement.style.overflow = "hidden", () => {
        document.documentElement.style.overflow = o2;
      };
    }, [n2]), (0, import_react134.useEffect)(() => {
      n2 !== t2 && r2(t2);
    }, [t2]), [n2, r2];
  };
  var Sr = ({ manifest: t2, theme: n2 }) => {
    const r2 = k2(), o2 = F2(), { activeCanvas: i2, informationOpen: a2, vault: l2, configOptions: s2 } = r2, [c2, m2] = (0, import_react134.useState)(false), [u2, f2] = (0, import_react134.useState)(false), [v2, h2] = (0, import_react134.useState)(
      void 0
    ), [x2, p2] = (0, import_react134.useState)([]), [w2, g2] = Cr(false), y2 = Be(Z2.sm), I2 = ($3) => {
      o2({
        type: "updateInformationOpen",
        informationOpen: $3
      });
    };
    return (0, import_react134.useEffect)(() => {
      s2 != null && s2.informationPanel.open && I2(!y2);
    }, [y2]), (0, import_react134.useEffect)(() => {
      if (!y2) {
        g2(false);
        return;
      }
      g2(a2);
    }, [a2]), (0, import_react134.useEffect)(() => {
      const $3 = B2(l2, i2), J2 = nt(
        l2,
        i2,
        "text/vtt"
      );
      $3 && (f2(
        ["Sound", "Video"].indexOf($3.type) > -1
      ), h2({ ...$3 })), p2(J2), m2(J2.length !== 0);
    }, [i2]), /* @__PURE__ */ import_react134.default.createElement(import_react_error_boundary_cjs.ErrorBoundary, { FallbackComponent: st }, /* @__PURE__ */ import_react134.default.createElement(
      dt,
      {
        className: `${n2} clover-iiif`,
        css: { background: s2 == null ? void 0 : s2.background },
        "data-body-locked": w2,
        "data-information-panel": c2,
        "data-information-panel-open": a2
      },
      /* @__PURE__ */ import_react134.default.createElement(
        $409067139f391064$export$be92b6f5f03c0fe9,
        {
          open: a2,
          onOpenChange: I2
        },
        /* @__PURE__ */ import_react134.default.createElement(
          wr,
          {
            manifestLabel: t2.label,
            manifestId: t2.id
          }
        ),
        /* @__PURE__ */ import_react134.default.createElement(
          tr,
          {
            activeCanvas: i2,
            painting: v2,
            resources: x2,
            items: t2.items,
            isAudioVideo: u2
          }
        )
      )
    ));
  };
  var le = {
    ignoreCache: false,
    headers: {
      Accept: "application/json, text/javascript, text/plain"
    },
    timeout: 5e3,
    withCredentials: false
  };
  function kr(t2) {
    return {
      ok: t2.status >= 200 && t2.status < 300,
      status: t2.status,
      statusText: t2.statusText,
      headers: t2.getAllResponseHeaders(),
      data: t2.responseText,
      json: () => JSON.parse(t2.responseText)
    };
  }
  function se(t2, n2 = null) {
    return {
      ok: false,
      status: t2.status,
      statusText: t2.statusText,
      headers: t2.getAllResponseHeaders(),
      data: n2 || t2.statusText,
      json: () => JSON.parse(n2 || t2.statusText)
    };
  }
  function Ir(t2, n2 = le) {
    const r2 = n2.headers || le.headers;
    return new Promise((o2, i2) => {
      const a2 = new XMLHttpRequest();
      a2.open("get", t2), a2.withCredentials = n2.withCredentials, r2 && Object.keys(r2).forEach(
        (l2) => a2.setRequestHeader(l2, r2[l2])
      ), a2.onload = () => {
        o2(kr(a2));
      }, a2.onerror = () => {
        i2(se(a2, "Failed to make request."));
      }, a2.ontimeout = () => {
        i2(se(a2, "Request took longer than expected."));
      }, a2.send();
    });
  }
  var Or = ({
    canvasIdCallback: t2 = () => {
    },
    customTheme: n2,
    iiifContent: r2,
    id: o2,
    manifestId: i2,
    options: a2
  }) => {
    var s2;
    let l2 = r2;
    return o2 && (l2 = o2), i2 && (l2 = i2), /* @__PURE__ */ import_react134.default.createElement(
      tt,
      {
        initialState: {
          ...W2,
          informationOpen: !!((s2 = a2 == null ? void 0 : a2.informationPanel) != null && s2.open),
          vault: new Vault({
            customFetcher: (c2) => Ir(c2, {
              withCredentials: a2 == null ? void 0 : a2.withCredentials,
              headers: a2 == null ? void 0 : a2.requestHeaders
            }).then((m2) => JSON.parse(m2.data))
          })
        }
      },
      /* @__PURE__ */ import_react134.default.createElement(
        $r,
        {
          iiifContent: l2,
          canvasIdCallback: t2,
          customTheme: n2,
          options: a2
        }
      )
    );
  };
  var $r = ({
    canvasIdCallback: t2,
    customTheme: n2,
    iiifContent: r2,
    options: o2
  }) => {
    const i2 = F2(), a2 = k2(), { activeCanvas: l2, activeManifest: s2, isLoaded: c2, vault: m2 } = a2, [u2, f2] = (0, import_react134.useState)(), [v2, h2] = (0, import_react134.useState)();
    let x2 = {};
    return n2 && (x2 = Q("custom", n2)), (0, import_react134.useEffect)(() => {
      t2 && t2(l2);
    }, [l2]), (0, import_react134.useEffect)(() => {
      s2 && m2.loadManifest(s2).then((p2) => {
        h2(p2), i2({
          type: "updateActiveCanvas",
          canvasId: p2.items[0] && p2.items[0].id
        });
      }).catch((p2) => {
        console.error(`Manifest failed to load: ${p2}`);
      }).finally(() => {
        i2({
          type: "updateIsLoaded",
          isLoaded: true
        });
      });
    }, [s2]), (0, import_react134.useEffect)(() => {
      i2({
        type: "updateConfigOptions",
        configOptions: o2
      }), m2.load(r2).then((p2) => {
        f2(p2);
      }).catch((p2) => {
        console.error(
          `The IIIF resource ${r2} failed to load: ${p2}`
        );
      });
    }, [r2, o2]), (0, import_react134.useEffect)(() => {
      let p2 = [];
      (u2 == null ? void 0 : u2.type) === "Collection" ? (i2({
        type: "updateCollection",
        collection: u2
      }), p2 = u2.items.filter((w2) => w2.type === "Manifest").map((w2) => w2.id), p2.length > 0 && i2({
        type: "updateActiveManifest",
        manifestId: p2[0]
      })) : (u2 == null ? void 0 : u2.type) === "Manifest" && i2({
        type: "updateActiveManifest",
        manifestId: u2.id
      });
    }, [u2]), c2 ? !v2 || !v2.items ? (console.log(`The IIIF manifest ${r2} failed to load.`), /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null)) : v2.items.length === 0 ? (console.log(`The IIIF manifest ${r2} does not contain canvases.`), /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null)) : /* @__PURE__ */ import_react134.default.createElement(Sr, { manifest: v2, theme: x2, key: v2.id }) : /* @__PURE__ */ import_react134.default.createElement(import_react134.default.Fragment, null, "Loading");
  };

  // src/components/ChangeDiscovery/OrderedItem.tsx
  var OrderedItem = ({
    activity,
    endTime,
    object
  }) => {
    const { canonical, id, type } = object;
    return /* @__PURE__ */ import_react136.default.createElement(Panel_default, {
      id
    }, /* @__PURE__ */ import_react136.default.createElement(PanelHeader, null, /* @__PURE__ */ import_react136.default.createElement(Badge_default, null, activity), /* @__PURE__ */ import_react136.default.createElement(SVG_default, null, /* @__PURE__ */ import_react136.default.createElement(ArrowForward, null)), /* @__PURE__ */ import_react136.default.createElement(Badge_default, null, type), endTime && /* @__PURE__ */ import_react136.default.createElement(PanelHeaderTime, null, endTime)), /* @__PURE__ */ import_react136.default.createElement(PanelBody, null, /* @__PURE__ */ import_react136.default.createElement(PanelContent, null, /* @__PURE__ */ import_react136.default.createElement("a", {
      href: id,
      target: "_blank"
    }, id)), /* @__PURE__ */ import_react136.default.createElement(PanelActions, null, canonical && /* @__PURE__ */ import_react136.default.createElement(Button_default, {
      as: "a",
      href: canonical
    }, "Visit"), /* @__PURE__ */ import_react136.default.createElement(Modal_default, {
      buttonText: "Preview",
      title: id
    }, /* @__PURE__ */ import_react136.default.createElement(Or, {
      iiifContent: id,
      options: {
        canvasHeight: "500px"
      }
    })))));
  };
  var OrderedItem_default = OrderedItem;

  // src/services/request.ts
  var import_axios = __toESM(require_axios2());
  var import_axios_request_handler = __toESM(require_axios_request());
  function getOrderedCollection(id) {
    return __async(this, null, function* () {
      try {
        const response = yield import_axios.default.get(id);
        if (response == null ? void 0 : response.data)
          return response == null ? void 0 : response.data;
      } catch (err) {
        console.error("Error requesting OrderedCollection", id);
        return null;
      }
    });
  }
  function getOrderedCollectionPage(id) {
    return __async(this, null, function* () {
      try {
        const page = new import_axios_request_handler.default(id);
        const response = yield page.poll(6e4).get();
        return response == null ? void 0 : response.data;
      } catch (err) {
        console.error("Error requesting OrderedCollectionPage", id);
        return null;
      }
    });
  }

  // src/components/ChangeDiscovery/OrderedCollectionPage.tsx
  var OrderedCollectionPage = ({
    id
  }) => {
    const [data, setData] = (0, import_react137.useState)();
    const dispatch = useOrderedCollectionDispatch();
    (0, import_react137.useEffect)(() => {
      if (id && !data)
        getOrderedCollectionPage(id).then((data2) => {
          var _a;
          data2.orderedItems.reverse();
          setData(data2);
          dispatch({
            type: "updatePrev",
            id: (_a = data2 == null ? void 0 : data2.prev) == null ? void 0 : _a.id
          });
        });
    }, [id]);
    if (!data)
      return /* @__PURE__ */ import_react137.default.createElement(import_react137.default.Fragment, null);
    return /* @__PURE__ */ import_react137.default.createElement("div", null, data.orderedItems.map((item) => /* @__PURE__ */ import_react137.default.createElement(OrderedItem_default, {
      activity: item.type,
      endTime: item.endTime,
      object: item.object,
      key: item.object.id
    })));
  };
  var OrderedCollectionPage_default = OrderedCollectionPage;

  // src/components/UI/Workspace/Workspace.tsx
  var import_react138 = __toESM(require_react());

  // src/components/UI/Workspace/Workspace.styled.tsx
  var WorkspaceHeader = styled("span", {
    display: "flex",
    margin: "0 0 2rem 0",
    fontSize: "1rem",
    opacity: "0.7"
  });
  var WorkspaceBody = styled("section", {
    display: "flex"
  });
  var WorkspaceScroll = styled("div", {
    width: "61.8%",
    flexShrink: "0"
  });
  var WorkspaceAside = styled("aside", {
    flexGrow: "1",
    margin: "0 0 0 2rem"
  });
  var WorkspaceActions = styled("div", {
    display: "flex",
    marginBottom: "1rem",
    [`> ${ButtonStyled}`]: {
      margin: "0 1rem 0 0",
      flexGrow: "1",
      "&:last-child": {
        margin: "0"
      }
    }
  });
  var WorkspaceStyled = styled("div", {});

  // node_modules/react-dnd-html5-backend/dist/utils/js_utils.js
  function memoize(fn2) {
    let result = null;
    const memoized = () => {
      if (result == null) {
        result = fn2();
      }
      return result;
    };
    return memoized;
  }
  function without2(items, item) {
    return items.filter(
      (i2) => i2 !== item
    );
  }
  function union(itemsA, itemsB) {
    const set = /* @__PURE__ */ new Set();
    const insertItem = (item) => set.add(item);
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    const result = [];
    set.forEach(
      (key) => result.push(key)
    );
    return result;
  }

  // node_modules/react-dnd-html5-backend/dist/EnterLeaveCounter.js
  var EnterLeaveCounter = class {
    enter(enteringNode) {
      const previousLength = this.entered.length;
      const isNodeEntered = (node) => this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));
      this.entered = union(this.entered.filter(isNodeEntered), [
        enteringNode
      ]);
      return previousLength === 0 && this.entered.length > 0;
    }
    leave(leavingNode) {
      const previousLength = this.entered.length;
      this.entered = without2(this.entered.filter(this.isNodeInDocument), leavingNode);
      return previousLength > 0 && this.entered.length === 0;
    }
    reset() {
      this.entered = [];
    }
    constructor(isNodeInDocument) {
      this.entered = [];
      this.isNodeInDocument = isNodeInDocument;
    }
  };

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/NativeDragSource.js
  var NativeDragSource = class {
    initializeExposedProperties() {
      Object.keys(this.config.exposeProperties).forEach((property) => {
        Object.defineProperty(this.item, property, {
          configurable: true,
          enumerable: true,
          get() {
            console.warn(`Browser doesn't allow reading "${property}" until the drop event.`);
            return null;
          }
        });
      });
    }
    loadDataTransfer(dataTransfer) {
      if (dataTransfer) {
        const newProperties = {};
        Object.keys(this.config.exposeProperties).forEach((property) => {
          const propertyFn = this.config.exposeProperties[property];
          if (propertyFn != null) {
            newProperties[property] = {
              value: propertyFn(dataTransfer, this.config.matchesTypes),
              configurable: true,
              enumerable: true
            };
          }
        });
        Object.defineProperties(this.item, newProperties);
      }
    }
    canDrag() {
      return true;
    }
    beginDrag() {
      return this.item;
    }
    isDragging(monitor, handle) {
      return handle === monitor.getSourceId();
    }
    endDrag() {
    }
    constructor(config) {
      this.config = config;
      this.item = {};
      this.initializeExposedProperties();
    }
  };

  // node_modules/react-dnd-html5-backend/dist/NativeTypes.js
  var NativeTypes_exports = {};
  __export(NativeTypes_exports, {
    FILE: () => FILE,
    HTML: () => HTML,
    TEXT: () => TEXT,
    URL: () => URL2
  });
  var FILE = "__NATIVE_FILE__";
  var URL2 = "__NATIVE_URL__";
  var TEXT = "__NATIVE_TEXT__";
  var HTML = "__NATIVE_HTML__";

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/getDataFromDataTransfer.js
  function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
    const result = typesToTry.reduce(
      (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),
      ""
    );
    return result != null ? result : defaultValue;
  }

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/nativeTypesConfig.js
  var nativeTypesConfig = {
    [FILE]: {
      exposeProperties: {
        files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),
        items: (dataTransfer) => dataTransfer.items,
        dataTransfer: (dataTransfer) => dataTransfer
      },
      matchesTypes: [
        "Files"
      ]
    },
    [HTML]: {
      exposeProperties: {
        html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
        dataTransfer: (dataTransfer) => dataTransfer
      },
      matchesTypes: [
        "Html",
        "text/html"
      ]
    },
    [URL2]: {
      exposeProperties: {
        urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, "").split("\n"),
        dataTransfer: (dataTransfer) => dataTransfer
      },
      matchesTypes: [
        "Url",
        "text/uri-list"
      ]
    },
    [TEXT]: {
      exposeProperties: {
        text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
        dataTransfer: (dataTransfer) => dataTransfer
      },
      matchesTypes: [
        "Text",
        "text/plain"
      ]
    }
  };

  // node_modules/react-dnd-html5-backend/dist/NativeDragSources/index.js
  function createNativeDragSource(type, dataTransfer) {
    const config = nativeTypesConfig[type];
    if (!config) {
      throw new Error(`native type ${type} has no configuration`);
    }
    const result = new NativeDragSource(config);
    result.loadDataTransfer(dataTransfer);
    return result;
  }
  function matchNativeItemType(dataTransfer) {
    if (!dataTransfer) {
      return null;
    }
    const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
    return Object.keys(nativeTypesConfig).filter((nativeItemType) => {
      const typeConfig = nativeTypesConfig[nativeItemType];
      if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
        return false;
      }
      return typeConfig.matchesTypes.some(
        (t2) => dataTransferTypes.indexOf(t2) > -1
      );
    })[0] || null;
  }

  // node_modules/react-dnd-html5-backend/dist/BrowserDetector.js
  var isFirefox = memoize(
    () => /firefox/i.test(navigator.userAgent)
  );
  var isSafari = memoize(
    () => Boolean(window.safari)
  );

  // node_modules/react-dnd-html5-backend/dist/MonotonicInterpolant.js
  var MonotonicInterpolant = class {
    interpolate(x2) {
      const { xs, ys, c1s, c2s, c3s } = this;
      let i2 = xs.length - 1;
      if (x2 === xs[i2]) {
        return ys[i2];
      }
      let low = 0;
      let high = c3s.length - 1;
      let mid;
      while (low <= high) {
        mid = Math.floor(0.5 * (low + high));
        const xHere = xs[mid];
        if (xHere < x2) {
          low = mid + 1;
        } else if (xHere > x2) {
          high = mid - 1;
        } else {
          return ys[mid];
        }
      }
      i2 = Math.max(0, high);
      const diff = x2 - xs[i2];
      const diffSq = diff * diff;
      return ys[i2] + c1s[i2] * diff + c2s[i2] * diffSq + c3s[i2] * diff * diffSq;
    }
    constructor(xs, ys) {
      const { length } = xs;
      const indexes = [];
      for (let i2 = 0; i2 < length; i2++) {
        indexes.push(i2);
      }
      indexes.sort(
        (a2, b3) => xs[a2] < xs[b3] ? -1 : 1
      );
      const dys = [];
      const dxs = [];
      const ms = [];
      let dx;
      let dy;
      for (let i1 = 0; i1 < length - 1; i1++) {
        dx = xs[i1 + 1] - xs[i1];
        dy = ys[i1 + 1] - ys[i1];
        dxs.push(dx);
        dys.push(dy);
        ms.push(dy / dx);
      }
      const c1s = [
        ms[0]
      ];
      for (let i2 = 0; i2 < dxs.length - 1; i2++) {
        const m22 = ms[i2];
        const mNext = ms[i2 + 1];
        if (m22 * mNext <= 0) {
          c1s.push(0);
        } else {
          dx = dxs[i2];
          const dxNext = dxs[i2 + 1];
          const common = dx + dxNext;
          c1s.push(3 * common / ((common + dxNext) / m22 + (common + dx) / mNext));
        }
      }
      c1s.push(ms[ms.length - 1]);
      const c2s = [];
      const c3s = [];
      let m2;
      for (let i3 = 0; i3 < c1s.length - 1; i3++) {
        m2 = ms[i3];
        const c1 = c1s[i3];
        const invDx = 1 / dxs[i3];
        const common = c1 + c1s[i3 + 1] - m2 - m2;
        c2s.push((m2 - c1 - common) * invDx);
        c3s.push(common * invDx * invDx);
      }
      this.xs = xs;
      this.ys = ys;
      this.c1s = c1s;
      this.c2s = c2s;
      this.c3s = c3s;
    }
  };

  // node_modules/react-dnd-html5-backend/dist/OffsetUtils.js
  var ELEMENT_NODE = 1;
  function getNodeClientOffset(node) {
    const el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
    if (!el) {
      return null;
    }
    const { top, left } = el.getBoundingClientRect();
    return {
      x: left,
      y: top
    };
  }
  function getEventClientOffset(e3) {
    return {
      x: e3.clientX,
      y: e3.clientY
    };
  }
  function isImageNode(node) {
    var ref;
    return node.nodeName === "IMG" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
  }
  function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
    let dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
    let dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
    if (isSafari() && isImage) {
      dragPreviewHeight /= window.devicePixelRatio;
      dragPreviewWidth /= window.devicePixelRatio;
    }
    return {
      dragPreviewWidth,
      dragPreviewHeight
    };
  }
  function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
    const isImage = isImageNode(dragPreview);
    const dragPreviewNode = isImage ? sourceNode : dragPreview;
    const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
    const offsetFromDragPreview = {
      x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
      y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
    };
    const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
    const { anchorX, anchorY } = anchorPoint;
    const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight);
    const calculateYOffset = () => {
      const interpolantY = new MonotonicInterpolant([
        0,
        0.5,
        1
      ], [
        offsetFromDragPreview.y,
        offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
        offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
      ]);
      let y2 = interpolantY.interpolate(anchorY);
      if (isSafari() && isImage) {
        y2 += (window.devicePixelRatio - 1) * dragPreviewHeight;
      }
      return y2;
    };
    const calculateXOffset = () => {
      const interpolantX = new MonotonicInterpolant([
        0,
        0.5,
        1
      ], [
        offsetFromDragPreview.x,
        offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
        offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
      ]);
      return interpolantX.interpolate(anchorX);
    };
    const { offsetX, offsetY } = offsetPoint;
    const isManualOffsetX = offsetX === 0 || offsetX;
    const isManualOffsetY = offsetY === 0 || offsetY;
    return {
      x: isManualOffsetX ? offsetX : calculateXOffset(),
      y: isManualOffsetY ? offsetY : calculateYOffset()
    };
  }

  // node_modules/react-dnd-html5-backend/dist/OptionsReader.js
  var OptionsReader = class {
    get window() {
      if (this.globalContext) {
        return this.globalContext;
      } else if (typeof window !== "undefined") {
        return window;
      }
      return void 0;
    }
    get document() {
      var ref;
      if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
        return this.globalContext.document;
      } else if (this.window) {
        return this.window.document;
      } else {
        return void 0;
      }
    }
    get rootElement() {
      var ref;
      return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
    }
    constructor(globalContext, options) {
      this.ownerDocument = null;
      this.globalContext = globalContext;
      this.optionsArgs = options;
    }
  };

  // node_modules/react-dnd-html5-backend/dist/HTML5BackendImpl.js
  function _defineProperty7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectSpread6(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      var ownKeys3 = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys3 = ownKeys3.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys3.forEach(function(key) {
        _defineProperty7(target, key, source[key]);
      });
    }
    return target;
  }
  var HTML5BackendImpl = class {
    profile() {
      var ref, ref1;
      return {
        sourcePreviewNodes: this.sourcePreviewNodes.size,
        sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
        sourceNodeOptions: this.sourceNodeOptions.size,
        sourceNodes: this.sourceNodes.size,
        dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
        dropTargetIds: this.dropTargetIds.length,
        dragEnterTargetIds: this.dragEnterTargetIds.length,
        dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
      };
    }
    get window() {
      return this.options.window;
    }
    get document() {
      return this.options.document;
    }
    get rootElement() {
      return this.options.rootElement;
    }
    setup() {
      const root2 = this.rootElement;
      if (root2 === void 0) {
        return;
      }
      if (root2.__isReactDndBackendSetUp) {
        throw new Error("Cannot have two HTML5 backends at the same time.");
      }
      root2.__isReactDndBackendSetUp = true;
      this.addEventListeners(root2);
    }
    teardown() {
      const root2 = this.rootElement;
      if (root2 === void 0) {
        return;
      }
      root2.__isReactDndBackendSetUp = false;
      this.removeEventListeners(this.rootElement);
      this.clearCurrentDragSourceNode();
      if (this.asyncEndDragFrameId) {
        var ref;
        (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
      }
    }
    connectDragPreview(sourceId, node, options) {
      this.sourcePreviewNodeOptions.set(sourceId, options);
      this.sourcePreviewNodes.set(sourceId, node);
      return () => {
        this.sourcePreviewNodes.delete(sourceId);
        this.sourcePreviewNodeOptions.delete(sourceId);
      };
    }
    connectDragSource(sourceId, node, options) {
      this.sourceNodes.set(sourceId, node);
      this.sourceNodeOptions.set(sourceId, options);
      const handleDragStart = (e3) => this.handleDragStart(e3, sourceId);
      const handleSelectStart = (e3) => this.handleSelectStart(e3);
      node.setAttribute("draggable", "true");
      node.addEventListener("dragstart", handleDragStart);
      node.addEventListener("selectstart", handleSelectStart);
      return () => {
        this.sourceNodes.delete(sourceId);
        this.sourceNodeOptions.delete(sourceId);
        node.removeEventListener("dragstart", handleDragStart);
        node.removeEventListener("selectstart", handleSelectStart);
        node.setAttribute("draggable", "false");
      };
    }
    connectDropTarget(targetId, node) {
      const handleDragEnter = (e3) => this.handleDragEnter(e3, targetId);
      const handleDragOver = (e3) => this.handleDragOver(e3, targetId);
      const handleDrop = (e3) => this.handleDrop(e3, targetId);
      node.addEventListener("dragenter", handleDragEnter);
      node.addEventListener("dragover", handleDragOver);
      node.addEventListener("drop", handleDrop);
      return () => {
        node.removeEventListener("dragenter", handleDragEnter);
        node.removeEventListener("dragover", handleDragOver);
        node.removeEventListener("drop", handleDrop);
      };
    }
    addEventListeners(target) {
      if (!target.addEventListener) {
        return;
      }
      target.addEventListener("dragstart", this.handleTopDragStart);
      target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
      target.addEventListener("dragend", this.handleTopDragEndCapture, true);
      target.addEventListener("dragenter", this.handleTopDragEnter);
      target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
      target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
      target.addEventListener("dragover", this.handleTopDragOver);
      target.addEventListener("dragover", this.handleTopDragOverCapture, true);
      target.addEventListener("drop", this.handleTopDrop);
      target.addEventListener("drop", this.handleTopDropCapture, true);
    }
    removeEventListeners(target) {
      if (!target.removeEventListener) {
        return;
      }
      target.removeEventListener("dragstart", this.handleTopDragStart);
      target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
      target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
      target.removeEventListener("dragenter", this.handleTopDragEnter);
      target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
      target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
      target.removeEventListener("dragover", this.handleTopDragOver);
      target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
      target.removeEventListener("drop", this.handleTopDrop);
      target.removeEventListener("drop", this.handleTopDropCapture, true);
    }
    getCurrentSourceNodeOptions() {
      const sourceId = this.monitor.getSourceId();
      const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
      return _objectSpread6({
        dropEffect: this.altKeyPressed ? "copy" : "move"
      }, sourceNodeOptions || {});
    }
    getCurrentDropEffect() {
      if (this.isDraggingNativeItem()) {
        return "copy";
      }
      return this.getCurrentSourceNodeOptions().dropEffect;
    }
    getCurrentSourcePreviewNodeOptions() {
      const sourceId = this.monitor.getSourceId();
      const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
      return _objectSpread6({
        anchorX: 0.5,
        anchorY: 0.5,
        captureDraggingState: false
      }, sourcePreviewNodeOptions || {});
    }
    isDraggingNativeItem() {
      const itemType = this.monitor.getItemType();
      return Object.keys(NativeTypes_exports).some(
        (key) => NativeTypes_exports[key] === itemType
      );
    }
    beginDragNativeItem(type, dataTransfer) {
      this.clearCurrentDragSourceNode();
      this.currentNativeSource = createNativeDragSource(type, dataTransfer);
      this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
      this.actions.beginDrag([
        this.currentNativeHandle
      ]);
    }
    setCurrentDragSourceNode(node) {
      this.clearCurrentDragSourceNode();
      this.currentDragSourceNode = node;
      const MOUSE_MOVE_TIMEOUT = 1e3;
      this.mouseMoveTimeoutTimer = setTimeout(() => {
        var ref;
        return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
      }, MOUSE_MOVE_TIMEOUT);
    }
    clearCurrentDragSourceNode() {
      if (this.currentDragSourceNode) {
        this.currentDragSourceNode = null;
        if (this.rootElement) {
          var ref;
          (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
          this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
        }
        this.mouseMoveTimeoutTimer = null;
        return true;
      }
      return false;
    }
    handleDragStart(e3, sourceId) {
      if (e3.defaultPrevented) {
        return;
      }
      if (!this.dragStartSourceIds) {
        this.dragStartSourceIds = [];
      }
      this.dragStartSourceIds.unshift(sourceId);
    }
    handleDragEnter(_e, targetId) {
      this.dragEnterTargetIds.unshift(targetId);
    }
    handleDragOver(_e, targetId) {
      if (this.dragOverTargetIds === null) {
        this.dragOverTargetIds = [];
      }
      this.dragOverTargetIds.unshift(targetId);
    }
    handleDrop(_e, targetId) {
      this.dropTargetIds.unshift(targetId);
    }
    constructor(manager, globalContext, options) {
      this.sourcePreviewNodes = /* @__PURE__ */ new Map();
      this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
      this.sourceNodes = /* @__PURE__ */ new Map();
      this.sourceNodeOptions = /* @__PURE__ */ new Map();
      this.dragStartSourceIds = null;
      this.dropTargetIds = [];
      this.dragEnterTargetIds = [];
      this.currentNativeSource = null;
      this.currentNativeHandle = null;
      this.currentDragSourceNode = null;
      this.altKeyPressed = false;
      this.mouseMoveTimeoutTimer = null;
      this.asyncEndDragFrameId = null;
      this.dragOverTargetIds = null;
      this.lastClientOffset = null;
      this.hoverRafId = null;
      this.getSourceClientOffset = (sourceId) => {
        const source = this.sourceNodes.get(sourceId);
        return source && getNodeClientOffset(source) || null;
      };
      this.endDragNativeItem = () => {
        if (!this.isDraggingNativeItem()) {
          return;
        }
        this.actions.endDrag();
        if (this.currentNativeHandle) {
          this.registry.removeSource(this.currentNativeHandle);
        }
        this.currentNativeHandle = null;
        this.currentNativeSource = null;
      };
      this.isNodeInDocument = (node) => {
        return Boolean(node && this.document && this.document.body && this.document.body.contains(node));
      };
      this.endDragIfSourceWasRemovedFromDOM = () => {
        const node = this.currentDragSourceNode;
        if (node == null || this.isNodeInDocument(node)) {
          return;
        }
        if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
          this.actions.endDrag();
        }
        this.cancelHover();
      };
      this.scheduleHover = (dragOverTargetIds) => {
        if (this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
          this.hoverRafId = requestAnimationFrame(() => {
            if (this.monitor.isDragging()) {
              this.actions.hover(dragOverTargetIds || [], {
                clientOffset: this.lastClientOffset
              });
            }
            this.hoverRafId = null;
          });
        }
      };
      this.cancelHover = () => {
        if (this.hoverRafId !== null && typeof cancelAnimationFrame !== "undefined") {
          cancelAnimationFrame(this.hoverRafId);
          this.hoverRafId = null;
        }
      };
      this.handleTopDragStartCapture = () => {
        this.clearCurrentDragSourceNode();
        this.dragStartSourceIds = [];
      };
      this.handleTopDragStart = (e3) => {
        if (e3.defaultPrevented) {
          return;
        }
        const { dragStartSourceIds } = this;
        this.dragStartSourceIds = null;
        const clientOffset = getEventClientOffset(e3);
        if (this.monitor.isDragging()) {
          this.actions.endDrag();
          this.cancelHover();
        }
        this.actions.beginDrag(dragStartSourceIds || [], {
          publishSource: false,
          getSourceClientOffset: this.getSourceClientOffset,
          clientOffset
        });
        const { dataTransfer } = e3;
        const nativeType = matchNativeItemType(dataTransfer);
        if (this.monitor.isDragging()) {
          if (dataTransfer && typeof dataTransfer.setDragImage === "function") {
            const sourceId = this.monitor.getSourceId();
            const sourceNode = this.sourceNodes.get(sourceId);
            const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
            if (dragPreview) {
              const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();
              const anchorPoint = {
                anchorX,
                anchorY
              };
              const offsetPoint = {
                offsetX,
                offsetY
              };
              const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
              dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
            }
          }
          try {
            dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData("application/json", {});
          } catch (err) {
          }
          this.setCurrentDragSourceNode(e3.target);
          const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();
          if (!captureDraggingState) {
            setTimeout(
              () => this.actions.publishDragSource(),
              0
            );
          } else {
            this.actions.publishDragSource();
          }
        } else if (nativeType) {
          this.beginDragNativeItem(nativeType);
        } else if (dataTransfer && !dataTransfer.types && (e3.target && !e3.target.hasAttribute || !e3.target.hasAttribute("draggable"))) {
          return;
        } else {
          e3.preventDefault();
        }
      };
      this.handleTopDragEndCapture = () => {
        if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
          this.actions.endDrag();
        }
        this.cancelHover();
      };
      this.handleTopDragEnterCapture = (e3) => {
        this.dragEnterTargetIds = [];
        if (this.isDraggingNativeItem()) {
          var ref;
          (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e3.dataTransfer);
        }
        const isFirstEnter = this.enterLeaveCounter.enter(e3.target);
        if (!isFirstEnter || this.monitor.isDragging()) {
          return;
        }
        const { dataTransfer } = e3;
        const nativeType = matchNativeItemType(dataTransfer);
        if (nativeType) {
          this.beginDragNativeItem(nativeType, dataTransfer);
        }
      };
      this.handleTopDragEnter = (e3) => {
        const { dragEnterTargetIds } = this;
        this.dragEnterTargetIds = [];
        if (!this.monitor.isDragging()) {
          return;
        }
        this.altKeyPressed = e3.altKey;
        if (dragEnterTargetIds.length > 0) {
          this.actions.hover(dragEnterTargetIds, {
            clientOffset: getEventClientOffset(e3)
          });
        }
        const canDrop = dragEnterTargetIds.some(
          (targetId) => this.monitor.canDropOnTarget(targetId)
        );
        if (canDrop) {
          e3.preventDefault();
          if (e3.dataTransfer) {
            e3.dataTransfer.dropEffect = this.getCurrentDropEffect();
          }
        }
      };
      this.handleTopDragOverCapture = (e3) => {
        this.dragOverTargetIds = [];
        if (this.isDraggingNativeItem()) {
          var ref;
          (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e3.dataTransfer);
        }
      };
      this.handleTopDragOver = (e3) => {
        const { dragOverTargetIds } = this;
        this.dragOverTargetIds = [];
        if (!this.monitor.isDragging()) {
          e3.preventDefault();
          if (e3.dataTransfer) {
            e3.dataTransfer.dropEffect = "none";
          }
          return;
        }
        this.altKeyPressed = e3.altKey;
        this.lastClientOffset = getEventClientOffset(e3);
        this.scheduleHover(dragOverTargetIds);
        const canDrop = (dragOverTargetIds || []).some(
          (targetId) => this.monitor.canDropOnTarget(targetId)
        );
        if (canDrop) {
          e3.preventDefault();
          if (e3.dataTransfer) {
            e3.dataTransfer.dropEffect = this.getCurrentDropEffect();
          }
        } else if (this.isDraggingNativeItem()) {
          e3.preventDefault();
        } else {
          e3.preventDefault();
          if (e3.dataTransfer) {
            e3.dataTransfer.dropEffect = "none";
          }
        }
      };
      this.handleTopDragLeaveCapture = (e3) => {
        if (this.isDraggingNativeItem()) {
          e3.preventDefault();
        }
        const isLastLeave = this.enterLeaveCounter.leave(e3.target);
        if (!isLastLeave) {
          return;
        }
        if (this.isDraggingNativeItem()) {
          setTimeout(
            () => this.endDragNativeItem(),
            0
          );
        }
        this.cancelHover();
      };
      this.handleTopDropCapture = (e3) => {
        this.dropTargetIds = [];
        if (this.isDraggingNativeItem()) {
          var ref;
          e3.preventDefault();
          (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e3.dataTransfer);
        } else if (matchNativeItemType(e3.dataTransfer)) {
          e3.preventDefault();
        }
        this.enterLeaveCounter.reset();
      };
      this.handleTopDrop = (e3) => {
        const { dropTargetIds } = this;
        this.dropTargetIds = [];
        this.actions.hover(dropTargetIds, {
          clientOffset: getEventClientOffset(e3)
        });
        this.actions.drop({
          dropEffect: this.getCurrentDropEffect()
        });
        if (this.isDraggingNativeItem()) {
          this.endDragNativeItem();
        } else if (this.monitor.isDragging()) {
          this.actions.endDrag();
        }
        this.cancelHover();
      };
      this.handleSelectStart = (e3) => {
        const target = e3.target;
        if (typeof target.dragDrop !== "function") {
          return;
        }
        if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
          return;
        }
        e3.preventDefault();
        target.dragDrop();
      };
      this.options = new OptionsReader(globalContext, options);
      this.actions = manager.getActions();
      this.monitor = manager.getMonitor();
      this.registry = manager.getRegistry();
      this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
    }
  };

  // node_modules/react-dnd-html5-backend/dist/index.js
  var HTML5Backend = function createBackend(manager, context, options) {
    return new HTML5BackendImpl(manager, context, options);
  };

  // src/components/UI/Workspace/Workspace.tsx
  var Workspace = ({ children }) => {
    return /* @__PURE__ */ import_react138.default.createElement(WorkspaceStyled, null, /* @__PURE__ */ import_react138.default.createElement(DndProvider, {
      backend: HTML5Backend
    }, children));
  };
  var Workspace_default = Workspace;

  // src/components/UI/Workspace/Dropzone/Dropzone.tsx
  var import_react139 = __toESM(require_react());

  // src/components/UI/Workspace/Dropzone/Dropzone.styled.ts
  var DropzoneStyled = styled("div", {
    height: "100%",
    padding: "1rem",
    border: "2px dashed #0002",
    backgroundColor: "#0001",
    borderRadius: "3px",
    transition: "$all",
    ul: {
      padding: "0",
      margin: "0 1rem",
      li: {
        fontSize: "0.8333rem",
        margin: "0 0 .25rem 0"
      }
    }
  });

  // src/components/UI/Workspace/Dropzone/Dropzone.tsx
  var Dropzone = () => {
    const { cart } = useOrderedCollectionState();
    const [{ canDrop, isOver }, drop] = useDrop(() => ({
      accept: "resource",
      drop: () => ({ name: "items" }),
      collect: (monitor) => ({
        isOver: monitor.isOver(),
        canDrop: monitor.canDrop()
      })
    }));
    const isActive = canDrop && isOver;
    const activeDropStyling = {
      backgroundColor: "#5746af22",
      border: "2px solid #5746afaa",
      boxShadow: " inset 5px 5px 8px #0001"
    };
    return /* @__PURE__ */ import_react139.default.createElement(DropzoneStyled, {
      ref: drop,
      style: isActive ? activeDropStyling : {}
    }, cart && /* @__PURE__ */ import_react139.default.createElement("ul", null, cart.map((id) => {
      return /* @__PURE__ */ import_react139.default.createElement("li", {
        key: id
      }, id);
    })));
  };
  var Dropzone_default = Dropzone;

  // src/components/ChangeDiscovery/OrderedCollection.tsx
  var OrderedCollection = ({
    handleCart = () => {
    },
    id
  }) => {
    const [data, setData] = (0, import_react140.useState)();
    const { cart, prev, pages } = useOrderedCollectionState();
    const dispatch = useOrderedCollectionDispatch();
    const handleReset = () => dispatch({
      type: "resetCart"
    });
    (0, import_react140.useEffect)(() => {
      if (id)
        getOrderedCollection(id).then((data2) => {
          var _a;
          setData(data2);
          dispatch({
            type: "updatePages",
            id: (_a = data2 == null ? void 0 : data2.last) == null ? void 0 : _a.id
          });
        });
    }, [id]);
    if (!data)
      return /* @__PURE__ */ import_react140.default.createElement(import_react140.default.Fragment, null);
    return /* @__PURE__ */ import_react140.default.createElement(Workspace_default, null, /* @__PURE__ */ import_react140.default.createElement(WorkspaceHeader, null, data == null ? void 0 : data.id), /* @__PURE__ */ import_react140.default.createElement(WorkspaceBody, null, /* @__PURE__ */ import_react140.default.createElement(WorkspaceScroll, null, pages.map((id2, index2) => /* @__PURE__ */ import_react140.default.createElement(OrderedCollectionPage_default, {
      id: id2,
      index: index2,
      key: index2
    })), prev && /* @__PURE__ */ import_react140.default.createElement(PrevPageObserver_default, {
      id: prev
    })), /* @__PURE__ */ import_react140.default.createElement(WorkspaceAside, null, cart.length > 0 && /* @__PURE__ */ import_react140.default.createElement(WorkspaceActions, null, /* @__PURE__ */ import_react140.default.createElement(Button_default, {
      onClick: () => handleCart(cart)
    }, "Harvest ", cart.length, " Resource(s)"), /* @__PURE__ */ import_react140.default.createElement(Button_default, {
      onClick: handleReset
    }, "Reset All")), /* @__PURE__ */ import_react140.default.createElement(Dropzone_default, null))));
  };
  var OrderedCollection_default = OrderedCollection;

  // src/index.tsx
  var App = ({ cartCallback = () => {
  }, id }) => {
    return /* @__PURE__ */ import_react141.default.createElement(OrderedCollectionProvider, null, /* @__PURE__ */ import_react141.default.createElement(OrderedCollection_default, {
      id,
      handleCart: cartCallback
    }));
  };
  var src_default = App;

  // src/dev.tsx
  var import_client = __toESM(require_client());
  var Wrapper = () => {
    const endpoint = "https://iiif.bodleian.ox.ac.uk/iiif/activity/all-changes";
    const handleCallback = (cart) => {
      console.log(cart);
    };
    return /* @__PURE__ */ import_react142.default.createElement(src_default, {
      id: endpoint,
      cartCallback: handleCallback
    });
  };
  var container = document.getElementById("root");
  var root = (0, import_client.createRoot)(container);
  root.render(
    /* @__PURE__ */ import_react142.default.createElement(import_react142.StrictMode, null, /* @__PURE__ */ import_react142.default.createElement(Wrapper, null))
  );
})();
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
//! Built on 2020-03-05
//! Git commit: v2.4.2-0-c450749
//! License: http://openseadragon.github.io/license/
//! http://openseadragon.github.io
//! openseadragon 2.4.2
//# sourceMappingURL=script.js.map
